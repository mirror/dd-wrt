diff -urpN busybox-1.29.3/Config.in busybox-1.30.0/Config.in
--- busybox-1.29.3/Config.in	2018-07-02 13:23:06.000000000 +0200
+++ busybox-1.30.0/Config.in	2018-12-05 15:44:34.000000000 +0100
@@ -178,6 +178,11 @@ config BUSYBOX
 
 	Running "busybox APPLET [ARGS...]" will still work, of course.
 
+config FEATURE_SHOW_SCRIPT
+	bool "Support --show SCRIPT"
+	default y
+	depends on BUSYBOX
+
 config FEATURE_INSTALLER
 	bool "Support --install [-s] to install applet links at runtime"
 	default y
diff -urpN busybox-1.29.3/Makefile busybox-1.30.0/Makefile
--- busybox-1.29.3/Makefile	2018-09-09 20:56:44.000000000 +0200
+++ busybox-1.30.0/Makefile	2018-12-30 16:15:45.000000000 +0100
@@ -1,6 +1,6 @@
 VERSION = 1
-PATCHLEVEL = 29
-SUBLEVEL = 3
+PATCHLEVEL = 30
+SUBLEVEL = 0
 EXTRAVERSION =
 NAME = Unnamed
 
@@ -361,7 +361,7 @@ scripts/basic/%: scripts_basic ;
 
 # This target generates Kbuild's and Config.in's from *.c files
 PHONY += gen_build_files
-gen_build_files: $(wildcard $(srctree)/*/*.c) $(wildcard $(srctree)/*/*/*.c)
+gen_build_files: $(wildcard $(srctree)/*/*.c) $(wildcard $(srctree)/*/*/*.c) $(wildcard $(srctree)/embed/*)
 	$(Q)$(srctree)/scripts/gen_build_files.sh $(srctree) $(objtree)
 
 # bbox: we have helpers in applets/
@@ -850,11 +850,14 @@ quiet_cmd_gen_common_bufsiz = GEN     in
       cmd_gen_common_bufsiz = $(srctree)/scripts/generate_BUFSIZ.sh include/common_bufsiz.h
 quiet_cmd_split_autoconf   = SPLIT   include/autoconf.h -> include/config/*
       cmd_split_autoconf   = scripts/basic/split-include include/autoconf.h include/config
+quiet_cmd_gen_embedded_scripts = GEN     include/embedded_scripts.h
+      cmd_gen_embedded_scripts = $(srctree)/scripts/embedded_scripts include/embedded_scripts.h $(srctree)/embed $(srctree)/applets_sh
 #bbox# piggybacked generation of few .h files
-include/config/MARKER: scripts/basic/split-include include/autoconf.h
+include/config/MARKER: scripts/basic/split-include include/autoconf.h $(wildcard $(srctree)/embed/*) $(wildcard $(srctree)/applets_sh/*) $(srctree)/scripts/embedded_scripts
 	$(call cmd,split_autoconf)
 	$(call cmd,gen_bbconfigopts)
 	$(call cmd,gen_common_bufsiz)
+	$(call cmd,gen_embedded_scripts)
 	@touch $@
 
 # Generate some files
@@ -974,6 +977,7 @@ MRPROPER_FILES += .config .config.old in
 		  include/autoconf.h \
 		  include/bbconfigopts.h \
 		  include/bbconfigopts_bz2.h \
+		  include/embedded_scripts.h \
 		  include/usage_compressed.h \
 		  include/applet_tables.h \
 		  include/applets.h \
diff -urpN busybox-1.29.3/applets/applet_tables.c busybox-1.30.0/applets/applet_tables.c
--- busybox-1.29.3/applets/applet_tables.c	2018-07-02 13:23:06.000000000 +0200
+++ busybox-1.30.0/applets/applet_tables.c	2018-12-05 15:44:34.000000000 +0100
@@ -84,7 +84,15 @@ int main(int argc, char **argv)
 
 	qsort(applets, NUM_APPLETS, sizeof(applets[0]), cmp_name);
 
-	if (!argv[1])
+	for (i = j = 0; i < NUM_APPLETS-1; ++i) {
+		if (cmp_name(applets+i, applets+i+1) == 0) {
+			fprintf(stderr, "%s: duplicate applet name '%s'\n", argv[0],
+					applets[i].name);
+			j = 1;
+		}
+	}
+
+	if (j != 0 || !argv[1])
 		return 1;
 	snprintf(tmp1, PATH_MAX, "%s.%u.new", argv[1], (int) getpid());
 	i = open(tmp1, O_WRONLY | O_TRUNC | O_CREAT, 0666);
diff -urpN busybox-1.29.3/applets/busybox.mkscripts busybox-1.30.0/applets/busybox.mkscripts
--- busybox-1.29.3/applets/busybox.mkscripts	1970-01-01 01:00:00.000000000 +0100
+++ busybox-1.30.0/applets/busybox.mkscripts	2018-12-05 15:44:34.000000000 +0100
@@ -0,0 +1,16 @@
+#!/bin/sh
+# Make busybox scripted applet list file.
+
+# input $1: full path to Config.h
+# input $2: full path to applets.h
+# output (stdout): list of pathnames that should be linked to busybox
+
+export LC_ALL=POSIX
+export LC_CTYPE=POSIX
+
+CONFIG_H=${1:-include/autoconf.h}
+APPLETS_H=${2:-include/applets.h}
+$HOSTCC -E -DMAKE_SCRIPTS -include $CONFIG_H $APPLETS_H |
+  awk '/^[ \t]*SCRIPT/{
+	print $2
+  }'
diff -urpN busybox-1.29.3/applets/install.sh busybox-1.30.0/applets/install.sh
--- busybox-1.29.3/applets/install.sh	2018-07-02 13:23:06.000000000 +0200
+++ busybox-1.30.0/applets/install.sh	2018-12-05 15:44:34.000000000 +0100
@@ -83,7 +83,7 @@ install -m 755 busybox "$prefix/bin/busy
 for i in $h; do
 	appdir=`dirname "$i"`
 	app=`basename "$i"`
-	if [ x"$noclobber" = x"1" ] && [ -e "$prefix/$i" ]; then
+	if [ x"$noclobber" = x"1" ] && ([ -e "$prefix/$i" ] || [ -h "$prefix/$i" ]); then
 		echo "  $prefix/$i already exists"
 		continue
 	fi
diff -urpN busybox-1.29.3/applets_sh/README busybox-1.30.0/applets_sh/README
--- busybox-1.29.3/applets_sh/README	2018-07-02 13:23:06.000000000 +0200
+++ busybox-1.30.0/applets_sh/README	1970-01-01 01:00:00.000000000 +0100
@@ -1,5 +0,0 @@
-This directory contains examples of applets implemented as shell scripts.
-
-So far these scripts are not hooked to the build system and are not
-installed by "make install". If you want to use them,
-you need to install them by hand.
diff -urpN busybox-1.29.3/applets_sh/dos2unix busybox-1.30.0/applets_sh/dos2unix
--- busybox-1.29.3/applets_sh/dos2unix	2018-07-02 13:23:06.000000000 +0200
+++ busybox-1.30.0/applets_sh/dos2unix	1970-01-01 01:00:00.000000000 +0100
@@ -1,5 +0,0 @@
-#!/bin/sh
-# TODO: use getopt to avoid parsing options as filenames,
-# and to support -- and --help
-[ $# -ne 0 ] && DASH_I=-i
-sed $DASH_I -e 's/\r$//' "$@"
diff -urpN busybox-1.29.3/applets_sh/nologin busybox-1.30.0/applets_sh/nologin
--- busybox-1.29.3/applets_sh/nologin	2018-07-02 13:23:06.000000000 +0200
+++ busybox-1.30.0/applets_sh/nologin	2018-12-05 15:44:34.000000000 +0100
@@ -1,4 +1,3 @@
-#!/bin/sh
-cat /etc/nologin.txt 2>/dev/null || echo "This account is not available"
+cat /etc/nologin.txt 2>/dev/null || echo This account is not available
 sleep 5
 exit 1
diff -urpN busybox-1.29.3/applets_sh/tac busybox-1.30.0/applets_sh/tac
--- busybox-1.29.3/applets_sh/tac	2018-07-02 13:23:06.000000000 +0200
+++ busybox-1.30.0/applets_sh/tac	1970-01-01 01:00:00.000000000 +0100
@@ -1,7 +0,0 @@
-#!/bin/sh
-# TODO: use getopt to avoid parsing options as filenames,
-# and to support -- and --help
-for i in "$@"
-do
-sed -e '1!G;h;$!d' "$i"
-done
diff -urpN busybox-1.29.3/applets_sh/unix2dos busybox-1.30.0/applets_sh/unix2dos
--- busybox-1.29.3/applets_sh/unix2dos	2018-07-02 13:23:06.000000000 +0200
+++ busybox-1.30.0/applets_sh/unix2dos	1970-01-01 01:00:00.000000000 +0100
@@ -1,5 +0,0 @@
-#!/bin/sh
-# TODO: use getopt to avoid parsing options as filenames,
-# and to support -- and --help
-[ $# -ne 0 ] && DASH_I=-i
-sed $DASH_I -e 's/$/\r/' "$@"
diff -urpN busybox-1.29.3/archival/bbunzip.c busybox-1.30.0/archival/bbunzip.c
--- busybox-1.29.3/archival/bbunzip.c	2018-07-02 13:23:06.000000000 +0200
+++ busybox-1.30.0/archival/bbunzip.c	2018-12-30 16:14:20.000000000 +0100
@@ -299,7 +299,7 @@ int uncompress_main(int argc UNUSED_PARA
 //usage:       "Decompress to stdout"
 
 //config:config GUNZIP
-//config:	bool "gunzip (12 kb)"
+//config:	bool "gunzip (11 kb)"
 //config:	default y
 //config:	select FEATURE_GZIP_DECOMPRESS
 //config:	help
@@ -308,7 +308,7 @@ int uncompress_main(int argc UNUSED_PARA
 //config:	an archive, without decompressing it.
 //config:
 //config:config ZCAT
-//config:	bool "zcat (25 kb)"
+//config:	bool "zcat (24 kb)"
 //config:	default y
 //config:	select FEATURE_GZIP_DECOMPRESS
 //config:	help
@@ -413,7 +413,7 @@ int gunzip_main(int argc UNUSED_PARAM, c
 //usage:       "Decompress to stdout"
 
 //config:config BUNZIP2
-//config:	bool "bunzip2 (8.8 kb)"
+//config:	bool "bunzip2 (8.7 kb)"
 //config:	default y
 //config:	select FEATURE_BZIP2_DECOMPRESS
 //config:	help
@@ -427,7 +427,7 @@ int gunzip_main(int argc UNUSED_PARAM, c
 //config:	should probably say N here.
 //config:
 //config:config BZCAT
-//config:	bool "bzcat (8.8 kb)"
+//config:	bool "bzcat (8.7 kb)"
 //config:	default y
 //config:	select FEATURE_BZIP2_DECOMPRESS
 //config:	help
@@ -481,7 +481,7 @@ int bunzip2_main(int argc UNUSED_PARAM,
 //usage:       "Decompress to stdout"
 
 //config:config UNLZMA
-//config:	bool "unlzma (8.6 kb)"
+//config:	bool "unlzma (7.5 kb)"
 //config:	default y
 //config:	help
 //config:	unlzma is a compression utility using the Lempel-Ziv-Markov chain
@@ -490,7 +490,7 @@ int bunzip2_main(int argc UNUSED_PARAM,
 //config:	compressors.
 //config:
 //config:config LZCAT
-//config:	bool "lzcat (8.5 kb)"
+//config:	bool "lzcat (7.5 kb)"
 //config:	default y
 //config:	help
 //config:	Alias to "unlzma -c".
diff -urpN busybox-1.29.3/archival/bzip2.c busybox-1.30.0/archival/bzip2.c
--- busybox-1.29.3/archival/bzip2.c	2018-07-02 13:23:06.000000000 +0200
+++ busybox-1.30.0/archival/bzip2.c	2018-12-30 16:14:20.000000000 +0100
@@ -7,7 +7,7 @@
  * about bzip2 library code.
  */
 //config:config BZIP2
-//config:	bool "bzip2 (18 kb)"
+//config:	bool "bzip2 (16 kb)"
 //config:	default y
 //config:	help
 //config:	bzip2 is a compression utility using the Burrows-Wheeler block
diff -urpN busybox-1.29.3/archival/cpio.c busybox-1.30.0/archival/cpio.c
--- busybox-1.29.3/archival/cpio.c	2018-07-02 13:23:06.000000000 +0200
+++ busybox-1.30.0/archival/cpio.c	2018-12-30 16:14:20.000000000 +0100
@@ -11,7 +11,7 @@
  * Only supports new ASCII and CRC formats
  */
 //config:config CPIO
-//config:	bool "cpio (14 kb)"
+//config:	bool "cpio (15 kb)"
 //config:	default y
 //config:	help
 //config:	cpio is an archival utility program used to create, modify, and
@@ -64,15 +64,17 @@
 //usage:     "\n	-p DIR	Copy files to DIR"
 //usage:	)
 //usage:     "\nOptions:"
+//usage:	IF_FEATURE_CPIO_O(
+//usage:     "\n	-H newc	Archive format"
+//usage:	)
 //usage:     "\n	-d	Make leading directories"
 //usage:     "\n	-m	Preserve mtime"
 //usage:     "\n	-v	Verbose"
 //usage:     "\n	-u	Overwrite"
 //usage:     "\n	-F FILE	Input (-t,-i,-p) or output (-o) file"
 //usage:     "\n	-R USER[:GRP]	Set owner of created files"
-//usage:	IF_FEATURE_CPIO_O(
-//usage:     "\n	-H newc	Archive format"
-//usage:	)
+//usage:     "\n	-L	Dereference symlinks"
+//usage:     "\n	-0	Input is separated by NULs"
 
 /* GNU cpio 2.9 --help (abridged):
 
@@ -374,6 +376,7 @@ int cpio_main(int argc UNUSED_PARAM, cha
 #endif
 		"owner\0"        Required_argument "R"
 		"verbose\0"      No_argument       "v"
+		"null\0"         No_argument       "0"
 		"quiet\0"        No_argument       "\xff"
 		"to-stdout\0"    No_argument       "\xfe"
 		;
diff -urpN busybox-1.29.3/archival/dpkg.c busybox-1.30.0/archival/dpkg.c
--- busybox-1.29.3/archival/dpkg.c	2018-07-02 13:23:06.000000000 +0200
+++ busybox-1.30.0/archival/dpkg.c	2018-12-30 16:14:20.000000000 +0100
@@ -26,7 +26,7 @@
  *  - (unknown, please let me know when you find any)
  */
 //config:config DPKG
-//config:	bool "dpkg (44 kb)"
+//config:	bool "dpkg (43 kb)"
 //config:	default y
 //config:	select FEATURE_SEAMLESS_GZ
 //config:	help
diff -urpN busybox-1.29.3/archival/dpkg_deb.c busybox-1.30.0/archival/dpkg_deb.c
--- busybox-1.29.3/archival/dpkg_deb.c	2018-07-02 13:23:06.000000000 +0200
+++ busybox-1.30.0/archival/dpkg_deb.c	2018-12-30 16:14:20.000000000 +0100
@@ -5,7 +5,7 @@
  * Licensed under GPLv2 or later, see file LICENSE in this source tree.
  */
 //config:config DPKG_DEB
-//config:	bool "dpkg_deb"
+//config:	bool "dpkg-deb (30 kb)"
 //config:	default y
 //config:	select FEATURE_SEAMLESS_GZ
 //config:	help
diff -urpN busybox-1.29.3/archival/gzip.c busybox-1.30.0/archival/gzip.c
--- busybox-1.29.3/archival/gzip.c	2018-07-30 18:02:27.000000000 +0200
+++ busybox-1.30.0/archival/gzip.c	2018-12-30 16:14:20.000000000 +0100
@@ -22,7 +22,7 @@ gzip: bogus: No such file or directory
 aa:      85.1% -- replaced with aa.gz
 */
 //config:config GZIP
-//config:	bool "gzip (19 kb)"
+//config:	bool "gzip (17 kb)"
 //config:	default y
 //config:	help
 //config:	gzip is used to compress files.
diff -urpN busybox-1.29.3/archival/libarchive/Kbuild.src busybox-1.30.0/archival/libarchive/Kbuild.src
--- busybox-1.29.3/archival/libarchive/Kbuild.src	2018-07-02 13:23:06.000000000 +0200
+++ busybox-1.30.0/archival/libarchive/Kbuild.src	2018-12-05 15:44:34.000000000 +0100
@@ -91,6 +91,7 @@ lib-$(CONFIG_FEATURE_SEAMLESS_LZMA)
 lib-$(CONFIG_FEATURE_SEAMLESS_XZ)       += open_transformer.o decompress_unxz.o
 lib-$(CONFIG_FEATURE_COMPRESS_USAGE)    += open_transformer.o decompress_bunzip2.o
 lib-$(CONFIG_FEATURE_COMPRESS_BBCONFIG) += open_transformer.o decompress_bunzip2.o
+lib-$(CONFIG_FEATURE_SH_EMBEDDED_SCRIPTS) += open_transformer.o decompress_bunzip2.o
 
 ifneq ($(lib-y),)
 lib-y += $(COMMON_FILES)
diff -urpN busybox-1.29.3/archival/libarchive/decompress_bunzip2.c busybox-1.30.0/archival/libarchive/decompress_bunzip2.c
--- busybox-1.29.3/archival/libarchive/decompress_bunzip2.c	2018-07-02 13:23:06.000000000 +0200
+++ busybox-1.30.0/archival/libarchive/decompress_bunzip2.c	2018-12-05 15:44:34.000000000 +0100
@@ -107,7 +107,7 @@ struct bunzip_data {
 	uint8_t selectors[32768];  /* nSelectors=15 bits */
 	struct group_data groups[MAX_GROUPS];  /* Huffman coding tables */
 };
-/* typedef struct bunzip_data bunzip_data; -- done in .h file */
+typedef struct bunzip_data bunzip_data;
 
 
 /* Return the next nnn bits of input.  All reads from the compressed input
@@ -575,7 +575,7 @@ static int get_next_block(bunzip_data *b
    in outbuf. IOW: on EOF returns len ("all bytes are not filled"), not 0.
    (Why? This allows to get rid of one local variable)
 */
-int FAST_FUNC read_bunzip(bunzip_data *bd, char *outbuf, int len)
+static int read_bunzip(bunzip_data *bd, char *outbuf, int len)
 {
 	const uint32_t *dbuf;
 	int pos, current, previous;
@@ -699,7 +699,7 @@ int FAST_FUNC read_bunzip(bunzip_data *b
 /* Because bunzip2 is used for help text unpacking, and because bb_show_usage()
    should work for NOFORK applets too, we must be extremely careful to not leak
    any allocations! */
-int FAST_FUNC start_bunzip(
+static int FAST_FUNC start_bunzip(
 		void *jmpbuf,
 		bunzip_data **bdp,
 		int in_fd,
@@ -759,7 +759,7 @@ int FAST_FUNC start_bunzip(
 	return RETVAL_OK;
 }
 
-void FAST_FUNC dealloc_bunzip(bunzip_data *bd)
+static void FAST_FUNC dealloc_bunzip(bunzip_data *bd)
 {
 	free(bd->dbuf);
 	free(bd);
@@ -809,7 +809,7 @@ unpack_bz2_stream(transformer_state_t *x
 		/* Observed case when i == RETVAL_OK:
 		 * "bzcat z.bz2", where "z.bz2" is a bzipped zero-length file
 		 * (to be exact, z.bz2 is exactly these 14 bytes:
-		 * 42 5a 68 39 17 72 45 38  50 90 00 00 00 00).
+		 * 42 5a 68 39 17 72 45 38 50 90 00 00 00 00).
 		 */
 		 && i != RETVAL_OK
 		) {
@@ -847,6 +847,36 @@ unpack_bz2_stream(transformer_state_t *x
 	return i ? i : IF_DESKTOP(total_written) + 0;
 }
 
+char* FAST_FUNC
+unpack_bz2_data(const char *packed, int packed_len, int unpacked_len)
+{
+	char *outbuf = NULL;
+	bunzip_data *bd;
+	int i;
+	jmp_buf jmpbuf;
+
+	/* Setup for I/O error handling via longjmp */
+	i = setjmp(jmpbuf);
+	if (i == 0) {
+		i = start_bunzip(&jmpbuf,
+			&bd,
+			/* src_fd: */ -1,
+			/* inbuf:  */ packed,
+			/* len:    */ packed_len
+		);
+	}
+	/* read_bunzip can longjmp and end up here with i != 0
+	 * on read data errors! Not trivial */
+	if (i == 0) {
+		/* Cannot use xmalloc: will leak bd in NOFORK case! */
+		outbuf = malloc_or_warn(unpacked_len);
+		if (outbuf)
+			read_bunzip(bd, outbuf, unpacked_len);
+	}
+	dealloc_bunzip(bd);
+	return outbuf;
+}
+
 #ifdef TESTING
 
 static char *const bunzip_errors[] = {
diff -urpN busybox-1.29.3/archival/libarchive/decompress_unlzma.c busybox-1.30.0/archival/libarchive/decompress_unlzma.c
--- busybox-1.29.3/archival/libarchive/decompress_unlzma.c	2018-07-02 13:23:06.000000000 +0200
+++ busybox-1.30.0/archival/libarchive/decompress_unlzma.c	2018-12-05 15:44:34.000000000 +0100
@@ -353,8 +353,10 @@ unpack_lzma_stream(transformer_state_t *
 						if ((int32_t)pos < 0) {
 							pos += header.dict_size;
 							/* see unzip_bad_lzma_2.zip: */
-							if (pos >= buffer_size)
+							if (pos >= buffer_size) {
+								dbg("%d pos:%d buffer_size:%d", __LINE__, pos, buffer_size);
 								goto bad;
+							}
 						}
 						previous_byte = buffer[pos];
 						goto one_byte1;
@@ -430,10 +432,9 @@ unpack_lzma_stream(transformer_state_t *
 						for (; num_bits2 != LZMA_NUM_ALIGN_BITS; num_bits2--)
 							rep0 = (rep0 << 1) | rc_direct_bit(rc);
 						rep0 <<= LZMA_NUM_ALIGN_BITS;
-						if ((int32_t)rep0 < 0) {
-							dbg("%d rep0:%d", __LINE__, rep0);
-							goto bad;
-						}
+						// Note: (int32_t)rep0 may be < 0 here
+						// (I have linux-3.3.4.tar.lzma which has it).
+						// I moved the check after "++rep0 == 0" check below.
 						prob3 = p + LZMA_ALIGN;
 					}
 					i2 = 1;
@@ -444,8 +445,13 @@ unpack_lzma_stream(transformer_state_t *
 						i2 <<= 1;
 					}
 				}
-				if (++rep0 == 0)
-					break;
+				rep0++;
+				if ((int32_t)rep0 <= 0) {
+					if (rep0 == 0)
+						break;
+					dbg("%d rep0:%d", __LINE__, rep0);
+					goto bad;
+				}
 			}
 
 			len += LZMA_MATCH_MIN_LEN;
diff -urpN busybox-1.29.3/archival/libarchive/get_header_tar.c busybox-1.30.0/archival/libarchive/get_header_tar.c
--- busybox-1.29.3/archival/libarchive/get_header_tar.c	2018-07-02 13:23:06.000000000 +0200
+++ busybox-1.30.0/archival/libarchive/get_header_tar.c	2018-12-05 15:44:34.000000000 +0100
@@ -414,7 +414,8 @@ char FAST_FUNC get_header_tar(archive_ha
 //	case 'D':	/* GNU dump dir */
 //	case 'M':	/* Continuation of multi volume archive */
 //	case 'N':	/* Old GNU for names > 100 characters */
-//	case 'V':	/* Volume header */
+	case 'V':	/* Volume header */
+		; /* Fall through to skip it */
 #endif
 	}
  skip_ext_hdr:
diff -urpN busybox-1.29.3/archival/libarchive/lzo1x_9x.c busybox-1.30.0/archival/libarchive/lzo1x_9x.c
--- busybox-1.29.3/archival/libarchive/lzo1x_9x.c	2018-07-02 13:23:06.000000000 +0200
+++ busybox-1.30.0/archival/libarchive/lzo1x_9x.c	2018-12-30 16:14:20.000000000 +0100
@@ -487,7 +487,7 @@ static int find_match(lzo1x_999_t *c, lz
 }
 
 /* this is a public functions, but there is no prototype in a header file */
-static int lzo1x_999_compress_internal(const uint8_t *in , unsigned in_len,
+static int lzo1x_999_compress_internal(const uint8_t *in, unsigned in_len,
 		uint8_t *out, unsigned *out_len,
 		void *wrkmem,
 		unsigned good_length,
diff -urpN busybox-1.29.3/archival/libarchive/open_transformer.c busybox-1.30.0/archival/libarchive/open_transformer.c
--- busybox-1.29.3/archival/libarchive/open_transformer.c	2018-07-02 13:23:06.000000000 +0200
+++ busybox-1.30.0/archival/libarchive/open_transformer.c	2018-12-05 15:44:34.000000000 +0100
@@ -278,8 +278,7 @@ static transformer_state_t *open_transfo
 
 	if (ENABLE_FEATURE_SEAMLESS_LZMA) {
 		/* .lzma has no header/signature, can only detect it by extension */
-		char *sfx = strrchr(fname, '.');
-		if (sfx && strcmp(sfx+1, "lzma") == 0) {
+		if (is_suffixed_with(fname, ".lzma")) {
 			xstate = xzalloc(sizeof(*xstate));
 			xstate->src_fd = fd;
 			xstate->xformer = unpack_lzma_stream;
diff -urpN busybox-1.29.3/archival/lzop.c busybox-1.30.0/archival/lzop.c
--- busybox-1.29.3/archival/lzop.c	2018-07-02 13:23:06.000000000 +0200
+++ busybox-1.30.0/archival/lzop.c	2018-12-30 16:14:20.000000000 +0100
@@ -25,7 +25,7 @@
    "Minimalized" for busybox by Alain Knaff
 */
 //config:config LZOP
-//config:	bool "lzop (13 kb)"
+//config:	bool "lzop (12 kb)"
 //config:	default y
 //config:	help
 //config:	Lzop compression/decompresion.
diff -urpN busybox-1.29.3/archival/rpm.c busybox-1.30.0/archival/rpm.c
--- busybox-1.29.3/archival/rpm.c	2018-07-02 13:23:06.000000000 +0200
+++ busybox-1.30.0/archival/rpm.c	2018-12-30 16:14:20.000000000 +0100
@@ -7,7 +7,7 @@
  * Licensed under GPLv2 or later, see file LICENSE in this source tree.
  */
 //config:config RPM
-//config:	bool "rpm (33 kb)"
+//config:	bool "rpm (32 kb)"
 //config:	default y
 //config:	help
 //config:	Mini RPM applet - queries and extracts RPM packages.
@@ -499,7 +499,7 @@ int rpm_main(int argc, char **argv)
  * Licensed under GPLv2 or later, see file LICENSE in this source tree.
  */
 //config:config RPM2CPIO
-//config:	bool "rpm2cpio (20 kb)"
+//config:	bool "rpm2cpio (21 kb)"
 //config:	default y
 //config:	help
 //config:	Converts a RPM file into a CPIO archive.
diff -urpN busybox-1.29.3/archival/tar.c busybox-1.30.0/archival/tar.c
--- busybox-1.29.3/archival/tar.c	2018-07-02 13:23:06.000000000 +0200
+++ busybox-1.30.0/archival/tar.c	2018-12-30 16:14:20.000000000 +0100
@@ -23,7 +23,7 @@
  * Licensed under GPLv2 or later, see file LICENSE in this source tree.
  */
 //config:config TAR
-//config:	bool "tar (40 kb)"
+//config:	bool "tar (39 kb)"
 //config:	default y
 //config:	help
 //config:	tar is an archiving program. It's commonly used with gzip to
@@ -596,35 +596,46 @@ static int FAST_FUNC writeFileToTarball(
 /* Don't inline: vfork scares gcc and pessimizes code */
 static void NOINLINE vfork_compressor(int tar_fd, const char *gzip)
 {
-	pid_t gzipPid;
-
 	// On Linux, vfork never unpauses parent early, although standard
 	// allows for that. Do we want to waste bytes checking for it?
 #  define WAIT_FOR_CHILD 0
 	volatile int vfork_exec_errno = 0;
-	struct fd_pair gzipDataPipe;
+	struct fd_pair data;
 #  if WAIT_FOR_CHILD
-	struct fd_pair gzipStatusPipe;
-	xpiped_pair(gzipStatusPipe);
+	struct fd_pair status;
+	xpiped_pair(status);
 #  endif
-	xpiped_pair(gzipDataPipe);
+	xpiped_pair(data);
 
 	signal(SIGPIPE, SIG_IGN); /* we only want EPIPE on errors */
 
-	gzipPid = xvfork();
-
-	if (gzipPid == 0) {
+	if (xvfork() == 0) {
 		/* child */
+		int tfd;
 		/* NB: close _first_, then move fds! */
-		close(gzipDataPipe.wr);
+		close(data.wr);
 #  if WAIT_FOR_CHILD
-		close(gzipStatusPipe.rd);
-		/* gzipStatusPipe.wr will close only on exec -
+		close(status.rd);
+		/* status.wr will close only on exec -
 		 * parent waits for this close to happen */
-		fcntl(gzipStatusPipe.wr, F_SETFD, FD_CLOEXEC);
+		fcntl(status.wr, F_SETFD, FD_CLOEXEC);
 #  endif
-		xmove_fd(gzipDataPipe.rd, 0);
-		xmove_fd(tar_fd, 1);
+		/* copy it: parent's tar_fd variable must not change */
+		tfd = tar_fd;
+		if (tfd == 0) {
+			/* Output tar fd may be zero.
+			 * xmove_fd(data.rd, 0) would destroy it.
+			 * Reproducer:
+			 *  exec 0>&-
+			 *  exec 1>&-
+			 *  tar czf Z.tar.gz FILE
+			 * Swapping move_fd's order wouldn't work:
+			 * data.rd is 1 and _it_ would be destroyed.
+			 */
+			tfd = dup(tfd);
+		}
+		xmove_fd(data.rd, 0);
+		xmove_fd(tfd, 1);
 		/* exec gzip/bzip2 program/applet */
 		BB_EXECLP(gzip, gzip, "-f", (char *)0);
 		vfork_exec_errno = errno;
@@ -632,20 +643,18 @@ static void NOINLINE vfork_compressor(in
 	}
 
 	/* parent */
-	xmove_fd(gzipDataPipe.wr, tar_fd);
-	close(gzipDataPipe.rd);
+	xmove_fd(data.wr, tar_fd);
+	close(data.rd);
 #  if WAIT_FOR_CHILD
-	close(gzipStatusPipe.wr);
+	close(status.wr);
 	while (1) {
-		char buf;
-		int n;
-
 		/* Wait until child execs (or fails to) */
-		n = full_read(gzipStatusPipe.rd, &buf, 1);
+		char buf;
+		int n = full_read(status.rd, &buf, 1);
 		if (n < 0 /* && errno == EAGAIN */)
 			continue;	/* try it again */
 	}
-	close(gzipStatusPipe.rd);
+	close(status.rd);
 #  endif
 	if (vfork_exec_errno) {
 		errno = vfork_exec_errno;
@@ -721,11 +730,7 @@ static NOINLINE int writeTarFile(
 	return errorFlag;
 }
 
-#else /* !FEATURE_TAR_CREATE */
-
-# define writeTarFile(...) 0
-
-#endif
+#endif /* FEATURE_TAR_CREATE */
 
 #if ENABLE_FEATURE_TAR_FROM
 static llist_t *append_file_list_to_list(llist_t *list)
@@ -1155,17 +1160,24 @@ int tar_main(int argc UNUSED_PARAM, char
 		if (LONE_DASH(tar_filename)) {
 			tar_handle->src_fd = tar_fd;
 			tar_handle->seek = seek_by_read;
+		} else
+		if (ENABLE_FEATURE_TAR_AUTODETECT
+		 && ENABLE_FEATURE_SEAMLESS_LZMA
+		 && flags == O_RDONLY
+		 && !(opt & OPT_ANY_COMPRESS)
+		 && is_suffixed_with(tar_filename, ".lzma")
+		/* We do this only for .lzma files, they have no signature.
+		 * All other compression formats are recognized in
+		 * get_header_tar() when first tar block has invalid format.
+		 * Doing it here for all filenames would falsely trigger
+		 * on e.g. tarball with 1st file named "BZh5".
+		 */
+		) {
+			tar_handle->src_fd = open_zipped(tar_filename, /*fail_if_not_compressed:*/ 0);
+			if (tar_handle->src_fd < 0)
+				bb_perror_msg_and_die("can't open '%s'", tar_filename);
 		} else {
-			if (ENABLE_FEATURE_TAR_AUTODETECT
-			 && flags == O_RDONLY
-			 && !(opt & OPT_ANY_COMPRESS)
-			) {
-				tar_handle->src_fd = open_zipped(tar_filename, /*fail_if_not_compressed:*/ 0);
-				if (tar_handle->src_fd < 0)
-					bb_perror_msg_and_die("can't open '%s'", tar_filename);
-			} else {
-				tar_handle->src_fd = xopen(tar_filename, flags);
-			}
+			tar_handle->src_fd = xopen(tar_filename, flags);
 		}
 	}
 
diff -urpN busybox-1.29.3/archival/unzip.c busybox-1.30.0/archival/unzip.c
--- busybox-1.29.3/archival/unzip.c	2018-07-02 13:23:06.000000000 +0200
+++ busybox-1.30.0/archival/unzip.c	2018-12-30 16:14:20.000000000 +0100
@@ -17,7 +17,7 @@
  * Zip64 + other methods
  */
 //config:config UNZIP
-//config:	bool "unzip (24 kb)"
+//config:	bool "unzip (26 kb)"
 //config:	default y
 //config:	help
 //config:	unzip will list or extract files from a ZIP archive,
@@ -153,15 +153,15 @@ typedef union {
 #define FIX_ENDIANNESS_CDF(cdf) \
 do { if (BB_BIG_ENDIAN) { \
 	(cdf).fmt.version_made_by = SWAP_LE16((cdf).fmt.version_made_by); \
-	(cdf).fmt.version_needed = SWAP_LE16((cdf).fmt.version_needed); \
-	(cdf).fmt.method        = SWAP_LE16((cdf).fmt.method      ); \
-	(cdf).fmt.modtime       = SWAP_LE16((cdf).fmt.modtime     ); \
-	(cdf).fmt.moddate       = SWAP_LE16((cdf).fmt.moddate     ); \
-	(cdf).fmt.crc32         = SWAP_LE32((cdf).fmt.crc32       ); \
-	(cdf).fmt.cmpsize       = SWAP_LE32((cdf).fmt.cmpsize     ); \
-	(cdf).fmt.ucmpsize      = SWAP_LE32((cdf).fmt.ucmpsize    ); \
-	(cdf).fmt.filename_len  = SWAP_LE16((cdf).fmt.filename_len); \
-	(cdf).fmt.extra_len     = SWAP_LE16((cdf).fmt.extra_len   ); \
+	(cdf).fmt.version_needed  = SWAP_LE16((cdf).fmt.version_needed ); \
+	(cdf).fmt.method          = SWAP_LE16((cdf).fmt.method         ); \
+	(cdf).fmt.modtime         = SWAP_LE16((cdf).fmt.modtime        ); \
+	(cdf).fmt.moddate         = SWAP_LE16((cdf).fmt.moddate        ); \
+	(cdf).fmt.crc32           = SWAP_LE32((cdf).fmt.crc32          ); \
+	(cdf).fmt.cmpsize         = SWAP_LE32((cdf).fmt.cmpsize        ); \
+	(cdf).fmt.ucmpsize        = SWAP_LE32((cdf).fmt.ucmpsize       ); \
+	(cdf).fmt.filename_len    = SWAP_LE16((cdf).fmt.filename_len   ); \
+	(cdf).fmt.extra_len       = SWAP_LE16((cdf).fmt.extra_len      ); \
 	(cdf).fmt.file_comment_length = SWAP_LE16((cdf).fmt.file_comment_length); \
 	(cdf).fmt.external_attributes = SWAP_LE32((cdf).fmt.external_attributes); \
 }} while (0)
@@ -456,7 +456,9 @@ static int get_lstat_mode(const char *ds
 	struct stat stat_buf;
 	if (lstat(dst_fn, &stat_buf) == -1) {
 		if (errno != ENOENT) {
-			bb_perror_msg_and_die("can't stat '%s'", dst_fn);
+			bb_perror_msg_and_die("can't stat '%s'",
+				dst_fn
+			);
 		}
 		/* File does not exist */
 		return -1;
@@ -634,7 +636,9 @@ int unzip_main(int argc, char **argv)
 				break;
 			if (++i > 2) {
 				*ext = '\0';
-				bb_error_msg_and_die("can't open %s[.zip]", src_fn);
+				bb_error_msg_and_die("can't open %s[.zip]",
+					src_fn
+				);
 			}
 			strcpy(ext, extn[i - 1]);
 		}
@@ -646,8 +650,11 @@ int unzip_main(int argc, char **argv)
 		xchdir(base_dir);
 
 	if (quiet <= 1) { /* not -qq */
-		if (quiet == 0)
-			printf("Archive:  %s\n", src_fn);
+		if (quiet == 0) {
+			printf("Archive:  %s\n",
+				printable_string(src_fn)
+			);
+		}
 		if (opts & OPT_l) {
 			puts(verbose ?
 				" Length   Method    Size  Cmpr    Date    Time   CRC-32   Name\n"
@@ -831,7 +838,8 @@ int unzip_main(int argc, char **argv)
 				printf(       "%9u  " "%s   "         "%s\n",
 					(unsigned)zip.fmt.ucmpsize,
 					dtbuf,
-					dst_fn);
+					printable_string(dst_fn)
+				);
 			} else {
 				char method6[7];
 				unsigned long percents;
@@ -860,7 +868,8 @@ int unzip_main(int argc, char **argv)
 					(unsigned)percents,
 					dtbuf,
 					zip.fmt.crc32,
-					dst_fn);
+					printable_string(dst_fn)
+				);
 				total_size += zip.fmt.cmpsize;
 			}
 			total_usize += zip.fmt.ucmpsize;
@@ -886,7 +895,7 @@ int unzip_main(int argc, char **argv)
 			mode = get_lstat_mode(dst_fn);
 			if (mode == -1) { /* ENOENT */
 				if (!quiet) {
-					printf("   creating: %s\n", dst_fn);
+					printf("   creating: %s\n", printable_string(dst_fn));
 				}
 				unzip_create_leading_dirs(dst_fn);
 				if (bb_make_directory(dst_fn, dir_mode, FILEUTILS_IGNORE_CHMOD_ERR)) {
@@ -895,7 +904,9 @@ int unzip_main(int argc, char **argv)
 			} else {
 				if (!S_ISDIR(mode)) {
 					bb_error_msg_and_die("'%s' exists but is not a %s",
-						dst_fn, "directory");
+						printable_string(dst_fn),
+						"directory"
+					);
 				}
 			}
 			goto skip_cmpsize;
@@ -914,12 +925,16 @@ int unzip_main(int argc, char **argv)
 			if (!S_ISREG(mode)) {
  fishy:
 				bb_error_msg_and_die("'%s' exists but is not a %s",
-					dst_fn, "regular file");
+					printable_string(dst_fn),
+					"regular file"
+				);
 			}
 			if (overwrite == O_ALWAYS) {
 				goto do_open_and_extract;
 			}
-			printf("replace %s? [y]es, [n]o, [A]ll, [N]one, [r]ename: ", dst_fn);
+			printf("replace %s? [y]es, [n]o, [A]ll, [N]one, [r]ename: ",
+				printable_string(dst_fn)
+			);
 			my_fgets80(key_buf);
 			/* User input could take a long time. Is it still a regular file? */
 			mode = get_lstat_mode(dst_fn);
@@ -949,7 +964,9 @@ int unzip_main(int argc, char **argv)
 			if (!quiet) {
 				printf(/* zip.fmt.method == 0
 					? " extracting: %s\n"
-					: */ "  inflating: %s\n", dst_fn);
+					: */ "  inflating: %s\n",
+					printable_string(dst_fn)
+				);
 			}
 #if ENABLE_FEATURE_UNZIP_CDF
 			if (S_ISLNK(file_mode)) {
diff -urpN busybox-1.29.3/console-tools/dumpkmap.c busybox-1.30.0/console-tools/dumpkmap.c
--- busybox-1.29.3/console-tools/dumpkmap.c	2018-07-02 13:23:06.000000000 +0200
+++ busybox-1.30.0/console-tools/dumpkmap.c	2018-12-30 16:14:20.000000000 +0100
@@ -7,7 +7,7 @@
  * Licensed under GPLv2 or later, see file LICENSE in this source tree.
  */
 //config:config DUMPKMAP
-//config:	bool "dumpkmap (1.3 kb)"
+//config:	bool "dumpkmap (1.6 kb)"
 //config:	default y
 //config:	select PLATFORM_LINUX
 //config:	help
diff -urpN busybox-1.29.3/console-tools/fgconsole.c busybox-1.30.0/console-tools/fgconsole.c
--- busybox-1.29.3/console-tools/fgconsole.c	2018-07-02 13:23:06.000000000 +0200
+++ busybox-1.30.0/console-tools/fgconsole.c	2018-12-30 16:14:20.000000000 +0100
@@ -7,7 +7,7 @@
  * Licensed under GPLv2 or later, see file LICENSE in this source tree.
  */
 //config:config FGCONSOLE
-//config:	bool "fgconsole (1.6 kb)"
+//config:	bool "fgconsole (1.5 kb)"
 //config:	default y
 //config:	select PLATFORM_LINUX
 //config:	help
diff -urpN busybox-1.29.3/console-tools/kbd_mode.c busybox-1.30.0/console-tools/kbd_mode.c
--- busybox-1.29.3/console-tools/kbd_mode.c	2018-07-02 13:23:06.000000000 +0200
+++ busybox-1.30.0/console-tools/kbd_mode.c	2018-12-30 16:14:20.000000000 +0100
@@ -9,7 +9,7 @@
  * Licensed under GPLv2 or later, see file LICENSE in this source tree.
  */
 //config:config KBD_MODE
-//config:	bool "kbd_mode (4 kb)"
+//config:	bool "kbd_mode (4.1 kb)"
 //config:	default y
 //config:	select PLATFORM_LINUX
 //config:	help
diff -urpN busybox-1.29.3/console-tools/loadfont.c busybox-1.30.0/console-tools/loadfont.c
--- busybox-1.29.3/console-tools/loadfont.c	2018-07-02 13:23:06.000000000 +0200
+++ busybox-1.30.0/console-tools/loadfont.c	2018-12-30 16:14:20.000000000 +0100
@@ -10,14 +10,14 @@
  * Licensed under GPLv2, see file LICENSE in this source tree.
  */
 //config:config LOADFONT
-//config:	bool "loadfont (5.4 kb)"
+//config:	bool "loadfont (5.2 kb)"
 //config:	default y
 //config:	select PLATFORM_LINUX
 //config:	help
 //config:	This program loads a console font from standard input.
 //config:
 //config:config SETFONT
-//config:	bool "setfont (26 kb)"
+//config:	bool "setfont (24 kb)"
 //config:	default y
 //config:	select PLATFORM_LINUX
 //config:	help
diff -urpN busybox-1.29.3/console-tools/loadkmap.c busybox-1.30.0/console-tools/loadkmap.c
--- busybox-1.29.3/console-tools/loadkmap.c	2018-07-02 13:23:06.000000000 +0200
+++ busybox-1.30.0/console-tools/loadkmap.c	2018-12-30 16:14:20.000000000 +0100
@@ -7,7 +7,7 @@
  * Licensed under GPLv2 or later, see file LICENSE in this source tree.
  */
 //config:config LOADKMAP
-//config:	bool "loadkmap (1.5 kb)"
+//config:	bool "loadkmap (1.8 kb)"
 //config:	default y
 //config:	select PLATFORM_LINUX
 //config:	help
diff -urpN busybox-1.29.3/console-tools/openvt.c busybox-1.30.0/console-tools/openvt.c
--- busybox-1.29.3/console-tools/openvt.c	2018-07-02 13:23:06.000000000 +0200
+++ busybox-1.30.0/console-tools/openvt.c	2018-12-30 16:14:20.000000000 +0100
@@ -8,7 +8,7 @@
  * Licensed under GPLv2 or later, see file LICENSE in this source tree.
  */
 //config:config OPENVT
-//config:	bool "openvt (7 kb)"
+//config:	bool "openvt (7.2 kb)"
 //config:	default y
 //config:	select PLATFORM_LINUX
 //config:	help
diff -urpN busybox-1.29.3/console-tools/reset.c busybox-1.30.0/console-tools/reset.c
--- busybox-1.29.3/console-tools/reset.c	2018-07-02 13:23:06.000000000 +0200
+++ busybox-1.30.0/console-tools/reset.c	2018-12-30 16:14:20.000000000 +0100
@@ -8,7 +8,7 @@
  * Licensed under GPLv2 or later, see file LICENSE in this source tree.
  */
 //config:config RESET
-//config:	bool "reset (275 bytes)"
+//config:	bool "reset (345 bytes)"
 //config:	default y
 //config:	help
 //config:	This program is used to reset the terminal screen, if it
diff -urpN busybox-1.29.3/console-tools/resize.c busybox-1.30.0/console-tools/resize.c
--- busybox-1.29.3/console-tools/resize.c	2018-07-02 13:23:06.000000000 +0200
+++ busybox-1.30.0/console-tools/resize.c	2018-12-30 16:14:20.000000000 +0100
@@ -7,7 +7,7 @@
  * Licensed under GPLv2 or later, see file LICENSE in this source tree.
  */
 //config:config RESIZE
-//config:	bool "resize (756 bytes)"
+//config:	bool "resize (903 bytes)"
 //config:	default y
 //config:	help
 //config:	This program is used to (re)set the width and height of your current
diff -urpN busybox-1.29.3/console-tools/setconsole.c busybox-1.30.0/console-tools/setconsole.c
--- busybox-1.29.3/console-tools/setconsole.c	2018-07-02 13:23:06.000000000 +0200
+++ busybox-1.30.0/console-tools/setconsole.c	2018-12-30 16:14:20.000000000 +0100
@@ -8,7 +8,7 @@
  * Licensed under GPLv2 or later, see file LICENSE in this source tree.
  */
 //config:config SETCONSOLE
-//config:	bool "setconsole (3.7 kb)"
+//config:	bool "setconsole (3.6 kb)"
 //config:	default y
 //config:	select PLATFORM_LINUX
 //config:	help
diff -urpN busybox-1.29.3/console-tools/setkeycodes.c busybox-1.30.0/console-tools/setkeycodes.c
--- busybox-1.29.3/console-tools/setkeycodes.c	2018-07-02 13:23:06.000000000 +0200
+++ busybox-1.30.0/console-tools/setkeycodes.c	2018-12-30 16:14:20.000000000 +0100
@@ -9,7 +9,7 @@
  * Licensed under GPLv2 or later, see file LICENSE in this source tree.
  */
 //config:config SETKEYCODES
-//config:	bool "setkeycodes (1.7 kb)"
+//config:	bool "setkeycodes (2.1 kb)"
 //config:	default y
 //config:	select PLATFORM_LINUX
 //config:	help
diff -urpN busybox-1.29.3/coreutils/basename.c busybox-1.30.0/coreutils/basename.c
--- busybox-1.29.3/coreutils/basename.c	2018-07-02 13:23:06.000000000 +0200
+++ busybox-1.30.0/coreutils/basename.c	2018-12-30 16:14:20.000000000 +0100
@@ -14,7 +14,7 @@
  * 3) Save some space by using strcmp().  Calling strncmp() here was silly.
  */
 //config:config BASENAME
-//config:	bool "basename (371 bytes)"
+//config:	bool "basename (438 bytes)"
 //config:	default y
 //config:	help
 //config:	basename is used to strip the directory and suffix from filenames,
diff -urpN busybox-1.29.3/coreutils/cat.c busybox-1.30.0/coreutils/cat.c
--- busybox-1.29.3/coreutils/cat.c	2018-07-02 13:23:06.000000000 +0200
+++ busybox-1.30.0/coreutils/cat.c	2018-12-05 15:44:34.000000000 +0100
@@ -195,6 +195,7 @@ int cat_main(int argc UNUSED_PARAM, char
 # define CAT_OPT_b (1<<1)
 	if (opts & (CAT_OPT_n|CAT_OPT_b)) { /* -n or -b */
 		struct number_state ns;
+		int exitcode;
 
 		ns.width = 6;
 		ns.start = 1;
@@ -203,10 +204,11 @@ int cat_main(int argc UNUSED_PARAM, char
 		ns.empty_str = "\n";
 		ns.all = !(opts & CAT_OPT_b); /* -n without -b */
 		ns.nonempty = (opts & CAT_OPT_b); /* -b (with or without -n) */
+		exitcode = EXIT_SUCCESS;
 		do {
-			print_numbered_lines(&ns, *argv);
+			exitcode |= print_numbered_lines(&ns, *argv);
 		} while (*++argv);
-		fflush_stdout_and_exit(EXIT_SUCCESS);
+		fflush_stdout_and_exit(exitcode);
 	}
 	/*opts >>= 2;*/
 #endif
diff -urpN busybox-1.29.3/coreutils/chgrp.c busybox-1.30.0/coreutils/chgrp.c
--- busybox-1.29.3/coreutils/chgrp.c	2018-07-02 13:23:06.000000000 +0200
+++ busybox-1.30.0/coreutils/chgrp.c	2018-12-30 16:14:20.000000000 +0100
@@ -7,7 +7,7 @@
  * Licensed under GPLv2 or later, see file LICENSE in this source tree.
  */
 //config:config CHGRP
-//config:	bool "chgrp (7.2 kb)"
+//config:	bool "chgrp (7.6 kb)"
 //config:	default y
 //config:	help
 //config:	chgrp is used to change the group ownership of files.
diff -urpN busybox-1.29.3/coreutils/chmod.c busybox-1.30.0/coreutils/chmod.c
--- busybox-1.29.3/coreutils/chmod.c	2018-07-02 13:23:06.000000000 +0200
+++ busybox-1.30.0/coreutils/chmod.c	2018-12-30 16:14:20.000000000 +0100
@@ -10,7 +10,7 @@
  * Licensed under GPLv2 or later, see file LICENSE in this source tree.
  */
 //config:config CHMOD
-//config:	bool "chmod (5.1 kb)"
+//config:	bool "chmod (5.5 kb)"
 //config:	default y
 //config:	help
 //config:	chmod is used to change the access permission of files.
diff -urpN busybox-1.29.3/coreutils/chown.c busybox-1.30.0/coreutils/chown.c
--- busybox-1.29.3/coreutils/chown.c	2018-07-02 13:23:06.000000000 +0200
+++ busybox-1.30.0/coreutils/chown.c	2018-12-30 16:14:20.000000000 +0100
@@ -7,7 +7,7 @@
  * Licensed under GPLv2 or later, see file LICENSE in this source tree.
  */
 //config:config CHOWN
-//config:	bool "chown (7.2 kb)"
+//config:	bool "chown (7.6 kb)"
 //config:	default y
 //config:	help
 //config:	chown is used to change the user and/or group ownership
diff -urpN busybox-1.29.3/coreutils/cksum.c busybox-1.30.0/coreutils/cksum.c
--- busybox-1.29.3/coreutils/cksum.c	2018-07-02 13:23:06.000000000 +0200
+++ busybox-1.30.0/coreutils/cksum.c	2018-12-30 16:14:20.000000000 +0100
@@ -7,7 +7,7 @@
  * Licensed under GPLv2 or later, see file LICENSE in this source tree.
  */
 //config:config CKSUM
-//config:	bool "cksum (4.2 kb)"
+//config:	bool "cksum (4.1 kb)"
 //config:	default y
 //config:	help
 //config:	cksum is used to calculate the CRC32 checksum of a file.
diff -urpN busybox-1.29.3/coreutils/comm.c busybox-1.30.0/coreutils/comm.c
--- busybox-1.29.3/coreutils/comm.c	2018-07-02 13:23:06.000000000 +0200
+++ busybox-1.30.0/coreutils/comm.c	2018-12-30 16:14:20.000000000 +0100
@@ -7,7 +7,7 @@
  * Licensed under GPLv2 or later, see file LICENSE in this source tree.
  */
 //config:config COMM
-//config:	bool "comm (3.9 kb)"
+//config:	bool "comm (4.2 kb)"
 //config:	default y
 //config:	help
 //config:	comm is used to compare two files line by line and return
diff -urpN busybox-1.29.3/coreutils/cp.c busybox-1.30.0/coreutils/cp.c
--- busybox-1.29.3/coreutils/cp.c	2018-07-02 13:23:06.000000000 +0200
+++ busybox-1.30.0/coreutils/cp.c	2018-12-30 16:14:20.000000000 +0100
@@ -12,7 +12,7 @@
  * Size reduction.
  */
 //config:config CP
-//config:	bool "cp (9.7 kb)"
+//config:	bool "cp (10 kb)"
 //config:	default y
 //config:	help
 //config:	cp is used to copy files and directories.
@@ -24,6 +24,11 @@
 //config:	help
 //config:	Enable long options.
 //config:	Also add support for --parents option.
+//config:
+//config:config FEATURE_CP_REFLINK
+//config:	bool "Enable --reflink[=auto]"
+//config:	default y
+//config:	depends on FEATURE_CP_LONG_OPTIONS
 
 //applet:IF_CP(APPLET_NOEXEC(cp, cp, BB_DIR_BIN, BB_SUID_DROP, cp))
 /* NOEXEC despite cases when it can be a "runner" (cp -r LARGE_DIR NEW_DIR) */
@@ -72,10 +77,14 @@ int cp_main(int argc, char **argv)
 #if ENABLE_FEATURE_CP_LONG_OPTIONS
 		/*OPT_rmdest  = FILEUTILS_RMDEST = 1 << FILEUTILS_CP_OPTNUM */
 		OPT_parents = 1 << (FILEUTILS_CP_OPTNUM+1),
+		OPT_reflink = 1 << (FILEUTILS_CP_OPTNUM+2),
 #endif
 	};
 
 #if ENABLE_FEATURE_CP_LONG_OPTIONS
+# if ENABLE_FEATURE_CP_REFLINK
+	char *reflink = NULL;
+# endif
 	flags = getopt32long(argv, "^"
 		FILEUTILS_CP_OPTSTR
 		"\0"
@@ -99,7 +108,22 @@ int cp_main(int argc, char **argv)
 		"update\0"         No_argument "u"
 		"remove-destination\0" No_argument "\xff"
 		"parents\0"        No_argument "\xfe"
+# if ENABLE_FEATURE_CP_REFLINK
+		"reflink\0"        Optional_argument "\xfd"
+		, &reflink
+# endif
 	);
+# if ENABLE_FEATURE_CP_REFLINK
+	BUILD_BUG_ON((int)OPT_reflink != (int)FILEUTILS_REFLINK);
+	if (flags & FILEUTILS_REFLINK) {
+		if (!reflink)
+			flags |= FILEUTILS_REFLINK_ALWAYS;
+		else if (strcmp(reflink, "always") == 0)
+			flags |= FILEUTILS_REFLINK_ALWAYS;
+		else if (strcmp(reflink, "auto") != 0)
+			bb_show_usage();
+	}
+# endif
 #else
 	flags = getopt32(argv, "^"
 		FILEUTILS_CP_OPTSTR
diff -urpN busybox-1.29.3/coreutils/cut.c busybox-1.30.0/coreutils/cut.c
--- busybox-1.29.3/coreutils/cut.c	2018-07-02 13:23:06.000000000 +0200
+++ busybox-1.30.0/coreutils/cut.c	2018-12-30 16:14:20.000000000 +0100
@@ -9,7 +9,7 @@
  * Licensed under GPLv2 or later, see file LICENSE in this source tree.
  */
 //config:config CUT
-//config:	bool "cut (5.3 kb)"
+//config:	bool "cut (5.8 kb)"
 //config:	default y
 //config:	help
 //config:	cut is used to print selected parts of lines from
diff -urpN busybox-1.29.3/coreutils/date.c busybox-1.30.0/coreutils/date.c
--- busybox-1.29.3/coreutils/date.c	2018-07-02 13:23:06.000000000 +0200
+++ busybox-1.30.0/coreutils/date.c	2018-12-30 16:14:20.000000000 +0100
@@ -19,7 +19,7 @@
    much as possible, missed out a lot of bounds checking */
 
 //config:config DATE
-//config:	bool "date (7.1 kb)"
+//config:	bool "date (7 kb)"
 //config:	default y
 //config:	help
 //config:	date is used to set the system date or display the
diff -urpN busybox-1.29.3/coreutils/dd.c busybox-1.30.0/coreutils/dd.c
--- busybox-1.29.3/coreutils/dd.c	2018-07-02 13:23:06.000000000 +0200
+++ busybox-1.30.0/coreutils/dd.c	2018-12-30 16:14:20.000000000 +0100
@@ -7,7 +7,7 @@
  * Licensed under GPLv2 or later, see file LICENSE in this source tree.
  */
 //config:config DD
-//config:	bool "dd (7.1 kb)"
+//config:	bool "dd (7.5 kb)"
 //config:	default y
 //config:	help
 //config:	dd copies a file (from standard input to standard output,
@@ -37,7 +37,7 @@
 //config:	elapsed time and speed.
 //config:
 //config:config FEATURE_DD_IBS_OBS
-//config:	bool "Enable ibs, obs, iflag and conv options"
+//config:	bool "Enable ibs, obs, iflag, oflag and conv options"
 //config:	default y
 //config:	depends on DD
 //config:	help
@@ -56,8 +56,11 @@
 //kbuild:lib-$(CONFIG_DD) += dd.o
 
 //usage:#define dd_trivial_usage
-//usage:       "[if=FILE] [of=FILE] " IF_FEATURE_DD_IBS_OBS("[ibs=N] [obs=N] ") "[bs=N] [count=N] [skip=N]\n"
-//usage:       "	[seek=N]" IF_FEATURE_DD_IBS_OBS(" [conv=notrunc|noerror|sync|fsync] [iflag=skip_bytes|fullblock]")
+//usage:       "[if=FILE] [of=FILE] [" IF_FEATURE_DD_IBS_OBS("ibs=N obs=N/") "bs=N] [count=N] [skip=N] [seek=N]\n"
+//usage:	IF_FEATURE_DD_IBS_OBS(
+//usage:       "	[conv=notrunc|noerror|sync|fsync]\n"
+//usage:       "	[iflag=skip_bytes|fullblock] [oflag=seek_bytes]"
+//usage:	)
 //usage:#define dd_full_usage "\n\n"
 //usage:       "Copy a file with converting and formatting\n"
 //usage:     "\n	if=FILE		Read from FILE instead of stdin"
@@ -80,6 +83,7 @@
 //usage:     "\n	conv=swab	Swap every pair of bytes"
 //usage:     "\n	iflag=skip_bytes	skip=N is in bytes"
 //usage:     "\n	iflag=fullblock	Read full blocks"
+//usage:     "\n	oflag=seek_bytes	seek=N is in bytes"
 //usage:	)
 //usage:	IF_FEATURE_DD_STATUS(
 //usage:     "\n	status=noxfer	Suppress rate output"
@@ -133,10 +137,14 @@ enum {
 	FLAG_SKIP_BYTES = (1 << 5) * ENABLE_FEATURE_DD_IBS_OBS,
 	FLAG_FULLBLOCK = (1 << 6) * ENABLE_FEATURE_DD_IBS_OBS,
 	/* end of input flags */
-	FLAG_TWOBUFS = (1 << 7) * ENABLE_FEATURE_DD_IBS_OBS,
-	FLAG_COUNT   = 1 << 8,
-	FLAG_STATUS_NONE = 1 << 9,
-	FLAG_STATUS_NOXFER = 1 << 10,
+	/* start of output flags */
+	FLAG_OFLAG_SHIFT = 7,
+	FLAG_SEEK_BYTES = (1 << 7) * ENABLE_FEATURE_DD_IBS_OBS,
+	/* end of output flags */
+	FLAG_TWOBUFS = (1 << 8) * ENABLE_FEATURE_DD_IBS_OBS,
+	FLAG_COUNT   = 1 << 9,
+	FLAG_STATUS_NONE = 1 << 10,
+	FLAG_STATUS_NOXFER = 1 << 11,
 };
 
 static void dd_output_status(int UNUSED_PARAM cur_signal)
@@ -250,7 +258,7 @@ int dd_main(int argc UNUSED_PARAM, char
 	static const char keywords[] ALIGN1 =
 		"bs\0""count\0""seek\0""skip\0""if\0""of\0"IF_FEATURE_DD_STATUS("status\0")
 #if ENABLE_FEATURE_DD_IBS_OBS
-		"ibs\0""obs\0""conv\0""iflag\0"
+		"ibs\0""obs\0""conv\0""iflag\0""oflag\0"
 #endif
 		;
 #if ENABLE_FEATURE_DD_IBS_OBS
@@ -258,6 +266,8 @@ int dd_main(int argc UNUSED_PARAM, char
 		"notrunc\0""sync\0""noerror\0""fsync\0""swab\0";
 	static const char iflag_words[] ALIGN1 =
 		"skip_bytes\0""fullblock\0";
+	static const char oflag_words[] ALIGN1 =
+		"seek_bytes\0";
 #endif
 #if ENABLE_FEATURE_DD_STATUS
 	static const char status_words[] ALIGN1 =
@@ -276,6 +286,7 @@ int dd_main(int argc UNUSED_PARAM, char
 		OP_obs,
 		OP_conv,
 		OP_iflag,
+		OP_oflag,
 		/* Must be in the same order as FLAG_XXX! */
 		OP_conv_notrunc = 0,
 		OP_conv_sync,
@@ -297,6 +308,7 @@ int dd_main(int argc UNUSED_PARAM, char
 	//swab          swap every pair of input bytes: will abort on non-even reads
 		OP_iflag_skip_bytes,
 		OP_iflag_fullblock,
+		OP_oflag_seek_bytes,
 #endif
 	};
 	smallint exitcode = EXIT_FAILURE;
@@ -312,13 +324,13 @@ int dd_main(int argc UNUSED_PARAM, char
 #endif
 	/* These are all zeroed at once! */
 	struct {
-		size_t oc;
+		IF_FEATURE_DD_IBS_OBS(size_t ocount;)
 		ssize_t prev_read_size; /* for detecting swab failure */
 		off_t count;
 		off_t seek, skip;
 		const char *infile, *outfile;
 	} Z;
-#define oc      (Z.oc     )
+#define ocount  (Z.ocount )
 #define prev_read_size (Z.prev_read_size)
 #define count   (Z.count  )
 #define seek    (Z.seek   )
@@ -368,6 +380,10 @@ int dd_main(int argc UNUSED_PARAM, char
 			G.flags |= parse_comma_flags(val, iflag_words, "iflag") << FLAG_IFLAG_SHIFT;
 			/*continue;*/
 		}
+		if (what == OP_oflag) {
+			G.flags |= parse_comma_flags(val, oflag_words, "oflag") << FLAG_OFLAG_SHIFT;
+			/*continue;*/
+		}
 #endif
 		if (what == OP_bs) {
 			ibs = xatoul_range_sfx(val, 1, ((size_t)-1L)/2, cwbkMG_suffixes);
@@ -439,7 +455,8 @@ int dd_main(int argc UNUSED_PARAM, char
 		xmove_fd(xopen(outfile, oflag), ofd);
 
 		if (seek && !(G.flags & FLAG_NOTRUNC)) {
-			if (ftruncate(ofd, seek * obs) < 0) {
+			size_t blocksz = (G.flags & FLAG_SEEK_BYTES) ? 1 : obs;
+			if (ftruncate(ofd, seek * blocksz) < 0) {
 				struct stat st;
 
 				if (fstat(ofd, &st) < 0
@@ -472,7 +489,8 @@ int dd_main(int argc UNUSED_PARAM, char
 		}
 	}
 	if (seek) {
-		if (lseek(ofd, seek * obs, SEEK_CUR) < 0)
+		size_t blocksz = (G.flags & FLAG_SEEK_BYTES) ? 1 : obs;
+		if (lseek(ofd, seek * blocksz, SEEK_CUR) < 0)
 			goto die_outfile;
 	}
 
@@ -527,24 +545,26 @@ int dd_main(int argc UNUSED_PARAM, char
 				n = ibs;
 			}
 		}
+#if ENABLE_FEATURE_DD_IBS_OBS
 		if (G.flags & FLAG_TWOBUFS) {
 			char *tmp = ibuf;
 			while (n) {
-				size_t d = obs - oc;
-
+				size_t d = obs - ocount;
 				if (d > (size_t)n)
 					d = n;
-				memcpy(obuf + oc, tmp, d);
+				memcpy(obuf + ocount, tmp, d);
 				n -= d;
 				tmp += d;
-				oc += d;
-				if (oc == obs) {
+				ocount += d;
+				if (ocount == obs) {
 					if (write_and_stats(obuf, obs, obs, outfile))
 						goto out_status;
-					oc = 0;
+					ocount = 0;
 				}
 			}
-		} else {
+		} else
+#endif
+		{
 			if (write_and_stats(ibuf, n, obs, outfile))
 				goto out_status;
 		}
@@ -555,10 +575,12 @@ int dd_main(int argc UNUSED_PARAM, char
 			goto die_outfile;
 	}
 
-	if (ENABLE_FEATURE_DD_IBS_OBS && oc) {
-		if (write_and_stats(obuf, oc, obs, outfile))
+#if ENABLE_FEATURE_DD_IBS_OBS
+	if (ocount != 0) {
+		if (write_and_stats(obuf, ocount, obs, outfile))
 			goto out_status;
 	}
+#endif
 	if (close(ifd) < 0) {
  die_infile:
 		bb_simple_perror_msg_and_die(infile);
diff -urpN busybox-1.29.3/coreutils/df.c busybox-1.30.0/coreutils/df.c
--- busybox-1.29.3/coreutils/df.c	2018-07-02 13:23:06.000000000 +0200
+++ busybox-1.30.0/coreutils/df.c	2018-12-30 16:14:20.000000000 +0100
@@ -18,7 +18,7 @@
  * Implement -P and -B; better coreutils compat; cleanup
  */
 //config:config DF
-//config:	bool "df (7.5 kb)"
+//config:	bool "df (6.8 kb)"
 //config:	default y
 //config:	help
 //config:	df reports the amount of disk space used and available
diff -urpN busybox-1.29.3/coreutils/dirname.c busybox-1.30.0/coreutils/dirname.c
--- busybox-1.29.3/coreutils/dirname.c	2018-07-02 13:23:06.000000000 +0200
+++ busybox-1.30.0/coreutils/dirname.c	2018-12-30 16:14:20.000000000 +0100
@@ -7,7 +7,7 @@
  * Licensed under GPLv2 or later, see file LICENSE in this source tree.
  */
 //config:config DIRNAME
-//config:	bool "dirname (289 bytes)"
+//config:	bool "dirname (329 bytes)"
 //config:	default y
 //config:	help
 //config:	dirname is used to strip a non-directory suffix from
diff -urpN busybox-1.29.3/coreutils/dos2unix.c busybox-1.30.0/coreutils/dos2unix.c
--- busybox-1.29.3/coreutils/dos2unix.c	2018-07-02 13:23:06.000000000 +0200
+++ busybox-1.30.0/coreutils/dos2unix.c	2018-12-30 16:14:20.000000000 +0100
@@ -12,14 +12,14 @@
  * Licensed under GPLv2 or later, see file LICENSE in this source tree.
  */
 //config:config DOS2UNIX
-//config:	bool "dos2unix (5.1 kb)"
+//config:	bool "dos2unix (5.2 kb)"
 //config:	default y
 //config:	help
 //config:	dos2unix is used to convert a text file from DOS format to
 //config:	UNIX format, and vice versa.
 //config:
 //config:config UNIX2DOS
-//config:	bool "unix2dos (5.1 kb)"
+//config:	bool "unix2dos (5.2 kb)"
 //config:	default y
 //config:	help
 //config:	unix2dos is used to convert a text file from UNIX format to
diff -urpN busybox-1.29.3/coreutils/du.c busybox-1.30.0/coreutils/du.c
--- busybox-1.29.3/coreutils/du.c	2018-07-02 13:23:06.000000000 +0200
+++ busybox-1.30.0/coreutils/du.c	2018-12-30 16:14:20.000000000 +0100
@@ -19,18 +19,16 @@
  * 4) Fixed busybox bug #1284 involving long overflow with human_readable.
  */
 //config:config DU
-//config:	bool "du (default blocksize of 512 bytes)"
+//config:	bool "du (6.3 kb)"
 //config:	default y
 //config:	help
 //config:	du is used to report the amount of disk space used
 //config:	for specified files.
 //config:
 //config:config FEATURE_DU_DEFAULT_BLOCKSIZE_1K
-//config:	bool "Use a default blocksize of 1024 bytes (1K)"
+//config:	bool "Use default blocksize of 1024 bytes (else it's 512 bytes)"
 //config:	default y
 //config:	depends on DU
-//config:	help
-//config:	Use a blocksize of (1K) instead of the default 512b.
 
 //applet:IF_DU(APPLET(du, BB_DIR_USR_BIN, BB_SUID_DROP))
 
diff -urpN busybox-1.29.3/coreutils/echo.c busybox-1.30.0/coreutils/echo.c
--- busybox-1.29.3/coreutils/echo.c	2018-07-02 13:23:06.000000000 +0200
+++ busybox-1.30.0/coreutils/echo.c	2018-12-30 16:14:20.000000000 +0100
@@ -19,10 +19,10 @@
  *    The previous version did not allow 4-digit octals.
  */
 //config:config ECHO
-//config:	bool "echo (basic SuSv3 version taking no options)"
+//config:	bool "echo (1.8 kb)"
 //config:	default y
 //config:	help
-//config:	echo is used to print a specified string to stdout.
+//config:	echo prints a specified string to stdout.
 //config:
 //config:# this entry also appears in shell/Config.in, next to the echo builtin
 //config:config FEATURE_FANCY_ECHO
diff -urpN busybox-1.29.3/coreutils/env.c busybox-1.30.0/coreutils/env.c
--- busybox-1.29.3/coreutils/env.c	2018-07-02 13:23:06.000000000 +0200
+++ busybox-1.30.0/coreutils/env.c	2018-12-30 16:14:20.000000000 +0100
@@ -24,7 +24,7 @@
  * - use xfunc_error_retval
  */
 //config:config ENV
-//config:	bool "env (3.8 kb)"
+//config:	bool "env (4 kb)"
 //config:	default y
 //config:	help
 //config:	env is used to set an environment variable and run
diff -urpN busybox-1.29.3/coreutils/expand.c busybox-1.30.0/coreutils/expand.c
--- busybox-1.29.3/coreutils/expand.c	2018-07-02 13:23:06.000000000 +0200
+++ busybox-1.30.0/coreutils/expand.c	2018-12-30 16:14:20.000000000 +0100
@@ -21,13 +21,13 @@
  *  Caveat: this versions of expand and unexpand don't accept tab lists.
  */
 //config:config EXPAND
-//config:	bool "expand (5.8 kb)"
+//config:	bool "expand (5.1 kb)"
 //config:	default y
 //config:	help
 //config:	By default, convert all tabs to spaces.
 //config:
 //config:config UNEXPAND
-//config:	bool "unexpand (6 kb)"
+//config:	bool "unexpand (5.3 kb)"
 //config:	default y
 //config:	help
 //config:	By default, convert only leading sequences of blanks to tabs.
diff -urpN busybox-1.29.3/coreutils/expr.c busybox-1.30.0/coreutils/expr.c
--- busybox-1.29.3/coreutils/expr.c	2018-07-02 13:23:06.000000000 +0200
+++ busybox-1.30.0/coreutils/expr.c	2018-12-30 16:14:20.000000000 +0100
@@ -23,7 +23,7 @@
  * provided they all associate ((x op x) op x).
  */
 //config:config EXPR
-//config:	bool "expr (6.1 kb)"
+//config:	bool "expr (6.6 kb)"
 //config:	default y
 //config:	help
 //config:	expr is used to calculate numbers and print the result
diff -urpN busybox-1.29.3/coreutils/factor.c busybox-1.30.0/coreutils/factor.c
--- busybox-1.29.3/coreutils/factor.c	2018-07-02 13:23:06.000000000 +0200
+++ busybox-1.30.0/coreutils/factor.c	2018-12-30 16:14:20.000000000 +0100
@@ -4,7 +4,7 @@
  * Licensed under GPLv2, see file LICENSE in this source tree.
  */
 //config:config FACTOR
-//config:	bool "factor (2.6 kb)"
+//config:	bool "factor (2.7 kb)"
 //config:	default y
 //config:	help
 //config:	factor factorizes integers
diff -urpN busybox-1.29.3/coreutils/fsync.c busybox-1.30.0/coreutils/fsync.c
--- busybox-1.29.3/coreutils/fsync.c	2018-07-02 13:23:06.000000000 +0200
+++ busybox-1.30.0/coreutils/fsync.c	2018-12-30 16:14:20.000000000 +0100
@@ -7,7 +7,7 @@
  * Licensed under GPLv2 or later, see file LICENSE in this source tree.
  */
 //config:config FSYNC
-//config:	bool "fsync (3.7 kb)"
+//config:	bool "fsync (3.6 kb)"
 //config:	default y
 //config:	help
 //config:	fsync is used to flush file-related cached blocks to disk.
diff -urpN busybox-1.29.3/coreutils/head.c busybox-1.30.0/coreutils/head.c
--- busybox-1.29.3/coreutils/head.c	2018-07-02 13:23:06.000000000 +0200
+++ busybox-1.30.0/coreutils/head.c	2018-12-30 16:14:20.000000000 +0100
@@ -7,7 +7,7 @@
  * Licensed under GPLv2 or later, see file LICENSE in this source tree.
  */
 //config:config HEAD
-//config:	bool "head (3.7 kb)"
+//config:	bool "head (3.8 kb)"
 //config:	default y
 //config:	help
 //config:	head is used to print the first specified number of lines
diff -urpN busybox-1.29.3/coreutils/hostid.c busybox-1.30.0/coreutils/hostid.c
--- busybox-1.29.3/coreutils/hostid.c	2018-07-02 13:23:06.000000000 +0200
+++ busybox-1.30.0/coreutils/hostid.c	2018-12-30 16:14:20.000000000 +0100
@@ -7,7 +7,7 @@
  * Licensed under GPLv2 or later, see file LICENSE in this source tree.
  */
 //config:config HOSTID
-//config:	bool "hostid (247 bytes)"
+//config:	bool "hostid (286 bytes)"
 //config:	default y
 //config:	help
 //config:	hostid prints the numeric identifier (in hexadecimal) for
diff -urpN busybox-1.29.3/coreutils/id.c busybox-1.30.0/coreutils/id.c
--- busybox-1.29.3/coreutils/id.c	2018-07-02 13:23:06.000000000 +0200
+++ busybox-1.30.0/coreutils/id.c	2018-12-30 16:14:20.000000000 +0100
@@ -13,13 +13,13 @@
  * Added -G option Tito Ragusa (C) 2008 for SUSv3.
  */
 //config:config ID
-//config:	bool "id (6.7 kb)"
+//config:	bool "id (7 kb)"
 //config:	default y
 //config:	help
 //config:	id displays the current user and group ID names.
 //config:
 //config:config GROUPS
-//config:	bool "groups (6.5 kb)"
+//config:	bool "groups (6.7 kb)"
 //config:	default y
 //config:	help
 //config:	Print the group names associated with current user id.
diff -urpN busybox-1.29.3/coreutils/link.c busybox-1.30.0/coreutils/link.c
--- busybox-1.29.3/coreutils/link.c	2018-07-02 13:23:06.000000000 +0200
+++ busybox-1.30.0/coreutils/link.c	2018-12-30 16:14:20.000000000 +0100
@@ -6,7 +6,7 @@
  * Licensed under GPLv2, see file LICENSE in this source tree.
  */
 //config:config LINK
-//config:	bool "link (3.1 kb)"
+//config:	bool "link (3.2 kb)"
 //config:	default y
 //config:	help
 //config:	link creates hard links between files.
diff -urpN busybox-1.29.3/coreutils/ln.c busybox-1.30.0/coreutils/ln.c
--- busybox-1.29.3/coreutils/ln.c	2018-07-02 13:23:06.000000000 +0200
+++ busybox-1.30.0/coreutils/ln.c	2018-12-30 16:14:20.000000000 +0100
@@ -7,7 +7,7 @@
  * Licensed under GPLv2 or later, see file LICENSE in this source tree.
  */
 //config:config LN
-//config:	bool "ln (4.5 kb)"
+//config:	bool "ln (4.9 kb)"
 //config:	default y
 //config:	help
 //config:	ln is used to create hard or soft links between files.
diff -urpN busybox-1.29.3/coreutils/logname.c busybox-1.30.0/coreutils/logname.c
--- busybox-1.29.3/coreutils/logname.c	2018-07-02 13:23:06.000000000 +0200
+++ busybox-1.30.0/coreutils/logname.c	2018-12-30 16:14:20.000000000 +0100
@@ -16,7 +16,7 @@
  * a diagnostic message and an error return.
  */
 //config:config LOGNAME
-//config:	bool "logname (894 bytes)"
+//config:	bool "logname (1.1 kb)"
 //config:	default y
 //config:	help
 //config:	logname is used to print the current user's login name.
diff -urpN busybox-1.29.3/coreutils/ls.c busybox-1.30.0/coreutils/ls.c
--- busybox-1.29.3/coreutils/ls.c	2018-07-02 13:23:06.000000000 +0200
+++ busybox-1.30.0/coreutils/ls.c	2018-12-05 15:44:34.000000000 +0100
@@ -421,7 +421,7 @@ static unsigned calc_name_len(const char
 	uni_stat_t uni_stat;
 
 	// TODO: quote tab as \t, etc, if -Q
-	name = printable_string(&uni_stat, name);
+	name = printable_string2(&uni_stat, name);
 
 	if (!(option_mask32 & OPT_Q)) {
 		return uni_stat.unicode_width;
@@ -450,7 +450,7 @@ static unsigned print_name(const char *n
 	uni_stat_t uni_stat;
 
 	// TODO: quote tab as \t, etc, if -Q
-	name = printable_string(&uni_stat, name);
+	name = printable_string2(&uni_stat, name);
 
 	if (!(option_mask32 & OPT_Q)) {
 		fputs(name, stdout);
@@ -1016,7 +1016,15 @@ static void scan_and_display_dirs_recur(
 		subdnp = scan_one_dir((*dn)->fullname, &nfiles);
 #if ENABLE_DESKTOP
 		if (option_mask32 & (OPT_s|OPT_l)) {
-			printf("total %"OFF_FMT"u\n", calculate_blocks(subdnp));
+			if (option_mask32 & OPT_h) {
+				printf("total %-"HUMAN_READABLE_MAX_WIDTH_STR"s\n",
+					/* print size, no fractions, use suffixes */
+					make_human_readable_str(calculate_blocks(subdnp) * 1024,
+								0, 0)
+				);
+			} else {
+				printf("total %"OFF_FMT"u\n", calculate_blocks(subdnp));
+			}
 		}
 #endif
 		if (nfiles > 0) {
diff -urpN busybox-1.29.3/coreutils/md5_sha1_sum.c busybox-1.30.0/coreutils/md5_sha1_sum.c
--- busybox-1.29.3/coreutils/md5_sha1_sum.c	2018-07-02 13:23:06.000000000 +0200
+++ busybox-1.30.0/coreutils/md5_sha1_sum.c	2018-12-30 16:14:20.000000000 +0100
@@ -6,31 +6,31 @@
  * Licensed under GPLv2 or later, see file LICENSE in this source tree.
  */
 //config:config MD5SUM
-//config:	bool "md5sum (6.8 kb)"
+//config:	bool "md5sum (6.5 kb)"
 //config:	default y
 //config:	help
 //config:	Compute and check MD5 message digest
 //config:
 //config:config SHA1SUM
-//config:	bool "sha1sum (6 kb)"
+//config:	bool "sha1sum (5.9 kb)"
 //config:	default y
 //config:	help
 //config:	Compute and check SHA1 message digest
 //config:
 //config:config SHA256SUM
-//config:	bool "sha256sum (7.1 kb)"
+//config:	bool "sha256sum (7 kb)"
 //config:	default y
 //config:	help
 //config:	Compute and check SHA256 message digest
 //config:
 //config:config SHA512SUM
-//config:	bool "sha512sum (7.6 kb)"
+//config:	bool "sha512sum (7.4 kb)"
 //config:	default y
 //config:	help
 //config:	Compute and check SHA512 message digest
 //config:
 //config:config SHA3SUM
-//config:	bool "sha3sum (6.3 kb)"
+//config:	bool "sha3sum (6.1 kb)"
 //config:	default y
 //config:	help
 //config:	Compute and check SHA3 message digest
diff -urpN busybox-1.29.3/coreutils/mkdir.c busybox-1.30.0/coreutils/mkdir.c
--- busybox-1.29.3/coreutils/mkdir.c	2018-07-02 13:23:06.000000000 +0200
+++ busybox-1.30.0/coreutils/mkdir.c	2018-12-30 16:14:20.000000000 +0100
@@ -14,7 +14,7 @@
 /* Nov 28, 2006      Yoshinori Sato <ysato@users.sourceforge.jp>: Add SELinux Support.
  */
 //config:config MKDIR
-//config:	bool "mkdir (4.4 kb)"
+//config:	bool "mkdir (4.5 kb)"
 //config:	default y
 //config:	help
 //config:	mkdir is used to create directories with the specified names.
diff -urpN busybox-1.29.3/coreutils/mkfifo.c busybox-1.30.0/coreutils/mkfifo.c
--- busybox-1.29.3/coreutils/mkfifo.c	2018-07-02 13:23:06.000000000 +0200
+++ busybox-1.30.0/coreutils/mkfifo.c	2018-12-30 16:14:20.000000000 +0100
@@ -7,7 +7,7 @@
  * Licensed under GPLv2 or later, see file LICENSE in this source tree.
  */
 //config:config MKFIFO
-//config:	bool "mkfifo (3.7 kb)"
+//config:	bool "mkfifo (3.8 kb)"
 //config:	default y
 //config:	help
 //config:	mkfifo is used to create FIFOs (named pipes).
diff -urpN busybox-1.29.3/coreutils/mknod.c busybox-1.30.0/coreutils/mknod.c
--- busybox-1.29.3/coreutils/mknod.c	2018-07-02 13:23:06.000000000 +0200
+++ busybox-1.30.0/coreutils/mknod.c	2018-12-30 16:14:20.000000000 +0100
@@ -7,7 +7,7 @@
  * Licensed under GPLv2 or later, see file LICENSE in this source tree.
  */
 //config:config MKNOD
-//config:	bool "mknod (4 kb)"
+//config:	bool "mknod (4.5 kb)"
 //config:	default y
 //config:	help
 //config:	mknod is used to create FIFOs or block/character special
diff -urpN busybox-1.29.3/coreutils/mktemp.c busybox-1.30.0/coreutils/mktemp.c
--- busybox-1.29.3/coreutils/mktemp.c	2018-07-02 13:23:06.000000000 +0200
+++ busybox-1.30.0/coreutils/mktemp.c	2018-12-30 16:14:20.000000000 +0100
@@ -29,7 +29,7 @@
  *        -p; else /tmp [deprecated]
  */
 //config:config MKTEMP
-//config:	bool "mktemp (4 kb)"
+//config:	bool "mktemp (4.2 kb)"
 //config:	default y
 //config:	help
 //config:	mktemp is used to create unique temporary files
diff -urpN busybox-1.29.3/coreutils/mv.c busybox-1.30.0/coreutils/mv.c
--- busybox-1.29.3/coreutils/mv.c	2018-07-02 13:23:06.000000000 +0200
+++ busybox-1.30.0/coreutils/mv.c	2018-12-30 16:14:20.000000000 +0100
@@ -12,7 +12,7 @@
  * Size reduction and improved error checking.
  */
 //config:config MV
-//config:	bool "mv (9.8 kb)"
+//config:	bool "mv (10 kb)"
 //config:	default y
 //config:	help
 //config:	mv is used to move or rename files or directories.
diff -urpN busybox-1.29.3/coreutils/nice.c busybox-1.30.0/coreutils/nice.c
--- busybox-1.29.3/coreutils/nice.c	2018-07-02 13:23:06.000000000 +0200
+++ busybox-1.30.0/coreutils/nice.c	2018-12-30 16:14:20.000000000 +0100
@@ -7,7 +7,7 @@
  * Licensed under GPLv2 or later, see file LICENSE in this source tree.
  */
 //config:config NICE
-//config:	bool "nice (1.8 kb)"
+//config:	bool "nice (2.1 kb)"
 //config:	default y
 //config:	help
 //config:	nice runs a program with modified scheduling priority.
diff -urpN busybox-1.29.3/coreutils/nl.c busybox-1.30.0/coreutils/nl.c
--- busybox-1.29.3/coreutils/nl.c	2018-07-02 13:23:06.000000000 +0200
+++ busybox-1.30.0/coreutils/nl.c	2018-12-30 16:14:20.000000000 +0100
@@ -5,7 +5,7 @@
  * Licensed under GPLv2, see file LICENSE in this source tree.
  */
 //config:config NL
-//config:	bool "nl (4.3 kb)"
+//config:	bool "nl (4.6 kb)"
 //config:	default y
 //config:	help
 //config:	nl is used to number lines of files.
@@ -58,6 +58,8 @@ int nl_main(int argc UNUSED_PARAM, char
 		"number-width\0"	Required_argument "w"
 	;
 #endif
+	int exitcode;
+
 	ns.width = 6;
 	ns.start = 1;
 	ns.inc = 1;
@@ -72,9 +74,10 @@ int nl_main(int argc UNUSED_PARAM, char
 	if (!*argv)
 		*--argv = (char*)"-";
 
+	exitcode = EXIT_SUCCESS;
 	do {
-		print_numbered_lines(&ns, *argv);
+		exitcode |= print_numbered_lines(&ns, *argv);
 	} while (*++argv);
 
-	fflush_stdout_and_exit(EXIT_SUCCESS);
+	fflush_stdout_and_exit(exitcode);
 }
diff -urpN busybox-1.29.3/coreutils/nproc.c busybox-1.30.0/coreutils/nproc.c
--- busybox-1.29.3/coreutils/nproc.c	2018-07-02 13:23:06.000000000 +0200
+++ busybox-1.30.0/coreutils/nproc.c	2018-12-30 16:14:20.000000000 +0100
@@ -4,7 +4,7 @@
  * Licensed under GPLv2, see LICENSE in this source tree
  */
 //config:config NPROC
-//config:	bool "nproc (248 bytes)"
+//config:	bool "nproc (3.7 kb)"
 //config:	default y
 //config:	help
 //config:	Print number of CPUs
@@ -14,10 +14,14 @@
 //kbuild:lib-$(CONFIG_NPROC) += nproc.o
 
 //usage:#define nproc_trivial_usage
-//usage:	""
-//TODO: "[--all] [--ignore=N]"
+//usage:	""IF_LONG_OPTS("--all --ignore=N")
 //usage:#define nproc_full_usage "\n\n"
-//usage:	"Print number of CPUs"
+//usage:	"Print number of available CPUs"
+//usage:	IF_LONG_OPTS(
+//usage:     "\n"
+//usage:     "\n	--all		Number of installed CPUs"
+//usage:     "\n	--ignore=N	Exclude N CPUs"
+//usage:	)
 
 #include <sched.h>
 #include "libbb.h"
@@ -26,13 +30,30 @@ int nproc_main(int argc, char **argv) MA
 int nproc_main(int argc UNUSED_PARAM, char **argv UNUSED_PARAM)
 {
 	unsigned long mask[1024];
-	unsigned i, count = 0;
-
-	//getopt32(argv, "");
-
-	//if --all, count /sys/devices/system/cpu/cpuN dirs, else:
-
+	int count = 0;
+#if ENABLE_LONG_OPTS
+	int ignore = 0;
+	int opts = getopt32long(argv, "\xfe:+",
+			"ignore\0" Required_argument "\xfe"
+			"all\0"    No_argument       "\xff"
+			, &ignore
+	);
+
+	if (opts & (1 << 1)) {
+		DIR *cpusd = opendir("/sys/devices/system/cpu");
+		if (cpusd) {
+			struct dirent *de;
+			while (NULL != (de = readdir(cpusd))) {
+				char *cpuid = strstr(de->d_name, "cpu");
+				if (cpuid && isdigit(cpuid[strlen(cpuid) - 1]))
+					count++;
+			}
+			closedir(cpusd);
+		}
+	} else
+#endif
 	if (sched_getaffinity(0, sizeof(mask), (void*)mask) == 0) {
+		int i;
 		for (i = 0; i < ARRAY_SIZE(mask); i++) {
 			unsigned long m = mask[i];
 			while (m) {
@@ -42,8 +63,11 @@ int nproc_main(int argc UNUSED_PARAM, ch
 			}
 		}
 	}
-	if (count == 0)
-		count++;
+
+	IF_LONG_OPTS(count -= ignore;)
+	if (count <= 0)
+		count = 1;
+
 	printf("%u\n", count);
 
 	return 0;
diff -urpN busybox-1.29.3/coreutils/paste.c busybox-1.30.0/coreutils/paste.c
--- busybox-1.29.3/coreutils/paste.c	2018-07-02 13:23:06.000000000 +0200
+++ busybox-1.30.0/coreutils/paste.c	2018-12-30 16:14:20.000000000 +0100
@@ -7,7 +7,7 @@
  * Licensed under GPLv2 or later, see file LICENSE in this source tree.
  */
 //config:config PASTE
-//config:	bool "paste (4.5 kb)"
+//config:	bool "paste (4.9 kb)"
 //config:	default y
 //config:	help
 //config:	paste is used to paste lines of different files together
diff -urpN busybox-1.29.3/coreutils/printenv.c busybox-1.30.0/coreutils/printenv.c
--- busybox-1.29.3/coreutils/printenv.c	2018-07-02 13:23:06.000000000 +0200
+++ busybox-1.30.0/coreutils/printenv.c	2018-12-30 16:14:20.000000000 +0100
@@ -8,7 +8,7 @@
  * Licensed under GPLv2 or later, see file LICENSE in this source tree.
  */
 //config:config PRINTENV
-//config:	bool "printenv (1 kb)"
+//config:	bool "printenv (1.3 kb)"
 //config:	default y
 //config:	help
 //config:	printenv is used to print all or part of environment.
diff -urpN busybox-1.29.3/coreutils/printf.c busybox-1.30.0/coreutils/printf.c
--- busybox-1.29.3/coreutils/printf.c	2018-07-02 13:23:06.000000000 +0200
+++ busybox-1.30.0/coreutils/printf.c	2018-12-30 16:14:20.000000000 +0100
@@ -38,7 +38,7 @@
 /* 19990508 Busy Boxed! Dave Cinege */
 
 //config:config PRINTF
-//config:	bool "printf (3.3 kb)"
+//config:	bool "printf (3.8 kb)"
 //config:	default y
 //config:	help
 //config:	printf is used to format and print specified strings.
@@ -95,6 +95,12 @@ static int multiconvert(const char *arg,
 
 static void FAST_FUNC conv_strtoull(const char *arg, void *result)
 {
+	/* Allow leading '+' - bb_strtoull() by itself does not allow it,
+	 * and probably shouldn't (other callers might require purely numeric
+	 * inputs to be allowed.
+	 */
+	if (arg[0] == '+')
+		arg++;
 	*(unsigned long long*)result = bb_strtoull(arg, NULL, 0);
 	/* both coreutils 6.10 and bash 3.2:
 	 * $ printf '%x\n' -2
@@ -107,6 +113,8 @@ static void FAST_FUNC conv_strtoull(cons
 }
 static void FAST_FUNC conv_strtoll(const char *arg, void *result)
 {
+	if (arg[0] == '+')
+		arg++;
 	*(long long*)result = bb_strtoll(arg, NULL, 0);
 }
 static void FAST_FUNC conv_strtod(const char *arg, void *result)
@@ -191,6 +199,7 @@ static void print_direc(char *format, un
 	if (have_width - 1 == have_prec)
 		have_width = NULL;
 
+	/* multiconvert sets errno = 0, but %s needs it cleared */
 	errno = 0;
 
 	switch (format[fmt_length - 1]) {
@@ -199,7 +208,7 @@ static void print_direc(char *format, un
 		break;
 	case 'd':
 	case 'i':
-		llv = my_xstrtoll(argument);
+		llv = my_xstrtoll(skip_whitespace(argument));
  print_long:
 		if (!have_width) {
 			if (!have_prec)
@@ -217,7 +226,7 @@ static void print_direc(char *format, un
 	case 'u':
 	case 'x':
 	case 'X':
-		llv = my_xstrtoull(argument);
+		llv = my_xstrtoull(skip_whitespace(argument));
 		/* cheat: unsigned long and long have same width, so... */
 		goto print_long;
 	case 's':
diff -urpN busybox-1.29.3/coreutils/pwd.c busybox-1.30.0/coreutils/pwd.c
--- busybox-1.29.3/coreutils/pwd.c	2018-07-02 13:23:06.000000000 +0200
+++ busybox-1.30.0/coreutils/pwd.c	2018-12-30 16:14:20.000000000 +0100
@@ -7,7 +7,7 @@
  * Licensed under GPLv2 or later, see file LICENSE in this source tree.
  */
 //config:config PWD
-//config:	bool "pwd (3.4 kb)"
+//config:	bool "pwd (3.7 kb)"
 //config:	default y
 //config:	help
 //config:	pwd is used to print the current directory.
diff -urpN busybox-1.29.3/coreutils/readlink.c busybox-1.30.0/coreutils/readlink.c
--- busybox-1.29.3/coreutils/readlink.c	2018-07-02 13:23:06.000000000 +0200
+++ busybox-1.30.0/coreutils/readlink.c	2018-12-30 16:14:20.000000000 +0100
@@ -7,7 +7,7 @@
  * Licensed under GPLv2 or later, see file LICENSE in this source tree.
  */
 //config:config READLINK
-//config:	bool "readlink (3.6 kb)"
+//config:	bool "readlink (4 kb)"
 //config:	default y
 //config:	help
 //config:	This program reads a symbolic link and returns the name
diff -urpN busybox-1.29.3/coreutils/realpath.c busybox-1.30.0/coreutils/realpath.c
--- busybox-1.29.3/coreutils/realpath.c	2018-07-02 13:23:06.000000000 +0200
+++ busybox-1.30.0/coreutils/realpath.c	2018-12-30 16:14:20.000000000 +0100
@@ -8,7 +8,7 @@
  * Licensed under GPLv2 or later, see file LICENSE in this source tree.
  */
 //config:config REALPATH
-//config:	bool "realpath (1.1 kb)"
+//config:	bool "realpath (1.6 kb)"
 //config:	default y
 //config:	help
 //config:	Return the canonicalized absolute pathname.
diff -urpN busybox-1.29.3/coreutils/rm.c busybox-1.30.0/coreutils/rm.c
--- busybox-1.29.3/coreutils/rm.c	2018-07-02 13:23:06.000000000 +0200
+++ busybox-1.30.0/coreutils/rm.c	2018-12-30 16:14:20.000000000 +0100
@@ -11,7 +11,7 @@
  * Size reduction.
  */
 //config:config RM
-//config:	bool "rm (4.9 kb)"
+//config:	bool "rm (5.4 kb)"
 //config:	default y
 //config:	help
 //config:	rm is used to remove files or directories.
diff -urpN busybox-1.29.3/coreutils/rmdir.c busybox-1.30.0/coreutils/rmdir.c
--- busybox-1.29.3/coreutils/rmdir.c	2018-07-02 13:23:06.000000000 +0200
+++ busybox-1.30.0/coreutils/rmdir.c	2018-12-30 16:14:20.000000000 +0100
@@ -7,7 +7,7 @@
  * Licensed under GPLv2 or later, see file LICENSE in this source tree.
  */
 //config:config RMDIR
-//config:	bool "rmdir (3.4 kb)"
+//config:	bool "rmdir (3.5 kb)"
 //config:	default y
 //config:	help
 //config:	rmdir is used to remove empty directories.
diff -urpN busybox-1.29.3/coreutils/seq.c busybox-1.30.0/coreutils/seq.c
--- busybox-1.29.3/coreutils/seq.c	2018-07-02 13:23:06.000000000 +0200
+++ busybox-1.30.0/coreutils/seq.c	2018-12-30 16:14:20.000000000 +0100
@@ -7,7 +7,7 @@
  * Licensed under GPLv2, see file LICENSE in this source tree.
  */
 //config:config SEQ
-//config:	bool "seq (3.6 kb)"
+//config:	bool "seq (3.8 kb)"
 //config:	default y
 //config:	help
 //config:	print a sequence of numbers
diff -urpN busybox-1.29.3/coreutils/shred.c busybox-1.30.0/coreutils/shred.c
--- busybox-1.29.3/coreutils/shred.c	2018-07-02 13:23:06.000000000 +0200
+++ busybox-1.30.0/coreutils/shred.c	2018-12-30 16:14:20.000000000 +0100
@@ -5,7 +5,7 @@
  * Licensed under GPLv2, see file LICENSE in this source tree.
  */
 //config:config SHRED
-//config:	bool "shred (5 kb)"
+//config:	bool "shred (4.9 kb)"
 //config:	default y
 //config:	help
 //config:	Overwrite a file to hide its contents, and optionally delete it
diff -urpN busybox-1.29.3/coreutils/sleep.c busybox-1.30.0/coreutils/sleep.c
--- busybox-1.29.3/coreutils/sleep.c	2018-07-02 13:23:06.000000000 +0200
+++ busybox-1.30.0/coreutils/sleep.c	2018-12-30 16:14:20.000000000 +0100
@@ -13,7 +13,7 @@
  * time suffixes for seconds, minutes, hours, and days.
  */
 //config:config SLEEP
-//config:	bool "sleep (1.7 kb)"
+//config:	bool "sleep (2 kb)"
 //config:	default y
 //config:	help
 //config:	sleep is used to pause for a specified number of seconds.
@@ -32,13 +32,6 @@
 //config:	depends on SLEEP
 //config:	help
 //config:	Allow sleep to pause for specified minutes, hours, and days.
-//config:
-//config:config FEATURE_FLOAT_SLEEP
-//config:	bool "Enable fractional arguments"
-//config:	default y
-//config:	depends on FEATURE_FANCY_SLEEP
-//config:	help
-//config:	Allow for fractional numeric parameters.
 
 /* Do not make this applet NOFORK. It breaks ^C-ing of pauses in shells */
 //applet:IF_SLEEP(APPLET(sleep, BB_DIR_BIN, BB_SUID_DROP))
@@ -66,89 +59,28 @@
 
 #include "libbb.h"
 
-#if ENABLE_FEATURE_FANCY_SLEEP || ENABLE_FEATURE_FLOAT_SLEEP
-static const struct suffix_mult sfx[] = {
-	{ "s", 1 },
-	{ "m", 60 },
-	{ "h", 60*60 },
-	{ "d", 24*60*60 },
-	{ "", 0 }
-};
-#endif
-
 int sleep_main(int argc, char **argv) MAIN_EXTERNALLY_VISIBLE;
 int sleep_main(int argc UNUSED_PARAM, char **argv)
 {
-#if ENABLE_FEATURE_FLOAT_SLEEP
-	double duration;
-	struct timespec ts;
-#else
-	unsigned duration;
-#endif
+	duration_t duration;
 
 	++argv;
 	if (!*argv)
 		bb_show_usage();
 
-#if ENABLE_FEATURE_FLOAT_SLEEP
-
-# if ENABLE_LOCALE_SUPPORT
+#if ENABLE_FEATURE_FANCY_SLEEP
+# if ENABLE_FLOAT_DURATION
 	/* undo busybox.c setlocale */
 	setlocale(LC_NUMERIC, "C");
 # endif
 	duration = 0;
 	do {
-		char *arg = *argv;
-		if (strchr(arg, '.')) {
-			double d;
-			char *pp;
-			int len = strspn(arg, "0123456789.");
-			char sv = arg[len];
-			arg[len] = '\0';
-			errno = 0;
-			d = strtod(arg, &pp);
-			if (errno || *pp)
-				bb_show_usage();
-			arg += len;
-			*arg-- = sv;
-			sv = *arg;
-			*arg = '1';
-			duration += d * xatoul_sfx(arg, sfx);
-			*arg = sv;
-		} else {
-			duration += xatoul_sfx(arg, sfx);
-		}
+		duration += parse_duration_str(*argv);
 	} while (*++argv);
-
-	ts.tv_sec = MAXINT(typeof(ts.tv_sec));
-	ts.tv_nsec = 0;
-	if (duration >= 0 && duration < ts.tv_sec) {
-		ts.tv_sec = duration;
-		ts.tv_nsec = (duration - ts.tv_sec) * 1000000000;
-	}
-	do {
-		errno = 0;
-		nanosleep(&ts, &ts);
-	} while (errno == EINTR);
-
-#elif ENABLE_FEATURE_FANCY_SLEEP
-
-	duration = 0;
-	do {
-		duration += xatou_range_sfx(*argv, 0, UINT_MAX - duration, sfx);
-	} while (*++argv);
-	sleep(duration);
-
+	sleep_for_duration(duration);
 #else /* simple */
-
 	duration = xatou(*argv);
 	sleep(duration);
-	// Off. If it's really needed, provide example why
-	//if (sleep(duration)) {
-	//	bb_perror_nomsg_and_die();
-	//}
-
 #endif
-
 	return EXIT_SUCCESS;
 }
diff -urpN busybox-1.29.3/coreutils/sort.c busybox-1.30.0/coreutils/sort.c
--- busybox-1.29.3/coreutils/sort.c	2018-07-02 13:23:06.000000000 +0200
+++ busybox-1.30.0/coreutils/sort.c	2018-12-30 16:14:20.000000000 +0100
@@ -12,7 +12,7 @@
  * http://www.opengroup.org/onlinepubs/007904975/utilities/sort.html
  */
 //config:config SORT
-//config:	bool "sort (7.4 kb)"
+//config:	bool "sort (7.7 kb)"
 //config:	default y
 //config:	help
 //config:	sort is used to sort lines of text in specified files.
@@ -60,6 +60,7 @@
 //usage:	IF_FEATURE_SORT_BIG(
 //usage:     "\n	-g	General numerical sort"
 //usage:     "\n	-M	Sort month"
+//usage:     "\n	-V	Sort version"
 //usage:     "\n	-t CHAR	Field separator"
 //usage:     "\n	-k N[,M] Sort by Nth field"
 //usage:	)
@@ -91,32 +92,33 @@
 
 /* These are sort types */
 enum {
-	FLAG_n  = 1,            /* Numeric sort */
-	FLAG_g  = 2,            /* Sort using strtod() */
-	FLAG_M  = 4,            /* Sort date */
+	FLAG_n  = 1 << 0,       /* Numeric sort */
+	FLAG_g  = 1 << 1,       /* Sort using strtod() */
+	FLAG_M  = 1 << 2,       /* Sort date */
+	FLAG_V  = 1 << 3,       /* Sort version */
 /* ucsz apply to root level only, not keys.  b at root level implies bb */
-	FLAG_u  = 8,            /* Unique */
-	FLAG_c  = 0x10,         /* Check: no output, exit(!ordered) */
-	FLAG_s  = 0x20,         /* Stable sort, no ascii fallback at end */
-	FLAG_z  = 0x40,         /* Input and output is NUL terminated, not \n */
+	FLAG_u  = 1 << 4,       /* Unique */
+	FLAG_c  = 1 << 5,       /* Check: no output, exit(!ordered) */
+	FLAG_s  = 1 << 6,       /* Stable sort, no ascii fallback at end */
+	FLAG_z  = 1 << 7,       /* Input and output is NUL terminated, not \n */
 /* These can be applied to search keys, the previous four can't */
-	FLAG_b  = 0x80,         /* Ignore leading blanks */
-	FLAG_r  = 0x100,        /* Reverse */
-	FLAG_d  = 0x200,        /* Ignore !(isalnum()|isspace()) */
-	FLAG_f  = 0x400,        /* Force uppercase */
-	FLAG_i  = 0x800,        /* Ignore !isprint() */
-	FLAG_m  = 0x1000,       /* ignored: merge already sorted files; do not sort */
-	FLAG_S  = 0x2000,       /* ignored: -S, --buffer-size=SIZE */
-	FLAG_T  = 0x4000,       /* ignored: -T, --temporary-directory=DIR */
-	FLAG_o  = 0x8000,
-	FLAG_k  = 0x10000,
-	FLAG_t  = 0x20000,
+	FLAG_b  = 1 << 8,       /* Ignore leading blanks */
+	FLAG_r  = 1 << 9,       /* Reverse */
+	FLAG_d  = 1 << 10,      /* Ignore !(isalnum()|isspace()) */
+	FLAG_f  = 1 << 11,      /* Force uppercase */
+	FLAG_i  = 1 << 12,      /* Ignore !isprint() */
+	FLAG_m  = 1 << 13,      /* ignored: merge already sorted files; do not sort */
+	FLAG_S  = 1 << 14,      /* ignored: -S, --buffer-size=SIZE */
+	FLAG_T  = 1 << 15,      /* ignored: -T, --temporary-directory=DIR */
+	FLAG_o  = 1 << 16,
+	FLAG_k  = 1 << 17,
+	FLAG_t  = 1 << 18,
 	FLAG_bb = 0x80000000,   /* Ignore trailing blanks  */
 	FLAG_no_tie_break = 0x40000000,
 };
 
 static const char sort_opt_str[] ALIGN1 = "^"
-			"ngMucszbrdfimS:T:o:k:*t:"
+			"ngMVucszbrdfimS:T:o:k:*t:"
 			"\0" "o--o:t--t"/*-t, -o: at most one of each*/;
 /*
  * OPT_STR must not be string literal, needs to have stable address:
@@ -273,10 +275,15 @@ static int compare_keys(const void *xarg
 		y = *(char **)yarg;
 #endif
 		/* Perform actual comparison */
-		switch (flags & (FLAG_n | FLAG_M | FLAG_g)) {
+		switch (flags & (FLAG_n | FLAG_g | FLAG_M | FLAG_V)) {
 		default:
 			bb_error_msg_and_die("unknown sort type");
 			break;
+#if defined(HAVE_STRVERSCMP) && HAVE_STRVERSCMP == 1
+		case FLAG_V:
+			retval = strverscmp(x, y);
+			break;
+#endif
 		/* Ascii sort */
 		case 0:
 #if ENABLE_LOCALE_SUPPORT
diff -urpN busybox-1.29.3/coreutils/split.c busybox-1.30.0/coreutils/split.c
--- busybox-1.29.3/coreutils/split.c	2018-07-02 13:23:06.000000000 +0200
+++ busybox-1.30.0/coreutils/split.c	2018-12-30 16:14:20.000000000 +0100
@@ -6,7 +6,7 @@
  * Licensed under GPLv2 or later, see file LICENSE in this source tree.
  */
 //config:config SPLIT
-//config:	bool "split (5.4 kb)"
+//config:	bool "split (5 kb)"
 //config:	default y
 //config:	help
 //config:	Split a file into pieces.
diff -urpN busybox-1.29.3/coreutils/stat.c busybox-1.30.0/coreutils/stat.c
--- busybox-1.29.3/coreutils/stat.c	2018-07-02 13:23:06.000000000 +0200
+++ busybox-1.30.0/coreutils/stat.c	2018-12-30 16:14:20.000000000 +0100
@@ -13,7 +13,7 @@
  * Licensed under GPLv2 or later, see file LICENSE in this source tree.
  */
 //config:config STAT
-//config:	bool "stat (10 kb)"
+//config:	bool "stat (11 kb)"
 //config:	default y
 //config:	help
 //config:	display file or filesystem status.
diff -urpN busybox-1.29.3/coreutils/stty.c busybox-1.30.0/coreutils/stty.c
--- busybox-1.29.3/coreutils/stty.c	2018-07-02 13:23:06.000000000 +0200
+++ busybox-1.30.0/coreutils/stty.c	2018-12-30 16:14:20.000000000 +0100
@@ -21,7 +21,7 @@
  * Special for busybox ported by Vladimir Oleynik <dzo@simtreas.ru> 2001
  */
 //config:config STTY
-//config:	bool "stty (8.6 kb)"
+//config:	bool "stty (8.9 kb)"
 //config:	default y
 //config:	help
 //config:	stty is used to change and print terminal line settings.
diff -urpN busybox-1.29.3/coreutils/sum.c busybox-1.30.0/coreutils/sum.c
--- busybox-1.29.3/coreutils/sum.c	2018-07-02 13:23:06.000000000 +0200
+++ busybox-1.30.0/coreutils/sum.c	2018-12-30 16:14:20.000000000 +0100
@@ -13,7 +13,7 @@
  * Licensed under GPLv2 or later, see file LICENSE in this source tree.
  */
 //config:config SUM
-//config:	bool "sum (4.3 kb)"
+//config:	bool "sum (4 kb)"
 //config:	default y
 //config:	help
 //config:	checksum and count the blocks in a file
diff -urpN busybox-1.29.3/coreutils/sync.c busybox-1.30.0/coreutils/sync.c
--- busybox-1.29.3/coreutils/sync.c	2018-07-02 13:23:06.000000000 +0200
+++ busybox-1.30.0/coreutils/sync.c	2018-12-30 16:14:20.000000000 +0100
@@ -8,7 +8,7 @@
  * Licensed under GPLv2 or later, see file LICENSE in this source tree.
  */
 //config:config SYNC
-//config:	bool "sync (769 bytes)"
+//config:	bool "sync (3.8 kb)"
 //config:	default y
 //config:	help
 //config:	sync is used to flush filesystem buffers.
diff -urpN busybox-1.29.3/coreutils/tac.c busybox-1.30.0/coreutils/tac.c
--- busybox-1.29.3/coreutils/tac.c	2018-07-02 13:23:06.000000000 +0200
+++ busybox-1.30.0/coreutils/tac.c	2018-12-30 16:14:20.000000000 +0100
@@ -13,7 +13,7 @@
  * http://www.uclibc.org/lists/busybox/2003-July/008813.html
  */
 //config:config TAC
-//config:	bool "tac (4.1 kb)"
+//config:	bool "tac (3.9 kb)"
 //config:	default y
 //config:	help
 //config:	tac is used to concatenate and print files in reverse.
diff -urpN busybox-1.29.3/coreutils/tail.c busybox-1.30.0/coreutils/tail.c
--- busybox-1.29.3/coreutils/tail.c	2018-07-02 13:23:06.000000000 +0200
+++ busybox-1.30.0/coreutils/tail.c	2018-12-30 16:14:20.000000000 +0100
@@ -19,7 +19,7 @@
  * 7) lseek attempted when count==0 even if arg was +0 (from top)
  */
 //config:config TAIL
-//config:	bool "tail (7.1 kb)"
+//config:	bool "tail (6.8 kb)"
 //config:	default y
 //config:	help
 //config:	tail is used to print the last specified number of lines
diff -urpN busybox-1.29.3/coreutils/tee.c busybox-1.30.0/coreutils/tee.c
--- busybox-1.29.3/coreutils/tee.c	2018-07-02 13:23:06.000000000 +0200
+++ busybox-1.30.0/coreutils/tee.c	2018-12-30 16:14:20.000000000 +0100
@@ -7,7 +7,7 @@
  * Licensed under GPLv2 or later, see file LICENSE in this source tree.
  */
 //config:config TEE
-//config:	bool "tee (4.3 kb)"
+//config:	bool "tee (4.2 kb)"
 //config:	default y
 //config:	help
 //config:	tee is used to read from standard input and write
diff -urpN busybox-1.29.3/coreutils/test.c busybox-1.30.0/coreutils/test.c
--- busybox-1.29.3/coreutils/test.c	2018-07-02 13:23:06.000000000 +0200
+++ busybox-1.30.0/coreutils/test.c	2018-12-30 16:14:20.000000000 +0100
@@ -20,7 +20,7 @@
  *     "This program is in the Public Domain."
  */
 //config:config TEST
-//config:	bool "test (3.6 kb)"
+//config:	bool "test (4.1 kb)"
 //config:	default y
 //config:	help
 //config:	test is used to check file types and compare values,
diff -urpN busybox-1.29.3/coreutils/timeout.c busybox-1.30.0/coreutils/timeout.c
--- busybox-1.29.3/coreutils/timeout.c	2018-07-02 13:23:06.000000000 +0200
+++ busybox-1.30.0/coreutils/timeout.c	2018-12-30 16:14:20.000000000 +0100
@@ -28,7 +28,7 @@
  * rewrite  14-11-2008 vda
  */
 //config:config TIMEOUT
-//config:	bool "timeout (5.5 kb)"
+//config:	bool "timeout (6 kb)"
 //config:	default y
 //config:	help
 //config:	Runs a program and watches it. If it does not terminate in
@@ -39,10 +39,10 @@
 //kbuild:lib-$(CONFIG_TIMEOUT) += timeout.o
 
 //usage:#define timeout_trivial_usage
-//usage:       "[-t SECS] [-s SIG] PROG ARGS"
+//usage:       "[-s SIG] SECS PROG ARGS"
 //usage:#define timeout_full_usage "\n\n"
 //usage:       "Runs PROG. Sends SIG to it if it is not gone in SECS seconds.\n"
-//usage:       "Defaults: SECS: 10, SIG: TERM."
+//usage:       "Default SIG: TERM."
 
 #include "libbb.h"
 
@@ -52,7 +52,7 @@ int timeout_main(int argc UNUSED_PARAM,
 	int signo;
 	int status;
 	int parent = 0;
-	int timeout = 10;
+	int timeout;
 	pid_t pid;
 #if !BB_MMU
 	char *sv1, *sv2;
@@ -63,24 +63,29 @@ int timeout_main(int argc UNUSED_PARAM,
 
 	/* -t SECONDS; -p PARENT_PID */
 	/* '+': stop at first non-option */
-	getopt32(argv, "+s:t:+" USE_FOR_NOMMU("p:+"), &opt_s, &timeout, &parent);
+	getopt32(argv, "+s:" USE_FOR_NOMMU("p:+"), &opt_s, &parent);
 	/*argv += optind; - no, wait for bb_daemonize_or_rexec! */
+
 	signo = get_signum(opt_s);
 	if (signo < 0)
 		bb_error_msg_and_die("unknown signal '%s'", opt_s);
 
+	if (!argv[optind])
+		bb_show_usage();
+	timeout = parse_duration_str(argv[optind++]);
+	if (!argv[optind]) /* no PROG? */
+		bb_show_usage();
+
 	/* We want to create a grandchild which will watch
 	 * and kill the grandparent. Other methods:
 	 * making parent watch child disrupts parent<->child link
 	 * (example: "tcpsvd 0.0.0.0 1234 timeout service_prog" -
 	 * it's better if service_prog is a child of tcpsvd!),
 	 * making child watch parent results in programs having
-	 * unexpected children. */
+	 * unexpected children.	*/
 
 	if (parent) /* we were re-execed, already grandchild */
 		goto grandchild;
-	if (!argv[optind]) /* no PROG? */
-		bb_show_usage();
 
 #if !BB_MMU
 	sv1 = argv[optind];
diff -urpN busybox-1.29.3/coreutils/touch.c busybox-1.30.0/coreutils/touch.c
--- busybox-1.29.3/coreutils/touch.c	2018-07-02 13:23:06.000000000 +0200
+++ busybox-1.30.0/coreutils/touch.c	2018-12-30 16:14:20.000000000 +0100
@@ -13,7 +13,7 @@
  * Also, exiting on a failure was a bug.  All args should be processed.
  */
 //config:config TOUCH
-//config:	bool "touch (5.8 kb)"
+//config:	bool "touch (5.9 kb)"
 //config:	default y
 //config:	help
 //config:	touch is used to create or change the access and/or
diff -urpN busybox-1.29.3/coreutils/tr.c busybox-1.30.0/coreutils/tr.c
--- busybox-1.29.3/coreutils/tr.c	2018-07-02 13:23:06.000000000 +0200
+++ busybox-1.30.0/coreutils/tr.c	2018-12-30 16:14:20.000000000 +0100
@@ -19,7 +19,7 @@
  * TODO: graph, print
  */
 //config:config TR
-//config:	bool "tr (5.5 kb)"
+//config:	bool "tr (5.1 kb)"
 //config:	default y
 //config:	help
 //config:	tr is used to squeeze, and/or delete characters from standard
diff -urpN busybox-1.29.3/coreutils/truncate.c busybox-1.30.0/coreutils/truncate.c
--- busybox-1.29.3/coreutils/truncate.c	2018-07-02 13:23:06.000000000 +0200
+++ busybox-1.30.0/coreutils/truncate.c	2018-12-30 16:14:20.000000000 +0100
@@ -6,7 +6,7 @@
  * Licensed under GPLv2 or later, see file LICENSE in this source tree.
  */
 //config:config TRUNCATE
-//config:	bool "truncate (4.7 kb)"
+//config:	bool "truncate (4.2 kb)"
 //config:	default y
 //config:	help
 //config:	truncate truncates files to a given size. If a file does
diff -urpN busybox-1.29.3/coreutils/tty.c busybox-1.30.0/coreutils/tty.c
--- busybox-1.29.3/coreutils/tty.c	2018-07-02 13:23:06.000000000 +0200
+++ busybox-1.30.0/coreutils/tty.c	2018-12-30 16:14:20.000000000 +0100
@@ -7,7 +7,7 @@
  * Licensed under GPLv2 or later, see file LICENSE in this source tree.
  */
 //config:config TTY
-//config:	bool "tty (3.3 kb)"
+//config:	bool "tty (3.6 kb)"
 //config:	default y
 //config:	help
 //config:	tty is used to print the name of the current terminal to
diff -urpN busybox-1.29.3/coreutils/uname.c busybox-1.30.0/coreutils/uname.c
--- busybox-1.29.3/coreutils/uname.c	2018-07-02 13:23:06.000000000 +0200
+++ busybox-1.30.0/coreutils/uname.c	2018-12-30 16:14:20.000000000 +0100
@@ -44,7 +44,7 @@
  *  Fix handling of -a to not print "unknown", add -o and -i support.
  */
 //config:config UNAME
-//config:	bool "uname (3.7 kb)"
+//config:	bool "uname (3.9 kb)"
 //config:	default y
 //config:	help
 //config:	uname is used to print system information.
@@ -59,7 +59,7 @@
 //config:
 //can't use "ARCH" for this applet, all hell breaks loose in build system :)
 //config:config BB_ARCH
-//config:	bool "arch (1.6 kb)"
+//config:	bool "arch (1.1 kb)"
 //config:	default y
 //config:	help
 //config:	Same as uname -m.
diff -urpN busybox-1.29.3/coreutils/uniq.c busybox-1.30.0/coreutils/uniq.c
--- busybox-1.29.3/coreutils/uniq.c	2018-07-02 13:23:06.000000000 +0200
+++ busybox-1.30.0/coreutils/uniq.c	2018-12-30 16:14:20.000000000 +0100
@@ -7,7 +7,7 @@
  * Licensed under GPLv2 or later, see file LICENSE in this source tree.
  */
 //config:config UNIQ
-//config:	bool "uniq (4.8 kb)"
+//config:	bool "uniq (4.9 kb)"
 //config:	default y
 //config:	help
 //config:	uniq is used to remove duplicate lines from a sorted file.
diff -urpN busybox-1.29.3/coreutils/unlink.c busybox-1.30.0/coreutils/unlink.c
--- busybox-1.29.3/coreutils/unlink.c	2018-07-02 13:23:06.000000000 +0200
+++ busybox-1.30.0/coreutils/unlink.c	2018-12-30 16:14:20.000000000 +0100
@@ -7,7 +7,7 @@
  * Licensed under GPLv2, see LICENSE in this source tree
  */
 //config:config UNLINK
-//config:	bool "unlink (3.5 kb)"
+//config:	bool "unlink (3.2 kb)"
 //config:	default y
 //config:	help
 //config:	unlink deletes a file by calling unlink()
diff -urpN busybox-1.29.3/coreutils/usleep.c busybox-1.30.0/coreutils/usleep.c
--- busybox-1.29.3/coreutils/usleep.c	2018-07-02 13:23:06.000000000 +0200
+++ busybox-1.30.0/coreutils/usleep.c	2018-12-30 16:14:20.000000000 +0100
@@ -7,7 +7,7 @@
  * Licensed under GPLv2 or later, see file LICENSE in this source tree.
  */
 //config:config USLEEP
-//config:	bool "usleep (1.1 kb)"
+//config:	bool "usleep (1.3 kb)"
 //config:	default y
 //config:	help
 //config:	usleep is used to pause for a specified number of microseconds.
diff -urpN busybox-1.29.3/coreutils/uudecode.c busybox-1.30.0/coreutils/uudecode.c
--- busybox-1.29.3/coreutils/uudecode.c	2018-07-02 13:23:06.000000000 +0200
+++ busybox-1.30.0/coreutils/uudecode.c	2018-12-30 16:14:20.000000000 +0100
@@ -11,7 +11,7 @@
  * "end" line
  */
 //config:config UUDECODE
-//config:	bool "uudecode (5.9 kb)"
+//config:	bool "uudecode (5.8 kb)"
 //config:	default y
 //config:	help
 //config:	uudecode is used to decode a uuencoded file.
@@ -175,7 +175,7 @@ int uudecode_main(int argc UNUSED_PARAM,
 //kbuild:lib-$(CONFIG_BASE64) += uudecode.o
 
 //config:config BASE64
-//config:	bool "base64 (5 kb)"
+//config:	bool "base64 (4.9 kb)"
 //config:	default y
 //config:	help
 //config:	Base64 encode and decode
diff -urpN busybox-1.29.3/coreutils/uuencode.c busybox-1.30.0/coreutils/uuencode.c
--- busybox-1.29.3/coreutils/uuencode.c	2018-07-02 13:23:06.000000000 +0200
+++ busybox-1.30.0/coreutils/uuencode.c	2018-12-30 16:14:20.000000000 +0100
@@ -8,7 +8,7 @@
  * Licensed under GPLv2 or later, see file LICENSE in this source tree.
  */
 //config:config UUENCODE
-//config:	bool "uuencode (4.6 kb)"
+//config:	bool "uuencode (4.4 kb)"
 //config:	default y
 //config:	help
 //config:	uuencode is used to uuencode a file.
diff -urpN busybox-1.29.3/coreutils/wc.c busybox-1.30.0/coreutils/wc.c
--- busybox-1.29.3/coreutils/wc.c	2018-07-02 13:23:06.000000000 +0200
+++ busybox-1.30.0/coreutils/wc.c	2018-12-30 16:14:20.000000000 +0100
@@ -33,7 +33,7 @@
  * for which 'wc -c' should output '0'.
  */
 //config:config WC
-//config:	bool "wc (4.4 kb)"
+//config:	bool "wc (4.5 kb)"
 //config:	default y
 //config:	help
 //config:	wc is used to print the number of bytes, words, and lines,
diff -urpN busybox-1.29.3/coreutils/who.c busybox-1.30.0/coreutils/who.c
--- busybox-1.29.3/coreutils/who.c	2018-07-02 13:23:06.000000000 +0200
+++ busybox-1.30.0/coreutils/who.c	2018-12-30 16:14:20.000000000 +0100
@@ -15,7 +15,7 @@
  * Licensed under GPLv2 or later, see file LICENSE in this source tree.
  */
 //config:config WHO
-//config:	bool "who (3.7 kb)"
+//config:	bool "who (3.9 kb)"
 //config:	default y
 //config:	depends on FEATURE_UTMP
 //config:	help
@@ -23,14 +23,14 @@
 //config:
 // procps-ng has this variation of "who":
 //config:config W
-//config:	bool "w (3.7 kb)"
+//config:	bool "w (3.8 kb)"
 //config:	default y
 //config:	depends on FEATURE_UTMP
 //config:	help
 //config:	Print users currently logged on.
 //config:
 //config:config USERS
-//config:	bool "users (3.2 kb)"
+//config:	bool "users (3.4 kb)"
 //config:	default y
 //config:	depends on FEATURE_UTMP
 //config:	help
diff -urpN busybox-1.29.3/coreutils/whoami.c busybox-1.30.0/coreutils/whoami.c
--- busybox-1.29.3/coreutils/whoami.c	2018-07-02 13:23:06.000000000 +0200
+++ busybox-1.30.0/coreutils/whoami.c	2018-12-30 16:14:20.000000000 +0100
@@ -7,7 +7,7 @@
  * Licensed under GPLv2 or later, see file LICENSE in this source tree.
  */
 //config:config WHOAMI
-//config:	bool "whoami (2.9 kb)"
+//config:	bool "whoami (3.2 kb)"
 //config:	default y
 //config:	help
 //config:	whoami is used to print the username of the current
diff -urpN busybox-1.29.3/coreutils/yes.c busybox-1.30.0/coreutils/yes.c
--- busybox-1.29.3/coreutils/yes.c	2018-07-02 13:23:06.000000000 +0200
+++ busybox-1.30.0/coreutils/yes.c	2018-12-30 16:14:20.000000000 +0100
@@ -11,7 +11,7 @@
  * Size reductions and removed redundant applet name prefix from error messages.
  */
 //config:config YES
-//config:	bool "yes (956 bytes)"
+//config:	bool "yes (1.2 kb)"
 //config:	default y
 //config:	help
 //config:	yes is used to repeatedly output a specific string, or
diff -urpN busybox-1.29.3/debianutils/pipe_progress.c busybox-1.30.0/debianutils/pipe_progress.c
--- busybox-1.29.3/debianutils/pipe_progress.c	2018-07-02 13:23:06.000000000 +0200
+++ busybox-1.30.0/debianutils/pipe_progress.c	2018-12-30 16:14:20.000000000 +0100
@@ -7,7 +7,7 @@
  * Licensed under GPLv2 or later, see file LICENSE in this source tree.
  */
 //config:config PIPE_PROGRESS
-//config:	bool "pipe_progress (225 bytes)"
+//config:	bool "pipe_progress (275 bytes)"
 //config:	default y
 //config:	help
 //config:	Display a dot to indicate pipe activity.
diff -urpN busybox-1.29.3/debianutils/run_parts.c busybox-1.30.0/debianutils/run_parts.c
--- busybox-1.29.3/debianutils/run_parts.c	2018-07-02 13:23:06.000000000 +0200
+++ busybox-1.30.0/debianutils/run_parts.c	2018-12-30 16:14:20.000000000 +0100
@@ -23,7 +23,7 @@
  * broken compatibility because the BusyBox policy doesn't allow them.
  */
 //config:config RUN_PARTS
-//config:	bool "run-parts (5.6 kb)"
+//config:	bool "run-parts (6.1 kb)"
 //config:	default y
 //config:	help
 //config:	run-parts is a utility designed to run all the scripts in a directory.
diff -urpN busybox-1.29.3/debianutils/which.c busybox-1.30.0/debianutils/which.c
--- busybox-1.29.3/debianutils/which.c	2018-07-02 13:23:06.000000000 +0200
+++ busybox-1.30.0/debianutils/which.c	2018-12-30 16:14:20.000000000 +0100
@@ -6,7 +6,7 @@
  * Licensed under GPLv2 or later, see file LICENSE in this source tree.
  */
 //config:config WHICH
-//config:	bool "which (3.7 kb)"
+//config:	bool "which (3.8 kb)"
 //config:	default y
 //config:	help
 //config:	which is used to find programs in your PATH and
diff -urpN busybox-1.29.3/docs/embedded-scripts.txt busybox-1.30.0/docs/embedded-scripts.txt
--- busybox-1.29.3/docs/embedded-scripts.txt	1970-01-01 01:00:00.000000000 +0100
+++ busybox-1.30.0/docs/embedded-scripts.txt	2018-12-05 15:44:34.000000000 +0100
@@ -0,0 +1,111 @@
+Embedded Shell Scripts in BusyBox
+=================================
+
+BusyBox allows applets to be implemented as shell scripts.  Since
+this obviously requires a shell to interpret the scripts the feature
+depends on having a shell built into the binary.  Either ash or hush
+will do.  If both are present ash will be used.  Support for embedded
+scripts also has to be enabled.
+
+It's unlikely that your applet will be implemented as a pure shell
+script:  it will probably need some external commands.  If these are
+to be provided by BusyBox you'll need to ensure they're enabled too.
+
+There are two ways to include scripts in BusyBox:  the quick-and-dirty
+custom script and the full-featured scripted applet.
+
+Custom Scripts
+--------------
+
+When embedded script support is enabled the BusyBox build process
+assumes that any files in the directory 'embed' at the top level of
+the source tree are scripts to be embedded.
+
+The embed directory isn't present in the BusyBox source tree and
+BusyBox itself will never put anything there:  it's entirely for the
+use of third parties.
+
+Adding a custom script is as simple as running the following sequence
+of commands in the BusyBox source directory:
+
+   mkdir embed
+   echo 'echo foo' >embed/foo
+   make defconfig
+   make
+
+The resulting binary includes the new applet foo!
+
+Custom scripts have limited opportunities for configuration:  the only
+control developers have is to put them in the embed directory, or not.
+Everything else takes default values.  For more control you need the
+additional features provided by scripted applets.
+
+Scripted Applets
+----------------
+
+Suppose we want to make a shell script version of the sample applet
+from the New Applet HOWTO.  First we'd have to write a script (vaguely)
+equivalent to the C code:
+
+   return $(($RANDOM%256))
+
+This should be placed in the file applets_sh/mu in the source tree.
+
+Next we need the configuration data.  This is very similar to the example
+code for the native applet:
+
+//config:config MU
+//config:   bool "MU"
+//config:   default y
+//config:   help
+//config:   Returns an indeterminate value.
+
+//applet:IF_MU(APPLET_SCRIPTED(mu, scripted, BB_DIR_USR_BIN, BB_SUID_DROP, mu))
+
+//usage:#define mu_trivial_usage
+//usage:    "[-abcde] FILE..."
+//usage:#define mu_full_usage
+//usage:    "Returns an indeterminate value\n"
+//usage:     "\n    -a  First function"
+//usage:     "\n    -b  Second function"
+
+The only difference is that the applet is specified as being of type
+APPLET_SCRIPTED.  It would also be useful to include details of any
+dependencies the script has.  No external commands are used by our mu
+script, but it does depend on optional shell features.  We can ensure
+these are selected by adding this to the configuration:
+
+//config:config MU_DEPENDENCIES
+//config:	bool "Enable dependencies for mu"
+//config:	default y
+//config:	depends on MU
+//config:	select ASH_RANDOM_SUPPORT
+//config:	select FEATURE_SH_MATH
+//config:	help
+//config:	mu is implemented as a shell script. It requires support
+//config:	for $RANDOM and arithmetic.
+
+The configuration data should be placed in a C file in an appropriate
+subdirectory.  There isn't any C code, though!  In this case the file
+could be miscutils/mu.c.
+
+Scripted applets are just as configurable as applets written in C.
+They can be enabled or disabled using the configuration menu; their
+install directory can be specified and their usage messages are stored
+along with those of all other applets.
+
+Additional Notes
+----------------
+
+The source for embedded scripts can be displayed by running:
+
+   busybox --show SCRIPT
+
+This can be disabled by turning off FEATURE_SHOW_SCRIPT in the
+configuration, though it won't prevent a determined user from
+extracting the source code.
+
+It can be argued that embedded scripts are linked into the BusyBox
+binary and are therefore not subject to the 'mere aggregation'
+exception in the GPL.  If this is the case embedded scripts should
+have a licence compatible with BusyBox's GPL v2-only licence.
diff -urpN busybox-1.29.3/docs/mdev.txt busybox-1.30.0/docs/mdev.txt
--- busybox-1.29.3/docs/mdev.txt	2018-07-02 13:23:06.000000000 +0200
+++ busybox-1.30.0/docs/mdev.txt	2018-12-05 15:44:34.000000000 +0100
@@ -60,9 +60,9 @@ or
 For example:
 	hd[a-z][0-9]* 0:3 660
 
-The config file parsing stops at the first matching line.  If no line is
-matched, then the default of 0:0 660 is used.  To set your own default, simply
-create your own total match like so:
+The config file parsing stops at the first matching line unless this line
+starts with "-". If no line is matched, then the default of 0:0 660 is used.
+To set your own default, simply create your own total match like so:
 
 	.* 1:1 777
 
diff -urpN busybox-1.29.3/docs/posix_conformance.txt busybox-1.30.0/docs/posix_conformance.txt
--- busybox-1.29.3/docs/posix_conformance.txt	2018-07-02 13:23:06.000000000 +0200
+++ busybox-1.30.0/docs/posix_conformance.txt	2018-12-05 15:44:34.000000000 +0100
@@ -182,6 +182,7 @@ dd compatibility options:
   conv=fsync      |  yes   |           |
   iflag=skip_bytes|  yes   |           |
   iflag=fullblock |  yes   |           |
+  oflag=seek_bytes|  yes   |           |
 
 df POSIX options
  option           | exists | compliant | remarks
diff -urpN busybox-1.29.3/e2fsprogs/chattr.c busybox-1.30.0/e2fsprogs/chattr.c
--- busybox-1.29.3/e2fsprogs/chattr.c	2018-07-02 13:23:06.000000000 +0200
+++ busybox-1.30.0/e2fsprogs/chattr.c	2018-12-30 16:14:20.000000000 +0100
@@ -10,7 +10,7 @@
  * Public License
  */
 //config:config CHATTR
-//config:	bool "chattr (3.2 kb)"
+//config:	bool "chattr (3.8 kb)"
 //config:	default y
 //config:	help
 //config:	chattr changes the file attributes on a second extended file system.
diff -urpN busybox-1.29.3/e2fsprogs/fsck.c busybox-1.30.0/e2fsprogs/fsck.c
--- busybox-1.29.3/e2fsprogs/fsck.c	2018-07-02 13:23:06.000000000 +0200
+++ busybox-1.30.0/e2fsprogs/fsck.c	2018-12-30 16:14:20.000000000 +0100
@@ -34,7 +34,7 @@
  * It doesn't guess filesystem types from on-disk format.
  */
 //config:config FSCK
-//config:	bool "fsck (6.7 kb)"
+//config:	bool "fsck (7.4 kb)"
 //config:	default y
 //config:	help
 //config:	fsck is used to check and optionally repair one or more filesystems.
diff -urpN busybox-1.29.3/e2fsprogs/lsattr.c busybox-1.30.0/e2fsprogs/lsattr.c
--- busybox-1.29.3/e2fsprogs/lsattr.c	2018-07-02 13:23:06.000000000 +0200
+++ busybox-1.30.0/e2fsprogs/lsattr.c	2018-12-30 16:14:20.000000000 +0100
@@ -10,7 +10,7 @@
  * Public License
  */
 //config:config LSATTR
-//config:	bool "lsattr (5 kb)"
+//config:	bool "lsattr (5.5 kb)"
 //config:	default y
 //config:	select PLATFORM_LINUX
 //config:	help
diff -urpN busybox-1.29.3/e2fsprogs/tune2fs.c busybox-1.30.0/e2fsprogs/tune2fs.c
--- busybox-1.29.3/e2fsprogs/tune2fs.c	2018-07-02 13:23:06.000000000 +0200
+++ busybox-1.30.0/e2fsprogs/tune2fs.c	2018-12-05 15:44:34.000000000 +0100
@@ -39,23 +39,6 @@
 #include <linux/fs.h>
 #include "bb_e2fs_defs.h"
 
-// storage helpers
-char BUG_wrong_field_size(void);
-#define STORE_LE(field, value) \
-do { \
-	if (sizeof(field) == 4) \
-		field = SWAP_LE32(value); \
-	else if (sizeof(field) == 2) \
-		field = SWAP_LE16(value); \
-	else if (sizeof(field) == 1) \
-		field = (value); \
-	else \
-		BUG_wrong_field_size(); \
-} while (0)
-
-#define FETCH_LE32(field) \
-	(sizeof(field) == 4 ? SWAP_LE32(field) : BUG_wrong_field_size())
-
 enum {
 	OPT_L = 1 << 0, // label
 	OPT_c = 1 << 1, // max mount count
diff -urpN busybox-1.29.3/editors/awk.c busybox-1.30.0/editors/awk.c
--- busybox-1.29.3/editors/awk.c	2018-07-02 13:23:06.000000000 +0200
+++ busybox-1.30.0/editors/awk.c	2018-12-30 16:14:20.000000000 +0100
@@ -7,7 +7,7 @@
  * Licensed under GPLv2 or later, see file LICENSE in this source tree.
  */
 //config:config AWK
-//config:	bool "awk (22 kb)"
+//config:	bool "awk (23 kb)"
 //config:	default y
 //config:	help
 //config:	Awk is used as a pattern scanning and processing language.
@@ -1849,6 +1849,8 @@ static void handle_special(var *v)
 
 	if (v == intvar[NF]) {
 		n = (int)getvar_i(v);
+		if (n < 0)
+			syntax_error("NF set to negative value");
 		fsrealloc(n);
 
 		/* recalculate $0 */
diff -urpN busybox-1.29.3/editors/cmp.c busybox-1.30.0/editors/cmp.c
--- busybox-1.29.3/editors/cmp.c	2018-07-02 13:23:06.000000000 +0200
+++ busybox-1.30.0/editors/cmp.c	2018-12-30 16:14:20.000000000 +0100
@@ -7,7 +7,7 @@
  * Licensed under GPLv2 or later, see file LICENSE in this source tree.
  */
 //config:config CMP
-//config:	bool "cmp (5.4 kb)"
+//config:	bool "cmp (4.9 kb)"
 //config:	default y
 //config:	help
 //config:	cmp is used to compare two files and returns the result
diff -urpN busybox-1.29.3/editors/ed.c busybox-1.30.0/editors/ed.c
--- busybox-1.29.3/editors/ed.c	2018-07-02 13:23:06.000000000 +0200
+++ busybox-1.30.0/editors/ed.c	2018-12-30 16:14:20.000000000 +0100
@@ -7,7 +7,7 @@
  * The "ed" built-in command (much simplified)
  */
 //config:config ED
-//config:	bool "ed (25 kb)"
+//config:	bool "ed (21 kb)"
 //config:	default y
 //config:	help
 //config:	The original 1970's Unix text editor, from the days of teletypes.
diff -urpN busybox-1.29.3/editors/patch.c busybox-1.30.0/editors/patch.c
--- busybox-1.29.3/editors/patch.c	2018-07-02 13:23:06.000000000 +0200
+++ busybox-1.30.0/editors/patch.c	2018-12-30 16:14:20.000000000 +0100
@@ -21,7 +21,7 @@
  * [file] which file to patch
  */
 //config:config PATCH
-//config:	bool "patch (9.1 kb)"
+//config:	bool "patch (9.4 kb)"
 //config:	default y
 //config:	help
 //config:	Apply a unified diff formatted patch.
diff -urpN busybox-1.29.3/editors/patch_toybox.c busybox-1.30.0/editors/patch_toybox.c
--- busybox-1.29.3/editors/patch_toybox.c	2018-07-02 13:23:06.000000000 +0200
+++ busybox-1.30.0/editors/patch_toybox.c	2018-12-30 16:14:20.000000000 +0100
@@ -26,7 +26,7 @@
 USE_PATCH(NEWTOY(patch, USE_TOYBOX_DEBUG("x")"up#i:R", TOYFLAG_USR|TOYFLAG_BIN))
 
 config PATCH
-	bool "patch (9.1 kb)"
+	bool "patch (9.4 kb)"
 	default y
 	help
 	  usage: patch [-i file] [-p depth] [-Ru]
diff -urpN busybox-1.29.3/editors/sed.c busybox-1.30.0/editors/sed.c
--- busybox-1.29.3/editors/sed.c	2018-07-02 13:23:06.000000000 +0200
+++ busybox-1.30.0/editors/sed.c	2018-12-05 15:44:34.000000000 +0100
@@ -180,18 +180,23 @@ static void sed_free_and_close_stuff(voi
 		if (sed_cmd->sw_file)
 			fclose(sed_cmd->sw_file);
 
-		if (sed_cmd->beg_match) {
-			regfree(sed_cmd->beg_match);
-			free(sed_cmd->beg_match);
-		}
-		if (sed_cmd->end_match) {
-			regfree(sed_cmd->end_match);
-			free(sed_cmd->end_match);
-		}
-		if (sed_cmd->sub_match) {
-			regfree(sed_cmd->sub_match);
-			free(sed_cmd->sub_match);
-		}
+		/* Used to free regexps, but now there is code
+		 * in get_address() which can reuse a regexp
+		 * for constructs as /regexp/cmd1;//cmd2
+		 * leading to double-frees here:
+		 */
+		//if (sed_cmd->beg_match) {
+		//	regfree(sed_cmd->beg_match);
+		//	free(sed_cmd->beg_match);
+		//}
+		//if (sed_cmd->end_match) {
+		//	regfree(sed_cmd->end_match);
+		//	free(sed_cmd->end_match);
+		//}
+		//if (sed_cmd->sub_match) {
+		//	regfree(sed_cmd->sub_match);
+		//	free(sed_cmd->sub_match);
+		//}
 		free(sed_cmd->string);
 		free(sed_cmd);
 		sed_cmd = sed_cmd_next;
diff -urpN busybox-1.29.3/editors/vi.c busybox-1.30.0/editors/vi.c
--- busybox-1.29.3/editors/vi.c	2018-07-02 13:23:06.000000000 +0200
+++ busybox-1.30.0/editors/vi.c	2018-12-30 16:14:20.000000000 +0100
@@ -19,7 +19,7 @@
  *	An "ex" line oriented mode- maybe using "cmdedit"
  */
 //config:config VI
-//config:	bool "vi (22 kb)"
+//config:	bool "vi (23 kb)"
 //config:	default y
 //config:	help
 //config:	'vi' is a text editor. More specifically, it is the One True
@@ -255,8 +255,8 @@ enum {
 	YANKDEL = TRUE,
 	FORWARD = 1,	// code depends on "1"  for array index
 	BACK = -1,	// code depends on "-1" for array index
-	LIMITED = 0,	// how much of text[] in char_search
-	FULL = 1,	// how much of text[] in char_search
+	LIMITED = 0,	// char_search() only current line
+	FULL = 1,	// char_search() to the end/beginning of entire text
 
 	S_BEFORE_WS = 1,	// used in skip_thing() for moving "dot"
 	S_TO_WS = 2,		// used in skip_thing() for moving "dot"
@@ -561,7 +561,7 @@ static void indicate_error(void);
 static void Hit_Return(void);
 
 #if ENABLE_FEATURE_VI_SEARCH
-static char *char_search(char *, const char *, int, int);	// search for pattern starting at p
+static char *char_search(char *, const char *, int);	// search for pattern starting at p
 #endif
 #if ENABLE_FEATURE_VI_COLON
 static char *get_one_address(char *, int *);	// get colon addr, if present
@@ -938,7 +938,7 @@ static char *get_one_address(char *p, in
 		p = q;
 		if (*p == '/')
 			p++;
-		q = char_search(dot, pat, FORWARD, FULL);
+		q = char_search(dot, pat, (FORWARD << 1) | FULL);
 		if (q != NULL) {
 			*addr = count_lines(text, q);
 		}
@@ -1442,7 +1442,7 @@ static void colon(char *buf)
 			char *ls = q;		// orig line start
 			char *found;
  vc4:
-			found = char_search(q, F, FORWARD, LIMITED);	// search cur line only for "find"
+			found = char_search(q, F, (FORWARD << 1) | LIMITED);	// search cur line only for "find"
 			if (found) {
 				uintptr_t bias;
 				// we found the "find" pattern - delete it
@@ -1895,13 +1895,14 @@ static char *new_screen(int ro, int co)
 # if ENABLE_FEATURE_VI_REGEX_SEARCH
 
 // search for pattern starting at p
-static char *char_search(char *p, const char *pat, int dir, int range)
+static char *char_search(char *p, const char *pat, int dir_and_range)
 {
 	struct re_pattern_buffer preg;
 	const char *err;
 	char *q;
 	int i;
 	int size;
+	int range;
 
 	re_syntax_options = RE_SYNTAX_POSIX_EXTENDED;
 	if (ignorecase)
@@ -1914,10 +1915,16 @@ static char *char_search(char *p, const
 		return p;
 	}
 
-	// assume a LIMITED forward search
-	q = end - 1;
-	if (dir == BACK)
+	range = (dir_and_range & 1);
+	q = end - 1; // if FULL
+	if (range == LIMITED)
+		q = next_line(p);
+	if (dir_and_range < 0) { // BACK?
 		q = text;
+		if (range == LIMITED)
+			q = prev_line(p);
+	}
+
 	// RANGE could be negative if we are searching backwards
 	range = q - p;
 	q = p;
@@ -1940,7 +1947,7 @@ static char *char_search(char *p, const
 	regfree(&preg);
 	if (i < 0)
 		return NULL;
-	if (dir == FORWARD)
+	if (dir_and_range > 0) // FORWARD?
 		p = p + i;
 	else
 		p = p - i;
@@ -1961,13 +1968,15 @@ static int mycmp(const char *s1, const c
 #   define mycmp strncmp
 #  endif
 
-static char *char_search(char *p, const char *pat, int dir, int range)
+static char *char_search(char *p, const char *pat, int dir_and_range)
 {
 	char *start, *stop;
 	int len;
+	int range;
 
 	len = strlen(pat);
-	if (dir == FORWARD) {
+	range = (dir_and_range & 1);
+	if (dir_and_range > 0) { //FORWARD?
 		stop = end - 1;	// assume range is p..end-1
 		if (range == LIMITED)
 			stop = next_line(p);	// range is to next line
@@ -1976,7 +1985,7 @@ static char *char_search(char *p, const
 				return start;
 			}
 		}
-	} else if (dir == BACK) {
+	} else { //BACK
 		stop = text;	// assume range is text..p
 		if (range == LIMITED)
 			stop = prev_line(p);	// range is to prev line
@@ -2355,7 +2364,7 @@ static void undo_push(char *src, unsigne
 	// Allocate a new undo object
 	if (u_type == UNDO_DEL || u_type == UNDO_DEL_CHAIN) {
 		// For UNDO_DEL objects, save deleted text
-		if ((src + length) == end)
+		if ((text + length) == end)
 			length--;
 		// If this deletion empties text[], strip the newline. When the buffer becomes
 		// zero-length, a newline is added back, which requires this to compensate.
@@ -3586,12 +3595,7 @@ static void do_cmd(int c)
 		break;
 	case 12:			// ctrl-L  force redraw whole screen
 	case 18:			// ctrl-R  force redraw
-		place_cursor(0, 0);
-		clear_to_eos();
-		//mysleep(10); // why???
-		screen_erase();	// erase the internal screen buffer
-		last_status_cksum = 0;	// force status update
-		refresh(TRUE);	// this will redraw the entire display
+		redraw(TRUE);	// this will redraw the entire display
 		break;
 	case 13:			// Carriage Return ^M
 	case '+':			// +- goto next line
@@ -3818,7 +3822,7 @@ static void do_cmd(int c)
 				p = dot - 1;
 			}
  dc4:
-			q = char_search(p, last_search_pattern + 1, dir, FULL);
+			q = char_search(p, last_search_pattern + 1, (dir << 1) | FULL);
 			if (q != NULL) {
 				dot = q;	// good search, update "dot"
 				msg = NULL;
@@ -3829,7 +3833,7 @@ static void do_cmd(int c)
 			if (dir == BACK) {
 				p = end - 1;
 			}
-			q = char_search(p, last_search_pattern + 1, dir, FULL);
+			q = char_search(p, last_search_pattern + 1, (dir << 1) | FULL);
 			if (q != NULL) {	// found something
 				dot = q;	// found new pattern- goto it
 				msg = "search hit BOTTOM, continuing at TOP";
@@ -3845,13 +3849,13 @@ static void do_cmd(int c)
 		} while (--cmdcnt > 0);
 		break;
 	case '{':			// {- move backward paragraph
-		q = char_search(dot, "\n\n", BACK, FULL);
+		q = char_search(dot, "\n\n", (BACK << 1) | FULL);
 		if (q != NULL) {	// found blank line
 			dot = next_line(q);	// move to next blank line
 		}
 		break;
 	case '}':			// }- move forward paragraph
-		q = char_search(dot, "\n\n", FORWARD, FULL);
+		q = char_search(dot, "\n\n", (FORWARD << 1) | FULL);
 		if (q != NULL) {	// found blank line
 			dot = next_line(q);	// move to next blank line
 		}
diff -urpN busybox-1.29.3/examples/udhcp/simple.script busybox-1.30.0/examples/udhcp/simple.script
--- busybox-1.29.3/examples/udhcp/simple.script	2018-07-02 13:23:06.000000000 +0200
+++ busybox-1.30.0/examples/udhcp/simple.script	2018-12-05 15:44:34.000000000 +0100
@@ -6,19 +6,31 @@ RESOLV_CONF="/etc/resolv.conf"
 [ -n "$1" ] || { echo "Error: should be called from udhcpc"; exit 1; }
 
 NETMASK=""
-[ -n "$subnet" ] && NETMASK="netmask $subnet"
+if command -v ip >/dev/null; then
+	[ -n "$subnet" ] && NETMASK="/$subnet"
+else
+	[ -n "$subnet" ] && NETMASK="netmask $subnet"
+fi
 BROADCAST="broadcast +"
 [ -n "$broadcast" ] && BROADCAST="broadcast $broadcast"
 
 case "$1" in
 	deconfig)
 		echo "Setting IP address 0.0.0.0 on $interface"
-		ifconfig $interface 0.0.0.0
+		if command -v ip >/dev/null; then
+			ip addr flush dev $interface
+		else
+			ifconfig $interface 0.0.0.0
+		fi
 		;;
 
 	renew|bound)
 		echo "Setting IP address $ip on $interface"
-		ifconfig $interface $ip $NETMASK $BROADCAST
+		if command -v ip >/dev/null; then
+			ip addr add $ip$NETMASK $BROADCAST dev $interface
+		else
+			ifconfig $interface $ip $NETMASK $BROADCAST
+		fi
 
 		if [ -n "$router" ] ; then
 			echo "Deleting routers"
diff -urpN busybox-1.29.3/examples/var_service/dhcp_if/README busybox-1.30.0/examples/var_service/dhcp_if/README
--- busybox-1.29.3/examples/var_service/dhcp_if/README	2018-07-02 13:23:06.000000000 +0200
+++ busybox-1.30.0/examples/var_service/dhcp_if/README	1970-01-01 01:00:00.000000000 +0100
@@ -1,5 +0,0 @@
-The real README file is one directory up.
-
-This directory's run script can have useful comments.
-If it doesn't but you feel it should, please send a patch
-to busybox's mailing list.
diff -urpN busybox-1.29.3/examples/var_service/dhcp_if/dhcp_handler busybox-1.30.0/examples/var_service/dhcp_if/dhcp_handler
--- busybox-1.29.3/examples/var_service/dhcp_if/dhcp_handler	2018-07-02 13:23:06.000000000 +0200
+++ busybox-1.30.0/examples/var_service/dhcp_if/dhcp_handler	2018-12-05 15:44:34.000000000 +0100
@@ -52,7 +52,7 @@ if test x"$1" != x"bound" && test x"$1"
 	rm "$file_ntpconf"
 	rm "$dir_ipconf/$file_ipconf"
 	rm "$dir_ntpconf/$file_ntpconf"
-	sv u /var/service/fw
+	svc -u fw
 	exit
 fi
 
@@ -67,10 +67,10 @@ if test $? != 0; then
 	echo "Reconfiguring fw"
 	mkdir -p "$dir_ipconf" 2>/dev/null
 	cp "$file_ipconf" "$dir_ipconf/$file_ipconf"
-	sv u /var/service/fw
+	svc -u fw
 fi
 
-if test -d /var/service/ntpd; then
+if test -d ../ntpd; then
 	./convert2ntpconf "$file_ntpconf"
 	# Reconfigure ntp server addresses if needed
 	diff --brief "$file_ntpconf" "$dir_ntpconf/$file_ntpconf" >/dev/null 2>&1
@@ -78,7 +78,7 @@ if test -d /var/service/ntpd; then
 		echo "Reconfiguring ntp"
 		mkdir -p "$dir_ntpconf" 2>/dev/null
 		cp "$file_ntpconf" "$dir_ntpconf/$file_ntpconf"
-		sv t /var/service/ntpd
-		sv u /var/service/ntpd
+		svc -t ntpd
+		svc -u ntpd
 	fi
 fi
diff -urpN busybox-1.29.3/examples/var_service/dhcp_if/finish busybox-1.30.0/examples/var_service/dhcp_if/finish
--- busybox-1.29.3/examples/var_service/dhcp_if/finish	2018-07-02 13:23:06.000000000 +0200
+++ busybox-1.30.0/examples/var_service/dhcp_if/finish	2018-12-05 15:44:34.000000000 +0100
@@ -14,4 +14,4 @@ rm "$file_ipconf"
 rm "$file_ntpconf"
 rm "$dir_ipconf/$file_ipconf"
 rm "$dir_ntpconf/$file_ntpconf"
-sv u /var/service/fw
+svc -u fw
diff -urpN busybox-1.29.3/examples/var_service/dhcp_if/log/run busybox-1.30.0/examples/var_service/dhcp_if/log/run
--- busybox-1.29.3/examples/var_service/dhcp_if/log/run	2018-07-02 13:23:06.000000000 +0200
+++ busybox-1.30.0/examples/var_service/dhcp_if/log/run	2018-12-05 15:44:34.000000000 +0100
@@ -1,21 +1,2 @@
 #!/bin/sh
-
-user=logger
-
-logdir="/var/log/service/`(cd ..;basename $PWD)`"
-mkdir -p "$logdir" 2>/dev/null
-chown -R "$user": "$logdir"
-chmod -R go-rwxst,u+rwX "$logdir"
-rm -rf logdir
-ln -s "$logdir" logdir
-
-# make this dir accessible to logger
-chmod a+rX .
-
-exec >/dev/null
-exec 2>&1
-exec \
-env - PATH="$PATH" \
-softlimit \
-setuidgid "$user" \
-svlogd -tt "$logdir"
+exec std_service_logger
diff -urpN busybox-1.29.3/examples/var_service/dhcp_if/p_log busybox-1.30.0/examples/var_service/dhcp_if/p_log
--- busybox-1.29.3/examples/var_service/dhcp_if/p_log	2018-07-02 13:23:06.000000000 +0200
+++ busybox-1.30.0/examples/var_service/dhcp_if/p_log	1970-01-01 01:00:00.000000000 +0100
@@ -1,4 +0,0 @@
-#!/bin/sh
-
-cd log/logdir || exit 1
-cat @* current | $PAGER
diff -urpN busybox-1.29.3/examples/var_service/dhcp_if/w_log busybox-1.30.0/examples/var_service/dhcp_if/w_log
--- busybox-1.29.3/examples/var_service/dhcp_if/w_log	2018-07-02 13:23:06.000000000 +0200
+++ busybox-1.30.0/examples/var_service/dhcp_if/w_log	1970-01-01 01:00:00.000000000 +0100
@@ -1,4 +0,0 @@
-#!/bin/sh
-
-cd log/logdir || exit 1
-watch -n2 'w=`ttysize w`; h=`ttysize h`; tail -$((h-3)) current 2>&1 | cut -b1-$((w-2))'
diff -urpN busybox-1.29.3/examples/var_service/dhcp_if_pinger/README busybox-1.30.0/examples/var_service/dhcp_if_pinger/README
--- busybox-1.29.3/examples/var_service/dhcp_if_pinger/README	2018-07-02 13:23:06.000000000 +0200
+++ busybox-1.30.0/examples/var_service/dhcp_if_pinger/README	1970-01-01 01:00:00.000000000 +0100
@@ -1,5 +0,0 @@
-The real README file is one directory up.
-
-This directory's run script can have useful comments.
-If it doesn't but you feel it should, please send a patch
-to busybox's mailing list.
diff -urpN busybox-1.29.3/examples/var_service/dhcp_if_pinger/run busybox-1.30.0/examples/var_service/dhcp_if_pinger/run
--- busybox-1.29.3/examples/var_service/dhcp_if_pinger/run	2018-07-02 13:23:06.000000000 +0200
+++ busybox-1.30.0/examples/var_service/dhcp_if_pinger/run	2018-12-05 15:44:34.000000000 +0100
@@ -21,9 +21,9 @@ if test -f "$0.log"; then
 	mv "$0.log.new" "$0.log"
 fi
 
-test -f "/var/service/dhcp_$if/env.out" || exec env - sleep "$ping_time"
+test -f "../dhcp_$if/env.out" || exec env - sleep "$ping_time"
 
-. "/var/service/dhcp_$if/env.out"
+. "../dhcp_$if/env.out"
 test x"$router" != x"" || exec env - sleep "$ping_time"
 
 #msg "Pinging $router"
@@ -36,12 +36,12 @@ while true; do
 	env - sleep "$retry_time"
 done
 
-test -d "/var/service/dhcp_$if" && {
-	msg "Restarting /var/service/dhcp_$if"
-	sv t "/var/service/dhcp_$if"
+test -d "../dhcp_$if" && {
+	msg "Restarting dhcp_$if"
+	svc -t "dhcp_$if"
 }
-test -d "/var/service/supplicant_$if" && {
-	msg "Restarting /var/service/supplicant_$if"
-	sv t "/var/service/supplicant_$if"
+test -d "../supplicant_$if" && {
+	msg "Restarting supplicant_$if"
+	svc -t "supplicant_$if"
 }
 exec env - sleep "$ping_time"
diff -urpN busybox-1.29.3/examples/var_service/dhcpd_if/README busybox-1.30.0/examples/var_service/dhcpd_if/README
--- busybox-1.29.3/examples/var_service/dhcpd_if/README	2018-07-02 13:23:06.000000000 +0200
+++ busybox-1.30.0/examples/var_service/dhcpd_if/README	1970-01-01 01:00:00.000000000 +0100
@@ -1,5 +0,0 @@
-The real README file is one directory up.
-
-This directory's run script can have useful comments.
-If it doesn't but you feel it should, please send a patch
-to busybox's mailing list.
diff -urpN busybox-1.29.3/examples/var_service/dhcpd_if/log/run busybox-1.30.0/examples/var_service/dhcpd_if/log/run
--- busybox-1.29.3/examples/var_service/dhcpd_if/log/run	2018-07-02 13:23:06.000000000 +0200
+++ busybox-1.30.0/examples/var_service/dhcpd_if/log/run	2018-12-05 15:44:34.000000000 +0100
@@ -1,21 +1,2 @@
 #!/bin/sh
-
-user=logger
-
-logdir="/var/log/service/`(cd ..;basename $PWD)`"
-mkdir -p "$logdir" 2>/dev/null
-chown -R "$user": "$logdir"
-chmod -R go-rwxst,u+rwX "$logdir"
-rm -rf logdir
-ln -s "$logdir" logdir
-
-# make this dir accessible to logger
-chmod a+rX .
-
-exec >/dev/null
-exec 2>&1
-exec \
-env - PATH="$PATH" \
-softlimit \
-setuidgid "$user" \
-svlogd -tt "$logdir"
+exec std_service_logger
diff -urpN busybox-1.29.3/examples/var_service/dhcpd_if/p_log busybox-1.30.0/examples/var_service/dhcpd_if/p_log
--- busybox-1.29.3/examples/var_service/dhcpd_if/p_log	2018-07-02 13:23:06.000000000 +0200
+++ busybox-1.30.0/examples/var_service/dhcpd_if/p_log	1970-01-01 01:00:00.000000000 +0100
@@ -1,4 +0,0 @@
-#!/bin/sh
-
-cd log/logdir || exit 1
-cat @* current | $PAGER
diff -urpN busybox-1.29.3/examples/var_service/dhcpd_if/w_log busybox-1.30.0/examples/var_service/dhcpd_if/w_log
--- busybox-1.29.3/examples/var_service/dhcpd_if/w_log	2018-07-02 13:23:06.000000000 +0200
+++ busybox-1.30.0/examples/var_service/dhcpd_if/w_log	1970-01-01 01:00:00.000000000 +0100
@@ -1,4 +0,0 @@
-#!/bin/sh
-
-cd log/logdir
-watch -n1 'w=`ttysize w`; h=`ttysize h`; tail -$((h-3)) current 2>&1 | cut -b0-$((w-2))'
diff -urpN busybox-1.29.3/examples/var_service/dnsmasq/log/run busybox-1.30.0/examples/var_service/dnsmasq/log/run
--- busybox-1.29.3/examples/var_service/dnsmasq/log/run	2018-07-02 13:23:06.000000000 +0200
+++ busybox-1.30.0/examples/var_service/dnsmasq/log/run	2018-12-05 15:44:34.000000000 +0100
@@ -1,21 +1,2 @@
 #!/bin/sh
-
-user=logger
-
-logdir="/var/log/service/`(cd ..;basename $PWD)`"
-mkdir -p "$logdir" 2>/dev/null
-chown -R "$user": "$logdir"
-chmod -R go-rwxst,u+rwX "$logdir"
-rm -rf logdir
-ln -s "$logdir" logdir
-
-# make this dir accessible to logger
-chmod a+rX .
-
-exec >/dev/null
-exec 2>&1
-exec \
-env - PATH="$PATH" \
-softlimit \
-setuidgid "$user" \
-svlogd -tt "$logdir"
+exec std_service_logger
diff -urpN busybox-1.29.3/examples/var_service/dnsmasq/p_log busybox-1.30.0/examples/var_service/dnsmasq/p_log
--- busybox-1.29.3/examples/var_service/dnsmasq/p_log	2018-07-02 13:23:06.000000000 +0200
+++ busybox-1.30.0/examples/var_service/dnsmasq/p_log	1970-01-01 01:00:00.000000000 +0100
@@ -1,4 +0,0 @@
-#!/bin/sh
-
-cd log/logdir || exit 1
-cat @* current | $PAGER
diff -urpN busybox-1.29.3/examples/var_service/dnsmasq/w_log busybox-1.30.0/examples/var_service/dnsmasq/w_log
--- busybox-1.29.3/examples/var_service/dnsmasq/w_log	2018-07-02 13:23:06.000000000 +0200
+++ busybox-1.30.0/examples/var_service/dnsmasq/w_log	1970-01-01 01:00:00.000000000 +0100
@@ -1,4 +0,0 @@
-#!/bin/sh
-
-cd log/logdir || exit 1
-watch -n2 'w=`ttysize w`; h=`ttysize h`; tail -$((h-3)) current 2>&1 | cut -b1-$((w-2))'
diff -urpN busybox-1.29.3/examples/var_service/ftpd/README busybox-1.30.0/examples/var_service/ftpd/README
--- busybox-1.29.3/examples/var_service/ftpd/README	2018-07-02 13:23:06.000000000 +0200
+++ busybox-1.30.0/examples/var_service/ftpd/README	1970-01-01 01:00:00.000000000 +0100
@@ -1,5 +0,0 @@
-The real README file is one directory up.
-
-This directory's run script can have useful comments.
-If it doesn't but you feel it should, please send a patch
-to busybox's mailing list.
diff -urpN busybox-1.29.3/examples/var_service/ftpd/log/run busybox-1.30.0/examples/var_service/ftpd/log/run
--- busybox-1.29.3/examples/var_service/ftpd/log/run	2018-07-02 13:23:06.000000000 +0200
+++ busybox-1.30.0/examples/var_service/ftpd/log/run	2018-12-05 15:44:34.000000000 +0100
@@ -1,21 +1,2 @@
 #!/bin/sh
-
-user=logger
-
-logdir="/var/log/service/`(cd ..;basename $PWD)`"
-mkdir -p "$logdir" 2>/dev/null
-chown -R "$user": "$logdir"
-chmod -R go-rwxst,u+rwX "$logdir"
-rm -rf logdir
-ln -s "$logdir" logdir
-
-# make this dir accessible to logger
-chmod a+rX .
-
-exec >/dev/null
-exec 2>&1
-exec \
-env - PATH="$PATH" \
-softlimit \
-setuidgid "$user" \
-svlogd -tt "$logdir"
+exec std_service_logger
diff -urpN busybox-1.29.3/examples/var_service/ftpd/p_log busybox-1.30.0/examples/var_service/ftpd/p_log
--- busybox-1.29.3/examples/var_service/ftpd/p_log	2018-07-02 13:23:06.000000000 +0200
+++ busybox-1.30.0/examples/var_service/ftpd/p_log	1970-01-01 01:00:00.000000000 +0100
@@ -1,4 +0,0 @@
-#!/bin/sh
-
-cd log/logdir || exit 1
-cat @* current | $PAGER
diff -urpN busybox-1.29.3/examples/var_service/ftpd/w_log busybox-1.30.0/examples/var_service/ftpd/w_log
--- busybox-1.29.3/examples/var_service/ftpd/w_log	2018-07-02 13:23:06.000000000 +0200
+++ busybox-1.30.0/examples/var_service/ftpd/w_log	1970-01-01 01:00:00.000000000 +0100
@@ -1,4 +0,0 @@
-#!/bin/sh
-
-cd log/logdir || exit 1
-watch -n2 'w=`ttysize w`; h=`ttysize h`; tail -$((h-3)) current 2>&1 | cut -b1-$((w-2))'
diff -urpN busybox-1.29.3/examples/var_service/fw/README busybox-1.30.0/examples/var_service/fw/README
--- busybox-1.29.3/examples/var_service/fw/README	2018-07-02 13:23:06.000000000 +0200
+++ busybox-1.30.0/examples/var_service/fw/README	1970-01-01 01:00:00.000000000 +0100
@@ -1,5 +0,0 @@
-The real README file is one directory up.
-
-This directory's run script can have useful comments.
-If it doesn't but you feel it should, please send a patch
-to busybox's mailing list.
diff -urpN busybox-1.29.3/examples/var_service/fw/etc/dnsmasq_servers.conf busybox-1.30.0/examples/var_service/fw/etc/dnsmasq_servers.conf
--- busybox-1.29.3/examples/var_service/fw/etc/dnsmasq_servers.conf	2018-07-02 13:23:06.000000000 +0200
+++ busybox-1.30.0/examples/var_service/fw/etc/dnsmasq_servers.conf	2018-12-05 15:44:34.000000000 +0100
@@ -35,4 +35,4 @@ $empty && echo "server=8.8.8.8"
 $empty && echo "server=8.8.4.4"
 
 # SIGHUP: make dnsmasq reload config
-sv h dnsmasq
+svc -h dnsmasq
diff -urpN busybox-1.29.3/examples/var_service/fw/run busybox-1.30.0/examples/var_service/fw/run
--- busybox-1.29.3/examples/var_service/fw/run	2018-07-02 13:23:06.000000000 +0200
+++ busybox-1.30.0/examples/var_service/fw/run	2018-12-05 15:44:34.000000000 +0100
@@ -8,7 +8,7 @@ extif="if"
 ext_open_tcp="22 80 88" # space-separated
 
 # Make ourself one-shot
-sv o .
+svc -o .
 # Debug
 #date '+%Y-%m-%d %H:%M:%S' >>"$0.log"
 
diff -urpN busybox-1.29.3/examples/var_service/getty_tty1/README busybox-1.30.0/examples/var_service/getty_tty1/README
--- busybox-1.29.3/examples/var_service/getty_tty1/README	2018-07-02 13:23:06.000000000 +0200
+++ busybox-1.30.0/examples/var_service/getty_tty1/README	1970-01-01 01:00:00.000000000 +0100
@@ -1,5 +0,0 @@
-The real README file is one directory up.
-
-This directory's run script can have useful comments.
-If it doesn't but you feel it should, please send a patch
-to busybox's mailing list.
diff -urpN busybox-1.29.3/examples/var_service/gpm/README busybox-1.30.0/examples/var_service/gpm/README
--- busybox-1.29.3/examples/var_service/gpm/README	2018-07-02 13:23:06.000000000 +0200
+++ busybox-1.30.0/examples/var_service/gpm/README	1970-01-01 01:00:00.000000000 +0100
@@ -1,5 +0,0 @@
-The real README file is one directory up.
-
-This directory's run script can have useful comments.
-If it doesn't but you feel it should, please send a patch
-to busybox's mailing list.
diff -urpN busybox-1.29.3/examples/var_service/httpd/README busybox-1.30.0/examples/var_service/httpd/README
--- busybox-1.29.3/examples/var_service/httpd/README	2018-07-02 13:23:06.000000000 +0200
+++ busybox-1.30.0/examples/var_service/httpd/README	1970-01-01 01:00:00.000000000 +0100
@@ -1,5 +0,0 @@
-The real README file is one directory up.
-
-This directory's run script can have useful comments.
-If it doesn't but you feel it should, please send a patch
-to busybox's mailing list.
diff -urpN busybox-1.29.3/examples/var_service/httpd/log/run busybox-1.30.0/examples/var_service/httpd/log/run
--- busybox-1.29.3/examples/var_service/httpd/log/run	2018-07-02 13:23:06.000000000 +0200
+++ busybox-1.30.0/examples/var_service/httpd/log/run	2018-12-05 15:44:34.000000000 +0100
@@ -1,21 +1,2 @@
 #!/bin/sh
-
-user=logger
-
-logdir="/var/log/service/`(cd ..;basename $PWD)`"
-mkdir -p "$logdir" 2>/dev/null
-chown -R "$user": "$logdir"
-chmod -R go-rwxst,u+rwX "$logdir"
-rm -rf logdir
-ln -s "$logdir" logdir
-
-# make this dir accessible to logger
-chmod a+rX .
-
-exec >/dev/null
-exec 2>&1
-exec \
-env - PATH="$PATH" \
-softlimit \
-setuidgid "$user" \
-svlogd -tt "$logdir"
+exec std_service_logger
diff -urpN busybox-1.29.3/examples/var_service/httpd/p_log busybox-1.30.0/examples/var_service/httpd/p_log
--- busybox-1.29.3/examples/var_service/httpd/p_log	2018-07-02 13:23:06.000000000 +0200
+++ busybox-1.30.0/examples/var_service/httpd/p_log	1970-01-01 01:00:00.000000000 +0100
@@ -1,4 +0,0 @@
-#!/bin/sh
-
-cd log/logdir || exit 1
-cat @* current | $PAGER
diff -urpN busybox-1.29.3/examples/var_service/httpd/w_log busybox-1.30.0/examples/var_service/httpd/w_log
--- busybox-1.29.3/examples/var_service/httpd/w_log	2018-07-02 13:23:06.000000000 +0200
+++ busybox-1.30.0/examples/var_service/httpd/w_log	1970-01-01 01:00:00.000000000 +0100
@@ -1,4 +0,0 @@
-#!/bin/sh
-
-cd log/logdir || exit 1
-watch -n2 'w=`ttysize w`; h=`ttysize h`; tail -$((h-3)) current 2>&1 | cut -b1-$((w-2))'
diff -urpN busybox-1.29.3/examples/var_service/ifplugd_if/README busybox-1.30.0/examples/var_service/ifplugd_if/README
--- busybox-1.29.3/examples/var_service/ifplugd_if/README	2018-07-02 13:23:06.000000000 +0200
+++ busybox-1.30.0/examples/var_service/ifplugd_if/README	1970-01-01 01:00:00.000000000 +0100
@@ -1,5 +0,0 @@
-The real README file is one directory up.
-
-This directory's run script can have useful comments.
-If it doesn't but you feel it should, please send a patch
-to busybox's mailing list.
diff -urpN busybox-1.29.3/examples/var_service/ifplugd_if/log/run busybox-1.30.0/examples/var_service/ifplugd_if/log/run
--- busybox-1.29.3/examples/var_service/ifplugd_if/log/run	2018-07-02 13:23:06.000000000 +0200
+++ busybox-1.30.0/examples/var_service/ifplugd_if/log/run	2018-12-05 15:44:34.000000000 +0100
@@ -1,21 +1,2 @@
 #!/bin/sh
-
-user=logger
-
-logdir="/var/log/service/`(cd ..;basename $PWD)`"
-mkdir -p "$logdir" 2>/dev/null
-chown -R "$user": "$logdir"
-chmod -R go-rwxst,u+rwX "$logdir"
-rm -rf logdir
-ln -s "$logdir" logdir
-
-# make this dir accessible to logger
-chmod a+rX .
-
-exec >/dev/null
-exec 2>&1
-exec \
-env - PATH="$PATH" \
-softlimit \
-setuidgid "$user" \
-svlogd -tt "$logdir"
+exec std_service_logger
diff -urpN busybox-1.29.3/examples/var_service/ifplugd_if/p_log busybox-1.30.0/examples/var_service/ifplugd_if/p_log
--- busybox-1.29.3/examples/var_service/ifplugd_if/p_log	2018-07-02 13:23:06.000000000 +0200
+++ busybox-1.30.0/examples/var_service/ifplugd_if/p_log	1970-01-01 01:00:00.000000000 +0100
@@ -1,4 +0,0 @@
-#!/bin/sh
-
-cd log/logdir || exit 1
-cat @* current | $PAGER
diff -urpN busybox-1.29.3/examples/var_service/ifplugd_if/w_log busybox-1.30.0/examples/var_service/ifplugd_if/w_log
--- busybox-1.29.3/examples/var_service/ifplugd_if/w_log	2018-07-02 13:23:06.000000000 +0200
+++ busybox-1.30.0/examples/var_service/ifplugd_if/w_log	1970-01-01 01:00:00.000000000 +0100
@@ -1,4 +0,0 @@
-#!/bin/sh
-
-cd log/logdir || exit 1
-watch -n2 'w=`ttysize w`; h=`ttysize h`; tail -$((h-3)) current 2>&1 | cut -b1-$((w-2))'
diff -urpN busybox-1.29.3/examples/var_service/inetd/README busybox-1.30.0/examples/var_service/inetd/README
--- busybox-1.29.3/examples/var_service/inetd/README	2018-07-02 13:23:06.000000000 +0200
+++ busybox-1.30.0/examples/var_service/inetd/README	1970-01-01 01:00:00.000000000 +0100
@@ -1,5 +0,0 @@
-The real README file is one directory up.
-
-This directory's run script can have useful comments.
-If it doesn't but you feel it should, please send a patch
-to busybox's mailing list.
diff -urpN busybox-1.29.3/examples/var_service/inetd/log/run busybox-1.30.0/examples/var_service/inetd/log/run
--- busybox-1.29.3/examples/var_service/inetd/log/run	2018-07-02 13:23:06.000000000 +0200
+++ busybox-1.30.0/examples/var_service/inetd/log/run	2018-12-05 15:44:34.000000000 +0100
@@ -1,21 +1,2 @@
 #!/bin/sh
-
-user=logger
-
-logdir="/var/log/service/`(cd ..;basename $PWD)`"
-mkdir -p "$logdir" 2>/dev/null
-chown -R "$user": "$logdir"
-chmod -R go-rwxst,u+rwX "$logdir"
-rm -rf logdir
-ln -s "$logdir" logdir
-
-# make this dir accessible to logger
-chmod a+rX .
-
-exec >/dev/null
-exec 2>&1
-exec \
-env - PATH="$PATH" \
-softlimit \
-setuidgid "$user" \
-svlogd -tt "$logdir"
+exec std_service_logger
diff -urpN busybox-1.29.3/examples/var_service/inetd/p_log busybox-1.30.0/examples/var_service/inetd/p_log
--- busybox-1.29.3/examples/var_service/inetd/p_log	2018-07-02 13:23:06.000000000 +0200
+++ busybox-1.30.0/examples/var_service/inetd/p_log	1970-01-01 01:00:00.000000000 +0100
@@ -1,4 +0,0 @@
-#!/bin/sh
-
-cd log/logdir || exit 1
-cat @* current | $PAGER
diff -urpN busybox-1.29.3/examples/var_service/inetd/w_log busybox-1.30.0/examples/var_service/inetd/w_log
--- busybox-1.29.3/examples/var_service/inetd/w_log	2018-07-02 13:23:06.000000000 +0200
+++ busybox-1.30.0/examples/var_service/inetd/w_log	1970-01-01 01:00:00.000000000 +0100
@@ -1,4 +0,0 @@
-#!/bin/sh
-
-cd log/logdir || exit 1
-watch -n2 'w=`ttysize w`; h=`ttysize h`; tail -$((h-3)) current 2>&1 | cut -b1-$((w-2))'
diff -urpN busybox-1.29.3/examples/var_service/nmeter/README busybox-1.30.0/examples/var_service/nmeter/README
--- busybox-1.29.3/examples/var_service/nmeter/README	2018-07-02 13:23:06.000000000 +0200
+++ busybox-1.30.0/examples/var_service/nmeter/README	1970-01-01 01:00:00.000000000 +0100
@@ -1,5 +0,0 @@
-The real README file is one directory up.
-
-This directory's run script can have useful comments.
-If it doesn't but you feel it should, please send a patch
-to busybox's mailing list.
diff -urpN busybox-1.29.3/examples/var_service/ntpd/README busybox-1.30.0/examples/var_service/ntpd/README
--- busybox-1.29.3/examples/var_service/ntpd/README	2018-07-02 13:23:06.000000000 +0200
+++ busybox-1.30.0/examples/var_service/ntpd/README	1970-01-01 01:00:00.000000000 +0100
@@ -1,5 +0,0 @@
-The real README file is one directory up.
-
-This directory's run script can have useful comments.
-If it doesn't but you feel it should, please send a patch
-to busybox's mailing list.
diff -urpN busybox-1.29.3/examples/var_service/ntpd/log/run busybox-1.30.0/examples/var_service/ntpd/log/run
--- busybox-1.29.3/examples/var_service/ntpd/log/run	2018-07-02 13:23:06.000000000 +0200
+++ busybox-1.30.0/examples/var_service/ntpd/log/run	2018-12-05 15:44:34.000000000 +0100
@@ -1,21 +1,2 @@
 #!/bin/sh
-
-user=logger
-
-logdir="/var/log/service/`(cd ..;basename $PWD)`"
-mkdir -p "$logdir" 2>/dev/null
-chown -R "$user": "$logdir"
-chmod -R go-rwxst,u+rwX "$logdir"
-rm -rf logdir
-ln -s "$logdir" logdir
-
-# make this dir accessible to logger
-chmod a+rX .
-
-exec >/dev/null
-exec 2>&1
-exec \
-env - PATH="$PATH" \
-softlimit \
-setuidgid "$user" \
-svlogd -tt "$logdir"
+exec std_service_logger
diff -urpN busybox-1.29.3/examples/var_service/ntpd/ntp.script busybox-1.30.0/examples/var_service/ntpd/ntp.script
--- busybox-1.29.3/examples/var_service/ntpd/ntp.script	2018-07-02 13:23:06.000000000 +0200
+++ busybox-1.30.0/examples/var_service/ntpd/ntp.script	2018-12-05 15:44:34.000000000 +0100
@@ -1,5 +1,4 @@
 #!/bin/sh
-
 # Note that there is no provision to prevent several copies of the script
 # to be run in quick succession. In fact, it happens rather often
 # if initial syncronization results in a step.
@@ -8,6 +7,9 @@
 #
 # Script should be ready to deal with this.
 
+# For other parts of the system which prefer to run only on the stable clock
+echo "$1" >rundir/sync_status
+
 dt=`date '+%Y-%m-%d %H:%M:%S'`
 
 echo "`tail -n 199 -- "$0.log" 2>/dev/null`" >"$0.log.$$"
diff -urpN busybox-1.29.3/examples/var_service/ntpd/p_log busybox-1.30.0/examples/var_service/ntpd/p_log
--- busybox-1.29.3/examples/var_service/ntpd/p_log	2018-07-02 13:23:06.000000000 +0200
+++ busybox-1.30.0/examples/var_service/ntpd/p_log	1970-01-01 01:00:00.000000000 +0100
@@ -1,4 +0,0 @@
-#!/bin/sh
-
-cd log/logdir || exit 1
-cat @* current | $PAGER
diff -urpN busybox-1.29.3/examples/var_service/ntpd/run busybox-1.30.0/examples/var_service/ntpd/run
--- busybox-1.29.3/examples/var_service/ntpd/run	2018-07-02 13:23:06.000000000 +0200
+++ busybox-1.30.0/examples/var_service/ntpd/run	2018-12-05 15:44:34.000000000 +0100
@@ -6,12 +6,22 @@ exec 2>&1
 exec </dev/null
 
 user=root
+start_delay=15
+net_down_delay=5
 pool="us.pool.ntp.org" # replace "us" with your country code
 
 service="${PWD##*/}"
 rundir="/var/run/service/$service"
 default_p_opt="-p 0.$pool -p 1.$pool -p 2.$pool -p 3.$pool"
 
+echo "* Checking network"
+test -f /var/run/service/fw/up || exec sleep $net_down_delay
+
+# With multiple interfaces (e.g. wired+wireless) going up,
+# networking scripts may restart ntpd service several times
+# in quick succession. Do not be too eager to start sending
+# NTP requests:
+sleep $start_delay
 
 # Make sure rundir/ exists
 mkdir -p "$rundir" 2>/dev/null
@@ -20,30 +30,25 @@ chmod -R a=rX "$rundir"
 rm -rf rundir 2>/dev/null
 ln -s "$rundir" rundir
 
-
-echo "* Checking network"
-test -f /var/run/service/fw/up || exec sleep 7
-sleep 5  # to let it settle
-
 # Grab config from dhcp
 cfg=-1
 for f in rundir/*.ntpconf; do
-        test -f "$f" || continue
-        . "$f"
+	test -f "$f" || continue
+	. "$f"
 done
 
 # Select peers
 p_opt=""
 cfg=0
 while test x"${ntpip[$cfg]}" != x""; do
-        p_opt="$p_opt -p ${ntpip[$cfg]}"
-        let cfg=cfg+1
+	p_opt="$p_opt -p ${ntpip[$cfg]}"
+	let cfg=cfg+1
 done
 test x"$p_opt" == x"" && p_opt="$default_p_opt"
 
 if test x"$p_opt" == x""; then
 	echo "* No NTP peers configured, stopping"
-	sv o .
+	svc -o .
 	exec sleep 1
 fi
 
diff -urpN busybox-1.29.3/examples/var_service/ntpd/w_log busybox-1.30.0/examples/var_service/ntpd/w_log
--- busybox-1.29.3/examples/var_service/ntpd/w_log	2018-07-02 13:23:06.000000000 +0200
+++ busybox-1.30.0/examples/var_service/ntpd/w_log	1970-01-01 01:00:00.000000000 +0100
@@ -1,4 +0,0 @@
-#!/bin/sh
-
-cd log/logdir || exit 1
-watch -n2 'w=`ttysize w`; h=`ttysize h`; tail -$((h-3)) current 2>&1 | cut -b1-$((w-2))'
diff -urpN busybox-1.29.3/examples/var_service/std_service_logger busybox-1.30.0/examples/var_service/std_service_logger
--- busybox-1.29.3/examples/var_service/std_service_logger	1970-01-01 01:00:00.000000000 +0100
+++ busybox-1.30.0/examples/var_service/std_service_logger	2018-12-05 15:44:34.000000000 +0100
@@ -0,0 +1,32 @@
+#!/bin/sh
+
+user=logger
+
+exec >/dev/null 2>&1
+
+service="${PWD%/log}"
+service="${service##*/}"
+logdir="/var/log/service/$service"
+
+mkdir -p "$logdir"
+chown -R "$user": "$logdir"
+chmod -R go-rwxst,u+rwX "$logdir"
+# TODO: if "$logdir/config" does not exist,
+# based on service's preferences, write some setup in it:
+# e.g. smaller nNUM directive ("I'm not that important,
+# save 2 rather than default 10 one-megabyte log files")
+
+# Convenience symlink in this log/ directory:
+rm logdir
+ln -s "$logdir" logdir
+
+# Make current dir accessible to logger:
+chmod a+rX .
+
+args=""
+test "$LOG_NOTIMESTAMP" || args="-tt"
+
+exec \
+env - PATH="$PATH" \
+chpst -u "$user" -m $((20 * 1024*1024)) \
+svlogd $args "$logdir"
diff -urpN busybox-1.29.3/examples/var_service/supplicant_if/README busybox-1.30.0/examples/var_service/supplicant_if/README
--- busybox-1.29.3/examples/var_service/supplicant_if/README	2018-07-02 13:23:06.000000000 +0200
+++ busybox-1.30.0/examples/var_service/supplicant_if/README	1970-01-01 01:00:00.000000000 +0100
@@ -1,5 +0,0 @@
-The real README file is one directory up.
-
-This directory's run script can have useful comments.
-If it doesn't but you feel it should, please send a patch
-to busybox's mailing list.
diff -urpN busybox-1.29.3/examples/var_service/supplicant_if/log/run busybox-1.30.0/examples/var_service/supplicant_if/log/run
--- busybox-1.29.3/examples/var_service/supplicant_if/log/run	2018-07-02 13:23:06.000000000 +0200
+++ busybox-1.30.0/examples/var_service/supplicant_if/log/run	2018-12-05 15:44:34.000000000 +0100
@@ -1,21 +1,2 @@
 #!/bin/sh
-
-user=logger
-
-logdir="/var/log/service/`(cd ..;basename $PWD)`"
-mkdir -p "$logdir" 2>/dev/null
-chown -R "$user": "$logdir"
-chmod -R go-rwxst,u+rwX "$logdir"
-rm -rf logdir
-ln -s "$logdir" logdir
-
-# make this dir accessible to logger
-chmod a+rX .
-
-exec >/dev/null
-exec 2>&1
-exec \
-env - PATH="$PATH" \
-softlimit \
-setuidgid "$user" \
-svlogd -tt "$logdir"
+exec std_service_logger
diff -urpN busybox-1.29.3/examples/var_service/supplicant_if/p_log busybox-1.30.0/examples/var_service/supplicant_if/p_log
--- busybox-1.29.3/examples/var_service/supplicant_if/p_log	2018-07-02 13:23:06.000000000 +0200
+++ busybox-1.30.0/examples/var_service/supplicant_if/p_log	1970-01-01 01:00:00.000000000 +0100
@@ -1,4 +0,0 @@
-#!/bin/sh
-
-cd log/logdir || exit 1
-cat @* current | $PAGER
diff -urpN busybox-1.29.3/examples/var_service/supplicant_if/w_log busybox-1.30.0/examples/var_service/supplicant_if/w_log
--- busybox-1.29.3/examples/var_service/supplicant_if/w_log	2018-07-02 13:23:06.000000000 +0200
+++ busybox-1.30.0/examples/var_service/supplicant_if/w_log	1970-01-01 01:00:00.000000000 +0100
@@ -1,4 +0,0 @@
-#!/bin/sh
-
-cd log/logdir || exit 1
-watch -n2 'w=`ttysize w`; h=`ttysize h`; tail -$((h-3)) current 2>&1 | cut -b1-$((w-2))'
diff -urpN busybox-1.29.3/examples/var_service/sview busybox-1.30.0/examples/var_service/sview
--- busybox-1.29.3/examples/var_service/sview	1970-01-01 01:00:00.000000000 +0100
+++ busybox-1.30.0/examples/var_service/sview	2018-12-05 15:44:34.000000000 +0100
@@ -0,0 +1,19 @@
+#!/bin/sh
+
+test "$1" || {
+	echo "Syntax: ${0##*/} SERVICE"
+	exit 1
+}
+
+test x"$1" = x"${1#*/}" -a x"$1" != x"." && {
+	# has no slashes and is not a "."
+	cd "/var/service/$1" || exit $?
+	set -- "."
+}
+
+test -x "$1/view" && exec "$1/view"
+
+cd "log/logdir" || exit $?
+
+h=`ttysize h`
+exec tail -n $((h-1)) -F current 2>&1
diff -urpN busybox-1.29.3/examples/var_service/svpage busybox-1.30.0/examples/var_service/svpage
--- busybox-1.29.3/examples/var_service/svpage	1970-01-01 01:00:00.000000000 +0100
+++ busybox-1.30.0/examples/var_service/svpage	2018-12-05 15:44:34.000000000 +0100
@@ -0,0 +1,19 @@
+#!/bin/sh
+
+test "$1" || {
+	echo "Syntax: ${0##*/} SERVICE"
+	exit 1
+}
+
+test x"$1" = x"${1#*/}" -a x"$1" != x"." && {
+	# has no slashes and is not a "."
+	cd "/var/service/$1" || exit $?
+	set -- "."
+}
+
+test -x "$1/page" && exec "$1/page"
+
+cd "log/logdir" || exit $?
+
+test "$PAGER" || PAGER=less
+cat @* current | $PAGER
diff -urpN busybox-1.29.3/examples/var_service/tftpd/README busybox-1.30.0/examples/var_service/tftpd/README
--- busybox-1.29.3/examples/var_service/tftpd/README	2018-07-02 13:23:06.000000000 +0200
+++ busybox-1.30.0/examples/var_service/tftpd/README	1970-01-01 01:00:00.000000000 +0100
@@ -1,5 +0,0 @@
-The real README file is one directory up.
-
-This directory's run script can have useful comments.
-If it doesn't but you feel it should, please send a patch
-to busybox's mailing list.
diff -urpN busybox-1.29.3/examples/var_service/tftpd/log/run busybox-1.30.0/examples/var_service/tftpd/log/run
--- busybox-1.29.3/examples/var_service/tftpd/log/run	2018-07-02 13:23:06.000000000 +0200
+++ busybox-1.30.0/examples/var_service/tftpd/log/run	2018-12-05 15:44:34.000000000 +0100
@@ -1,21 +1,2 @@
 #!/bin/sh
-
-user=logger
-
-logdir="/var/log/service/`(cd ..;basename $PWD)`"
-mkdir -p "$logdir" 2>/dev/null
-chown -R "$user": "$logdir"
-chmod -R go-rwxst,u+rwX "$logdir"
-rm -rf logdir
-ln -s "$logdir" logdir
-
-# make this dir accessible to logger
-chmod a+rX .
-
-exec >/dev/null
-exec 2>&1
-exec \
-env - PATH="$PATH" \
-softlimit \
-setuidgid "$user" \
-svlogd -tt "$logdir"
+exec std_service_logger
diff -urpN busybox-1.29.3/examples/var_service/tftpd/p_log busybox-1.30.0/examples/var_service/tftpd/p_log
--- busybox-1.29.3/examples/var_service/tftpd/p_log	2018-07-02 13:23:06.000000000 +0200
+++ busybox-1.30.0/examples/var_service/tftpd/p_log	1970-01-01 01:00:00.000000000 +0100
@@ -1,4 +0,0 @@
-#!/bin/sh
-
-cd log/logdir || exit 1
-cat @* current | $PAGER
diff -urpN busybox-1.29.3/examples/var_service/tftpd/w_log busybox-1.30.0/examples/var_service/tftpd/w_log
--- busybox-1.29.3/examples/var_service/tftpd/w_log	2018-07-02 13:23:06.000000000 +0200
+++ busybox-1.30.0/examples/var_service/tftpd/w_log	1970-01-01 01:00:00.000000000 +0100
@@ -1,4 +0,0 @@
-#!/bin/sh
-
-cd log/logdir || exit 1
-watch -n2 'w=`ttysize w`; h=`ttysize h`; tail -$((h-3)) current 2>&1 | cut -b1-$((w-2))'
diff -urpN busybox-1.29.3/examples/var_service/zcip_if/README busybox-1.30.0/examples/var_service/zcip_if/README
--- busybox-1.29.3/examples/var_service/zcip_if/README	2018-07-02 13:23:06.000000000 +0200
+++ busybox-1.30.0/examples/var_service/zcip_if/README	1970-01-01 01:00:00.000000000 +0100
@@ -1,5 +0,0 @@
-The real README file is one directory up.
-
-This directory's run script can have useful comments.
-If it doesn't but you feel it should, please send a patch
-to busybox's mailing list.
diff -urpN busybox-1.29.3/examples/var_service/zcip_if/finish busybox-1.30.0/examples/var_service/zcip_if/finish
--- busybox-1.29.3/examples/var_service/zcip_if/finish	2018-07-02 13:23:06.000000000 +0200
+++ busybox-1.30.0/examples/var_service/zcip_if/finish	2018-12-05 15:44:34.000000000 +0100
@@ -1,5 +1,5 @@
 #!/bin/sh
-# executed when service is taken down ("sv d .")
+# executed when service is taken down
 
 service=${PWD##*/}
 file_ipconf="$service.ipconf"
@@ -10,4 +10,4 @@ echo "Finish: deconfiguring"
 rm "env.out"
 rm "$file_ipconf"
 rm "$dir_ipconf/$file_ipconf"
-sv u /var/service/fw
+svc -u fw
diff -urpN busybox-1.29.3/examples/var_service/zcip_if/log/run busybox-1.30.0/examples/var_service/zcip_if/log/run
--- busybox-1.29.3/examples/var_service/zcip_if/log/run	2018-07-02 13:23:06.000000000 +0200
+++ busybox-1.30.0/examples/var_service/zcip_if/log/run	2018-12-05 15:44:34.000000000 +0100
@@ -1,21 +1,2 @@
 #!/bin/sh
-
-user=logger
-
-logdir="/var/log/service/`(cd ..;basename $PWD)`"
-mkdir -p "$logdir" 2>/dev/null
-chown -R "$user": "$logdir"
-chmod -R go-rwxst,u+rwX "$logdir"
-rm -rf logdir
-ln -s "$logdir" logdir
-
-# make this dir accessible to logger
-chmod a+rX .
-
-exec >/dev/null
-exec 2>&1
-exec \
-env - PATH="$PATH" \
-softlimit \
-setuidgid "$user" \
-svlogd -tt "$logdir"
+exec std_service_logger
diff -urpN busybox-1.29.3/examples/var_service/zcip_if/p_log busybox-1.30.0/examples/var_service/zcip_if/p_log
--- busybox-1.29.3/examples/var_service/zcip_if/p_log	2018-07-02 13:23:06.000000000 +0200
+++ busybox-1.30.0/examples/var_service/zcip_if/p_log	1970-01-01 01:00:00.000000000 +0100
@@ -1,4 +0,0 @@
-#!/bin/sh
-
-cd log/logdir || exit 1
-cat @* current | $PAGER
diff -urpN busybox-1.29.3/examples/var_service/zcip_if/w_log busybox-1.30.0/examples/var_service/zcip_if/w_log
--- busybox-1.29.3/examples/var_service/zcip_if/w_log	2018-07-02 13:23:06.000000000 +0200
+++ busybox-1.30.0/examples/var_service/zcip_if/w_log	1970-01-01 01:00:00.000000000 +0100
@@ -1,4 +0,0 @@
-#!/bin/sh
-
-cd log/logdir || exit 1
-watch -n2 'w=`ttysize w`; h=`ttysize h`; tail -$((h-3)) current 2>&1 | cut -b1-$((w-2))'
diff -urpN busybox-1.29.3/examples/var_service/zcip_if/zcip_handler busybox-1.30.0/examples/var_service/zcip_if/zcip_handler
--- busybox-1.29.3/examples/var_service/zcip_if/zcip_handler	2018-07-02 13:23:06.000000000 +0200
+++ busybox-1.30.0/examples/var_service/zcip_if/zcip_handler	2018-12-05 15:44:34.000000000 +0100
@@ -28,7 +28,7 @@ if test x"$1" != x"config"; then
 	echo "Deconfiguring"
 	rm "$file_ipconf"
 	rm "$dir_ipconf/$file_ipconf"
-	sv u /var/service/fw
+	svc -u fw
 	exit
 fi
 
@@ -43,5 +43,5 @@ if test $? != 0; then
 	echo "Reconfiguring fw"
 	mkdir -p "$dir_ipconf" 2>/dev/null
 	cp "$file_ipconf" "$dir_ipconf/$file_ipconf"
-	sv u /var/service/fw
+	svc -u fw
 fi
diff -urpN busybox-1.29.3/findutils/find.c busybox-1.30.0/findutils/find.c
--- busybox-1.29.3/findutils/find.c	2018-07-02 13:23:06.000000000 +0200
+++ busybox-1.30.0/findutils/find.c	2018-12-05 15:44:34.000000000 +0100
@@ -95,6 +95,11 @@
 //config:	Enable searching based on file type (file,
 //config:	directory, socket, device, etc.).
 //config:
+//config:config FEATURE_FIND_EXECUTABLE
+//config:	bool "Enable -executable: file is executable"
+//config:	default y
+//config:	depends on FIND
+//config:
 //config:config FEATURE_FIND_XDEV
 //config:	bool "Enable -xdev: 'stay in filesystem'"
 //config:	default y
@@ -182,6 +187,13 @@
 //config:	If the file is a directory, don't descend into it. Useful for
 //config:	exclusion .svn and CVS directories.
 //config:
+//config:config FEATURE_FIND_QUIT
+//config:	bool "Enable -quit: exit"
+//config:	default y
+//config:	depends on FIND
+//config:	help
+//config:	If this action is reached, 'find' exits.
+//config:
 //config:config FEATURE_FIND_DELETE
 //config:	bool "Enable -delete: delete files/dirs"
 //config:	default y
@@ -265,6 +277,9 @@
 //usage:	IF_FEATURE_FIND_TYPE(
 //usage:     "\n	-type X		File type is X (one of: f,d,l,b,c,s,p)"
 //usage:	)
+//usage:	IF_FEATURE_FIND_EXECUTABLE(
+//usage:     "\n	-executable	File is executable"
+//usage:	)
 //usage:	IF_FEATURE_FIND_PERM(
 //usage:     "\n	-perm MASK	At least one mask bit (+MASK), all bits (-MASK),"
 //usage:     "\n			or exactly MASK bits are set in file's mode"
@@ -318,6 +333,9 @@
 //usage:	IF_FEATURE_FIND_DELETE(
 //usage:     "\n	-delete		Delete current file/directory. Turns on -depth option"
 //usage:	)
+//usage:	IF_FEATURE_FIND_QUIT(
+//usage:     "\n	-quit		Exit"
+//usage:	)
 //usage:
 //usage:#define find_example_usage
 //usage:       "$ find / -name passwd\n"
@@ -365,6 +383,7 @@ IF_FEATURE_FIND_PATH(   ACTS(path,  cons
 IF_FEATURE_FIND_REGEX(  ACTS(regex, regex_t compiled_pattern;))
 IF_FEATURE_FIND_PRINT0( ACTS(print0))
 IF_FEATURE_FIND_TYPE(   ACTS(type,  int type_mask;))
+IF_FEATURE_FIND_EXECUTABLE(ACTS(executable))
 IF_FEATURE_FIND_PERM(   ACTS(perm,  char perm_char; mode_t perm_mask;))
 IF_FEATURE_FIND_MTIME(  ACTS(mtime, char mtime_char; unsigned mtime_days;))
 IF_FEATURE_FIND_MMIN(   ACTS(mmin,  char mmin_char; unsigned mmin_mins;))
@@ -375,6 +394,7 @@ IF_FEATURE_FIND_SIZE(   ACTS(size,  char
 IF_FEATURE_FIND_CONTEXT(ACTS(context, security_context_t context;))
 IF_FEATURE_FIND_PAREN(  ACTS(paren, action ***subexpr;))
 IF_FEATURE_FIND_PRUNE(  ACTS(prune))
+IF_FEATURE_FIND_QUIT(   ACTS(quit))
 IF_FEATURE_FIND_DELETE( ACTS(delete))
 IF_FEATURE_FIND_EXEC(   ACTS(exec,
 				char **exec_argv; /* -exec ARGS */
@@ -402,6 +422,7 @@ struct globals {
 	action ***actions;
 	smallint need_print;
 	smallint xdev_on;
+	smalluint exitstatus;
 	recurse_flags_t recurse_flags;
 	IF_FEATURE_FIND_EXEC_PLUS(unsigned max_argv_len;)
 } FIX_ALIASING;
@@ -566,6 +587,12 @@ ACTF(type)
 	return ((statbuf->st_mode & S_IFMT) == ap->type_mask);
 }
 #endif
+#if ENABLE_FEATURE_FIND_EXECUTABLE
+ACTF(executable)
+{
+	return access(fileName, X_OK) == 0;
+}
+#endif
 #if ENABLE_FEATURE_FIND_PERM
 ACTF(perm)
 {
@@ -774,6 +801,12 @@ ACTF(prune)
 	return SKIP + TRUE;
 }
 #endif
+#if ENABLE_FEATURE_FIND_QUIT
+ACTF(quit)
+{
+	exit(G.exitstatus);
+}
+#endif
 #if ENABLE_FEATURE_FIND_DELETE
 ACTF(delete)
 {
@@ -954,8 +987,10 @@ static action*** parse_params(char **arg
 	                        PARM_print     ,
 	IF_FEATURE_FIND_PRINT0( PARM_print0    ,)
 	IF_FEATURE_FIND_PRUNE(  PARM_prune     ,)
+	IF_FEATURE_FIND_QUIT(   PARM_quit      ,)
 	IF_FEATURE_FIND_DELETE( PARM_delete    ,)
 	IF_FEATURE_FIND_EXEC(   PARM_exec      ,)
+	IF_FEATURE_FIND_EXECUTABLE(PARM_executable,)
 	IF_FEATURE_FIND_PAREN(  PARM_char_brace,)
 	/* All options/actions starting from here require argument */
 	                        PARM_name      ,
@@ -997,8 +1032,10 @@ static action*** parse_params(char **arg
 	                        "-print\0"
 	IF_FEATURE_FIND_PRINT0( "-print0\0" )
 	IF_FEATURE_FIND_PRUNE(  "-prune\0"  )
+	IF_FEATURE_FIND_QUIT(   "-quit\0"  )
 	IF_FEATURE_FIND_DELETE( "-delete\0" )
 	IF_FEATURE_FIND_EXEC(   "-exec\0"   )
+	IF_FEATURE_FIND_EXECUTABLE("-executable\0")
 	IF_FEATURE_FIND_PAREN(  "(\0"       )
 	/* All options/actions starting from here require argument */
 	                        "-name\0"
@@ -1152,6 +1189,12 @@ static action*** parse_params(char **arg
 			(void) ALLOC_ACTION(prune);
 		}
 #endif
+#if ENABLE_FEATURE_FIND_QUIT
+		else if (parm == PARM_quit) {
+			dbg("%d", __LINE__);
+			(void) ALLOC_ACTION(quit);
+		}
+#endif
 #if ENABLE_FEATURE_FIND_DELETE
 		else if (parm == PARM_delete) {
 			dbg("%d", __LINE__);
@@ -1262,6 +1305,11 @@ static action*** parse_params(char **arg
 			dbg("created:type mask:%x", ap->type_mask);
 		}
 #endif
+#if ENABLE_FEATURE_FIND_EXECUTABLE
+		else if (parm == PARM_executable) {
+			(void) ALLOC_ACTION(executable);
+		}
+#endif
 #if ENABLE_FEATURE_FIND_PERM
 /* -perm BITS   File's mode bits are exactly BITS (octal or symbolic).
  *              Symbolic modes use mode 0 as a point of departure.
@@ -1401,7 +1449,7 @@ static action*** parse_params(char **arg
 int find_main(int argc, char **argv) MAIN_EXTERNALLY_VISIBLE;
 int find_main(int argc UNUSED_PARAM, char **argv)
 {
-	int i, firstopt, status = EXIT_SUCCESS;
+	int i, firstopt;
 	char **past_HLP, *saved;
 
 	INIT_G();
@@ -1475,10 +1523,10 @@ int find_main(int argc UNUSED_PARAM, cha
 				NULL,           /* user data */
 				0)              /* depth */
 		) {
-			status |= EXIT_FAILURE;
+			G.exitstatus |= EXIT_FAILURE;
 		}
 	}
 
-	IF_FEATURE_FIND_EXEC_PLUS(status |= flush_exec_plus();)
-	return status;
+	IF_FEATURE_FIND_EXEC_PLUS(G.exitstatus |= flush_exec_plus();)
+	return G.exitstatus;
 }
diff -urpN busybox-1.29.3/findutils/grep.c busybox-1.30.0/findutils/grep.c
--- busybox-1.29.3/findutils/grep.c	2018-07-02 13:23:06.000000000 +0200
+++ busybox-1.30.0/findutils/grep.c	2018-12-30 16:14:20.000000000 +0100
@@ -18,19 +18,19 @@
  * (C) 2006 Jac Goudsmit added -o option
  */
 //config:config GREP
-//config:	bool "grep (8.5 kb)"
+//config:	bool "grep (8.6 kb)"
 //config:	default y
 //config:	help
 //config:	grep is used to search files for a specified pattern.
 //config:
 //config:config EGREP
-//config:	bool "egrep (7.6 kb)"
+//config:	bool "egrep (7.8 kb)"
 //config:	default y
 //config:	help
 //config:	Alias to "grep -E".
 //config:
 //config:config FGREP
-//config:	bool "fgrep (7.6 kb)"
+//config:	bool "fgrep (7.8 kb)"
 //config:	default y
 //config:	help
 //config:	Alias to "grep -F".
@@ -704,10 +704,15 @@ int grep_main(int argc UNUSED_PARAM, cha
 	/* do normal option parsing */
 #if ENABLE_FEATURE_GREP_CONTEXT
 	/* -H unsets -h; -C unsets -A,-B */
-	opts = getopt32(argv,
-		"^" OPTSTR_GREP "\0" "H-h:C-AB",
+	opts = getopt32long(argv, "^"
+		OPTSTR_GREP
+			"\0"
+			"H-h:C-AB",
+		"color\0" Optional_argument "\xff",
 		&pattern_head, &fopt, &max_matches,
-		&lines_after, &lines_before, &Copt);
+		&lines_after, &lines_before, &Copt
+		, NULL
+	);
 
 	if (opts & OPT_C) {
 		/* -C unsets prev -A and -B, but following -A or -B
diff -urpN busybox-1.29.3/findutils/xargs.c busybox-1.30.0/findutils/xargs.c
--- busybox-1.29.3/findutils/xargs.c	2018-07-02 13:23:06.000000000 +0200
+++ busybox-1.30.0/findutils/xargs.c	2018-12-30 16:14:20.000000000 +0100
@@ -15,7 +15,7 @@
  * http://www.opengroup.org/onlinepubs/007904975/utilities/xargs.html
  */
 //config:config XARGS
-//config:	bool "xargs (6.7 kb)"
+//config:	bool "xargs (7.2 kb)"
 //config:	default y
 //config:	help
 //config:	xargs is used to execute a specified command for
@@ -204,14 +204,15 @@ static int xargs_exec(void)
 		status = (errno == ENOENT) ? 127 : 126;
 	}
 	else if (status >= 0x180) {
-		bb_error_msg("'%s' terminated by signal %d",
+		bb_error_msg("'%s' terminated by signal %u",
 			G.args[0], status - 0x180);
 		status = 125;
 	}
 	else if (status != 0) {
 		if (status == 255) {
 			bb_error_msg("%s: exited with status 255; aborting", G.args[0]);
-			return 124;
+			status = 124;
+			goto ret;
 		}
 		/* "123 if any invocation of the command exited with status 1-125"
 		 * This implies that nonzero exit code is remembered,
@@ -220,7 +221,7 @@ static int xargs_exec(void)
 		G.xargs_exitcode = 123;
 		status = 0;
 	}
-
+ ret:
 	if (status != 0)
 		G.xargs_exitcode = status;
 	return status;
@@ -520,7 +521,7 @@ static int xargs_ask_confirmation(void)
 //usage:	)
 //usage:     "\n	-r	Don't run command if input is empty"
 //usage:	IF_FEATURE_XARGS_SUPPORT_ZERO_TERM(
-//usage:     "\n	-0	Input is separated by NUL characters"
+//usage:     "\n	-0	Input is separated by NULs"
 //usage:	)
 //usage:	IF_FEATURE_XARGS_SUPPORT_ARGS_FILE(
 //usage:     "\n	-a FILE	Read from FILE instead of stdin"
diff -urpN busybox-1.29.3/include/applets.src.h busybox-1.30.0/include/applets.src.h
--- busybox-1.29.3/include/applets.src.h	2018-07-02 13:23:06.000000000 +0200
+++ busybox-1.30.0/include/applets.src.h	2018-12-05 15:44:34.000000000 +0100
@@ -27,36 +27,49 @@ s     - suid type:
 # define APPLET_ODDNAME(name,main,l,s,help)  int main##_main(int argc, char **argv) MAIN_EXTERNALLY_VISIBLE;
 # define APPLET_NOEXEC(name,main,l,s,help)   int main##_main(int argc, char **argv) MAIN_EXTERNALLY_VISIBLE;
 # define APPLET_NOFORK(name,main,l,s,help)   int main##_main(int argc, char **argv) MAIN_EXTERNALLY_VISIBLE;
+# define APPLET_SCRIPTED(name,main,l,s,help)
 
 #elif defined(NAME_MAIN)
 # define APPLET(name,l,s)                    name name##_main
 # define APPLET_ODDNAME(name,main,l,s,help)  name main##_main
 # define APPLET_NOEXEC(name,main,l,s,help)   name main##_main
 # define APPLET_NOFORK(name,main,l,s,help)   name main##_main
+# define APPLET_SCRIPTED(name,main,l,s,help) name scripted_main
 
 #elif defined(MAKE_USAGE) && ENABLE_FEATURE_VERBOSE_USAGE
 # define APPLET(name,l,s)                    MAKE_USAGE(#name, name##_trivial_usage name##_full_usage)
 # define APPLET_ODDNAME(name,main,l,s,help)  MAKE_USAGE(#name, help##_trivial_usage help##_full_usage)
 # define APPLET_NOEXEC(name,main,l,s,help)   MAKE_USAGE(#name, help##_trivial_usage help##_full_usage)
 # define APPLET_NOFORK(name,main,l,s,help)   MAKE_USAGE(#name, help##_trivial_usage help##_full_usage)
+# define APPLET_SCRIPTED(name,main,l,s,help) MAKE_USAGE(#name, help##_trivial_usage help##_full_usage)
 
 #elif defined(MAKE_USAGE) && !ENABLE_FEATURE_VERBOSE_USAGE
 # define APPLET(name,l,s)                    MAKE_USAGE(#name, name##_trivial_usage)
 # define APPLET_ODDNAME(name,main,l,s,help)  MAKE_USAGE(#name, help##_trivial_usage)
 # define APPLET_NOEXEC(name,main,l,s,help)   MAKE_USAGE(#name, help##_trivial_usage)
 # define APPLET_NOFORK(name,main,l,s,help)   MAKE_USAGE(#name, help##_trivial_usage)
+# define APPLET_SCRIPTED(name,main,l,s,help) MAKE_USAGE(#name, help##_trivial_usage)
 
 #elif defined(MAKE_LINKS)
 # define APPLET(name,l,c)                    LINK l name
 # define APPLET_ODDNAME(name,main,l,s,help)  LINK l name
 # define APPLET_NOEXEC(name,main,l,s,help)   LINK l name
 # define APPLET_NOFORK(name,main,l,s,help)   LINK l name
+# define APPLET_SCRIPTED(name,main,l,s,help) LINK l name
 
 #elif defined(MAKE_SUID)
 # define APPLET(name,l,s)                    SUID s l name
 # define APPLET_ODDNAME(name,main,l,s,help)  SUID s l name
 # define APPLET_NOEXEC(name,main,l,s,help)   SUID s l name
 # define APPLET_NOFORK(name,main,l,s,help)   SUID s l name
+# define APPLET_SCRIPTED(name,main,l,s,help) SUID s l name
+
+#elif defined(MAKE_SCRIPTS)
+# define APPLET(name,l,s)
+# define APPLET_ODDNAME(name,main,l,s,help)
+# define APPLET_NOEXEC(name,main,l,s,help)
+# define APPLET_NOFORK(name,main,l,s,help)
+# define APPLET_SCRIPTED(name,main,l,s,help) SCRIPT name
 
 #else
   static struct bb_applet applets[] = { /*    name, main, location, need_suid */
@@ -64,6 +77,7 @@ s     - suid type:
 # define APPLET_ODDNAME(name,main,l,s,help)  { #name, #main, l, s },
 # define APPLET_NOEXEC(name,main,l,s,help)   { #name, #main, l, s, 1 },
 # define APPLET_NOFORK(name,main,l,s,help)   { #name, #main, l, s, 1, 1 },
+# define APPLET_SCRIPTED(name,main,l,s,help) { #name, #main, l, s },
 #endif
 
 #if ENABLE_INSTALL_NO_USR
@@ -84,3 +98,4 @@ INSERT
 #undef APPLET_ODDNAME
 #undef APPLET_NOEXEC
 #undef APPLET_NOFORK
+#undef APPLET_SCRIPTED
diff -urpN busybox-1.29.3/include/bb_archive.h busybox-1.30.0/include/bb_archive.h
--- busybox-1.29.3/include/bb_archive.h	2018-07-02 13:23:06.000000000 +0200
+++ busybox-1.30.0/include/bb_archive.h	2018-12-05 15:44:34.000000000 +0100
@@ -214,12 +214,7 @@ const llist_t *find_list_entry(const lli
 const llist_t *find_list_entry2(const llist_t *list, const char *filename) FAST_FUNC;
 
 /* A bit of bunzip2 internals are exposed for compressed help support: */
-typedef struct bunzip_data bunzip_data;
-int start_bunzip(void *, bunzip_data **bdp, int in_fd, const void *inbuf, int len) FAST_FUNC;
-/* NB: read_bunzip returns < 0 on error, or the number of *unfilled* bytes
- * in outbuf. IOW: on EOF returns len ("all bytes are not filled"), not 0: */
-int read_bunzip(bunzip_data *bd, char *outbuf, int len) FAST_FUNC;
-void dealloc_bunzip(bunzip_data *bd) FAST_FUNC;
+char *unpack_bz2_data(const char *packed, int packed_len, int unpacked_len) FAST_FUNC;
 
 /* Meaning and direction (input/output) of the fields are transformer-specific */
 typedef struct transformer_state_t {
diff -urpN busybox-1.29.3/include/libbb.h busybox-1.30.0/include/libbb.h
--- busybox-1.29.3/include/libbb.h	2018-07-02 13:23:06.000000000 +0200
+++ busybox-1.30.0/include/libbb.h	2018-12-30 16:14:20.000000000 +0100
@@ -410,6 +410,9 @@ enum {	/* cp.c, mv.c, install.c depend o
 	FILEUTILS_PRESERVE_SECURITY_CONTEXT = 1 << 15, /* -c */
 #endif
 	FILEUTILS_RMDEST          = 1 << (16 - !ENABLE_SELINUX), /* --remove-destination */
+	/* bit 17 skipped for "cp --parents" */
+	FILEUTILS_REFLINK         = 1 << (18 - !ENABLE_SELINUX), /* cp --reflink=auto */
+	FILEUTILS_REFLINK_ALWAYS  = 1 << (19 - !ENABLE_SELINUX), /* cp --reflink[=always] */
 	/*
 	 * Hole. cp may have some bits set here,
 	 * they should not affect remove_file()/copy_file()
@@ -541,6 +544,8 @@ void sig_unblock(int sig) FAST_FUNC;
 int sigaction_set(int sig, const struct sigaction *act) FAST_FUNC;
 /* SIG_BLOCK/SIG_UNBLOCK all signals: */
 int sigprocmask_allsigs(int how) FAST_FUNC;
+/* Return old set in the same set: */
+int sigprocmask2(int how, sigset_t *set) FAST_FUNC;
 /* Standard handler which just records signo */
 extern smallint bb_got_signal;
 void record_signo(int signo); /* not FAST_FUNC! */
@@ -733,18 +738,25 @@ struct hostent *xgethostbyname(const cha
 // + inet_common.c has additional IPv4-only stuff
 
 
+struct tls_aes {
+	uint32_t key[60];
+	unsigned rounds;
+};
 #define TLS_MAX_MAC_SIZE 32
 #define TLS_MAX_KEY_SIZE 32
+#define TLS_MAX_IV_SIZE   4
 struct tls_handshake_data; /* opaque */
 typedef struct tls_state {
+	unsigned flags;
+
 	int ofd;
 	int ifd;
 
 	unsigned min_encrypted_len_on_read;
 	uint16_t cipher_id;
-	uint8_t  encrypt_on_write;
 	unsigned MAC_size;
 	unsigned key_size;
+	unsigned IV_size;
 
 	uint8_t *outbuf;
 	int     outbuf_size;
@@ -766,12 +778,21 @@ typedef struct tls_state {
 	/*uint64_t read_seq64_be;*/
 	uint64_t write_seq64_be;
 
+	/*uint8_t *server_write_MAC_key;*/
 	uint8_t *client_write_key;
 	uint8_t *server_write_key;
+	uint8_t *client_write_IV;
+	uint8_t *server_write_IV;
 	uint8_t client_write_MAC_key[TLS_MAX_MAC_SIZE];
 	uint8_t server_write_MAC_k__[TLS_MAX_MAC_SIZE];
 	uint8_t client_write_k__[TLS_MAX_KEY_SIZE];
 	uint8_t server_write_k__[TLS_MAX_KEY_SIZE];
+	uint8_t client_write_I_[TLS_MAX_IV_SIZE];
+	uint8_t server_write_I_[TLS_MAX_IV_SIZE];
+
+	struct tls_aes aes_encrypt;
+	struct tls_aes aes_decrypt;
+	uint8_t H[16]; //used by AES_GCM
 } tls_state_t;
 
 static inline tls_state_t *new_tls_state(void)
@@ -830,7 +851,8 @@ typedef struct uni_stat_t {
 } uni_stat_t;
 /* Returns a string with unprintable chars replaced by '?' or
  * SUBST_WCHAR. This function is unicode-aware. */
-const char* FAST_FUNC printable_string(uni_stat_t *stats, const char *str);
+const char* FAST_FUNC printable_string(const char *str);
+const char* FAST_FUNC printable_string2(uni_stat_t *stats, const char *str);
 /* Prints unprintable char ch as ^C or M-c to file
  * (M-c is used only if ch is ORed with PRINTABLE_META),
  * else it is printed as-is (except for ch = 0x9b) */
@@ -1015,6 +1037,14 @@ int xatoi_positive(const char *numstr) F
 /* Useful for reading port numbers */
 uint16_t xatou16(const char *numstr) FAST_FUNC;
 
+#if ENABLE_FLOAT_DURATION
+typedef double duration_t;
+void sleep_for_duration(duration_t duration) FAST_FUNC;
+#else
+typedef unsigned duration_t;
+#define sleep_for_duration(duration) sleep(duration)
+#endif
+duration_t parse_duration_str(char *str) FAST_FUNC;
 
 /* These parse entries in /etc/passwd and /etc/group.  This is desirable
  * for BusyBox since we want to avoid using the glibc NSS stuff, which
@@ -1309,9 +1339,22 @@ void bb_logenv_override(void) FAST_FUNC;
 #define MAIN_EXTERNALLY_VISIBLE
 #endif
 
+/* Embedded script support */
+char *get_script_content(unsigned n) FAST_FUNC;
+int scripted_main(int argc, char** argv);
 
 /* Applets which are useful from another applets */
 int bb_cat(char** argv) FAST_FUNC;
+int ash_main(int argc, char** argv)
+#if ENABLE_ASH || ENABLE_SH_IS_ASH || ENABLE_BASH_IS_ASH
+		MAIN_EXTERNALLY_VISIBLE
+#endif
+;
+int hush_main(int argc, char** argv)
+#if ENABLE_HUSH || ENABLE_SH_IS_HUSH || ENABLE_BASH_IS_HUSH
+		MAIN_EXTERNALLY_VISIBLE
+#endif
+;
 /* If shell needs them, they exist even if not enabled as applets */
 int echo_main(int argc, char** argv) IF_ECHO(MAIN_EXTERNALLY_VISIBLE);
 int printf_main(int argc, char **argv) IF_PRINTF(MAIN_EXTERNALLY_VISIBLE);
@@ -1345,7 +1388,7 @@ struct number_state {
 	const char *empty_str;
 	smallint all, nonempty;
 };
-void print_numbered_lines(struct number_state *ns, const char *filename) FAST_FUNC;
+int print_numbered_lines(struct number_state *ns, const char *filename) FAST_FUNC;
 
 
 /* Networking */
@@ -1745,7 +1788,7 @@ enum {
 	FOR_SHELL        = DO_HISTORY | TAB_COMPLETION | USERNAME_COMPLETION,
 };
 line_input_t *new_line_input_t(int flags) FAST_FUNC;
-/* So far static: void free_line_input_t(line_input_t *n) FAST_FUNC; */
+void free_line_input_t(line_input_t *n) FAST_FUNC;
 /*
  * maxsize must be >= 2.
  * Returns:
@@ -1970,7 +2013,7 @@ typedef struct bb_progress_t {
 	(p)->curfile = NULL; \
 } while (0)
 void bb_progress_init(bb_progress_t *p, const char *curfile) FAST_FUNC;
-void bb_progress_update(bb_progress_t *p,
+int bb_progress_update(bb_progress_t *p,
 			uoff_t beg_range,
 			uoff_t transferred,
 			uoff_t totalsize) FAST_FUNC;
@@ -2116,6 +2159,23 @@ extern const char bb_default_login_shell
 # define FB_0 "/dev/fb0"
 #endif
 
+// storage helpers for mk*fs utilities
+char BUG_wrong_field_size(void);
+#define STORE_LE(field, value) \
+do { \
+	if (sizeof(field) == 4) \
+		field = SWAP_LE32((uint32_t)(value)); \
+	else if (sizeof(field) == 2) \
+		field = SWAP_LE16((uint16_t)(value)); \
+	else if (sizeof(field) == 1) \
+		field = (uint8_t)(value); \
+	else \
+		BUG_wrong_field_size(); \
+} while (0)
+
+#define FETCH_LE32(field) \
+	(sizeof(field) == 4 ? SWAP_LE32(field) : BUG_wrong_field_size())
+
 
 #define ARRAY_SIZE(x) ((unsigned)(sizeof(x) / sizeof((x)[0])))
 #define BUILD_BUG_ON(condition) ((void)sizeof(char[1 - 2*!!(condition)]))
diff -urpN busybox-1.29.3/include/platform.h busybox-1.30.0/include/platform.h
--- busybox-1.29.3/include/platform.h	2018-07-02 13:23:06.000000000 +0200
+++ busybox-1.30.0/include/platform.h	2018-12-05 15:44:34.000000000 +0100
@@ -236,6 +236,7 @@ typedef uint64_t bb__aliased_uint64_t FI
 # define move_from_unaligned32(v, u32p) ((v) = *(bb__aliased_uint32_t*)(u32p))
 # define move_to_unaligned16(u16p, v)   (*(bb__aliased_uint16_t*)(u16p) = (v))
 # define move_to_unaligned32(u32p, v)   (*(bb__aliased_uint32_t*)(u32p) = (v))
+# define move_to_unaligned64(u64p, v)   (*(bb__aliased_uint64_t*)(u64p) = (v))
 /* #elif ... - add your favorite arch today! */
 #else
 # define BB_UNALIGNED_MEMACCESS_OK 0
@@ -252,6 +253,10 @@ typedef uint64_t bb__aliased_uint64_t FI
 	uint32_t __t = (v); \
 	memcpy((u32p), &__t, 4); \
 } while (0)
+# define move_to_unaligned64(u64p, v) do { \
+	uint64_t __t = (v); \
+	memcpy((u64p), &__t, 8); \
+} while (0)
 #endif
 
 /* Unaligned, fixed-endian accessors */
diff -urpN busybox-1.29.3/include/usage.src.h busybox-1.30.0/include/usage.src.h
--- busybox-1.29.3/include/usage.src.h	2018-07-02 13:23:06.000000000 +0200
+++ busybox-1.30.0/include/usage.src.h	2018-12-05 15:44:34.000000000 +0100
@@ -14,6 +14,9 @@
 
 #define NOUSAGE_STR "\b"
 
+#define scripted_trivial_usage NOUSAGE_STR
+#define scripted_full_usage ""
+
 #if !ENABLE_USE_BB_CRYPT || ENABLE_USE_BB_CRYPT_SHA
 # define CRYPT_METHODS_HELP_STR "des,md5,sha256/512" \
 	" (default "CONFIG_FEATURE_DEFAULT_PASSWD_ALGO")"
diff -urpN busybox-1.29.3/init/bootchartd.c busybox-1.30.0/init/bootchartd.c
--- busybox-1.29.3/init/bootchartd.c	2018-07-02 13:23:06.000000000 +0200
+++ busybox-1.30.0/init/bootchartd.c	2018-12-30 16:14:20.000000000 +0100
@@ -23,7 +23,7 @@
 //config:	help
 //config:	Create extended header file compatible with "big" bootchartd.
 //config:	"Big" bootchartd is a shell script and it dumps some
-//config:	"convenient" info int the header, such as:
+//config:	"convenient" info into the header, such as:
 //config:		title = Boot chart for `hostname` (`date`)
 //config:		system.uname = `uname -srvm`
 //config:		system.release = `cat /etc/DISTRO-release`
diff -urpN busybox-1.29.3/init/halt.c busybox-1.30.0/init/halt.c
--- busybox-1.29.3/init/halt.c	2018-07-02 13:23:06.000000000 +0200
+++ busybox-1.30.0/init/halt.c	2018-12-30 16:14:20.000000000 +0100
@@ -7,19 +7,19 @@
  * Licensed under GPLv2, see file LICENSE in this source tree.
  */
 //config:config HALT
-//config:	bool "halt (3.7 kb)"
+//config:	bool "halt (4 kb)"
 //config:	default y
 //config:	help
 //config:	Stop all processes and halt the system.
 //config:
 //config:config POWEROFF
-//config:	bool "poweroff (3.7 kb)"
+//config:	bool "poweroff (4 kb)"
 //config:	default y
 //config:	help
 //config:	Stop all processes and power off the system.
 //config:
 //config:config REBOOT
-//config:	bool "reboot (3.7 kb)"
+//config:	bool "reboot (4 kb)"
 //config:	default y
 //config:	help
 //config:	Stop all processes and reboot the system.
diff -urpN busybox-1.29.3/init/init.c busybox-1.30.0/init/init.c
--- busybox-1.29.3/init/init.c	2018-07-02 13:23:06.000000000 +0200
+++ busybox-1.30.0/init/init.c	2018-12-30 16:14:20.000000000 +0100
@@ -9,7 +9,7 @@
  * Licensed under GPLv2 or later, see file LICENSE in this source tree.
  */
 //config:config INIT
-//config:	bool "init (9.3 kb)"
+//config:	bool "init (10 kb)"
 //config:	default y
 //config:	select FEATURE_SYSLOG
 //config:	help
@@ -752,8 +752,13 @@ static void pause_and_low_level_reboot(u
 		reboot(magic);
 		_exit(EXIT_SUCCESS);
 	}
-	while (1)
-		sleep(1);
+	/* Used to have "while (1) sleep(1)" here.
+	 * However, in containers reboot() call is ignored, and with that loop
+	 * we would eternally sleep here - not what we want.
+	 */
+	waitpid(pid, NULL, 0);
+	sleep(1); /* paranoia */
+	_exit(EXIT_SUCCESS);
 }
 
 static void run_shutdown_and_kill_processes(void)
diff -urpN busybox-1.29.3/klibc-utils/nuke.c busybox-1.30.0/klibc-utils/nuke.c
--- busybox-1.29.3/klibc-utils/nuke.c	2018-07-02 13:23:06.000000000 +0200
+++ busybox-1.30.0/klibc-utils/nuke.c	2018-12-30 16:14:20.000000000 +0100
@@ -4,7 +4,7 @@
  * Licensed under GPLv2, see file LICENSE in this source tree.
  */
 //config:config NUKE
-//config:	bool "nuke (2.4 kb)"
+//config:	bool "nuke (2.9 kb)"
 //config:	default y
 //config:	help
 //config:	Alias to "rm -rf".
diff -urpN busybox-1.29.3/klibc-utils/resume.c busybox-1.30.0/klibc-utils/resume.c
--- busybox-1.29.3/klibc-utils/resume.c	2018-07-02 13:23:06.000000000 +0200
+++ busybox-1.30.0/klibc-utils/resume.c	2018-12-30 16:14:20.000000000 +0100
@@ -4,7 +4,7 @@
  * Licensed under GPLv2, see file LICENSE in this source tree.
  */
 //config:config RESUME
-//config:	bool "resume (3.3 kb)"
+//config:	bool "resume (3.2 kb)"
 //config:	default y
 //config:	help
 //config:	Resume from saved "suspend-to-disk" image
diff -urpN busybox-1.29.3/klibc-utils/run-init.c busybox-1.30.0/klibc-utils/run-init.c
--- busybox-1.29.3/klibc-utils/run-init.c	2018-07-02 13:23:06.000000000 +0200
+++ busybox-1.30.0/klibc-utils/run-init.c	2018-12-30 16:14:20.000000000 +0100
@@ -6,7 +6,7 @@
  * Licensed under GPLv2, see file LICENSE in this source tree.
  */
 //config:config RUN_INIT
-//config:	bool "run-init (7.5 kb)"
+//config:	bool "run-init (7.7 kb)"
 //config:	default y
 //config:	select PLATFORM_LINUX
 //config:	help
diff -urpN busybox-1.29.3/libbb/appletlib.c busybox-1.30.0/libbb/appletlib.c
--- busybox-1.29.3/libbb/appletlib.c	2018-07-02 13:23:06.000000000 +0200
+++ busybox-1.30.0/libbb/appletlib.c	2018-12-05 15:44:34.000000000 +0100
@@ -50,6 +50,16 @@
 
 #include "usage_compressed.h"
 
+#if ENABLE_FEATURE_SH_EMBEDDED_SCRIPTS
+# define DEFINE_SCRIPT_DATA 1
+# include "embedded_scripts.h"
+#else
+# define NUM_SCRIPTS 0
+#endif
+#if NUM_SCRIPTS > 0
+# include "bb_archive.h"
+static const char packed_scripts[] ALIGN1 = { PACKED_SCRIPTS };
+#endif
 
 /* "Do not compress usage text if uncompressed text is small
  *  and we don't include bunzip2 code for other reasons"
@@ -97,34 +107,8 @@ static const char usage_messages[] ALIGN
 
 static const char packed_usage[] ALIGN1 = { PACKED_USAGE };
 # include "bb_archive.h"
-static const char *unpack_usage_messages(void)
-{
-	char *outbuf = NULL;
-	bunzip_data *bd;
-	int i;
-	jmp_buf jmpbuf;
-
-	/* Setup for I/O error handling via longjmp */
-	i = setjmp(jmpbuf);
-	if (i == 0) {
-		i = start_bunzip(&jmpbuf,
-			&bd,
-			/* src_fd: */ -1,
-			/* inbuf:  */ packed_usage,
-			/* len:    */ sizeof(packed_usage)
-		);
-	}
-	/* read_bunzip can longjmp and end up here with i != 0
-	 * on read data errors! Not trivial */
-	if (i == 0) {
-		/* Cannot use xmalloc: will leak bd in NOFORK case! */
-		outbuf = malloc_or_warn(sizeof(UNPACKED_USAGE));
-		if (outbuf)
-			read_bunzip(bd, outbuf, sizeof(UNPACKED_USAGE));
-	}
-	dealloc_bunzip(bd);
-	return outbuf;
-}
+# define unpack_usage_messages() \
+	unpack_bz2_data(packed_usage, sizeof(packed_usage), sizeof(UNPACKED_USAGE))
 # define dealloc_usage_messages(s) free(s)
 
 #else
@@ -142,21 +126,23 @@ void FAST_FUNC bb_show_usage(void)
 		/* Imagine that this applet is "true". Dont suck in printf! */
 		const char *usage_string = unpack_usage_messages();
 
-		if (*usage_string == '\b') {
-			full_write2_str("No help available.\n\n");
-		} else {
-			full_write2_str("Usage: "SINGLE_APPLET_STR" ");
-			full_write2_str(usage_string);
-			full_write2_str("\n\n");
+		if (usage_string) {
+			if (*usage_string == '\b') {
+				full_write2_str("No help available.\n\n");
+			} else {
+				full_write2_str("Usage: "SINGLE_APPLET_STR" ");
+				full_write2_str(usage_string);
+				full_write2_str("\n\n");
+			}
+			if (ENABLE_FEATURE_CLEAN_UP)
+				dealloc_usage_messages((char*)usage_string);
 		}
-		if (ENABLE_FEATURE_CLEAN_UP)
-			dealloc_usage_messages((char*)usage_string);
 #else
 		const char *p;
 		const char *usage_string = p = unpack_usage_messages();
 		int ap = find_applet_by_name(applet_name);
 
-		if (ap < 0) /* never happens, paranoia */
+		if (ap < 0 || usage_string == NULL)
 			xfunc_die();
 		while (ap) {
 			while (*p++) continue;
@@ -169,8 +155,11 @@ void FAST_FUNC bb_show_usage(void)
 		else {
 			full_write2_str("\nUsage: ");
 			full_write2_str(applet_name);
-			full_write2_str(" ");
-			full_write2_str(p);
+			if (p[0]) {
+				if (p[0] != '\n')
+					full_write2_str(" ");
+				full_write2_str(p);
+			}
 			full_write2_str("\n");
 		}
 		if (ENABLE_FEATURE_CLEAN_UP)
@@ -734,7 +723,7 @@ static void install_links(const char *bu
 	 * busybox.h::bb_install_loc_t, or else... */
 	int (*lf)(const char *, const char *);
 	char *fpc;
-        const char *appname = applet_names;
+	const char *appname = applet_names;
 	unsigned i;
 	int rc;
 
@@ -767,6 +756,50 @@ static void install_links(const char *bu
 
 static void run_applet_and_exit(const char *name, char **argv) NORETURN;
 
+# if NUM_SCRIPTS > 0
+static int find_script_by_name(const char *name)
+{
+	int i;
+	int applet = find_applet_by_name(name);
+
+	if (applet >= 0) {
+		for (i = 0; i < NUM_SCRIPTS; ++i)
+			if (applet_numbers[i] == applet)
+				return i;
+	}
+	return -1;
+}
+
+int scripted_main(int argc UNUSED_PARAM, char **argv)
+{
+	int script = find_script_by_name(applet_name);
+	if (script >= 0)
+#if ENABLE_ASH || ENABLE_SH_IS_ASH || ENABLE_BASH_IS_ASH
+		exit(ash_main(-script - 1, argv));
+#elif ENABLE_HUSH || ENABLE_SH_IS_HUSH || ENABLE_BASH_IS_HUSH
+		exit(hush_main(-script - 1, argv));
+#else
+		return 1;
+#endif
+	return 0;
+}
+
+char* FAST_FUNC
+get_script_content(unsigned n)
+{
+	char *t = unpack_bz2_data(packed_scripts, sizeof(packed_scripts),
+					UNPACKED_SCRIPTS_LENGTH);
+	if (t) {
+		while (n != 0) {
+			while (*t++ != '\0')
+				continue;
+			n--;
+		}
+	}
+	return t;
+}
+# endif /* NUM_SCRIPTS > 0 */
+
 # if ENABLE_BUSYBOX
 #  if ENABLE_FEATURE_SH_STANDALONE && ENABLE_FEATURE_TAB_COMPLETION
     /*
@@ -804,6 +837,9 @@ int busybox_main(int argc UNUSED_PARAM,
 			"\n"
 			"Usage: busybox [function [arguments]...]\n"
 			"   or: busybox --list"IF_FEATURE_INSTALLER("[-full]")"\n"
+#  if ENABLE_FEATURE_SHOW_SCRIPT && NUM_SCRIPTS > 0
+			"   or: busybox --show SCRIPT\n"
+#  endif
 			IF_FEATURE_INSTALLER(
 			"   or: busybox --install [-s] [DIR]\n"
 			)
@@ -826,9 +862,9 @@ int busybox_main(int argc UNUSED_PARAM,
 			"Currently defined functions:\n"
 		);
 		col = 0;
-		a = applet_names;
 		/* prevent last comma to be in the very last pos */
 		output_width--;
+		a = applet_names;
 		while (*a) {
 			int len2 = strlen(a) + 2;
 			if (col >= (int)output_width - len2) {
@@ -849,6 +885,19 @@ int busybox_main(int argc UNUSED_PARAM,
 		return 0;
 	}
 
+#  if ENABLE_FEATURE_SHOW_SCRIPT && NUM_SCRIPTS > 0
+	if (strcmp(argv[1], "--show") == 0) {
+		int n;
+		if (!argv[2])
+			bb_error_msg_and_die(bb_msg_requires_arg, "--show");
+		n = find_script_by_name(argv[2]);
+		if (n < 0)
+			bb_error_msg_and_die("script '%s' not found", argv[2]);
+		full_write1_str(get_script_content(n));
+		return 0;
+	}
+#  endif
+
 	if (is_prefixed_with(argv[1], "--list")) {
 		unsigned i = 0;
 		const char *a = applet_names;
diff -urpN busybox-1.29.3/libbb/copy_file.c busybox-1.30.0/libbb/copy_file.c
--- busybox-1.29.3/libbb/copy_file.c	2018-07-02 13:23:06.000000000 +0200
+++ busybox-1.30.0/libbb/copy_file.c	2018-12-05 15:44:34.000000000 +0100
@@ -340,8 +340,27 @@ int FAST_FUNC copy_file(const char *sour
 			}
 		}
 #endif
+#if ENABLE_FEATURE_CP_REFLINK
+# undef BTRFS_IOCTL_MAGIC
+# define BTRFS_IOCTL_MAGIC 0x94
+# undef BTRFS_IOC_CLONE
+# define BTRFS_IOC_CLONE _IOW (BTRFS_IOCTL_MAGIC, 9, int)
+		if (flags & FILEUTILS_REFLINK) {
+			retval = ioctl(dst_fd, BTRFS_IOC_CLONE, src_fd);
+			if (retval == 0)
+				goto do_close;
+			/* reflink did not work */
+			if (flags & FILEUTILS_REFLINK_ALWAYS) {
+				bb_perror_msg("failed to clone '%s' from '%s'", dest, source);
+				goto do_close;
+			}
+			/* fall through to standard copy */
+			retval = 0;
+		}
+#endif
 		if (bb_copyfd_eof(src_fd, dst_fd) == -1)
 			retval = -1;
+ IF_FEATURE_CP_REFLINK(do_close:)
 		/* Careful with writing... */
 		if (close(dst_fd) < 0) {
 			bb_perror_msg("error writing to '%s'", dest);
@@ -369,14 +388,15 @@ int FAST_FUNC copy_file(const char *sour
 		char *lpath = xmalloc_readlink_or_warn(source);
 		if (lpath) {
 			int r = symlink(lpath, dest);
-			free(lpath);
 			if (r < 0) {
 				/* shared message */
 				bb_perror_msg("can't create %slink '%s' to '%s'",
 					"sym", dest, lpath
 				);
+				free(lpath);
 				return -1;
 			}
+			free(lpath);
 			if (flags & FILEUTILS_PRESERVE_STATUS)
 				if (lchown(dest, source_stat.st_uid, source_stat.st_gid) < 0)
 					bb_perror_msg("can't preserve %s of '%s'", "ownership", dest);
diff -urpN busybox-1.29.3/libbb/dump.c busybox-1.30.0/libbb/dump.c
--- busybox-1.29.3/libbb/dump.c	2018-07-02 13:23:06.000000000 +0200
+++ busybox-1.30.0/libbb/dump.c	2018-12-05 15:44:34.000000000 +0100
@@ -387,7 +387,10 @@ static unsigned char *get(priv_dumper_t
 			if (need == blocksize) {
 				return NULL;
 			}
-			if (dumper->pub.dump_vflag != ALL && !memcmp(dumper->get__curp, dumper->get__savp, nread)) {
+			if (dumper->pub.dump_vflag != ALL   /* not "show all"? */
+			 && dumper->pub.dump_vflag != FIRST /* not first line? */
+			 && memcmp(dumper->get__curp, dumper->get__savp, nread) == 0 /* same data? */
+			) {
 				if (dumper->pub.dump_vflag != DUP) {
 					puts("*");
 				}
@@ -399,7 +402,7 @@ static unsigned char *get(priv_dumper_t
 		}
 		n = fread(dumper->get__curp + nread, sizeof(unsigned char),
 				dumper->pub.dump_length == -1 ? need : MIN(dumper->pub.dump_length, need), stdin);
-		if (!n) {
+		if (n == 0) {
 			if (ferror(stdin)) {
 				bb_simple_perror_msg(dumper->argv[-1]);
 			}
@@ -411,9 +414,10 @@ static unsigned char *get(priv_dumper_t
 			dumper->pub.dump_length -= n;
 		}
 		need -= n;
-		if (!need) {
-			if (dumper->pub.dump_vflag == ALL || dumper->pub.dump_vflag == FIRST
-			 || memcmp(dumper->get__curp, dumper->get__savp, blocksize)
+		if (need == 0) {
+			if (dumper->pub.dump_vflag == ALL   /* "show all"? */
+			 || dumper->pub.dump_vflag == FIRST /* first line? */
+			 || memcmp(dumper->get__curp, dumper->get__savp, blocksize) != 0 /* not same data? */
 			) {
 				if (dumper->pub.dump_vflag == DUP || dumper->pub.dump_vflag == FIRST) {
 					dumper->pub.dump_vflag = WAIT;
diff -urpN busybox-1.29.3/libbb/duration.c busybox-1.30.0/libbb/duration.c
--- busybox-1.29.3/libbb/duration.c	1970-01-01 01:00:00.000000000 +0100
+++ busybox-1.30.0/libbb/duration.c	2018-12-05 15:44:34.000000000 +0100
@@ -0,0 +1,78 @@
+/* vi: set sw=4 ts=4: */
+/*
+ * Utility routines.
+ *
+ * Copyright (C) 2018 Denys Vlasenko
+ *
+ * Licensed under GPLv2, see file LICENSE in this source tree.
+ */
+//config:config FLOAT_DURATION
+//config:	bool "Enable fractional duration arguments"
+//config:	default y
+//config:	help
+//config:	Allow sleep N.NNN, top -d N.NNN etc.
+
+//kbuild:lib-$(CONFIG_SLEEP)   += duration.o
+//kbuild:lib-$(CONFIG_TOP)     += duration.o
+//kbuild:lib-$(CONFIG_TIMEOUT) += duration.o
+//kbuild:lib-$(CONFIG_PING)    += duration.o
+//kbuild:lib-$(CONFIG_PING6)   += duration.o
+
+#include "libbb.h"
+
+static const struct suffix_mult duration_suffixes[] = {
+	{ "s", 1 },
+	{ "m", 60 },
+	{ "h", 60*60 },
+	{ "d", 24*60*60 },
+	{ "", 0 }
+};
+
+#if ENABLE_FLOAT_DURATION
+duration_t FAST_FUNC parse_duration_str(char *str)
+{
+	duration_t duration;
+
+	if (strchr(str, '.')) {
+		double d;
+		char *pp;
+		int len = strspn(str, "0123456789.");
+		char sv = str[len];
+		str[len] = '\0';
+		errno = 0;
+		d = strtod(str, &pp);
+		if (errno || *pp)
+			bb_show_usage();
+		str += len;
+		*str-- = sv;
+		sv = *str;
+		*str = '1';
+		duration = d * xatoul_sfx(str, duration_suffixes);
+		*str = sv;
+	} else {
+		duration = xatoul_sfx(str, duration_suffixes);
+	}
+
+	return duration;
+}
+void FAST_FUNC sleep_for_duration(duration_t duration)
+{
+	struct timespec ts;
+
+	ts.tv_sec = MAXINT(typeof(ts.tv_sec));
+	ts.tv_nsec = 0;
+	if (duration >= 0 && duration < ts.tv_sec) {
+		ts.tv_sec = duration;
+		ts.tv_nsec = (duration - ts.tv_sec) * 1000000000;
+	}
+	do {
+		errno = 0;
+		nanosleep(&ts, &ts);
+	} while (errno == EINTR);
+}
+#else
+duration_t FAST_FUNC parse_duration_str(char *str)
+{
+	return xatou_range_sfx(str, 0, UINT_MAX, duration_suffixes);
+}
+#endif
diff -urpN busybox-1.29.3/libbb/hash_md5_sha.c busybox-1.30.0/libbb/hash_md5_sha.c
--- busybox-1.29.3/libbb/hash_md5_sha.c	2018-07-02 13:23:06.000000000 +0200
+++ busybox-1.30.0/libbb/hash_md5_sha.c	2018-12-05 15:44:34.000000000 +0100
@@ -794,6 +794,11 @@ static const uint32_t init512_lo[] = {
 };
 #endif /* NEED_SHA512 */
 
+// Note: SHA-384 is identical to SHA-512, except that initial hash values are
+// 0xcbbb9d5dc1059ed8, 0x629a292a367cd507, 0x9159015a3070dd17, 0x152fecd8f70e5939,
+// 0x67332667ffc00b31, 0x8eb44a8768581511, 0xdb0c2e0d64f98fa7, 0x47b5481dbefa4fa4,
+// and the output is constructed by omitting last two 64-bit words of it.
+
 /* Initialize structure containing state of computation.
    (FIPS 180-2:5.3.2)  */
 void FAST_FUNC sha256_begin(sha256_ctx_t *ctx)
diff -urpN busybox-1.29.3/libbb/lineedit.c busybox-1.30.0/libbb/lineedit.c
--- busybox-1.29.3/libbb/lineedit.c	2018-07-02 13:23:06.000000000 +0200
+++ busybox-1.30.0/libbb/lineedit.c	2018-12-30 16:14:20.000000000 +0100
@@ -1086,7 +1086,7 @@ static void showfiles(void)
 			);
 		}
 		if (ENABLE_UNICODE_SUPPORT)
-			puts(printable_string(NULL, matches[n]));
+			puts(printable_string(matches[n]));
 		else
 			puts(matches[n]);
 	}
@@ -1373,6 +1373,16 @@ void FAST_FUNC show_history(const line_i
 		printf("%4d %s\n", i, st->history[i]);
 }
 
+void FAST_FUNC free_line_input_t(line_input_t *n)
+{
+# if ENABLE_FEATURE_EDITING_SAVEHISTORY
+	int i = n->cnt_history;
+	while (i > 0)
+		free(n->history[--i]);
+#endif
+	free(n);
+}
+
 # if ENABLE_FEATURE_EDITING_SAVEHISTORY
 /* We try to ensure that concurrent additions to the history
  * do not overwrite each other.
@@ -1382,14 +1392,6 @@ void FAST_FUNC show_history(const line_i
  * than configured MAX_HISTORY lines.
  */
 
-static void free_line_input_t(line_input_t *n)
-{
-	int i = n->cnt_history;
-	while (i > 0)
-		free(n->history[--i]);
-	free(n);
-}
-
 /* state->flags is already checked to be nonzero */
 static void load_history(line_input_t *st_parm)
 {
@@ -2309,6 +2311,18 @@ static int32_t reverse_i_search(int time
 }
 #endif
 
+#if ENABLE_FEATURE_EDITING_WINCH
+static void sigaction2(int sig, struct sigaction *act)
+{
+	// Grr... gcc 8.1.1:
+	// "passing argument 3 to restrict-qualified parameter aliases with argument 2"
+	// dance around that...
+	struct sigaction *oact FIX_ALIASING;
+	oact = act;
+	sigaction(sig, act, oact);
+}
+#endif
+
 /* maxsize must be >= 2.
  * Returns:
  * -1 on read errors or EOF, or on bare Ctrl-D,
@@ -2419,7 +2433,7 @@ int FAST_FUNC read_line_input(line_input
 	/* Install window resize handler (NB: after *all* init is complete) */
 	S.SIGWINCH_handler.sa_handler = win_changed;
 	S.SIGWINCH_handler.sa_flags = SA_RESTART;
-	sigaction(SIGWINCH, &S.SIGWINCH_handler, &S.SIGWINCH_handler);
+	sigaction2(SIGWINCH, &S.SIGWINCH_handler);
 #endif
 	read_key_buffer[0] = 0;
 	while (1) {
diff -urpN busybox-1.29.3/libbb/nuke_str.c busybox-1.30.0/libbb/nuke_str.c
--- busybox-1.29.3/libbb/nuke_str.c	2018-07-02 13:23:06.000000000 +0200
+++ busybox-1.30.0/libbb/nuke_str.c	2018-12-05 15:44:34.000000000 +0100
@@ -12,7 +12,7 @@
 
 void FAST_FUNC nuke_str(char *str)
 {
-        if (str) {
+	if (str) {
 		while (*str)
 			*str++ = 0;
 		/* or: memset(str, 0, strlen(str)); - not as small as above */
diff -urpN busybox-1.29.3/libbb/print_numbered_lines.c busybox-1.30.0/libbb/print_numbered_lines.c
--- busybox-1.29.3/libbb/print_numbered_lines.c	2018-07-02 13:23:06.000000000 +0200
+++ busybox-1.30.0/libbb/print_numbered_lines.c	2018-12-05 15:44:34.000000000 +0100
@@ -8,12 +8,16 @@
 
 #include "libbb.h"
 
-void FAST_FUNC print_numbered_lines(struct number_state *ns, const char *filename)
+int FAST_FUNC print_numbered_lines(struct number_state *ns, const char *filename)
 {
 	FILE *fp = fopen_or_warn_stdin(filename);
-	unsigned N = ns->start;
+	unsigned N;
 	char *line;
 
+	if (!fp)
+		return EXIT_FAILURE;
+
+	N = ns->start;
 	while ((line = xmalloc_fgetline(fp)) != NULL) {
 		if (ns->all
 		 || (ns->nonempty && line[0])
@@ -27,4 +31,6 @@ void FAST_FUNC print_numbered_lines(stru
 	ns->start = N;
 
 	fclose(fp);
+
+	return EXIT_SUCCESS;
 }
diff -urpN busybox-1.29.3/libbb/printable_string.c busybox-1.30.0/libbb/printable_string.c
--- busybox-1.29.3/libbb/printable_string.c	2018-07-02 13:23:06.000000000 +0200
+++ busybox-1.30.0/libbb/printable_string.c	2018-12-05 15:44:34.000000000 +0100
@@ -9,7 +9,7 @@
 #include "libbb.h"
 #include "unicode.h"
 
-const char* FAST_FUNC printable_string(uni_stat_t *stats, const char *str)
+const char* FAST_FUNC printable_string2(uni_stat_t *stats, const char *str)
 {
 	char *dst;
 	const char *s;
@@ -55,3 +55,8 @@ const char* FAST_FUNC printable_string(u
 #endif
 	return auto_string(dst);
 }
+
+const char* FAST_FUNC printable_string(const char *str)
+{
+	return printable_string2(NULL, str);
+}
diff -urpN busybox-1.29.3/libbb/process_escape_sequence.c busybox-1.30.0/libbb/process_escape_sequence.c
--- busybox-1.29.3/libbb/process_escape_sequence.c	2018-07-02 13:23:06.000000000 +0200
+++ busybox-1.30.0/libbb/process_escape_sequence.c	2018-12-05 15:44:34.000000000 +0100
@@ -37,12 +37,18 @@ char FAST_FUNC bb_process_escape_sequenc
 	 * We treat \2 as a valid octal escape sequence. */
 	do {
 		unsigned r;
-#if !WANT_HEX_ESCAPES
 		unsigned d = (unsigned char)(*q) - '0';
-#else
-		unsigned d = (unsigned char)_tolower(*q) - '0';
-		if (d >= 10)
-			d += ('0' - 'a' + 10);
+#if WANT_HEX_ESCAPES
+		if (d >= 10) {
+			d = (unsigned char)_tolower(*q) - 'a';
+			//d += 10;
+			/* The above would map 'A'-'F' and 'a'-'f' to 10-15,
+			 * however, some chars like '@' would map to 9 < base.
+			 * Do not allow that, map invalid chars to N > base:
+			 */
+			if ((int)d >= 0)
+				d += 10;
+		}
 #endif
 		if (d >= base) {
 			if (WANT_HEX_ESCAPES && base == 16) {
diff -urpN busybox-1.29.3/libbb/progress.c busybox-1.30.0/libbb/progress.c
--- busybox-1.29.3/libbb/progress.c	2018-07-02 13:23:06.000000000 +0200
+++ busybox-1.30.0/libbb/progress.c	2018-12-05 15:44:34.000000000 +0100
@@ -69,7 +69,7 @@ void FAST_FUNC bb_progress_init(bb_progr
  * will be "totalsize" bytes.
  * If totalsize == 0, then it is unknown.
  */
-void FAST_FUNC bb_progress_update(bb_progress_t *p,
+int FAST_FUNC bb_progress_update(bb_progress_t *p,
 		uoff_t beg_size,
 		uoff_t transferred,
 		uoff_t totalsize)
@@ -94,7 +94,7 @@ void FAST_FUNC bb_progress_update(bb_pro
 		 * Do not update on every call
 		 * (we can be called on every network read!)
 		 */
-		return;
+		return -1;
 	}
 
 	/* Before we lose real, unscaled sizes, produce human-readable size string */
@@ -211,4 +211,5 @@ void FAST_FUNC bb_progress_update(bb_pro
 	}
 	if (notty)
 		fputc('\n', stderr);
+	return notty;
 }
diff -urpN busybox-1.29.3/libbb/remove_file.c busybox-1.30.0/libbb/remove_file.c
--- busybox-1.29.3/libbb/remove_file.c	2018-07-02 13:23:06.000000000 +0200
+++ busybox-1.30.0/libbb/remove_file.c	2018-12-05 15:44:34.000000000 +0100
@@ -73,7 +73,7 @@ int FAST_FUNC remove_file(const char *pa
 				return status;
 		}
 
-		if (rmdir(path) < 0) {
+		if (status == 0 && rmdir(path) < 0) {
 			bb_perror_msg("can't remove '%s'", path);
 			return -1;
 		}
diff -urpN busybox-1.29.3/libbb/signals.c busybox-1.30.0/libbb/signals.c
--- busybox-1.29.3/libbb/signals.c	2018-07-02 13:23:06.000000000 +0200
+++ busybox-1.30.0/libbb/signals.c	2018-12-30 16:14:20.000000000 +0100
@@ -31,6 +31,16 @@ int FAST_FUNC sigprocmask_allsigs(int ho
 	return sigprocmask(how, &set, NULL);
 }
 
+int FAST_FUNC sigprocmask2(int how, sigset_t *set)
+{
+	// Grr... gcc 8.1.1:
+	// "passing argument 3 to restrict-qualified parameter aliases with argument 2"
+	// dance around that...
+	sigset_t *oset FIX_ALIASING;
+	oset = set;
+	return sigprocmask(how, set, oset);
+}
+
 void FAST_FUNC bb_signals(int sigs, void (*f)(int))
 {
 	int sig_no = 0;
diff -urpN busybox-1.29.3/libbb/time.c busybox-1.30.0/libbb/time.c
--- busybox-1.29.3/libbb/time.c	2018-07-02 13:23:06.000000000 +0200
+++ busybox-1.30.0/libbb/time.c	2018-12-05 15:44:34.000000000 +0100
@@ -184,6 +184,7 @@ void FAST_FUNC parse_datestr(const char
 			ptm->tm_year -= 1900; /* Adjust years */
 			ptm->tm_mon -= 1; /* Adjust month from 1-12 to 0-11 */
 		} else {
+ err:
 			bb_error_msg_and_die(bb_msg_invalid_date, date_str);
 		}
 		ptm->tm_sec = 0; /* assume zero if [.SS] is not given */
@@ -194,6 +195,19 @@ void FAST_FUNC parse_datestr(const char
 				end = '\0';
 			/* else end != NUL and we error out */
 		}
+		/* Users were confused by "date -s 20180923"
+		 * working (not in the way they were expecting).
+		 * It was interpreted as MMDDhhmm, and not bothered by
+		 * "month #20" in the least. Prevent such cases:
+		 */
+		if (ptm->tm_sec > 60 /* allow "23:60" leap second */
+		 || ptm->tm_min > 59
+		 || ptm->tm_hour > 23
+		 || ptm->tm_mday > 31
+		 || ptm->tm_mon > 11 /* month# is 0..11, not 1..12 */
+		) {
+			goto err;
+		}
 	}
 	if (end != '\0') {
 		bb_error_msg_and_die(bb_msg_invalid_date, date_str);
diff -urpN busybox-1.29.3/libbb/u_signal_names.c busybox-1.30.0/libbb/u_signal_names.c
--- busybox-1.29.3/libbb/u_signal_names.c	2018-07-02 13:23:06.000000000 +0200
+++ busybox-1.30.0/libbb/u_signal_names.c	2018-12-05 15:44:34.000000000 +0100
@@ -12,6 +12,18 @@
 //config:	help
 //config:	Support RTMIN[+n] and RTMAX[-n] signal names
 //config:	in kill, killall etc. This costs ~250 bytes.
+//config:
+//config:config FEATURE_RTMINMAX_USE_LIBC_DEFINITIONS
+//config:	bool "Use the definitions of SIGRTMIN/SIGRTMAX provided by libc"
+//config:	default y
+//config:	depends on FEATURE_RTMINMAX
+//config:	help
+//config:	Some C libraries reserve a few real-time signals for internal
+//config:	use, and adjust the values of SIGRTMIN/SIGRTMAX seen by
+//config:	applications accordingly. Saying yes here means that a signal
+//config:	name RTMIN+n will be interpreted according to the libc definition
+//config:	of SIGRTMIN, and not the raw definition provided by the kernel.
+//config:	This behavior matches "kill -l RTMIN+n" from bash.
 
 #include "libbb.h"
 
@@ -123,7 +135,7 @@ static const char signals[][7] ALIGN1 =
 #ifdef SIGSYS
 	[SIGSYS   ] = "SYS",
 #endif
-#if ENABLE_FEATURE_RTMINMAX
+#if ENABLE_FEATURE_RTMINMAX && !ENABLE_FEATURE_RTMINMAX_USE_LIBC_DEFINITIONS
 # ifdef __SIGRTMIN
 	[__SIGRTMIN] = "RTMIN",
 # endif
@@ -141,8 +153,12 @@ int FAST_FUNC get_signum(const char *nam
 {
 	unsigned i;
 
+	/* bb_strtou returns UINT_MAX on error. NSIG is smaller
+	 * than UINT_MAX on any sane Unix. Hence no need
+	 * to check errno after bb_strtou().
+	 */
 	i = bb_strtou(name, NULL, 10);
-	if (!errno && i < NSIG) /* for shells, we allow 0 too */
+	if (i < NSIG) /* for shells, we allow 0 too */
 		return i;
 	if (strncasecmp(name, "SIG", 3) == 0)
 		name += 3;
@@ -168,36 +184,46 @@ int FAST_FUNC get_signum(const char *nam
 # endif
 #endif
 
-#if ENABLE_FEATURE_RTMINMAX
-# if defined(SIGRTMIN) && defined(SIGRTMAX)
-/* libc may use some rt sigs for pthreads and therefore "remap" SIGRTMIN/MAX,
- * but we want to use "raw" SIGRTMIN/MAX. Underscored names, if exist, provide
- * them. If they don't exist, fall back to non-underscored ones: */
+#if ENABLE_FEATURE_RTMINMAX && defined(SIGRTMIN) && defined(SIGRTMAX)
+	{
+# if ENABLE_FEATURE_RTMINMAX_USE_LIBC_DEFINITIONS
+		/* Use the libc provided values. */
+		unsigned sigrtmin = SIGRTMIN;
+		unsigned sigrtmax = SIGRTMAX;
+# else
+	/* Use the "raw" SIGRTMIN/MAX. Underscored names, if exist, provide
+	 * them. If they don't exist, fall back to non-underscored ones: */
 #  if !defined(__SIGRTMIN)
 #   define __SIGRTMIN SIGRTMIN
 #  endif
 #  if !defined(__SIGRTMAX)
 #   define __SIGRTMAX SIGRTMAX
 #  endif
-	if (strncasecmp(name, "RTMIN", 5) == 0) {
-		if (!name[5])
-			return __SIGRTMIN;
-		if (name[5] == '+') {
-			i = bb_strtou(name + 6, NULL, 10);
-			if (!errno && i <= __SIGRTMAX - __SIGRTMIN)
-				return __SIGRTMIN + i;
+
+#  define sigrtmin __SIGRTMIN
+#  define sigrtmax __SIGRTMAX
+# endif
+		if (strncasecmp(name, "RTMIN", 5) == 0) {
+			if (!name[5])
+				return sigrtmin;
+			if (name[5] == '+') {
+				i = bb_strtou(name + 6, NULL, 10);
+				if (i <= sigrtmax - sigrtmin)
+					return sigrtmin + i;
+			}
 		}
-	}
-	else if (strncasecmp(name, "RTMAX", 5) == 0) {
-		if (!name[5])
-			return __SIGRTMAX;
-		if (name[5] == '-') {
-			i = bb_strtou(name + 6, NULL, 10);
-			if (!errno && i <= __SIGRTMAX - __SIGRTMIN)
-				return __SIGRTMAX - i;
+		else if (strncasecmp(name, "RTMAX", 5) == 0) {
+			if (!name[5])
+				return sigrtmax;
+			if (name[5] == '-') {
+				i = bb_strtou(name + 6, NULL, 10);
+				if (i <= sigrtmax - sigrtmin)
+					return sigrtmax - i;
+			}
 		}
+# undef sigrtmin
+# undef sigrtmax
 	}
-# endif
 #endif
 
 	return -1;
@@ -228,8 +254,16 @@ void FAST_FUNC print_signames(void)
 			printf("%2u) %s\n", signo, name);
 	}
 #if ENABLE_FEATURE_RTMINMAX
-# ifdef __SIGRTMAX
+# if ENABLE_FEATURE_RTMINMAX_USE_LIBC_DEFINITIONS
+#  if defined(SIGRTMIN) && defined(SIGRTMAX)
+	printf("%2u) %s\n", SIGRTMIN, "RTMIN");
+	printf("%2u) %s\n", SIGRTMAX, "RTMAX");
+#  endif
+# else
+// __SIGRTMIN is included in signals[] array.
+#  ifdef __SIGRTMAX
 	printf("%2u) %s\n", __SIGRTMAX, "RTMAX");
+#  endif
 # endif
 #endif
 }
diff -urpN busybox-1.29.3/libbb/unicode.c busybox-1.30.0/libbb/unicode.c
--- busybox-1.29.3/libbb/unicode.c	2018-07-02 13:23:06.000000000 +0200
+++ busybox-1.30.0/libbb/unicode.c	2018-12-05 15:44:34.000000000 +0100
@@ -996,7 +996,7 @@ size_t FAST_FUNC unicode_strlen(const ch
 size_t FAST_FUNC unicode_strwidth(const char *string)
 {
 	uni_stat_t uni_stat;
-	printable_string(&uni_stat, string);
+	printable_string2(&uni_stat, string);
 	return uni_stat.unicode_width;
 }
 
@@ -1121,6 +1121,8 @@ static char* FAST_FUNC unicode_conv_to_p
 			dst[dst_len++] = ' ';
 		}
 	}
+	if (!dst) /* for example, if input was "" */
+		dst = xzalloc(1);
 	dst[dst_len] = '\0';
 	if (stats) {
 		stats->byte_count = dst_len;
diff -urpN busybox-1.29.3/libbb/xfuncs_printf.c busybox-1.30.0/libbb/xfuncs_printf.c
--- busybox-1.29.3/libbb/xfuncs_printf.c	2018-07-02 13:23:06.000000000 +0200
+++ busybox-1.30.0/libbb/xfuncs_printf.c	2018-12-05 15:44:34.000000000 +0100
@@ -222,6 +222,7 @@ void FAST_FUNC xdup2(int from, int to)
 {
 	if (dup2(from, to) != to)
 		bb_perror_msg_and_die("can't duplicate file descriptor");
+		//		" %d to %d", from, to);
 }
 
 // "Renumber" opened fd
diff -urpN busybox-1.29.3/loginutils/add-remove-shell.c busybox-1.30.0/loginutils/add-remove-shell.c
--- busybox-1.29.3/loginutils/add-remove-shell.c	2018-07-02 13:23:06.000000000 +0200
+++ busybox-1.30.0/loginutils/add-remove-shell.c	2018-12-30 16:14:20.000000000 +0100
@@ -8,13 +8,13 @@
  * for details.
  */
 //config:config ADD_SHELL
-//config:	bool "add-shell (2.8 kb)"
+//config:	bool "add-shell (3.1 kb)"
 //config:	default y if DESKTOP
 //config:	help
 //config:	Add shells to /etc/shells.
 //config:
 //config:config REMOVE_SHELL
-//config:	bool "remove-shell (2.7 kb)"
+//config:	bool "remove-shell (3 kb)"
 //config:	default y if DESKTOP
 //config:	help
 //config:	Remove shells from /etc/shells.
diff -urpN busybox-1.29.3/loginutils/addgroup.c busybox-1.30.0/loginutils/addgroup.c
--- busybox-1.29.3/loginutils/addgroup.c	2018-07-02 13:23:06.000000000 +0200
+++ busybox-1.30.0/loginutils/addgroup.c	2018-12-30 16:14:20.000000000 +0100
@@ -9,7 +9,7 @@
  * Licensed under GPLv2 or later, see file LICENSE in this source tree.
  */
 //config:config ADDGROUP
-//config:	bool "addgroup (8.2 kb)"
+//config:	bool "addgroup (8.6 kb)"
 //config:	default y
 //config:	select LONG_OPTS
 //config:	help
diff -urpN busybox-1.29.3/loginutils/chpasswd.c busybox-1.30.0/loginutils/chpasswd.c
--- busybox-1.29.3/loginutils/chpasswd.c	2018-07-02 13:23:06.000000000 +0200
+++ busybox-1.30.0/loginutils/chpasswd.c	2018-12-05 15:44:34.000000000 +0100
@@ -24,18 +24,20 @@
 //kbuild:lib-$(CONFIG_CHPASSWD) += chpasswd.o
 
 //usage:#define chpasswd_trivial_usage
-//usage:	IF_LONG_OPTS("[--md5|--encrypted|--crypt-method]") IF_NOT_LONG_OPTS("[-m|-e|-c]")
+//usage:	IF_LONG_OPTS("[--md5|--encrypted|--crypt-method|--root]") IF_NOT_LONG_OPTS("[-m|-e|-c|-R]")
 //usage:#define chpasswd_full_usage "\n\n"
 //usage:       "Read user:password from stdin and update /etc/passwd\n"
 //usage:	IF_LONG_OPTS(
 //usage:     "\n	-e,--encrypted		Supplied passwords are in encrypted form"
-//usage:     "\n	-m,--md5		Eencrypt using md5, not des"
+//usage:     "\n	-m,--md5		Encrypt using md5, not des"
 //usage:     "\n	-c,--crypt-method ALG	"CRYPT_METHODS_HELP_STR
+//usage:     "\n	-R,--root DIR		Directory to chroot into"
 //usage:	)
 //usage:	IF_NOT_LONG_OPTS(
 //usage:     "\n	-e	Supplied passwords are in encrypted form"
-//usage:     "\n	-m	Eencrypt using md5, not des"
+//usage:     "\n	-m	Encrypt using md5, not des"
 //usage:     "\n	-c ALG	"CRYPT_METHODS_HELP_STR
+//usage:     "\n	-R DIR	Directory to chroot into"
 //usage:	)
 
 #include "libbb.h"
@@ -45,6 +47,7 @@ static const char chpasswd_longopts[] AL
 	"encrypted\0"    No_argument       "e"
 	"md5\0"          No_argument       "m"
 	"crypt-method\0" Required_argument "c"
+	"root\0"         Required_argument "R"
 	;
 #endif
 
@@ -56,16 +59,21 @@ int chpasswd_main(int argc UNUSED_PARAM,
 {
 	char *name;
 	const char *algo = CONFIG_FEATURE_DEFAULT_PASSWD_ALGO;
+	const char *root = NULL;
 	int opt;
 
 	if (getuid() != 0)
 		bb_error_msg_and_die(bb_msg_perm_denied_are_you_root);
 
-	opt = getopt32long(argv, "^" "emc:" "\0" "m--ec:e--mc:c--em",
+	opt = getopt32long(argv, "^" "emc:R:" "\0" "m--ec:e--mc:c--em",
 			chpasswd_longopts,
-			&algo
+			&algo, &root
 	);
 
+	if (root) {
+		xchroot(root);
+	}
+
 	while ((name = xmalloc_fgetline(stdin)) != NULL) {
 		char *free_me;
 		char *pass;
diff -urpN busybox-1.29.3/loginutils/deluser.c busybox-1.30.0/loginutils/deluser.c
--- busybox-1.29.3/loginutils/deluser.c	2018-07-02 13:23:06.000000000 +0200
+++ busybox-1.30.0/loginutils/deluser.c	2018-12-30 16:14:20.000000000 +0100
@@ -9,13 +9,13 @@
  * Licensed under GPLv2, see file LICENSE in this source tree.
  */
 //config:config DELUSER
-//config:	bool "deluser (8.4 kb)"
+//config:	bool "deluser (9.1 kb)"
 //config:	default y
 //config:	help
 //config:	Utility for deleting a user account.
 //config:
 //config:config DELGROUP
-//config:	bool "delgroup (5.6 kb)"
+//config:	bool "delgroup (6.4 kb)"
 //config:	default y
 //config:	help
 //config:	Utility for deleting a group account.
diff -urpN busybox-1.29.3/mailutils/mail.c busybox-1.30.0/mailutils/mail.c
--- busybox-1.29.3/mailutils/mail.c	2018-07-02 13:23:06.000000000 +0200
+++ busybox-1.30.0/mailutils/mail.c	2018-12-05 15:44:34.000000000 +0100
@@ -107,7 +107,7 @@ static char* FAST_FUNC parse_url(char *u
 }
 */
 
-void FAST_FUNC encode_base64(char *fname, const char *text, const char *eol)
+static void encode_n_base64(const char *fname, const char *text, size_t len)
 {
 	enum {
 		SRC_BUF_SIZE = 57,  /* This *MUST* be a multiple of 3 */
@@ -116,18 +116,12 @@ void FAST_FUNC encode_base64(char *fname
 #define src_buf text
 	char src[SRC_BUF_SIZE];
 	FILE *fp = fp;
-	ssize_t len = len;
 	char dst_buf[DST_BUF_SIZE + 1];
 
 	if (fname) {
-		fp = (NOT_LONE_DASH(fname)) ? xfopen_for_read(fname) : (FILE *)text;
+		fp = (NOT_LONE_DASH(fname)) ? xfopen_for_read(fname) : stdin;
 		src_buf = src;
-	} else if (text) {
-		// though we do not call uuencode(NULL, NULL) explicitly
-		// still we do not want to break things suddenly
-		len = strlen(text);
-	} else
-		return;
+	}
 
 	while (1) {
 		size_t size;
@@ -145,7 +139,7 @@ void FAST_FUNC encode_base64(char *fname
 		// encode the buffer we just read in
 		bb_uuencode(dst_buf, src_buf, size, bb_uuenc_tbl_base64);
 		if (fname) {
-			puts(eol);
+			puts("");
 		} else {
 			src_buf += size;
 			len -= size;
@@ -157,6 +151,21 @@ void FAST_FUNC encode_base64(char *fname
 #undef src_buf
 }
 
+void FAST_FUNC printstr_base64(const char *text)
+{
+	encode_n_base64(NULL, text, strlen(text));
+}
+
+void FAST_FUNC printbuf_base64(const char *text, unsigned len)
+{
+	encode_n_base64(NULL, text, len);
+}
+
+void FAST_FUNC printfile_base64(const char *fname)
+{
+	encode_n_base64(fname, NULL, 0);
+}
+
 /*
  * get username and password from a file descriptor
  */
diff -urpN busybox-1.29.3/mailutils/mail.h busybox-1.30.0/mailutils/mail.h
--- busybox-1.29.3/mailutils/mail.h	2018-07-02 13:23:06.000000000 +0200
+++ busybox-1.30.0/mailutils/mail.h	2018-12-05 15:44:34.000000000 +0100
@@ -34,4 +34,6 @@ void get_cred_or_die(int fd) FAST_FUNC;
 
 char *send_mail_command(const char *fmt, const char *param) FAST_FUNC;
 
-void encode_base64(char *fname, const char *text, const char *eol) FAST_FUNC;
+void printbuf_base64(const char *buf, unsigned len) FAST_FUNC;
+void printstr_base64(const char *buf) FAST_FUNC;
+void printfile_base64(const char *fname) FAST_FUNC;
diff -urpN busybox-1.29.3/mailutils/makemime.c busybox-1.30.0/mailutils/makemime.c
--- busybox-1.29.3/mailutils/makemime.c	2018-07-02 13:23:06.000000000 +0200
+++ busybox-1.30.0/mailutils/makemime.c	2018-12-30 16:14:20.000000000 +0100
@@ -7,7 +7,7 @@
  * Licensed under GPLv2, see file LICENSE in this source tree.
  */
 //config:config MAKEMIME
-//config:	bool "makemime (5.9 kb)"
+//config:	bool "makemime (5.4 kb)"
 //config:	default y
 //config:	help
 //config:	Create MIME-formatted messages.
@@ -234,7 +234,7 @@ int makemime_main(int argc UNUSED_PARAM,
 			, G.opt_charset
 			, bb_get_last_path_component_strip(*argv)
 		);
-		encode_base64(*argv++, (const char *)stdin, "");
+		printfile_base64(*argv++);
 	}
 
 	// put multipart footer
diff -urpN busybox-1.29.3/mailutils/sendmail.c busybox-1.30.0/mailutils/sendmail.c
--- busybox-1.29.3/mailutils/sendmail.c	2018-07-15 14:52:21.000000000 +0200
+++ busybox-1.30.0/mailutils/sendmail.c	2018-12-05 15:44:34.000000000 +0100
@@ -36,7 +36,9 @@
 //usage:     "\n		openssl s_client -quiet -tls1 -connect smtp.gmail.com:465"
 //usage:     "\n			$SMTP_ANTISPAM_DELAY: seconds to wait after helper connect"
 //usage:     "\n	-S HOST[:PORT]	Server (default $SMTPHOST or 127.0.0.1)"
-//usage:     "\n	-amLOGIN	Log in using AUTH LOGIN (-amCRAM-MD5 not supported)"
+//usage:     "\n	-amLOGIN	Log in using AUTH LOGIN"
+//usage:     "\n	-amPLAIN	or AUTH PLAIN"
+//usage:     "\n			(-amCRAM-MD5 not supported)"
 //usage:     "\n	-auUSER		Username for AUTH"
 //usage:     "\n	-apPASS 	Password for AUTH"
 //usage:     "\n"
@@ -248,6 +250,8 @@ int sendmail_main(int argc UNUSED_PARAM,
 		OPT_S = 1 << 6,         // specify connection string
 		OPT_a = 1 << 7,         // authentication tokens
 		OPT_v = 1 << 8,         // verbosity
+	//--- for -amMETHOD
+		OPT_am_plain = 1 << 9,  // AUTH PLAIN
 	};
 
 	// init global variables
@@ -286,9 +290,14 @@ int sendmail_main(int argc UNUSED_PARAM,
 			G.user = xstrdup(a+1);
 		if ('p' == a[0])
 			G.pass = xstrdup(a+1);
-		// N.B. we support only AUTH LOGIN so far
-		//if ('m' == a[0])
-		//	G.method = xstrdup(a+1);
+		if ('m' == a[0]) {
+			if ((a[1] | 0x20) == 'p') // PLAIN
+				opts |= OPT_am_plain;
+			else if ((a[1] | 0x20) == 'l') // LOGIN
+				; /* do nothing (this is the default) */
+			else
+				bb_error_msg_and_die("unsupported AUTH method %s", a+1);
+		}
 	}
 	// N.B. list == NULL here
 	//bb_error_msg("OPT[%x] AU[%s], AP[%s], AM[%s], ARGV[%s]", opts, au, ap, am, *argv);
@@ -348,13 +357,44 @@ int sendmail_main(int argc UNUSED_PARAM,
 
 	// perform authentication
 	if (opts & OPT_a) {
-		smtp_check("AUTH LOGIN", 334);
-		// we must read credentials unless they are given via -a[up] options
+		// read credentials unless they are given via -a[up] options
 		if (!G.user || !G.pass)
 			get_cred_or_die(4);
-		encode_base64(NULL, G.user, NULL);
-		smtp_check("", 334);
-		encode_base64(NULL, G.pass, NULL);
+		if (opts & OPT_am_plain) {
+			// C: AUTH PLAIN
+			// S: 334
+			// C: base64encoded(auth<NUL>user<NUL>pass)
+			// S: 235 2.7.0 Authentication successful
+//Note: a shorter format is allowed:
+// C: AUTH PLAIN base64encoded(auth<NUL>user<NUL>pass)
+// S: 235 2.7.0 Authentication successful
+			smtp_check("AUTH PLAIN", 334);
+			{
+				unsigned user_len = strlen(G.user);
+				unsigned pass_len = strlen(G.pass);
+				unsigned sz = 1 + user_len + 1 + pass_len;
+				char plain_auth[sz + 1];
+				// the format is:
+				// "authorization identity<NUL>username<NUL>password"
+				// authorization identity is empty.
+				plain_auth[0] = '\0';
+				strcpy(stpcpy(plain_auth + 1, G.user) + 1, G.pass);
+				printbuf_base64(plain_auth, sz);
+			}
+		} else {
+			// C: AUTH LOGIN
+			// S: 334 VXNlcm5hbWU6
+			//        ^^^^^^^^^^^^ server says "Username:"
+			// C: base64encoded(user)
+			// S: 334 UGFzc3dvcmQ6
+			//        ^^^^^^^^^^^^ server says "Password:"
+			// C: base64encoded(pass)
+			// S: 235 2.7.0 Authentication successful
+			smtp_check("AUTH LOGIN", 334);
+			printstr_base64(G.user);
+			smtp_check("", 334);
+			printstr_base64(G.pass);
+		}
 		smtp_check("", 235);
 	}
 
diff -urpN busybox-1.29.3/make_single_applets.sh busybox-1.30.0/make_single_applets.sh
--- busybox-1.29.3/make_single_applets.sh	2018-07-02 13:23:06.000000000 +0200
+++ busybox-1.30.0/make_single_applets.sh	2018-12-30 16:14:20.000000000 +0100
@@ -27,6 +27,8 @@ allno="$cfg"
 for app in $apps; do
 	allno="`echo "$allno" | sed "s/^CONFIG_${app}=y\$/# CONFIG_${app} is not set/"`"
 done
+# remove "busybox" as well
+allno="`echo "$allno" | sed "s/^CONFIG_BUSYBOX=y\$/# CONFIG_BUSYBOX is not set/"`"
 #echo "$allno" >.config_allno
 
 trap 'test -f .config.SV && mv .config.SV .config && touch .config' EXIT
diff -urpN busybox-1.29.3/miscutils/adjtimex.c busybox-1.30.0/miscutils/adjtimex.c
--- busybox-1.29.3/miscutils/adjtimex.c	2018-07-02 13:23:06.000000000 +0200
+++ busybox-1.30.0/miscutils/adjtimex.c	2018-12-30 16:14:20.000000000 +0100
@@ -11,7 +11,7 @@
  * Licensed under GPLv2 or later, see file LICENSE in this source tree.
  */
 //config:config ADJTIMEX
-//config:	bool "adjtimex (4.5 kb)"
+//config:	bool "adjtimex (4.7 kb)"
 //config:	default y
 //config:	select PLATFORM_LINUX
 //config:	help
diff -urpN busybox-1.29.3/miscutils/bbconfig.c busybox-1.30.0/miscutils/bbconfig.c
--- busybox-1.29.3/miscutils/bbconfig.c	2018-07-02 13:23:06.000000000 +0200
+++ busybox-1.30.0/miscutils/bbconfig.c	2018-12-05 15:44:34.000000000 +0100
@@ -43,29 +43,10 @@ int bbconfig_main(int argc, char **argv)
 int bbconfig_main(int argc UNUSED_PARAM, char **argv UNUSED_PARAM)
 {
 #if ENABLE_FEATURE_COMPRESS_BBCONFIG
-	bunzip_data *bd;
-	int i;
-	jmp_buf jmpbuf;
-
-	/* Setup for I/O error handling via longjmp */
-	i = setjmp(jmpbuf);
-	if (i == 0) {
-		i = start_bunzip(&jmpbuf,
-			&bd,
-			/* src_fd: */ -1,
-			/* inbuf:  */ bbconfig_config_bz2,
-			/* len:    */ sizeof(bbconfig_config_bz2)
-		);
-	}
-	/* read_bunzip can longjmp and end up here with i != 0
-	 * on read data errors! Not trivial */
-	if (i == 0) {
-		/* Cannot use xmalloc: will leak bd in NOFORK case! */
-		char *outbuf = malloc_or_warn(sizeof(bbconfig_config));
-		if (outbuf) {
-			read_bunzip(bd, outbuf, sizeof(bbconfig_config));
-			full_write1_str(outbuf);
-		}
+	const char *outbuf = unpack_bz2_data(bbconfig_config_bz2,
+			sizeof(bbconfig_config_bz2), sizeof(bbconfig_config));
+	if (outbuf) {
+		full_write1_str(outbuf);
 	}
 #else
 	full_write1_str(bbconfig_config);
diff -urpN busybox-1.29.3/miscutils/bc.c busybox-1.30.0/miscutils/bc.c
--- busybox-1.29.3/miscutils/bc.c	1970-01-01 01:00:00.000000000 +0100
+++ busybox-1.30.0/miscutils/bc.c	2018-12-30 16:14:20.000000000 +0100
@@ -0,0 +1,7386 @@
+/* vi: set sw=4 ts=4: */
+/*
+ * Licensed under GPLv2 or later, see file LICENSE in this source tree.
+ * Adapted from https://github.com/gavinhoward/bc
+ * Original code copyright (c) 2018 Gavin D. Howard and contributors.
+ */
+//TODO: GNU extensions:
+// support ibase up to 36
+// support "define void f()..."
+// support "define f(*param[])" - "pass array by reference" syntax
+
+#define DEBUG_LEXER   0
+#define DEBUG_COMPILE 0
+#define DEBUG_EXEC    0
+// This can be left enabled for production as well:
+#define SANITY_CHECKS 1
+
+//config:config BC
+//config:	bool "bc (45 kb)"
+//config:	default y
+//config:	select FEATURE_DC_BIG
+//config:	help
+//config:	bc is a command-line, arbitrary-precision calculator with a
+//config:	Turing-complete language. See the GNU bc manual
+//config:	(https://www.gnu.org/software/bc/manual/bc.html) and bc spec
+//config:	(http://pubs.opengroup.org/onlinepubs/9699919799/utilities/bc.html).
+//config:
+//config:	This bc has five differences to the GNU bc:
+//config:	  1) The period (.) is a shortcut for "last", as in the BSD bc.
+//config:	  2) Arrays are copied before being passed as arguments to
+//config:	     functions. This behavior is required by the bc spec.
+//config:	  3) Arrays can be passed to the builtin "length" function to get
+//config:	     the number of elements in the array. This prints "1":
+//config:		a[0] = 0; length(a[])
+//config:	  4) The precedence of the boolean "not" operator (!) is equal to
+//config:	     that of the unary minus (-) negation operator. This still
+//config:	     allows POSIX-compliant scripts to work while somewhat
+//config:	     preserving expected behavior (versus C) and making parsing
+//config:	     easier.
+//config:	  5) "read()" accepts expressions, not only numeric literals.
+//config:
+//config:config DC
+//config:	bool "dc (36 kb)"
+//config:	default y
+//config:	help
+//config:	dc is a reverse-polish notation command-line calculator which
+//config:	supports unlimited precision arithmetic. See the FreeBSD man page
+//config:	(https://www.unix.com/man-page/FreeBSD/1/dc/) and GNU dc manual
+//config:	(https://www.gnu.org/software/bc/manual/dc-1.05/html_mono/dc.html).
+//config:
+//config:	This dc has a few differences from the two above:
+//config:	  1) When printing a byte stream (command "P"), this dc follows what
+//config:	     the FreeBSD dc does.
+//config:	  2) Implements the GNU extensions for divmod ("~") and
+//config:	     modular exponentiation ("|").
+//config:	  3) Implements all FreeBSD extensions, except for "J" and "M".
+//config:	  4) Like the FreeBSD dc, this dc supports extended registers.
+//config:	     However, they are implemented differently. When it encounters
+//config:	     whitespace where a register should be, it skips the whitespace.
+//config:	     If the character following is not a lowercase letter, an error
+//config:	     is issued. Otherwise, the register name is parsed by the
+//config:	     following regex: [a-z][a-z0-9_]*
+//config:	     This generally means that register names will be surrounded by
+//config:	     whitespace. Examples:
+//config:		l idx s temp L index S temp2 < do_thing
+//config:	     Also note that, like the FreeBSD dc, extended registers are not
+//config:	     allowed unless the "-x" option is given.
+//config:
+//config:if BC || DC  # for menuconfig indenting
+//config:
+//config:config FEATURE_DC_BIG
+//config:	bool "Use bc code base for dc (larger, more features)"
+//config:	default y
+//config:
+//config:config FEATURE_DC_LIBM
+//config:	bool "Enable power and exp functions (requires libm)"
+//config:	default y
+//config:	depends on DC && !BC && !FEATURE_DC_BIG
+//config:	help
+//config:	Enable power and exp functions.
+//config:	NOTE: This will require libm to be present for linking.
+//config:
+//config:config FEATURE_BC_INTERACTIVE
+//config:	bool "Interactive mode (+4kb)"
+//config:	default y
+//config:	depends on BC || (DC && FEATURE_DC_BIG)
+//config:	help
+//config:	Enable interactive mode: when started on a tty,
+//config:	^C interrupts execution and returns to command line,
+//config:	errors also return to command line instead of exiting,
+//config:	line editing with history is available.
+//config:
+//config:	With this option off, input can still be taken from tty,
+//config:	but all errors are fatal, ^C is fatal,
+//config:	tty is treated exactly the same as any other
+//config:	standard input (IOW: no line editing).
+//config:
+//config:config FEATURE_BC_LONG_OPTIONS
+//config:	bool "Enable bc/dc long options"
+//config:	default y
+//config:	depends on BC || (DC && FEATURE_DC_BIG)
+//config:
+//config:endif
+
+//applet:IF_BC(APPLET(bc, BB_DIR_USR_BIN, BB_SUID_DROP))
+//applet:IF_DC(APPLET(dc, BB_DIR_USR_BIN, BB_SUID_DROP))
+
+//kbuild:lib-$(CONFIG_BC) += bc.o
+//kbuild:lib-$(CONFIG_DC) += bc.o
+
+//See www.gnu.org/software/bc/manual/bc.html
+//usage:#define bc_trivial_usage
+//usage:       "[-sqlw] FILE..."
+//usage:
+//usage:#define bc_full_usage "\n"
+//usage:     "\nArbitrary precision calculator"
+//usage:     "\n"
+///////:     "\n	-i	Interactive" - has no effect for now
+//usage:     "\n	-q	Quiet"
+//usage:     "\n	-l	Load standard math library"
+//usage:     "\n	-s	Be POSIX compatible"
+//usage:     "\n	-w	Warn if extensions are used"
+///////:     "\n	-v	Version"
+//usage:     "\n"
+//usage:     "\n$BC_LINE_LENGTH changes output width"
+//usage:
+//usage:#define bc_example_usage
+//usage:       "3 + 4.129\n"
+//usage:       "1903 - 2893\n"
+//usage:       "-129 * 213.28935\n"
+//usage:       "12 / -1932\n"
+//usage:       "12 % 12\n"
+//usage:       "34 ^ 189\n"
+//usage:       "scale = 13\n"
+//usage:       "ibase = 2\n"
+//usage:       "obase = A\n"
+//usage:
+//usage:#define dc_trivial_usage
+//usage:       IF_FEATURE_DC_BIG("[-x] ")"[-eSCRIPT]... [-fFILE]... [FILE]..."
+//usage:
+//usage:#define dc_full_usage "\n"
+//usage:     "\nTiny RPN calculator. Operations:"
+//usage:     "\n+, -, *, /, %, ~, ^," IF_FEATURE_DC_BIG(" |,")
+//usage:     "\np - print top of the stack without popping"
+//usage:     "\nf - print entire stack"
+//usage:     "\nk - pop the value and set the precision"
+//usage:     "\ni - pop the value and set input radix"
+//usage:     "\no - pop the value and set output radix"
+//usage:     "\nExamples: dc -e'2 2 + p' -> 4, dc -e'8 8 * 2 2 + / p' -> 16"
+//usage:
+//usage:#define dc_example_usage
+//usage:       "$ dc -e'2 2 + p'\n"
+//usage:       "4\n"
+//usage:       "$ dc -e'8 8 \\* 2 2 + / p'\n"
+//usage:       "16\n"
+//usage:       "$ dc -e'0 1 & p'\n"
+//usage:       "0\n"
+//usage:       "$ dc -e'0 1 | p'\n"
+//usage:       "1\n"
+//usage:       "$ echo '72 9 / 8 * p' | dc\n"
+//usage:       "64\n"
+
+#include "libbb.h"
+#include "common_bufsiz.h"
+
+#if !ENABLE_BC && !ENABLE_FEATURE_DC_BIG
+# include "dc.c"
+#else
+
+#if DEBUG_LEXER
+static uint8_t lex_indent;
+#define dbg_lex(...) \
+	do { \
+		fprintf(stderr, "%*s", lex_indent, ""); \
+		bb_error_msg(__VA_ARGS__); \
+	} while (0)
+#define dbg_lex_enter(...) \
+	do { \
+		dbg_lex(__VA_ARGS__); \
+		lex_indent++; \
+	} while (0)
+#define dbg_lex_done(...) \
+	do { \
+		lex_indent--; \
+		dbg_lex(__VA_ARGS__); \
+	} while (0)
+#else
+# define dbg_lex(...)       ((void)0)
+# define dbg_lex_enter(...) ((void)0)
+# define dbg_lex_done(...)  ((void)0)
+#endif
+
+#if DEBUG_COMPILE
+# define dbg_compile(...) bb_error_msg(__VA_ARGS__)
+#else
+# define dbg_compile(...) ((void)0)
+#endif
+
+#if DEBUG_EXEC
+# define dbg_exec(...) bb_error_msg(__VA_ARGS__)
+#else
+# define dbg_exec(...) ((void)0)
+#endif
+
+typedef enum BcStatus {
+	BC_STATUS_SUCCESS = 0,
+	BC_STATUS_FAILURE = 1,
+	BC_STATUS_PARSE_EMPTY_EXP = 2, // bc_parse_expr_empty_ok() uses this
+} BcStatus;
+
+#define BC_VEC_INVALID_IDX  ((size_t) -1)
+#define BC_VEC_START_CAP    (1 << 5)
+
+typedef void (*BcVecFree)(void *) FAST_FUNC;
+
+typedef struct BcVec {
+	char *v;
+	size_t len;
+	size_t cap;
+	size_t size;
+	BcVecFree dtor;
+} BcVec;
+
+typedef signed char BcDig;
+
+typedef struct BcNum {
+	BcDig *restrict num;
+	size_t rdx;
+	size_t len;
+	size_t cap;
+	bool neg;
+} BcNum;
+
+#define BC_NUM_MAX_IBASE        ((unsigned long) 16)
+// larger value might speed up BIGNUM calculations a bit:
+#define BC_NUM_DEF_SIZE         16
+#define BC_NUM_PRINT_WIDTH      69
+
+#define BC_NUM_KARATSUBA_LEN    32
+
+typedef enum BcInst {
+#if ENABLE_BC
+	BC_INST_INC_PRE,
+	BC_INST_DEC_PRE,
+	BC_INST_INC_POST,
+	BC_INST_DEC_POST,
+#endif
+	XC_INST_NEG,            // order
+
+	XC_INST_REL_EQ,         // should
+	XC_INST_REL_LE,         // match
+	XC_INST_REL_GE,         // LEX
+	XC_INST_REL_NE,         // constants
+	XC_INST_REL_LT,         // for
+	XC_INST_REL_GT,         // these
+
+	XC_INST_POWER,          // operations
+	XC_INST_MULTIPLY,       // |
+	XC_INST_DIVIDE,         // |
+	XC_INST_MODULUS,        // |
+	XC_INST_PLUS,           // |
+	XC_INST_MINUS,          // |
+
+	XC_INST_BOOL_NOT,       // |
+	XC_INST_BOOL_OR,        // |
+	XC_INST_BOOL_AND,       // |
+#if ENABLE_BC
+	BC_INST_ASSIGN_POWER,   // |
+	BC_INST_ASSIGN_MULTIPLY,// |
+	BC_INST_ASSIGN_DIVIDE,  // |
+	BC_INST_ASSIGN_MODULUS, // |
+	BC_INST_ASSIGN_PLUS,    // |
+	BC_INST_ASSIGN_MINUS,   // |
+#endif
+	XC_INST_ASSIGN,         // V
+
+	XC_INST_NUM,
+	XC_INST_VAR,
+	XC_INST_ARRAY_ELEM,
+	XC_INST_ARRAY,
+	XC_INST_SCALE_FUNC,
+
+	XC_INST_IBASE,       // order of these constans should match other enums
+	XC_INST_OBASE,       // order of these constans should match other enums
+	XC_INST_SCALE,       // order of these constans should match other enums
+	IF_BC(BC_INST_LAST,) // order of these constans should match other enums
+	XC_INST_LENGTH,
+	XC_INST_READ,
+	XC_INST_SQRT,
+
+	XC_INST_PRINT,
+	XC_INST_PRINT_POP,
+	XC_INST_STR,
+	XC_INST_PRINT_STR,
+
+#if ENABLE_BC
+	BC_INST_HALT,
+	BC_INST_JUMP,
+	BC_INST_JUMP_ZERO,
+
+	BC_INST_CALL,
+	BC_INST_RET0,
+#endif
+	XC_INST_RET,
+
+	XC_INST_POP,
+#if ENABLE_DC
+	DC_INST_POP_EXEC,
+
+	DC_INST_MODEXP,
+	DC_INST_DIVMOD,
+
+	DC_INST_EXECUTE,
+	DC_INST_EXEC_COND,
+
+	DC_INST_ASCIIFY,
+	DC_INST_PRINT_STREAM,
+
+	DC_INST_PRINT_STACK,
+	DC_INST_CLEAR_STACK,
+	DC_INST_STACK_LEN,
+	DC_INST_DUPLICATE,
+	DC_INST_SWAP,
+
+	DC_INST_LOAD,
+	DC_INST_PUSH_VAR,
+	DC_INST_PUSH_TO_VAR,
+
+	DC_INST_QUIT,
+	DC_INST_NQUIT,
+
+	DC_INST_INVALID = -1,
+#endif
+} BcInst;
+
+typedef struct BcId {
+	char *name;
+	size_t idx;
+} BcId;
+
+typedef struct BcFunc {
+	BcVec code;
+	IF_BC(BcVec labels;)
+	IF_BC(BcVec autos;)
+	IF_BC(BcVec strs;)
+	IF_BC(BcVec consts;)
+	IF_BC(size_t nparams;)
+} BcFunc;
+
+typedef enum BcResultType {
+	XC_RESULT_TEMP,
+
+	XC_RESULT_VAR,
+	XC_RESULT_ARRAY_ELEM,
+	XC_RESULT_ARRAY,
+
+	XC_RESULT_STR,
+
+	//code uses "inst - XC_INST_IBASE + XC_RESULT_IBASE" construct,
+	XC_RESULT_IBASE,       // relative order should match for: XC_INST_IBASE
+	XC_RESULT_OBASE,       // relative order should match for: XC_INST_OBASE
+	XC_RESULT_SCALE,       // relative order should match for: XC_INST_SCALE
+	IF_BC(BC_RESULT_LAST,) // relative order should match for: BC_INST_LAST
+	XC_RESULT_CONSTANT,
+	IF_BC(BC_RESULT_ONE,)
+} BcResultType;
+
+typedef union BcResultData {
+	BcNum n;
+	BcVec v;
+	BcId id;
+} BcResultData;
+
+typedef struct BcResult {
+	BcResultType t;
+	BcResultData d;
+} BcResult;
+
+typedef struct BcInstPtr {
+	size_t func;
+	size_t inst_idx;
+	IF_BC(size_t results_len_before_call;)
+} BcInstPtr;
+
+typedef enum BcLexType {
+	XC_LEX_EOF,
+	XC_LEX_INVALID,
+
+	XC_LEX_NLINE,
+	XC_LEX_WHITESPACE,
+	XC_LEX_STR,
+	XC_LEX_NAME,
+	XC_LEX_NUMBER,
+
+	XC_LEX_1st_op,
+	XC_LEX_NEG = XC_LEX_1st_op,     // order
+
+	XC_LEX_OP_REL_EQ,               // should
+	XC_LEX_OP_REL_LE,               // match
+	XC_LEX_OP_REL_GE,               // INST
+	XC_LEX_OP_REL_NE,               // constants
+	XC_LEX_OP_REL_LT,               // for
+	XC_LEX_OP_REL_GT,               // these
+
+	XC_LEX_OP_POWER,                // operations
+	XC_LEX_OP_MULTIPLY,             // |
+	XC_LEX_OP_DIVIDE,               // |
+	XC_LEX_OP_MODULUS,              // |
+	XC_LEX_OP_PLUS,                 // |
+	XC_LEX_OP_MINUS,                // |
+	XC_LEX_OP_last = XC_LEX_OP_MINUS,
+#if ENABLE_BC
+	BC_LEX_OP_BOOL_NOT,             // |
+	BC_LEX_OP_BOOL_OR,              // |
+	BC_LEX_OP_BOOL_AND,             // |
+
+	BC_LEX_OP_ASSIGN_POWER,         // |
+	BC_LEX_OP_ASSIGN_MULTIPLY,      // |
+	BC_LEX_OP_ASSIGN_DIVIDE,        // |
+	BC_LEX_OP_ASSIGN_MODULUS,       // |
+	BC_LEX_OP_ASSIGN_PLUS,          // |
+	BC_LEX_OP_ASSIGN_MINUS,         // |
+
+	BC_LEX_OP_ASSIGN,               // V
+
+	BC_LEX_OP_INC,
+	BC_LEX_OP_DEC,
+
+	BC_LEX_LPAREN, // () are 0x28 and 0x29
+	BC_LEX_RPAREN, // must be LPAREN+1: code uses (c - '(' + BC_LEX_LPAREN)
+
+	BC_LEX_LBRACKET, // [] are 0x5B and 0x5D
+	BC_LEX_COMMA,
+	BC_LEX_RBRACKET, // must be LBRACKET+2: code uses (c - '[' + BC_LEX_LBRACKET)
+
+	BC_LEX_LBRACE, // {} are 0x7B and 0x7D
+	BC_LEX_SCOLON,
+	BC_LEX_RBRACE, // must be LBRACE+2: code uses (c - '{' + BC_LEX_LBRACE)
+
+	BC_LEX_KEY_1st_keyword,
+	BC_LEX_KEY_AUTO = BC_LEX_KEY_1st_keyword,
+	BC_LEX_KEY_BREAK,
+	BC_LEX_KEY_CONTINUE,
+	BC_LEX_KEY_DEFINE,
+	BC_LEX_KEY_ELSE,
+	BC_LEX_KEY_FOR,
+	BC_LEX_KEY_HALT,
+	// code uses "type - BC_LEX_KEY_IBASE + XC_INST_IBASE" construct,
+	BC_LEX_KEY_IBASE,    // relative order should match for: XC_INST_IBASE
+	BC_LEX_KEY_OBASE,    // relative order should match for: XC_INST_OBASE
+	BC_LEX_KEY_IF,
+	BC_LEX_KEY_LAST,     // relative order should match for: BC_INST_LAST
+	BC_LEX_KEY_LENGTH,
+	BC_LEX_KEY_LIMITS,
+	BC_LEX_KEY_PRINT,
+	BC_LEX_KEY_QUIT,
+	BC_LEX_KEY_READ,
+	BC_LEX_KEY_RETURN,
+	BC_LEX_KEY_SCALE,
+	BC_LEX_KEY_SQRT,
+	BC_LEX_KEY_WHILE,
+#endif // ENABLE_BC
+
+#if ENABLE_DC
+	DC_LEX_OP_BOOL_NOT = XC_LEX_OP_last + 1,
+	DC_LEX_OP_ASSIGN,
+
+	DC_LEX_LPAREN,
+	DC_LEX_SCOLON,
+	DC_LEX_READ,
+	DC_LEX_IBASE,
+	DC_LEX_SCALE,
+	DC_LEX_OBASE,
+	DC_LEX_LENGTH,
+	DC_LEX_PRINT,
+	DC_LEX_QUIT,
+	DC_LEX_SQRT,
+	DC_LEX_LBRACE,
+
+	DC_LEX_EQ_NO_REG,
+	DC_LEX_OP_MODEXP,
+	DC_LEX_OP_DIVMOD,
+
+	DC_LEX_COLON,
+	DC_LEX_ELSE,
+	DC_LEX_EXECUTE,
+	DC_LEX_PRINT_STACK,
+	DC_LEX_CLEAR_STACK,
+	DC_LEX_STACK_LEVEL,
+	DC_LEX_DUPLICATE,
+	DC_LEX_SWAP,
+	DC_LEX_POP,
+
+	DC_LEX_ASCIIFY,
+	DC_LEX_PRINT_STREAM,
+
+	// code uses "t - DC_LEX_STORE_IBASE + XC_INST_IBASE" construct,
+	DC_LEX_STORE_IBASE,  // relative order should match for: XC_INST_IBASE
+	DC_LEX_STORE_OBASE,  // relative order should match for: XC_INST_OBASE
+	DC_LEX_STORE_SCALE,  // relative order should match for: XC_INST_SCALE
+	DC_LEX_LOAD,
+	DC_LEX_LOAD_POP,
+	DC_LEX_STORE_PUSH,
+	DC_LEX_PRINT_POP,
+	DC_LEX_NQUIT,
+	DC_LEX_SCALE_FACTOR,
+#endif
+} BcLexType;
+// must match order of BC_LEX_KEY_foo etc above
+#if ENABLE_BC
+struct BcLexKeyword {
+	char name8[8];
+};
+#define LEX_KW_ENTRY(a, b) \
+	{ .name8 = a /*, .posix = b */ }
+static const struct BcLexKeyword bc_lex_kws[20] = {
+	LEX_KW_ENTRY("auto"    , 1), // 0
+	LEX_KW_ENTRY("break"   , 1), // 1
+	LEX_KW_ENTRY("continue", 0), // 2 note: this one has no terminating NUL
+	LEX_KW_ENTRY("define"  , 1), // 3
+	LEX_KW_ENTRY("else"    , 0), // 4
+	LEX_KW_ENTRY("for"     , 1), // 5
+	LEX_KW_ENTRY("halt"    , 0), // 6
+	LEX_KW_ENTRY("ibase"   , 1), // 7
+	LEX_KW_ENTRY("obase"   , 1), // 8
+	LEX_KW_ENTRY("if"      , 1), // 9
+	LEX_KW_ENTRY("last"    , 0), // 10
+	LEX_KW_ENTRY("length"  , 1), // 11
+	LEX_KW_ENTRY("limits"  , 0), // 12
+	LEX_KW_ENTRY("print"   , 0), // 13
+	LEX_KW_ENTRY("quit"    , 1), // 14
+	LEX_KW_ENTRY("read"    , 0), // 15
+	LEX_KW_ENTRY("return"  , 1), // 16
+	LEX_KW_ENTRY("scale"   , 1), // 17
+	LEX_KW_ENTRY("sqrt"    , 1), // 18
+	LEX_KW_ENTRY("while"   , 1), // 19
+};
+#undef LEX_KW_ENTRY
+#define STRING_else  (bc_lex_kws[4].name8)
+#define STRING_for   (bc_lex_kws[5].name8)
+#define STRING_if    (bc_lex_kws[9].name8)
+#define STRING_while (bc_lex_kws[19].name8)
+enum {
+	POSIX_KWORD_MASK = 0
+		| (1 << 0)  // 0
+		| (1 << 1)  // 1
+		| (0 << 2)  // 2
+		| (1 << 3)  // 3
+		| (0 << 4)  // 4
+		| (1 << 5)  // 5
+		| (0 << 6)  // 6
+		| (1 << 7)  // 7
+		| (1 << 8)  // 8
+		| (1 << 9)  // 9
+		| (0 << 10) // 10
+		| (1 << 11) // 11
+		| (0 << 12) // 12
+		| (0 << 13) // 13
+		| (1 << 14) // 14
+		| (0 << 15) // 15
+		| (1 << 16) // 16
+		| (1 << 17) // 17
+		| (1 << 18) // 18
+		| (1 << 19) // 19
+};
+#define keyword_is_POSIX(i) ((1 << (i)) & POSIX_KWORD_MASK)
+
+// This is a bit array that corresponds to token types. An entry is
+// true if the token is valid in an expression, false otherwise.
+// Used to figure out when expr parsing should stop *without error message*
+// - 0 element indicates this condition. 1 means "this token is to be eaten
+// as part of the expression", it can then still be determined to be invalid
+// by later processing.
+enum {
+#define EXBITS(a,b,c,d,e,f,g,h) \
+	((uint64_t)((a << 0)+(b << 1)+(c << 2)+(d << 3)+(e << 4)+(f << 5)+(g << 6)+(h << 7)))
+	BC_PARSE_EXPRS_BITS = 0              // corresponding BC_LEX_xyz:
+	+ (EXBITS(0,0,0,0,0,1,1,1) << (0*8)) //  0: EOF    INVAL  NL     WS     STR    NAME   NUM    -
+	+ (EXBITS(1,1,1,1,1,1,1,1) << (1*8)) //  8: ==     <=     >=     !=     <      >      ^      *
+	+ (EXBITS(1,1,1,1,1,1,1,1) << (2*8)) // 16: /      %      +      -      !      ||     &&     ^=
+	+ (EXBITS(1,1,1,1,1,1,1,1) << (3*8)) // 24: *=     /=     %=     +=     -=     =      ++     --
+	+ (EXBITS(1,1,0,0,0,0,0,0) << (4*8)) // 32: (      )      [      ,      ]      {      ;      }
+	+ (EXBITS(0,0,0,0,0,0,0,1) << (5*8)) // 40: auto   break  cont   define else   for    halt   ibase
+	+ (EXBITS(1,0,1,1,0,0,0,1) << (6*8)) // 48: obase  if     last   length limits print  quit   read
+	+ (EXBITS(0,1,1,0,0,0,0,0) << (7*8)) // 56: return scale  sqrt   while
+#undef EXBITS
+};
+static ALWAYS_INLINE long lex_allowed_in_bc_expr(unsigned i)
+{
+#if ULONG_MAX > 0xffffffff
+	// 64-bit version (will not work correctly for 32-bit longs!)
+	return BC_PARSE_EXPRS_BITS & (1UL << i);
+#else
+	// 32-bit version
+	unsigned long m = (uint32_t)BC_PARSE_EXPRS_BITS;
+	if (i >= 32) {
+		m = (uint32_t)(BC_PARSE_EXPRS_BITS >> 32);
+		i &= 31;
+	}
+	return m & (1UL << i);
+#endif
+}
+
+// This is an array of data for operators that correspond to
+// [XC_LEX_1st_op...] token types.
+static const uint8_t bc_ops_prec_and_assoc[] ALIGN1 = {
+#define OP(p,l) ((int)(l) * 0x10 + (p))
+	OP(1, false), // neg
+	OP(6, true ), OP( 6, true  ), OP( 6, true  ), OP( 6, true  ), OP( 6, true  ), OP( 6, true ), // == <= >= != < >
+	OP(2, false), // pow
+	OP(3, true ), OP( 3, true  ), OP( 3, true  ), // mul div mod
+	OP(4, true ), OP( 4, true  ), // + -
+	OP(1, false), // not
+	OP(7, true ), OP( 7, true  ), // or and
+	OP(5, false), OP( 5, false ), OP( 5, false ), OP( 5, false ), OP( 5, false ), // ^= *= /= %= +=
+	OP(5, false), OP( 5, false ), // -= =
+	OP(0, false), OP( 0, false ), // inc dec
+#undef OP
+};
+#define bc_operation_PREC(i) (bc_ops_prec_and_assoc[i] & 0x0f)
+#define bc_operation_LEFT(i) (bc_ops_prec_and_assoc[i] & 0x10)
+#endif // ENABLE_BC
+
+#if ENABLE_DC
+static const //BcLexType - should be this type
+uint8_t
+dc_char_to_LEX[] ALIGN1 = {
+	// %&'(
+	XC_LEX_OP_MODULUS, XC_LEX_INVALID, XC_LEX_INVALID, DC_LEX_LPAREN,
+	// )*+,
+	XC_LEX_INVALID, XC_LEX_OP_MULTIPLY, XC_LEX_OP_PLUS, XC_LEX_INVALID,
+	// -./
+	XC_LEX_OP_MINUS, XC_LEX_INVALID, XC_LEX_OP_DIVIDE,
+	// 0123456789
+	XC_LEX_INVALID, XC_LEX_INVALID, XC_LEX_INVALID, XC_LEX_INVALID,
+	XC_LEX_INVALID, XC_LEX_INVALID, XC_LEX_INVALID, XC_LEX_INVALID,
+	XC_LEX_INVALID, XC_LEX_INVALID,
+	// :;<=>?@
+	DC_LEX_COLON, DC_LEX_SCOLON, XC_LEX_OP_REL_GT, XC_LEX_OP_REL_EQ,
+	XC_LEX_OP_REL_LT, DC_LEX_READ, XC_LEX_INVALID,
+	// ABCDEFGH
+	XC_LEX_INVALID, XC_LEX_INVALID, XC_LEX_INVALID, XC_LEX_INVALID,
+	XC_LEX_INVALID, XC_LEX_INVALID, DC_LEX_EQ_NO_REG, XC_LEX_INVALID,
+	// IJKLMNOP
+	DC_LEX_IBASE, XC_LEX_INVALID, DC_LEX_SCALE, DC_LEX_LOAD_POP,
+	XC_LEX_INVALID, DC_LEX_OP_BOOL_NOT, DC_LEX_OBASE, DC_LEX_PRINT_STREAM,
+	// QRSTUVWXY
+	DC_LEX_NQUIT, DC_LEX_POP, DC_LEX_STORE_PUSH, XC_LEX_INVALID, XC_LEX_INVALID,
+	XC_LEX_INVALID, XC_LEX_INVALID, DC_LEX_SCALE_FACTOR, XC_LEX_INVALID,
+	// Z[\]
+	DC_LEX_LENGTH, XC_LEX_INVALID, XC_LEX_INVALID, XC_LEX_INVALID,
+	// ^_`
+	XC_LEX_OP_POWER, XC_LEX_NEG, XC_LEX_INVALID,
+	// abcdefgh
+	DC_LEX_ASCIIFY, XC_LEX_INVALID, DC_LEX_CLEAR_STACK, DC_LEX_DUPLICATE,
+	DC_LEX_ELSE, DC_LEX_PRINT_STACK, XC_LEX_INVALID, XC_LEX_INVALID,
+	// ijklmnop
+	DC_LEX_STORE_IBASE, XC_LEX_INVALID, DC_LEX_STORE_SCALE, DC_LEX_LOAD,
+	XC_LEX_INVALID, DC_LEX_PRINT_POP, DC_LEX_STORE_OBASE, DC_LEX_PRINT,
+	// qrstuvwx
+	DC_LEX_QUIT, DC_LEX_SWAP, DC_LEX_OP_ASSIGN, XC_LEX_INVALID,
+	XC_LEX_INVALID, DC_LEX_SQRT, XC_LEX_INVALID, DC_LEX_EXECUTE,
+	// yz
+	XC_LEX_INVALID, DC_LEX_STACK_LEVEL,
+	// {|}~
+	DC_LEX_LBRACE, DC_LEX_OP_MODEXP, XC_LEX_INVALID, DC_LEX_OP_DIVMOD,
+};
+static const //BcInst - should be this type. Using signed narrow type since DC_INST_INVALID is -1
+int8_t
+dc_LEX_to_INST[] ALIGN1 = { //starts at XC_LEX_OP_POWER // corresponding XC/DC_LEX_xyz:
+	XC_INST_POWER,       XC_INST_MULTIPLY,          // XC_LEX_OP_POWER    XC_LEX_OP_MULTIPLY
+	XC_INST_DIVIDE,      XC_INST_MODULUS,           // XC_LEX_OP_DIVIDE   XC_LEX_OP_MODULUS
+	XC_INST_PLUS,        XC_INST_MINUS,             // XC_LEX_OP_PLUS     XC_LEX_OP_MINUS
+	XC_INST_BOOL_NOT,                               // DC_LEX_OP_BOOL_NOT
+	DC_INST_INVALID,                                // DC_LEX_OP_ASSIGN
+	XC_INST_REL_GT,                                 // DC_LEX_LPAREN
+	DC_INST_INVALID,                                // DC_LEX_SCOLON
+	DC_INST_INVALID,                                // DC_LEX_READ
+	XC_INST_IBASE,                                  // DC_LEX_IBASE
+	XC_INST_SCALE,                                  // DC_LEX_SCALE
+	XC_INST_OBASE,                                  // DC_LEX_OBASE
+	XC_INST_LENGTH,                                 // DC_LEX_LENGTH
+	XC_INST_PRINT,                                  // DC_LEX_PRINT
+	DC_INST_QUIT,                                   // DC_LEX_QUIT
+	XC_INST_SQRT,                                   // DC_LEX_SQRT
+	XC_INST_REL_GE,                                 // DC_LEX_LBRACE
+	XC_INST_REL_EQ,                                 // DC_LEX_EQ_NO_REG
+	DC_INST_MODEXP,      DC_INST_DIVMOD,            // DC_LEX_OP_MODEXP   DC_LEX_OP_DIVMOD
+	DC_INST_INVALID,     DC_INST_INVALID,           // DC_LEX_COLON       DC_LEX_ELSE
+	DC_INST_EXECUTE,                                // DC_LEX_EXECUTE
+	DC_INST_PRINT_STACK, DC_INST_CLEAR_STACK,       // DC_LEX_PRINT_STACK DC_LEX_CLEAR_STACK
+	DC_INST_STACK_LEN,   DC_INST_DUPLICATE,         // DC_LEX_STACK_LEVEL DC_LEX_DUPLICATE
+	DC_INST_SWAP,        XC_INST_POP,               // DC_LEX_SWAP        DC_LEX_POP
+	DC_INST_ASCIIFY,     DC_INST_PRINT_STREAM,      // DC_LEX_ASCIIFY     DC_LEX_PRINT_STREAM
+	DC_INST_INVALID,     DC_INST_INVALID,           // DC_LEX_STORE_IBASE DC_LEX_STORE_OBASE
+	DC_INST_INVALID,     DC_INST_INVALID,           // DC_LEX_STORE_SCALE DC_LEX_LOAD
+	DC_INST_INVALID,     DC_INST_INVALID,           // DC_LEX_LOAD_POP    DC_LEX_STORE_PUSH
+	XC_INST_PRINT,       DC_INST_NQUIT,             // DC_LEX_PRINT_POP   DC_LEX_NQUIT
+	XC_INST_SCALE_FUNC,                             // DC_LEX_SCALE_FACTOR
+	// DC_INST_INVALID in this table either means that corresponding LEX
+	// is not possible for dc, or that it does not compile one-to-one
+	// to a single INST.
+};
+#endif // ENABLE_DC
+
+typedef struct BcParse {
+	smallint lex;      // was BcLexType // first member is most used
+	smallint lex_last; // was BcLexType
+	size_t lex_line;
+	const char *lex_inbuf;
+	const char *lex_next_at; // last lex_next() was called at this string
+	const char *lex_filename;
+	FILE *lex_input_fp;
+	BcVec  lex_strnumbuf;
+
+	BcFunc *func;
+	size_t fidx;
+	IF_BC(size_t in_funcdef;)
+	IF_BC(BcVec exits;)
+	IF_BC(BcVec conds;)
+	IF_BC(BcVec ops;)
+} BcParse;
+
+typedef struct BcProgram {
+	size_t len;
+	size_t nchars;
+
+	size_t scale;
+	size_t ib_t;
+	size_t ob_t;
+
+	BcVec results;
+	BcVec exestack;
+
+	BcVec fns;
+	IF_BC(BcVec fn_map;)
+
+	BcVec vars;
+	BcVec var_map;
+
+	BcVec arrs;
+	BcVec arr_map;
+
+	IF_DC(BcVec strs;)
+	IF_DC(BcVec consts;)
+
+	BcNum zero;
+	IF_BC(BcNum one;)
+	IF_BC(BcNum last;)
+} BcProgram;
+
+struct globals {
+	BcParse prs; // first member is most used
+
+	// For error messages. Can be set to current parsed line,
+	// or [TODO] to current executing line (can be before last parsed one)
+	unsigned err_line;
+
+	BcVec input_buffer;
+
+	IF_FEATURE_BC_INTERACTIVE(smallint ttyin;)
+	IF_FEATURE_CLEAN_UP(smallint exiting;)
+
+	BcProgram prog;
+
+	BcVec files;
+
+	char *env_args;
+
+#if ENABLE_FEATURE_EDITING
+	line_input_t *line_input_state;
+#endif
+} FIX_ALIASING;
+#define G (*ptr_to_globals)
+#define INIT_G() do { \
+	SET_PTR_TO_GLOBALS(xzalloc(sizeof(G))); \
+} while (0)
+#define FREE_G() do { \
+	FREE_PTR_TO_GLOBALS(); \
+} while (0)
+#define G_posix (ENABLE_BC && (option_mask32 & BC_FLAG_S))
+#define G_warn  (ENABLE_BC && (option_mask32 & BC_FLAG_W))
+#define G_exreg (ENABLE_DC && (option_mask32 & DC_FLAG_X))
+#if ENABLE_FEATURE_BC_INTERACTIVE
+# define G_interrupt bb_got_signal
+# define G_ttyin     G.ttyin
+#else
+# define G_interrupt 0
+# define G_ttyin     0
+#endif
+#if ENABLE_FEATURE_CLEAN_UP
+# define G_exiting G.exiting
+#else
+# define G_exiting 0
+#endif
+#define IS_BC (ENABLE_BC && (!ENABLE_DC || applet_name[0] == 'b'))
+#define IS_DC (ENABLE_DC && (!ENABLE_BC || applet_name[0] != 'b'))
+
+#if ENABLE_BC
+# define BC_PARSE_REL           (1 << 0)
+# define BC_PARSE_PRINT         (1 << 1)
+# define BC_PARSE_ARRAY         (1 << 2)
+# define BC_PARSE_NOCALL        (1 << 3)
+#endif
+
+#define BC_PROG_MAIN      0
+#define BC_PROG_READ      1
+#if ENABLE_DC
+#define BC_PROG_REQ_FUNCS 2
+#endif
+
+#define BC_FLAG_W (1 << 0)
+#define BC_FLAG_V (1 << 1)
+#define BC_FLAG_S (1 << 2)
+#define BC_FLAG_Q (1 << 3)
+#define BC_FLAG_L (1 << 4)
+#define BC_FLAG_I ((1 << 5) * ENABLE_DC)
+#define DC_FLAG_X ((1 << 6) * ENABLE_DC)
+
+#define BC_MAX_OBASE    ((unsigned) 999)
+#define BC_MAX_DIM      ((unsigned) INT_MAX)
+#define BC_MAX_SCALE    ((unsigned) UINT_MAX)
+#define BC_MAX_STRING   ((unsigned) UINT_MAX - 1)
+#define BC_MAX_NUM      BC_MAX_STRING
+// Unused apart from "limits" message. Just show a "biggish number" there.
+//#define BC_MAX_NAME     BC_MAX_STRING
+//#define BC_MAX_EXP      ((unsigned long) LONG_MAX)
+//#define BC_MAX_VARS     ((unsigned long) SIZE_MAX - 1)
+#define BC_MAX_NAME_STR "999999999"
+#define BC_MAX_EXP_STR  "999999999"
+#define BC_MAX_VARS_STR "999999999"
+
+#define BC_MAX_OBASE_STR "999"
+
+#if INT_MAX == 2147483647
+# define BC_MAX_DIM_STR "2147483647"
+#elif INT_MAX == 9223372036854775807
+# define BC_MAX_DIM_STR "9223372036854775807"
+#else
+# error Strange INT_MAX
+#endif
+
+#if UINT_MAX == 4294967295
+# define BC_MAX_SCALE_STR  "4294967295"
+# define BC_MAX_STRING_STR "4294967294"
+#elif UINT_MAX == 18446744073709551615
+# define BC_MAX_SCALE_STR  "18446744073709551615"
+# define BC_MAX_STRING_STR "18446744073709551614"
+#else
+# error Strange UINT_MAX
+#endif
+#define BC_MAX_NUM_STR BC_MAX_STRING_STR
+
+// In configurations where errors abort instead of propagating error
+// return code up the call chain, functions returning BC_STATUS
+// actually don't return anything, they always succeed and return "void".
+// A macro wrapper is provided, which makes this statement work:
+//  s = zbc_func(...)
+// and makes it visible to the compiler that s is always zero,
+// allowing compiler to optimize dead code after the statement.
+//
+// To make code more readable, each such function has a "z"
+// ("always returning zero") prefix, i.e. zbc_foo or zdc_foo.
+//
+#if ENABLE_FEATURE_BC_INTERACTIVE || ENABLE_FEATURE_CLEAN_UP
+# define ERRORS_ARE_FATAL 0
+# define ERRORFUNC        /*nothing*/
+# define IF_ERROR_RETURN_POSSIBLE(a)  a
+# define BC_STATUS        BcStatus
+# define RETURN_STATUS(v) return (v)
+# define COMMA_SUCCESS    /*nothing*/
+#else
+# define ERRORS_ARE_FATAL 1
+# define ERRORFUNC        NORETURN
+# define IF_ERROR_RETURN_POSSIBLE(a)  /*nothing*/
+# define BC_STATUS        void
+# define RETURN_STATUS(v) do { ((void)(v)); return; } while (0)
+# define COMMA_SUCCESS    ,BC_STATUS_SUCCESS
+#endif
+
+//
+// Utility routines
+//
+
+#define BC_MAX(a, b) ((a) > (b) ? (a) : (b))
+#define BC_MIN(a, b) ((a) < (b) ? (a) : (b))
+
+static void fflush_and_check(void)
+{
+	fflush_all();
+	if (ferror(stdout) || ferror(stderr))
+		bb_perror_msg_and_die("output error");
+}
+
+#if ENABLE_FEATURE_CLEAN_UP
+#define QUIT_OR_RETURN_TO_MAIN \
+do { \
+	IF_FEATURE_BC_INTERACTIVE(G_ttyin = 0;) /* do not loop in main loop anymore */ \
+	G_exiting = 1; \
+	return BC_STATUS_FAILURE; \
+} while (0)
+#else
+static void quit(void) NORETURN;
+static void quit(void)
+{
+	if (ferror(stdin))
+		bb_perror_msg_and_die("input error");
+	fflush_and_check();
+	dbg_exec("quit(): exiting with exitcode SUCCESS");
+	exit(0);
+}
+#define QUIT_OR_RETURN_TO_MAIN quit()
+#endif
+
+static void bc_verror_msg(const char *fmt, va_list p)
+{
+	const char *sv = sv; // for compiler
+	if (G.prs.lex_filename) {
+		sv = applet_name;
+		applet_name = xasprintf("%s: %s:%u", applet_name, G.prs.lex_filename, G.err_line);
+	}
+	bb_verror_msg(fmt, p, NULL);
+	if (G.prs.lex_filename) {
+		free((char*)applet_name);
+		applet_name = sv;
+	}
+}
+
+static NOINLINE ERRORFUNC int bc_error_fmt(const char *fmt, ...)
+{
+	va_list p;
+
+	va_start(p, fmt);
+	bc_verror_msg(fmt, p);
+	va_end(p);
+
+	if (ENABLE_FEATURE_CLEAN_UP || G_ttyin)
+		IF_ERROR_RETURN_POSSIBLE(return BC_STATUS_FAILURE);
+	exit(1);
+}
+
+#if ENABLE_BC
+static NOINLINE BC_STATUS zbc_posix_error_fmt(const char *fmt, ...)
+{
+	va_list p;
+
+	// Are non-POSIX constructs totally ok?
+	if (!(option_mask32 & (BC_FLAG_S|BC_FLAG_W)))
+		RETURN_STATUS(BC_STATUS_SUCCESS); // yes
+
+	va_start(p, fmt);
+	bc_verror_msg(fmt, p);
+	va_end(p);
+
+	// Do we treat non-POSIX constructs as errors?
+	if (!(option_mask32 & BC_FLAG_S))
+		RETURN_STATUS(BC_STATUS_SUCCESS); // no, it's a warning
+
+	if (ENABLE_FEATURE_CLEAN_UP || G_ttyin)
+		RETURN_STATUS(BC_STATUS_FAILURE);
+	exit(1);
+}
+#define zbc_posix_error_fmt(...) (zbc_posix_error_fmt(__VA_ARGS__) COMMA_SUCCESS)
+#endif
+
+// We use error functions with "return bc_error(FMT[, PARAMS])" idiom.
+// This idiom begs for tail-call optimization, but for it to work,
+// function must not have caller-cleaned parameters on stack.
+// Unfortunately, vararg function API does exactly that on most arches.
+// Thus, use these shims for the cases when we have no vararg PARAMS:
+static ERRORFUNC int bc_error(const char *msg)
+{
+	IF_ERROR_RETURN_POSSIBLE(return) bc_error_fmt("%s", msg);
+}
+static ERRORFUNC int bc_error_bad_character(char c)
+{
+	if (!c)
+		IF_ERROR_RETURN_POSSIBLE(return) bc_error("NUL character");
+	IF_ERROR_RETURN_POSSIBLE(return) bc_error_fmt("bad character '%c'", c);
+}
+static ERRORFUNC int bc_error_bad_expression(void)
+{
+	IF_ERROR_RETURN_POSSIBLE(return) bc_error("bad expression");
+}
+static ERRORFUNC int bc_error_bad_token(void)
+{
+	IF_ERROR_RETURN_POSSIBLE(return) bc_error("bad token");
+}
+static ERRORFUNC int bc_error_stack_has_too_few_elements(void)
+{
+	IF_ERROR_RETURN_POSSIBLE(return) bc_error("stack has too few elements");
+}
+static ERRORFUNC int bc_error_variable_is_wrong_type(void)
+{
+	IF_ERROR_RETURN_POSSIBLE(return) bc_error("variable is wrong type");
+}
+#if ENABLE_BC
+static BC_STATUS zbc_POSIX_requires(const char *msg)
+{
+	RETURN_STATUS(zbc_posix_error_fmt("POSIX requires %s", msg));
+}
+#define zbc_POSIX_requires(...) (zbc_POSIX_requires(__VA_ARGS__) COMMA_SUCCESS)
+static BC_STATUS zbc_POSIX_does_not_allow(const char *msg)
+{
+	RETURN_STATUS(zbc_posix_error_fmt("%s%s", "POSIX does not allow ", msg));
+}
+#define zbc_POSIX_does_not_allow(...) (zbc_POSIX_does_not_allow(__VA_ARGS__) COMMA_SUCCESS)
+static BC_STATUS zbc_POSIX_does_not_allow_bool_ops_this_is_bad(const char *msg)
+{
+	RETURN_STATUS(zbc_posix_error_fmt("%s%s %s", "POSIX does not allow ", "boolean operators; this is bad:", msg));
+}
+#define zbc_POSIX_does_not_allow_bool_ops_this_is_bad(...) (zbc_POSIX_does_not_allow_bool_ops_this_is_bad(__VA_ARGS__) COMMA_SUCCESS)
+static BC_STATUS zbc_POSIX_does_not_allow_empty_X_expression_in_for(const char *msg)
+{
+	RETURN_STATUS(zbc_posix_error_fmt("%san empty %s expression in 'for()'", "POSIX does not allow ", msg));
+}
+#define zbc_POSIX_does_not_allow_empty_X_expression_in_for(...) (zbc_POSIX_does_not_allow_empty_X_expression_in_for(__VA_ARGS__) COMMA_SUCCESS)
+#endif
+
+static void bc_vec_grow(BcVec *v, size_t n)
+{
+	size_t cap = v->cap * 2;
+	while (cap < v->len + n) cap *= 2;
+	v->v = xrealloc(v->v, v->size * cap);
+	v->cap = cap;
+}
+
+static void bc_vec_init(BcVec *v, size_t esize, BcVecFree dtor)
+{
+	v->size = esize;
+	v->cap = BC_VEC_START_CAP;
+	v->len = 0;
+	v->dtor = dtor;
+	v->v = xmalloc(esize * BC_VEC_START_CAP);
+}
+
+static void bc_char_vec_init(BcVec *v)
+{
+	bc_vec_init(v, sizeof(char), NULL);
+}
+
+static void bc_vec_expand(BcVec *v, size_t req)
+{
+	if (v->cap < req) {
+		v->v = xrealloc(v->v, v->size * req);
+		v->cap = req;
+	}
+}
+
+static void bc_vec_pop(BcVec *v)
+{
+	v->len--;
+	if (v->dtor)
+		v->dtor(v->v + (v->size * v->len));
+}
+
+static void bc_vec_npop(BcVec *v, size_t n)
+{
+	if (!v->dtor)
+		v->len -= n;
+	else {
+		size_t len = v->len - n;
+		while (v->len > len) v->dtor(v->v + (v->size * --v->len));
+	}
+}
+
+static void bc_vec_pop_all(BcVec *v)
+{
+	bc_vec_npop(v, v->len);
+}
+
+static size_t bc_vec_push(BcVec *v, const void *data)
+{
+	size_t len = v->len;
+	if (len >= v->cap) bc_vec_grow(v, 1);
+	memmove(v->v + (v->size * len), data, v->size);
+	v->len++;
+	return len;
+}
+
+// G.prog.results often needs "pop old operand, push result" idiom.
+// Can do this without a few extra ops
+static size_t bc_result_pop_and_push(const void *data)
+{
+	BcVec *v = &G.prog.results;
+	char *last;
+	size_t len = v->len - 1;
+
+	last = v->v + (v->size * len);
+	if (v->dtor)
+		v->dtor(last);
+	memmove(last, data, v->size);
+	return len;
+}
+
+static size_t bc_vec_pushByte(BcVec *v, char data)
+{
+	return bc_vec_push(v, &data);
+}
+
+static size_t bc_vec_pushZeroByte(BcVec *v)
+{
+	//return bc_vec_pushByte(v, '\0');
+	// better:
+	return bc_vec_push(v, &const_int_0);
+}
+
+static void bc_vec_pushAt(BcVec *v, const void *data, size_t idx)
+{
+	if (idx == v->len)
+		bc_vec_push(v, data);
+	else {
+		char *ptr;
+
+		if (v->len == v->cap) bc_vec_grow(v, 1);
+
+		ptr = v->v + v->size * idx;
+
+		memmove(ptr + v->size, ptr, v->size * (v->len++ - idx));
+		memmove(ptr, data, v->size);
+	}
+}
+
+static void bc_vec_string(BcVec *v, size_t len, const char *str)
+{
+	bc_vec_pop_all(v);
+	bc_vec_expand(v, len + 1);
+	memcpy(v->v, str, len);
+	v->len = len;
+
+	bc_vec_pushZeroByte(v);
+}
+
+static void *bc_vec_item(const BcVec *v, size_t idx)
+{
+	return v->v + v->size * idx;
+}
+
+static void *bc_vec_item_rev(const BcVec *v, size_t idx)
+{
+	return v->v + v->size * (v->len - idx - 1);
+}
+
+static void *bc_vec_top(const BcVec *v)
+{
+	return v->v + v->size * (v->len - 1);
+}
+
+static FAST_FUNC void bc_vec_free(void *vec)
+{
+	BcVec *v = (BcVec *) vec;
+	bc_vec_pop_all(v);
+	free(v->v);
+}
+
+static BcFunc* xc_program_func(size_t idx)
+{
+	return bc_vec_item(&G.prog.fns, idx);
+}
+// BC_PROG_MAIN is zeroth element, so:
+#define xc_program_func_BC_PROG_MAIN() ((BcFunc*)(G.prog.fns.v))
+
+#if ENABLE_BC
+static BcFunc* bc_program_current_func(void)
+{
+	BcInstPtr *ip = bc_vec_top(&G.prog.exestack);
+	BcFunc *func = xc_program_func(ip->func);
+	return func;
+}
+#endif
+
+static char** xc_program_str(size_t idx)
+{
+#if ENABLE_BC
+	if (IS_BC) {
+		BcFunc *func = bc_program_current_func();
+		return bc_vec_item(&func->strs, idx);
+	}
+#endif
+	IF_DC(return bc_vec_item(&G.prog.strs, idx);)
+}
+
+static char** xc_program_const(size_t idx)
+{
+#if ENABLE_BC
+	if (IS_BC) {
+		BcFunc *func = bc_program_current_func();
+		return bc_vec_item(&func->consts, idx);
+	}
+#endif
+	IF_DC(return bc_vec_item(&G.prog.consts, idx);)
+}
+
+static int bc_id_cmp(const void *e1, const void *e2)
+{
+	return strcmp(((const BcId *) e1)->name, ((const BcId *) e2)->name);
+}
+
+static FAST_FUNC void bc_id_free(void *id)
+{
+	free(((BcId *) id)->name);
+}
+
+static size_t bc_map_find_ge(const BcVec *v, const void *ptr)
+{
+	size_t low = 0, high = v->len;
+
+	while (low < high) {
+		size_t mid = (low + high) / 2;
+		BcId *id = bc_vec_item(v, mid);
+		int result = bc_id_cmp(ptr, id);
+
+		if (result == 0)
+			return mid;
+		if (result < 0)
+			high = mid;
+		else
+			low = mid + 1;
+	}
+
+	return low;
+}
+
+static int bc_map_insert(BcVec *v, const void *ptr, size_t *i)
+{
+	size_t n = *i = bc_map_find_ge(v, ptr);
+
+	if (n == v->len)
+		bc_vec_push(v, ptr);
+	else if (!bc_id_cmp(ptr, bc_vec_item(v, n)))
+		return 0; // "was not inserted"
+	else
+		bc_vec_pushAt(v, ptr, n);
+	return 1; // "was inserted"
+}
+
+#if ENABLE_BC
+static size_t bc_map_find_exact(const BcVec *v, const void *ptr)
+{
+	size_t i = bc_map_find_ge(v, ptr);
+	if (i >= v->len) return BC_VEC_INVALID_IDX;
+	return bc_id_cmp(ptr, bc_vec_item(v, i)) ? BC_VEC_INVALID_IDX : i;
+}
+#endif
+
+static void bc_num_setToZero(BcNum *n, size_t scale)
+{
+	n->len = 0;
+	n->neg = false;
+	n->rdx = scale;
+}
+
+static void bc_num_zero(BcNum *n)
+{
+	bc_num_setToZero(n, 0);
+}
+
+static void bc_num_one(BcNum *n)
+{
+	bc_num_setToZero(n, 0);
+	n->len = 1;
+	n->num[0] = 1;
+}
+
+// Note: this also sets BcNum to zero
+static void bc_num_init(BcNum *n, size_t req)
+{
+	req = req >= BC_NUM_DEF_SIZE ? req : BC_NUM_DEF_SIZE;
+	//memset(n, 0, sizeof(BcNum)); - cleared by assignments below
+	n->num = xmalloc(req);
+	n->cap = req;
+	n->rdx = 0;
+	n->len = 0;
+	n->neg = false;
+}
+
+static void bc_num_init_DEF_SIZE(BcNum *n)
+{
+	bc_num_init(n, BC_NUM_DEF_SIZE);
+}
+
+static void bc_num_expand(BcNum *n, size_t req)
+{
+	req = req >= BC_NUM_DEF_SIZE ? req : BC_NUM_DEF_SIZE;
+	if (req > n->cap) {
+		n->num = xrealloc(n->num, req);
+		n->cap = req;
+	}
+}
+
+static FAST_FUNC void bc_num_free(void *num)
+{
+	free(((BcNum *) num)->num);
+}
+
+static void bc_num_copy(BcNum *d, BcNum *s)
+{
+	if (d != s) {
+		bc_num_expand(d, s->cap);
+		d->len = s->len;
+		d->neg = s->neg;
+		d->rdx = s->rdx;
+		memcpy(d->num, s->num, sizeof(BcDig) * d->len);
+	}
+}
+
+static BC_STATUS zbc_num_ulong_abs(BcNum *n, unsigned long *result_p)
+{
+	size_t i;
+	unsigned long result;
+
+	result = 0;
+	i = n->len;
+	while (i > n->rdx) {
+		unsigned long prev = result;
+		result = result * 10 + n->num[--i];
+		// Even overflowed N*10 can still satisfy N*10>=N. For example,
+		//    0x1ff00000 * 10 is 0x13f600000,
+		// or 0x3f600000 truncated to 32 bits. Which is larger.
+		// However, (N*10)/8 < N check is always correct.
+		if ((result / 8) < prev)
+			RETURN_STATUS(bc_error("overflow"));
+	}
+	*result_p = result;
+
+	RETURN_STATUS(BC_STATUS_SUCCESS);
+}
+#define zbc_num_ulong_abs(...) (zbc_num_ulong_abs(__VA_ARGS__) COMMA_SUCCESS)
+
+static BC_STATUS zbc_num_ulong(BcNum *n, unsigned long *result_p)
+{
+	if (n->neg) RETURN_STATUS(bc_error("negative number"));
+
+	RETURN_STATUS(zbc_num_ulong_abs(n, result_p));
+}
+#define zbc_num_ulong(...) (zbc_num_ulong(__VA_ARGS__) COMMA_SUCCESS)
+
+#if ULONG_MAX == 0xffffffffUL // 10 digits: 4294967295
+# define ULONG_NUM_BUFSIZE (10 > BC_NUM_DEF_SIZE ? 10 : BC_NUM_DEF_SIZE)
+#elif ULONG_MAX == 0xffffffffffffffffULL // 20 digits: 18446744073709551615
+# define ULONG_NUM_BUFSIZE (20 > BC_NUM_DEF_SIZE ? 20 : BC_NUM_DEF_SIZE)
+#endif
+// minimum BC_NUM_DEF_SIZE, so that bc_num_expand() in bc_num_ulong2num()
+// would not hit realloc() code path - not good if num[] is not malloced
+
+static void bc_num_ulong2num(BcNum *n, unsigned long val)
+{
+	BcDig *ptr;
+
+	bc_num_zero(n);
+
+	if (val == 0) return;
+
+	bc_num_expand(n, ULONG_NUM_BUFSIZE);
+
+	ptr = n->num;
+	for (;;) {
+		n->len++;
+		*ptr++ = val % 10;
+		val /= 10;
+		if (val == 0) break;
+	}
+}
+
+static void bc_num_subArrays(BcDig *restrict a, BcDig *restrict b, size_t len)
+{
+	size_t i, j;
+	for (i = 0; i < len; ++i) {
+		a[i] -= b[i];
+		for (j = i; a[j] < 0;) {
+			a[j++] += 10;
+			a[j] -= 1;
+		}
+	}
+}
+
+static ssize_t bc_num_compare(BcDig *restrict a, BcDig *restrict b, size_t len)
+{
+	size_t i = len;
+	for (;;) {
+		int c;
+		if (i == 0)
+			return 0;
+		i--;
+		c = a[i] - b[i];
+		if (c != 0) {
+			i++;
+			if (c < 0)
+				return -i;
+			return i;
+		}
+	}
+}
+
+#define BC_NUM_NEG(n, neg)      ((((ssize_t)(n)) ^ -((ssize_t)(neg))) + (neg))
+#define BC_NUM_ONE(n)           ((n)->len == 1 && (n)->rdx == 0 && (n)->num[0] == 1)
+#define BC_NUM_INT(n)           ((n)->len - (n)->rdx)
+//#define BC_NUM_AREQ(a, b)       (BC_MAX((a)->rdx, (b)->rdx) + BC_MAX(BC_NUM_INT(a), BC_NUM_INT(b)) + 1)
+static /*ALWAYS_INLINE*/ size_t BC_NUM_AREQ(BcNum *a, BcNum *b)
+{
+	return BC_MAX(a->rdx, b->rdx) + BC_MAX(BC_NUM_INT(a), BC_NUM_INT(b)) + 1;
+}
+//#define BC_NUM_MREQ(a, b, scale) (BC_NUM_INT(a) + BC_NUM_INT(b) + BC_MAX((scale), (a)->rdx + (b)->rdx) + 1)
+static /*ALWAYS_INLINE*/ size_t BC_NUM_MREQ(BcNum *a, BcNum *b, size_t scale)
+{
+	return BC_NUM_INT(a) + BC_NUM_INT(b) + BC_MAX(scale, a->rdx + b->rdx) + 1;
+}
+
+static ssize_t bc_num_cmp(BcNum *a, BcNum *b)
+{
+	size_t i, min, a_int, b_int, diff;
+	BcDig *max_num, *min_num;
+	bool a_max, neg;
+	ssize_t cmp;
+
+	if (a == b) return 0;
+	if (a->len == 0) return BC_NUM_NEG(!!b->len, !b->neg);
+	if (b->len == 0) return BC_NUM_NEG(1, a->neg);
+
+	if (a->neg != b->neg) // signs of a and b differ
+		// +a,-b = a>b = 1 or -a,+b = a<b = -1
+		return (int)b->neg - (int)a->neg;
+	neg = a->neg; // 1 if both negative, 0 if both positive
+
+	a_int = BC_NUM_INT(a);
+	b_int = BC_NUM_INT(b);
+	a_int -= b_int;
+
+	if (a_int != 0) return (ssize_t) a_int;
+
+	a_max = (a->rdx > b->rdx);
+	if (a_max) {
+		min = b->rdx;
+		diff = a->rdx - b->rdx;
+		max_num = a->num + diff;
+		min_num = b->num;
+		// neg = (a_max == neg); - NOP (maps 1->1 and 0->0)
+	} else {
+		min = a->rdx;
+		diff = b->rdx - a->rdx;
+		max_num = b->num + diff;
+		min_num = a->num;
+		neg = !neg; // same as "neg = (a_max == neg)"
+	}
+
+	cmp = bc_num_compare(max_num, min_num, b_int + min);
+	if (cmp != 0) return BC_NUM_NEG(cmp, neg);
+
+	for (max_num -= diff, i = diff - 1; i < diff; --i) {
+		if (max_num[i]) return BC_NUM_NEG(1, neg);
+	}
+
+	return 0;
+}
+
+static void bc_num_truncate(BcNum *n, size_t places)
+{
+	if (places == 0) return;
+
+	n->rdx -= places;
+
+	if (n->len != 0) {
+		n->len -= places;
+		memmove(n->num, n->num + places, n->len * sizeof(BcDig));
+	}
+}
+
+static void bc_num_extend(BcNum *n, size_t places)
+{
+	size_t len = n->len + places;
+
+	if (places != 0) {
+		if (n->cap < len) bc_num_expand(n, len);
+
+		memmove(n->num + places, n->num, sizeof(BcDig) * n->len);
+		memset(n->num, 0, sizeof(BcDig) * places);
+
+		n->len += places;
+		n->rdx += places;
+	}
+}
+
+static void bc_num_clean(BcNum *n)
+{
+	while (n->len > 0 && n->num[n->len - 1] == 0) --n->len;
+	if (n->len == 0)
+		n->neg = false;
+	else if (n->len < n->rdx)
+		n->len = n->rdx;
+}
+
+static void bc_num_retireMul(BcNum *n, size_t scale, bool neg1, bool neg2)
+{
+	if (n->rdx < scale)
+		bc_num_extend(n, scale - n->rdx);
+	else
+		bc_num_truncate(n, n->rdx - scale);
+
+	bc_num_clean(n);
+	if (n->len != 0) n->neg = !neg1 != !neg2;
+}
+
+static void bc_num_split(BcNum *restrict n, size_t idx, BcNum *restrict a,
+                         BcNum *restrict b)
+{
+	if (idx < n->len) {
+		b->len = n->len - idx;
+		a->len = idx;
+		a->rdx = b->rdx = 0;
+
+		memcpy(b->num, n->num + idx, b->len * sizeof(BcDig));
+		memcpy(a->num, n->num, idx * sizeof(BcDig));
+	} else {
+		bc_num_zero(b);
+		bc_num_copy(a, n);
+	}
+
+	bc_num_clean(a);
+	bc_num_clean(b);
+}
+
+static BC_STATUS zbc_num_shift(BcNum *n, size_t places)
+{
+	if (places == 0 || n->len == 0) RETURN_STATUS(BC_STATUS_SUCCESS);
+
+	// This check makes sense only if size_t is (much) larger than BC_MAX_NUM.
+	if (SIZE_MAX > (BC_MAX_NUM | 0xff)) {
+		if (places + n->len > BC_MAX_NUM)
+			RETURN_STATUS(bc_error("number too long: must be [1,"BC_MAX_NUM_STR"]"));
+	}
+
+	if (n->rdx >= places)
+		n->rdx -= places;
+	else {
+		bc_num_extend(n, places - n->rdx);
+		n->rdx = 0;
+	}
+
+	bc_num_clean(n);
+
+	RETURN_STATUS(BC_STATUS_SUCCESS);
+}
+#define zbc_num_shift(...) (zbc_num_shift(__VA_ARGS__) COMMA_SUCCESS)
+
+typedef BC_STATUS (*BcNumBinaryOp)(BcNum *, BcNum *, BcNum *, size_t) FAST_FUNC;
+
+static BC_STATUS zbc_num_binary(BcNum *a, BcNum *b, BcNum *c, size_t scale,
+                              BcNumBinaryOp op, size_t req)
+{
+	BcStatus s;
+	BcNum num2, *ptr_a, *ptr_b;
+	bool init = false;
+
+	if (c == a) {
+		ptr_a = &num2;
+		memcpy(ptr_a, c, sizeof(BcNum));
+		init = true;
+	} else
+		ptr_a = a;
+
+	if (c == b) {
+		ptr_b = &num2;
+		if (c != a) {
+			memcpy(ptr_b, c, sizeof(BcNum));
+			init = true;
+		}
+	} else
+		ptr_b = b;
+
+	if (init)
+		bc_num_init(c, req);
+	else
+		bc_num_expand(c, req);
+
+	s = BC_STATUS_SUCCESS;
+	IF_ERROR_RETURN_POSSIBLE(s =) op(ptr_a, ptr_b, c, scale);
+
+	if (init) bc_num_free(&num2);
+
+	RETURN_STATUS(s);
+}
+#define zbc_num_binary(...) (zbc_num_binary(__VA_ARGS__) COMMA_SUCCESS)
+
+static FAST_FUNC BC_STATUS zbc_num_a(BcNum *a, BcNum *b, BcNum *restrict c, size_t scale);
+static FAST_FUNC BC_STATUS zbc_num_s(BcNum *a, BcNum *b, BcNum *restrict c, size_t scale);
+static FAST_FUNC BC_STATUS zbc_num_p(BcNum *a, BcNum *b, BcNum *restrict c, size_t scale);
+static FAST_FUNC BC_STATUS zbc_num_m(BcNum *a, BcNum *b, BcNum *restrict c, size_t scale);
+static FAST_FUNC BC_STATUS zbc_num_d(BcNum *a, BcNum *b, BcNum *restrict c, size_t scale);
+static FAST_FUNC BC_STATUS zbc_num_rem(BcNum *a, BcNum *b, BcNum *restrict c, size_t scale);
+
+static FAST_FUNC BC_STATUS zbc_num_add(BcNum *a, BcNum *b, BcNum *c, size_t scale)
+{
+	BcNumBinaryOp op = (!a->neg == !b->neg) ? zbc_num_a : zbc_num_s;
+	(void) scale;
+	RETURN_STATUS(zbc_num_binary(a, b, c, false, op, BC_NUM_AREQ(a, b)));
+}
+
+static FAST_FUNC BC_STATUS zbc_num_sub(BcNum *a, BcNum *b, BcNum *c, size_t scale)
+{
+	BcNumBinaryOp op = (!a->neg == !b->neg) ? zbc_num_s : zbc_num_a;
+	(void) scale;
+	RETURN_STATUS(zbc_num_binary(a, b, c, true, op, BC_NUM_AREQ(a, b)));
+}
+
+static FAST_FUNC BC_STATUS zbc_num_mul(BcNum *a, BcNum *b, BcNum *c, size_t scale)
+{
+	size_t req = BC_NUM_MREQ(a, b, scale);
+	RETURN_STATUS(zbc_num_binary(a, b, c, scale, zbc_num_m, req));
+}
+
+static FAST_FUNC BC_STATUS zbc_num_div(BcNum *a, BcNum *b, BcNum *c, size_t scale)
+{
+	size_t req = BC_NUM_MREQ(a, b, scale);
+	RETURN_STATUS(zbc_num_binary(a, b, c, scale, zbc_num_d, req));
+}
+
+static FAST_FUNC BC_STATUS zbc_num_mod(BcNum *a, BcNum *b, BcNum *c, size_t scale)
+{
+	size_t req = BC_NUM_MREQ(a, b, scale);
+	RETURN_STATUS(zbc_num_binary(a, b, c, scale, zbc_num_rem, req));
+}
+
+static FAST_FUNC BC_STATUS zbc_num_pow(BcNum *a, BcNum *b, BcNum *c, size_t scale)
+{
+	RETURN_STATUS(zbc_num_binary(a, b, c, scale, zbc_num_p, a->len * b->len + 1));
+}
+
+static const BcNumBinaryOp zxc_program_ops[] = {
+	zbc_num_pow, zbc_num_mul, zbc_num_div, zbc_num_mod, zbc_num_add, zbc_num_sub,
+};
+#define zbc_num_add(...) (zbc_num_add(__VA_ARGS__) COMMA_SUCCESS)
+#define zbc_num_sub(...) (zbc_num_sub(__VA_ARGS__) COMMA_SUCCESS)
+#define zbc_num_mul(...) (zbc_num_mul(__VA_ARGS__) COMMA_SUCCESS)
+#define zbc_num_div(...) (zbc_num_div(__VA_ARGS__) COMMA_SUCCESS)
+#define zbc_num_mod(...) (zbc_num_mod(__VA_ARGS__) COMMA_SUCCESS)
+#define zbc_num_pow(...) (zbc_num_pow(__VA_ARGS__) COMMA_SUCCESS)
+
+static BC_STATUS zbc_num_inv(BcNum *a, BcNum *b, size_t scale)
+{
+	BcNum one;
+	BcDig num[2];
+
+	one.cap = 2;
+	one.num = num;
+	bc_num_one(&one);
+
+	RETURN_STATUS(zbc_num_div(&one, a, b, scale));
+}
+#define zbc_num_inv(...) (zbc_num_inv(__VA_ARGS__) COMMA_SUCCESS)
+
+static FAST_FUNC BC_STATUS zbc_num_a(BcNum *a, BcNum *b, BcNum *restrict c, size_t sub)
+{
+	BcDig *ptr, *ptr_a, *ptr_b, *ptr_c;
+	size_t i, max, min_rdx, min_int, diff, a_int, b_int;
+	unsigned carry;
+
+	// Because this function doesn't need to use scale (per the bc spec),
+	// I am hijacking it to say whether it's doing an add or a subtract.
+
+	if (a->len == 0) {
+		bc_num_copy(c, b);
+		if (sub && c->len) c->neg = !c->neg;
+		RETURN_STATUS(BC_STATUS_SUCCESS);
+	}
+	if (b->len == 0) {
+		bc_num_copy(c, a);
+		RETURN_STATUS(BC_STATUS_SUCCESS);
+	}
+
+	c->neg = a->neg;
+	c->rdx = BC_MAX(a->rdx, b->rdx);
+	min_rdx = BC_MIN(a->rdx, b->rdx);
+	c->len = 0;
+
+	if (a->rdx > b->rdx) {
+		diff = a->rdx - b->rdx;
+		ptr = a->num;
+		ptr_a = a->num + diff;
+		ptr_b = b->num;
+	} else {
+		diff = b->rdx - a->rdx;
+		ptr = b->num;
+		ptr_a = a->num;
+		ptr_b = b->num + diff;
+	}
+
+	ptr_c = c->num;
+	for (i = 0; i < diff; ++i, ++c->len)
+		ptr_c[i] = ptr[i];
+
+	ptr_c += diff;
+	a_int = BC_NUM_INT(a);
+	b_int = BC_NUM_INT(b);
+
+	if (a_int > b_int) {
+		min_int = b_int;
+		max = a_int;
+		ptr = ptr_a;
+	} else {
+		min_int = a_int;
+		max = b_int;
+		ptr = ptr_b;
+	}
+
+	carry = 0;
+	for (i = 0; i < min_rdx + min_int; ++i) {
+		unsigned in = (unsigned)ptr_a[i] + (unsigned)ptr_b[i] + carry;
+		carry = in / 10;
+		ptr_c[i] = (BcDig)(in % 10);
+	}
+	for (; i < max + min_rdx; ++i) {
+		unsigned in = (unsigned)ptr[i] + carry;
+		carry = in / 10;
+		ptr_c[i] = (BcDig)(in % 10);
+	}
+	c->len += i;
+
+	if (carry != 0) c->num[c->len++] = (BcDig) carry;
+
+	RETURN_STATUS(BC_STATUS_SUCCESS); // can't make void, see zbc_num_binary()
+}
+
+static FAST_FUNC BC_STATUS zbc_num_s(BcNum *a, BcNum *b, BcNum *restrict c, size_t sub)
+{
+	ssize_t cmp;
+	BcNum *minuend, *subtrahend;
+	size_t start;
+	bool aneg, bneg, neg;
+
+	// Because this function doesn't need to use scale (per the bc spec),
+	// I am hijacking it to say whether it's doing an add or a subtract.
+
+	if (a->len == 0) {
+		bc_num_copy(c, b);
+		if (sub && c->len) c->neg = !c->neg;
+		RETURN_STATUS(BC_STATUS_SUCCESS);
+	}
+	if (b->len == 0) {
+		bc_num_copy(c, a);
+		RETURN_STATUS(BC_STATUS_SUCCESS);
+	}
+
+	aneg = a->neg;
+	bneg = b->neg;
+	a->neg = b->neg = false;
+
+	cmp = bc_num_cmp(a, b);
+
+	a->neg = aneg;
+	b->neg = bneg;
+
+	if (cmp == 0) {
+		bc_num_setToZero(c, BC_MAX(a->rdx, b->rdx));
+		RETURN_STATUS(BC_STATUS_SUCCESS);
+	}
+	if (cmp > 0) {
+		neg = a->neg;
+		minuend = a;
+		subtrahend = b;
+	} else {
+		neg = b->neg;
+		if (sub) neg = !neg;
+		minuend = b;
+		subtrahend = a;
+	}
+
+	bc_num_copy(c, minuend);
+	c->neg = neg;
+
+	if (c->rdx < subtrahend->rdx) {
+		bc_num_extend(c, subtrahend->rdx - c->rdx);
+		start = 0;
+	} else
+		start = c->rdx - subtrahend->rdx;
+
+	bc_num_subArrays(c->num + start, subtrahend->num, subtrahend->len);
+
+	bc_num_clean(c);
+
+	RETURN_STATUS(BC_STATUS_SUCCESS); // can't make void, see zbc_num_binary()
+}
+
+static FAST_FUNC BC_STATUS zbc_num_k(BcNum *restrict a, BcNum *restrict b,
+                         BcNum *restrict c)
+#define zbc_num_k(...) (zbc_num_k(__VA_ARGS__) COMMA_SUCCESS)
+{
+	BcStatus s;
+	size_t max = BC_MAX(a->len, b->len), max2 = (max + 1) / 2;
+	BcNum l1, h1, l2, h2, m2, m1, z0, z1, z2, temp;
+	bool aone;
+
+	if (a->len == 0 || b->len == 0) {
+		bc_num_zero(c);
+		RETURN_STATUS(BC_STATUS_SUCCESS);
+	}
+	aone = BC_NUM_ONE(a);
+	if (aone || BC_NUM_ONE(b)) {
+		bc_num_copy(c, aone ? b : a);
+		RETURN_STATUS(BC_STATUS_SUCCESS);
+	}
+
+	if (a->len + b->len < BC_NUM_KARATSUBA_LEN
+	 || a->len < BC_NUM_KARATSUBA_LEN
+	 || b->len < BC_NUM_KARATSUBA_LEN
+	) {
+		size_t i, j, len;
+
+		bc_num_expand(c, a->len + b->len + 1);
+
+		memset(c->num, 0, sizeof(BcDig) * c->cap);
+		c->len = len = 0;
+
+		for (i = 0; i < b->len; ++i) {
+			unsigned carry = 0;
+			for (j = 0; j < a->len; ++j) {
+				unsigned in = c->num[i + j];
+				in += (unsigned)a->num[j] * (unsigned)b->num[i] + carry;
+				// note: compilers prefer _unsigned_ div/const
+				carry = in / 10;
+				c->num[i + j] = (BcDig)(in % 10);
+			}
+
+			c->num[i + j] += (BcDig) carry;
+			len = BC_MAX(len, i + j + !!carry);
+
+#if ENABLE_FEATURE_BC_INTERACTIVE
+			// a=2^1000000
+			// a*a <- without check below, this will not be interruptible
+			if (G_interrupt) return BC_STATUS_FAILURE;
+#endif
+		}
+
+		c->len = len;
+
+		RETURN_STATUS(BC_STATUS_SUCCESS);
+	}
+
+	bc_num_init(&l1, max);
+	bc_num_init(&h1, max);
+	bc_num_init(&l2, max);
+	bc_num_init(&h2, max);
+	bc_num_init(&m1, max);
+	bc_num_init(&m2, max);
+	bc_num_init(&z0, max);
+	bc_num_init(&z1, max);
+	bc_num_init(&z2, max);
+	bc_num_init(&temp, max + max);
+
+	bc_num_split(a, max2, &l1, &h1);
+	bc_num_split(b, max2, &l2, &h2);
+
+	s = zbc_num_add(&h1, &l1, &m1, 0);
+	if (s) goto err;
+	s = zbc_num_add(&h2, &l2, &m2, 0);
+	if (s) goto err;
+
+	s = zbc_num_k(&h1, &h2, &z0);
+	if (s) goto err;
+	s = zbc_num_k(&m1, &m2, &z1);
+	if (s) goto err;
+	s = zbc_num_k(&l1, &l2, &z2);
+	if (s) goto err;
+
+	s = zbc_num_sub(&z1, &z0, &temp, 0);
+	if (s) goto err;
+	s = zbc_num_sub(&temp, &z2, &z1, 0);
+	if (s) goto err;
+
+	s = zbc_num_shift(&z0, max2 * 2);
+	if (s) goto err;
+	s = zbc_num_shift(&z1, max2);
+	if (s) goto err;
+	s = zbc_num_add(&z0, &z1, &temp, 0);
+	if (s) goto err;
+	s = zbc_num_add(&temp, &z2, c, 0);
+ err:
+	bc_num_free(&temp);
+	bc_num_free(&z2);
+	bc_num_free(&z1);
+	bc_num_free(&z0);
+	bc_num_free(&m2);
+	bc_num_free(&m1);
+	bc_num_free(&h2);
+	bc_num_free(&l2);
+	bc_num_free(&h1);
+	bc_num_free(&l1);
+	RETURN_STATUS(s);
+}
+
+static FAST_FUNC BC_STATUS zbc_num_m(BcNum *a, BcNum *b, BcNum *restrict c, size_t scale)
+{
+	BcStatus s;
+	BcNum cpa, cpb;
+	size_t maxrdx = BC_MAX(a->rdx, b->rdx);
+
+	scale = BC_MAX(scale, a->rdx);
+	scale = BC_MAX(scale, b->rdx);
+	scale = BC_MIN(a->rdx + b->rdx, scale);
+	maxrdx = BC_MAX(maxrdx, scale);
+
+	bc_num_init(&cpa, a->len);
+	bc_num_init(&cpb, b->len);
+
+	bc_num_copy(&cpa, a);
+	bc_num_copy(&cpb, b);
+	cpa.neg = cpb.neg = false;
+
+	s = zbc_num_shift(&cpa, maxrdx);
+	if (s) goto err;
+	s = zbc_num_shift(&cpb, maxrdx);
+	if (s) goto err;
+	s = zbc_num_k(&cpa, &cpb, c);
+	if (s) goto err;
+
+	maxrdx += scale;
+	bc_num_expand(c, c->len + maxrdx);
+
+	if (c->len < maxrdx) {
+		memset(c->num + c->len, 0, (c->cap - c->len) * sizeof(BcDig));
+		c->len += maxrdx;
+	}
+
+	c->rdx = maxrdx;
+	bc_num_retireMul(c, scale, a->neg, b->neg);
+ err:
+	bc_num_free(&cpb);
+	bc_num_free(&cpa);
+	RETURN_STATUS(s);
+}
+#define zbc_num_m(...) (zbc_num_m(__VA_ARGS__) COMMA_SUCCESS)
+
+static FAST_FUNC BC_STATUS zbc_num_d(BcNum *a, BcNum *b, BcNum *restrict c, size_t scale)
+{
+	BcStatus s;
+	size_t len, end, i;
+	BcNum cp;
+
+	if (b->len == 0)
+		RETURN_STATUS(bc_error("divide by zero"));
+	if (a->len == 0) {
+		bc_num_setToZero(c, scale);
+		RETURN_STATUS(BC_STATUS_SUCCESS);
+	}
+	if (BC_NUM_ONE(b)) {
+		bc_num_copy(c, a);
+		bc_num_retireMul(c, scale, a->neg, b->neg);
+		RETURN_STATUS(BC_STATUS_SUCCESS);
+	}
+
+	bc_num_init(&cp, BC_NUM_MREQ(a, b, scale));
+	bc_num_copy(&cp, a);
+	len = b->len;
+
+	if (len > cp.len) {
+		bc_num_expand(&cp, len + 2);
+		bc_num_extend(&cp, len - cp.len);
+	}
+
+	if (b->rdx > cp.rdx) bc_num_extend(&cp, b->rdx - cp.rdx);
+	cp.rdx -= b->rdx;
+	if (scale > cp.rdx) bc_num_extend(&cp, scale - cp.rdx);
+
+	if (b->rdx == b->len) {
+		for (;;) {
+			if (len == 0) break;
+			len--;
+			if (b->num[len] != 0)
+				break;
+		}
+		len++;
+	}
+
+	if (cp.cap == cp.len) bc_num_expand(&cp, cp.len + 1);
+
+	// We want an extra zero in front to make things simpler.
+	cp.num[cp.len++] = 0;
+	end = cp.len - len;
+
+	bc_num_expand(c, cp.len);
+
+	bc_num_zero(c);
+	memset(c->num + end, 0, (c->cap - end) * sizeof(BcDig));
+	c->rdx = cp.rdx;
+	c->len = cp.len;
+
+	s = BC_STATUS_SUCCESS;
+	for (i = end - 1; i < end; --i) {
+		BcDig *n, q;
+		n = cp.num + i;
+		for (q = 0; n[len] != 0 || bc_num_compare(n, b->num, len) >= 0; ++q)
+			bc_num_subArrays(n, b->num, len);
+		c->num[i] = q;
+#if ENABLE_FEATURE_BC_INTERACTIVE
+		// a=2^100000
+		// scale=40000
+		// 1/a <- without check below, this will not be interruptible
+		if (G_interrupt) {
+			s = BC_STATUS_FAILURE;
+			break;
+		}
+#endif
+	}
+
+	bc_num_retireMul(c, scale, a->neg, b->neg);
+	bc_num_free(&cp);
+
+	RETURN_STATUS(s);
+}
+#define zbc_num_d(...) (zbc_num_d(__VA_ARGS__) COMMA_SUCCESS)
+
+static FAST_FUNC BC_STATUS zbc_num_r(BcNum *a, BcNum *b, BcNum *restrict c,
+                         BcNum *restrict d, size_t scale, size_t ts)
+{
+	BcStatus s;
+	BcNum temp;
+	bool neg;
+
+	if (b->len == 0)
+		RETURN_STATUS(bc_error("divide by zero"));
+
+	if (a->len == 0) {
+		bc_num_setToZero(d, ts);
+		RETURN_STATUS(BC_STATUS_SUCCESS);
+	}
+
+	bc_num_init(&temp, d->cap);
+	s = zbc_num_d(a, b, c, scale);
+	if (s) goto err;
+
+	if (scale != 0) scale = ts;
+
+	s = zbc_num_m(c, b, &temp, scale);
+	if (s) goto err;
+	s = zbc_num_sub(a, &temp, d, scale);
+	if (s) goto err;
+
+	if (ts > d->rdx && d->len) bc_num_extend(d, ts - d->rdx);
+
+	neg = d->neg;
+	bc_num_retireMul(d, ts, a->neg, b->neg);
+	d->neg = neg;
+ err:
+	bc_num_free(&temp);
+	RETURN_STATUS(s);
+}
+#define zbc_num_r(...) (zbc_num_r(__VA_ARGS__) COMMA_SUCCESS)
+
+static FAST_FUNC BC_STATUS zbc_num_rem(BcNum *a, BcNum *b, BcNum *restrict c, size_t scale)
+{
+	BcStatus s;
+	BcNum c1;
+	size_t ts = BC_MAX(scale + b->rdx, a->rdx), len = BC_NUM_MREQ(a, b, ts);
+
+	bc_num_init(&c1, len);
+	s = zbc_num_r(a, b, &c1, c, scale, ts);
+	bc_num_free(&c1);
+
+	RETURN_STATUS(s);
+}
+#define zbc_num_rem(...) (zbc_num_rem(__VA_ARGS__) COMMA_SUCCESS)
+
+static FAST_FUNC BC_STATUS zbc_num_p(BcNum *a, BcNum *b, BcNum *restrict c, size_t scale)
+{
+	BcStatus s = BC_STATUS_SUCCESS;
+	BcNum copy;
+	unsigned long pow;
+	size_t i, powrdx, resrdx;
+	bool neg;
+
+	// GNU bc does not allow 2^2.0 - we do
+	for (i = 0; i < b->rdx; i++)
+		if (b->num[i] != 0)
+			RETURN_STATUS(bc_error("not an integer"));
+
+	if (b->len == 0) {
+		bc_num_one(c);
+		RETURN_STATUS(BC_STATUS_SUCCESS);
+	}
+	if (a->len == 0) {
+		bc_num_setToZero(c, scale);
+		RETURN_STATUS(BC_STATUS_SUCCESS);
+	}
+	if (BC_NUM_ONE(b)) {
+		if (!b->neg)
+			bc_num_copy(c, a);
+		else
+			s = zbc_num_inv(a, c, scale);
+		RETURN_STATUS(s);
+	}
+
+	neg = b->neg;
+	s = zbc_num_ulong_abs(b, &pow);
+	if (s) RETURN_STATUS(s);
+	// b is not used beyond this point
+
+	bc_num_init(&copy, a->len);
+	bc_num_copy(&copy, a);
+
+	if (!neg) {
+		if (a->rdx > scale)
+			scale = a->rdx;
+		if (a->rdx * pow < scale)
+			scale = a->rdx * pow;
+	}
+
+
+	for (powrdx = a->rdx; !(pow & 1); pow >>= 1) {
+		powrdx <<= 1;
+		s = zbc_num_mul(&copy, &copy, &copy, powrdx);
+		if (s) goto err;
+		// Not needed: zbc_num_mul() has a check for ^C:
+		//if (G_interrupt) {
+		//	s = BC_STATUS_FAILURE;
+		//	goto err;
+		//}
+	}
+
+	bc_num_copy(c, &copy);
+
+	for (resrdx = powrdx, pow >>= 1; pow != 0; pow >>= 1) {
+		powrdx <<= 1;
+		s = zbc_num_mul(&copy, &copy, &copy, powrdx);
+		if (s) goto err;
+
+		if (pow & 1) {
+			resrdx += powrdx;
+			s = zbc_num_mul(c, &copy, c, resrdx);
+			if (s) goto err;
+		}
+		// Not needed: zbc_num_mul() has a check for ^C:
+		//if (G_interrupt) {
+		//	s = BC_STATUS_FAILURE;
+		//	goto err;
+		//}
+	}
+
+	if (neg) {
+		s = zbc_num_inv(c, c, scale);
+		if (s) goto err;
+	}
+
+	if (c->rdx > scale) bc_num_truncate(c, c->rdx - scale);
+
+	// We can't use bc_num_clean() here.
+	for (i = 0; i < c->len; ++i)
+		if (c->num[i] != 0)
+			goto skip;
+	bc_num_setToZero(c, scale);
+ skip:
+
+ err:
+	bc_num_free(&copy);
+	RETURN_STATUS(s);
+}
+#define zbc_num_p(...) (zbc_num_p(__VA_ARGS__) COMMA_SUCCESS)
+
+static BC_STATUS zbc_num_sqrt(BcNum *a, BcNum *restrict b, size_t scale)
+{
+	BcStatus s;
+	BcNum num1, num2, half, f, fprime, *x0, *x1, *temp;
+	BcDig half_digs[1];
+	size_t pow, len, digs, digs1, resrdx, req, times = 0;
+	ssize_t cmp = 1, cmp1 = SSIZE_MAX, cmp2 = SSIZE_MAX;
+
+	req = BC_MAX(scale, a->rdx) + ((BC_NUM_INT(a) + 1) >> 1) + 1;
+	bc_num_expand(b, req);
+
+	if (a->len == 0) {
+		bc_num_setToZero(b, scale);
+		RETURN_STATUS(BC_STATUS_SUCCESS);
+	}
+	if (a->neg) {
+		RETURN_STATUS(bc_error("negative number"));
+	}
+	if (BC_NUM_ONE(a)) {
+		bc_num_one(b);
+		bc_num_extend(b, scale);
+		RETURN_STATUS(BC_STATUS_SUCCESS);
+	}
+
+	scale = BC_MAX(scale, a->rdx) + 1;
+	len = a->len + scale;
+
+	bc_num_init(&num1, len);
+	bc_num_init(&num2, len);
+
+	half.cap = ARRAY_SIZE(half_digs);
+	half.num = half_digs;
+	bc_num_one(&half);
+	half_digs[0] = 5;
+	half.rdx = 1;
+
+	bc_num_init(&f, len);
+	bc_num_init(&fprime, len);
+
+	x0 = &num1;
+	x1 = &num2;
+
+	bc_num_one(x0);
+	pow = BC_NUM_INT(a);
+
+	if (pow) {
+		if (pow & 1)
+			x0->num[0] = 2;
+		else
+			x0->num[0] = 6;
+
+		pow -= 2 - (pow & 1);
+
+		bc_num_extend(x0, pow);
+
+		// Make sure to move the radix back.
+		x0->rdx -= pow;
+	}
+
+	x0->rdx = digs = digs1 = 0;
+	resrdx = scale + 2;
+	len = BC_NUM_INT(x0) + resrdx - 1;
+
+	while (cmp != 0 || digs < len) {
+		s = zbc_num_div(a, x0, &f, resrdx);
+		if (s) goto err;
+		s = zbc_num_add(x0, &f, &fprime, resrdx);
+		if (s) goto err;
+		s = zbc_num_mul(&fprime, &half, x1, resrdx);
+		if (s) goto err;
+
+		cmp = bc_num_cmp(x1, x0);
+		digs = x1->len - (unsigned long long) llabs(cmp);
+
+		if (cmp == cmp2 && digs == digs1)
+			times += 1;
+		else
+			times = 0;
+
+		resrdx += times > 4;
+
+		cmp2 = cmp1;
+		cmp1 = cmp;
+		digs1 = digs;
+
+		temp = x0;
+		x0 = x1;
+		x1 = temp;
+	}
+
+	bc_num_copy(b, x0);
+	scale -= 1;
+	if (b->rdx > scale) bc_num_truncate(b, b->rdx - scale);
+ err:
+	bc_num_free(&fprime);
+	bc_num_free(&f);
+	bc_num_free(&num2);
+	bc_num_free(&num1);
+	RETURN_STATUS(s);
+}
+#define zbc_num_sqrt(...) (zbc_num_sqrt(__VA_ARGS__) COMMA_SUCCESS)
+
+static BC_STATUS zbc_num_divmod(BcNum *a, BcNum *b, BcNum *c, BcNum *d,
+                              size_t scale)
+{
+	BcStatus s;
+	BcNum num2, *ptr_a;
+	bool init = false;
+	size_t ts = BC_MAX(scale + b->rdx, a->rdx), len = BC_NUM_MREQ(a, b, ts);
+
+	if (c == a) {
+		memcpy(&num2, c, sizeof(BcNum));
+		ptr_a = &num2;
+		bc_num_init(c, len);
+		init = true;
+	} else {
+		ptr_a = a;
+		bc_num_expand(c, len);
+	}
+
+	s = zbc_num_r(ptr_a, b, c, d, scale, ts);
+
+	if (init) bc_num_free(&num2);
+
+	RETURN_STATUS(s);
+}
+#define zbc_num_divmod(...) (zbc_num_divmod(__VA_ARGS__) COMMA_SUCCESS)
+
+#if ENABLE_DC
+static BC_STATUS zdc_num_modexp(BcNum *a, BcNum *b, BcNum *c, BcNum *restrict d)
+{
+	BcStatus s;
+	BcNum base, exp, two, temp;
+	BcDig two_digs[1];
+
+	if (c->len == 0)
+		RETURN_STATUS(bc_error("divide by zero"));
+	if (a->rdx || b->rdx || c->rdx)
+		RETURN_STATUS(bc_error("not an integer"));
+	if (b->neg)
+		RETURN_STATUS(bc_error("negative number"));
+
+	bc_num_expand(d, c->len);
+	bc_num_init(&base, c->len);
+	bc_num_init(&exp, b->len);
+	bc_num_init(&temp, b->len);
+
+	two.cap = ARRAY_SIZE(two_digs);
+	two.num = two_digs;
+	bc_num_one(&two);
+	two_digs[0] = 2;
+
+	bc_num_one(d);
+
+	s = zbc_num_rem(a, c, &base, 0);
+	if (s) goto err;
+	bc_num_copy(&exp, b);
+
+	while (exp.len != 0) {
+		s = zbc_num_divmod(&exp, &two, &exp, &temp, 0);
+		if (s) goto err;
+
+		if (BC_NUM_ONE(&temp)) {
+			s = zbc_num_mul(d, &base, &temp, 0);
+			if (s) goto err;
+			s = zbc_num_rem(&temp, c, d, 0);
+			if (s) goto err;
+		}
+
+		s = zbc_num_mul(&base, &base, &temp, 0);
+		if (s) goto err;
+		s = zbc_num_rem(&temp, c, &base, 0);
+		if (s) goto err;
+	}
+ err:
+	bc_num_free(&temp);
+	bc_num_free(&exp);
+	bc_num_free(&base);
+	RETURN_STATUS(s);
+}
+#define zdc_num_modexp(...) (zdc_num_modexp(__VA_ARGS__) COMMA_SUCCESS)
+#endif // ENABLE_DC
+
+static FAST_FUNC void bc_string_free(void *string)
+{
+	free(*(char**)string);
+}
+
+static void bc_func_init(BcFunc *f)
+{
+	bc_char_vec_init(&f->code);
+	IF_BC(bc_vec_init(&f->labels, sizeof(size_t), NULL);)
+	IF_BC(bc_vec_init(&f->autos, sizeof(BcId), bc_id_free);)
+	IF_BC(bc_vec_init(&f->strs, sizeof(char *), bc_string_free);)
+	IF_BC(bc_vec_init(&f->consts, sizeof(char *), bc_string_free);)
+	IF_BC(f->nparams = 0;)
+}
+
+static FAST_FUNC void bc_func_free(void *func)
+{
+	BcFunc *f = (BcFunc *) func;
+	bc_vec_free(&f->code);
+	IF_BC(bc_vec_free(&f->labels);)
+	IF_BC(bc_vec_free(&f->autos);)
+	IF_BC(bc_vec_free(&f->strs);)
+	IF_BC(bc_vec_free(&f->consts);)
+}
+
+static void bc_array_expand(BcVec *a, size_t len);
+
+static void bc_array_init(BcVec *a, bool nums)
+{
+	if (nums)
+		bc_vec_init(a, sizeof(BcNum), bc_num_free);
+	else
+		bc_vec_init(a, sizeof(BcVec), bc_vec_free);
+	bc_array_expand(a, 1);
+}
+
+static void bc_array_expand(BcVec *a, size_t len)
+{
+	if (a->dtor == bc_num_free
+	 // && a->size == sizeof(BcNum) - always true
+	) {
+		BcNum n;
+		while (len > a->len) {
+			bc_num_init_DEF_SIZE(&n);
+			bc_vec_push(a, &n);
+		}
+	} else {
+		BcVec v;
+		while (len > a->len) {
+			bc_array_init(&v, true);
+			bc_vec_push(a, &v);
+		}
+	}
+}
+
+static void bc_array_copy(BcVec *d, const BcVec *s)
+{
+	BcNum *dnum, *snum;
+	size_t i;
+
+	bc_vec_pop_all(d);
+	bc_vec_expand(d, s->cap);
+	d->len = s->len;
+
+	dnum = (void*)d->v;
+	snum = (void*)s->v;
+	for (i = 0; i < s->len; i++, dnum++, snum++) {
+		bc_num_init(dnum, snum->len);
+		bc_num_copy(dnum, snum);
+	}
+}
+
+#if ENABLE_DC
+static void dc_result_copy(BcResult *d, BcResult *src)
+{
+	d->t = src->t;
+
+	switch (d->t) {
+		case XC_RESULT_TEMP:
+		case XC_RESULT_IBASE:
+		case XC_RESULT_SCALE:
+		case XC_RESULT_OBASE:
+			bc_num_init(&d->d.n, src->d.n.len);
+			bc_num_copy(&d->d.n, &src->d.n);
+			break;
+		case XC_RESULT_VAR:
+		case XC_RESULT_ARRAY:
+		case XC_RESULT_ARRAY_ELEM:
+			d->d.id.name = xstrdup(src->d.id.name);
+			break;
+		case XC_RESULT_CONSTANT:
+		IF_BC(case BC_RESULT_LAST:)
+		IF_BC(case BC_RESULT_ONE:)
+		case XC_RESULT_STR:
+			memcpy(&d->d.n, &src->d.n, sizeof(BcNum));
+			break;
+	}
+}
+#endif // ENABLE_DC
+
+static FAST_FUNC void bc_result_free(void *result)
+{
+	BcResult *r = (BcResult *) result;
+
+	switch (r->t) {
+		case XC_RESULT_TEMP:
+		case XC_RESULT_IBASE:
+		case XC_RESULT_SCALE:
+		case XC_RESULT_OBASE:
+			bc_num_free(&r->d.n);
+			break;
+		case XC_RESULT_VAR:
+		case XC_RESULT_ARRAY:
+		case XC_RESULT_ARRAY_ELEM:
+			free(r->d.id.name);
+			break;
+		default:
+			// Do nothing.
+			break;
+	}
+}
+
+static int bad_input_byte(char c)
+{
+	if ((c < ' ' && c != '\t' && c != '\r' && c != '\n') // also allow '\v' '\f'?
+	 || c > 0x7e
+	) {
+		bc_error_fmt("illegal character 0x%02x", c);
+		return 1;
+	}
+	return 0;
+}
+
+static void xc_read_line(BcVec *vec, FILE *fp)
+{
+ again:
+	bc_vec_pop_all(vec);
+	fflush_and_check();
+
+#if ENABLE_FEATURE_BC_INTERACTIVE
+	if (G_interrupt) { // ^C was pressed
+ intr:
+		if (fp != stdin) {
+			// ^C while running a script (bc SCRIPT): die.
+			// We do not return to interactive prompt:
+			// user might be running us from a shell,
+			// and SCRIPT might be intended to terminate
+			// (e.g. contain a "halt" stmt).
+			// ^C dropping user into a bc prompt instead of
+			// the shell would be unexpected.
+			xfunc_die();
+		}
+		// ^C while interactive input
+		G_interrupt = 0;
+		// GNU bc says "interrupted execution."
+		// GNU dc says "Interrupt!"
+		fputs("\ninterrupted execution\n", stderr);
+	}
+
+# if ENABLE_FEATURE_EDITING
+	if (G_ttyin && fp == stdin) {
+		int n, i;
+#  define line_buf bb_common_bufsiz1
+		n = read_line_input(G.line_input_state, "", line_buf, COMMON_BUFSIZE);
+		if (n <= 0) { // read errors or EOF, or ^D, or ^C
+			if (n == 0) // ^C
+				goto intr;
+			bc_vec_pushZeroByte(vec); // ^D or EOF (or error)
+			return;
+		}
+		i = 0;
+		for (;;) {
+			char c = line_buf[i++];
+			if (!c) break;
+			if (bad_input_byte(c)) goto again;
+		}
+		bc_vec_string(vec, n, line_buf);
+#  undef line_buf
+	} else
+# endif
+#endif
+	{
+		int c;
+		bool bad_chars = 0;
+
+		do {
+#if ENABLE_FEATURE_BC_INTERACTIVE
+			if (G_interrupt) {
+				// ^C was pressed: ignore entire line, get another one
+				bc_vec_pop_all(vec);
+				goto intr;
+			}
+#endif
+			do c = fgetc(fp); while (c == '\0');
+			if (c == EOF) {
+				if (ferror(fp))
+					bb_perror_msg_and_die("input error");
+				// Note: EOF does not append '\n'
+				break;
+			}
+			bad_chars |= bad_input_byte(c);
+			bc_vec_pushByte(vec, (char)c);
+		} while (c != '\n');
+
+		if (bad_chars) {
+			// Bad chars on this line
+			if (!G.prs.lex_filename) { // stdin
+				// ignore entire line, get another one
+				goto again;
+			}
+			bb_perror_msg_and_die("file '%s' is not text", G.prs.lex_filename);
+		}
+		bc_vec_pushZeroByte(vec);
+	}
+}
+
+//
+// Parsing routines
+//
+
+// "Input numbers may contain the characters 0-9 and A-Z.
+// (Note: They must be capitals.  Lower case letters are variable names.)
+// Single digit numbers always have the value of the digit regardless of
+// the value of ibase. (i.e. A = 10.) For multi-digit numbers, bc changes
+// all input digits greater or equal to ibase to the value of ibase-1.
+// This makes the number ZZZ always be the largest 3 digit number of the
+// input base."
+static bool xc_num_strValid(const char *val)
+{
+	bool radix = false;
+	for (;;) {
+		BcDig c = *val++;
+		if (c == '\0')
+			break;
+		if (c == '.') {
+			if (radix) return false;
+			radix = true;
+			continue;
+		}
+		if ((c < '0' || c > '9') && (c < 'A' || c > 'Z'))
+			return false;
+	}
+	return true;
+}
+
+// Note: n is already "bc_num_zero()"ed,
+// leading zeroes in "val" are removed
+static void bc_num_parseDecimal(BcNum *n, const char *val)
+{
+	size_t len, i;
+	const char *ptr;
+
+	len = strlen(val);
+	if (len == 0)
+		return;
+
+	bc_num_expand(n, len + 1); // +1 for e.g. "A" converting into 10
+
+	ptr = strchr(val, '.');
+
+	n->rdx = 0;
+	if (ptr != NULL)
+		n->rdx = (size_t)((val + len) - (ptr + 1));
+
+	for (i = 0; val[i]; ++i) {
+		if (val[i] != '0' && val[i] != '.') {
+			// Not entirely zero value - convert it, and exit
+			if (len == 1) {
+				unsigned c = val[0] - '0';
+				n->len = 1;
+				if (c > 9) { // A-Z => 10-36
+					n->len = 2;
+					c -= ('A' - '9' - 1);
+					n->num[1] = c/10;
+					c = c%10;
+				}
+				n->num[0] = c;
+				break;
+			}
+			i = len - 1;
+			for (;;) {
+				char c = val[i] - '0';
+				if (c > 9) // A-Z => 9
+					c = 9;
+				n->num[n->len] = c;
+				n->len++;
+ skip_dot:
+				if (i == 0) break;
+				if (val[--i] == '.') goto skip_dot;
+			}
+			break;
+		}
+	}
+	// if for() exits without hitting if(), the value is entirely zero
+}
+
+// Note: n is already "bc_num_zero()"ed,
+// leading zeroes in "val" are removed
+static void bc_num_parseBase(BcNum *n, const char *val, unsigned base_t)
+{
+	BcStatus s;
+	BcNum temp, mult, result;
+	BcNum base;
+	BcDig base_digs[ULONG_NUM_BUFSIZE];
+	BcDig c = '\0';
+	unsigned long v;
+	size_t i, digits;
+
+	for (i = 0; ; ++i) {
+		if (val[i] == '\0')
+			return;
+		if (val[i] != '.' && val[i] != '0')
+			break;
+	}
+
+	bc_num_init_DEF_SIZE(&temp);
+	bc_num_init_DEF_SIZE(&mult);
+	base.cap = ARRAY_SIZE(base_digs);
+	base.num = base_digs;
+	bc_num_ulong2num(&base, base_t);
+
+	for (;;) {
+		c = *val++;
+		if (c == '\0') goto int_err;
+		if (c == '.') break;
+
+		v = (unsigned long) (c <= '9' ? c - '0' : c - 'A' + 10);
+
+		s = zbc_num_mul(n, &base, &mult, 0);
+		if (s) goto int_err;
+		bc_num_ulong2num(&temp, v);
+		s = zbc_num_add(&mult, &temp, n, 0);
+		if (s) goto int_err;
+	}
+
+	bc_num_init(&result, base.len);
+	//bc_num_zero(&result); - already is
+	bc_num_one(&mult);
+
+	digits = 0;
+	for (;;) {
+		c = *val++;
+		if (c == '\0') break;
+		digits++;
+
+		v = (unsigned long) (c <= '9' ? c - '0' : c - 'A' + 10);
+
+		s = zbc_num_mul(&result, &base, &result, 0);
+		if (s) goto err;
+		bc_num_ulong2num(&temp, v);
+		s = zbc_num_add(&result, &temp, &result, 0);
+		if (s) goto err;
+		s = zbc_num_mul(&mult, &base, &mult, 0);
+		if (s) goto err;
+	}
+
+	s = zbc_num_div(&result, &mult, &result, digits);
+	if (s) goto err;
+	s = zbc_num_add(n, &result, n, digits);
+	if (s) goto err;
+
+	if (n->len != 0) {
+		if (n->rdx < digits)
+			bc_num_extend(n, digits - n->rdx);
+	} else
+		bc_num_zero(n);
+ err:
+	bc_num_free(&result);
+ int_err:
+	bc_num_free(&mult);
+	bc_num_free(&temp);
+}
+
+static BC_STATUS zxc_num_parse(BcNum *n, const char *val, unsigned base_t)
+{
+	if (!xc_num_strValid(val))
+		RETURN_STATUS(bc_error("bad number string"));
+
+	bc_num_zero(n);
+	while (*val == '0') val++;
+
+	if (base_t == 10)
+		bc_num_parseDecimal(n, val);
+	else
+		bc_num_parseBase(n, val, base_t);
+
+	RETURN_STATUS(BC_STATUS_SUCCESS);
+}
+#define zxc_num_parse(...) (zxc_num_parse(__VA_ARGS__) COMMA_SUCCESS)
+
+static bool xc_lex_more_input(void)
+{
+	BcParse *p = &G.prs;
+
+	bc_vec_pop_all(&G.input_buffer);
+
+	xc_read_line(&G.input_buffer, G.prs.lex_input_fp);
+
+	p->lex_inbuf = G.input_buffer.v;
+//	bb_error_msg("G.input_buffer.len:%d '%s'", G.input_buffer.len, G.input_buffer.v);
+
+	return G.input_buffer.len > 1;
+}
+
+// p->lex_inbuf points to the current string to be parsed.
+// if p->lex_inbuf points to '\0', it's either EOF or it points after
+// last processed line's terminating '\n' (and more reading needs to be done
+// to get next character).
+//
+// If you are in a situation where that is a possibility, call peek_inbuf().
+// If necessary, it performs more reading and changes p->lex_inbuf,
+// then it returns *p->lex_inbuf (which will be '\0' only if it's EOF).
+// After it, just referencing *p->lex_inbuf is valid, and if it wasn't '\0',
+// it's ok to do p->lex_inbuf++ once without end-of-buffer checking.
+//
+// eat_inbuf() is equvalent to "peek_inbuf(); if (c) p->lex_inbuf++":
+// it returns current char and advances the pointer (if not EOF).
+// After eat_inbuf(), referencing p->lex_inbuf[-1] and *p->lex_inbuf is valid.
+//
+// In many cases, you can use fast *p->lex_inbuf instead of peek_inbuf():
+// unless prev char might have been '\n', *p->lex_inbuf is '\0' ONLY
+// on real EOF, not end-of-buffer.
+//
+// bc cases to test interactively:
+// 1 #comment\  - prints "1<newline>" at once (comment is not continued)
+// 1 #comment/* - prints "1<newline>" at once
+// 1 #comment"  - prints "1<newline>" at once
+// 1\#comment   - error at once (\ is not a line continuation)
+// 1 + /*"*/2   - prints "3<newline>" at once
+// 1 + /*#*/2   - prints "3<newline>" at once
+// "str\"       - prints "str\" at once
+// "str#"       - prints "str#" at once
+// "str/*"      - prints "str/*" at once
+// "str#\       - waits for second line
+// end"         - ...prints "str#\<newline>end"
+static char peek_inbuf(void)
+{
+	if (*G.prs.lex_inbuf == '\0') {
+		if (G.prs.lex_input_fp)
+			if (!xc_lex_more_input())
+				G.prs.lex_input_fp = NULL;
+	}
+	return *G.prs.lex_inbuf;
+}
+static char eat_inbuf(void)
+{
+	char c = peek_inbuf();
+	if (c) G.prs.lex_inbuf++;
+	return c;
+}
+
+static void xc_lex_lineComment(void)
+{
+	BcParse *p = &G.prs;
+	char c;
+
+	// Try: echo -n '#foo' | bc
+	p->lex = XC_LEX_WHITESPACE;
+
+	// We depend here on input being done in whole lines:
+	// '\0' which isn't the EOF can only be seen after '\n'.
+	while ((c = *p->lex_inbuf) != '\n' && c != '\0')
+		p->lex_inbuf++;
+}
+
+static void xc_lex_whitespace(void)
+{
+	BcParse *p = &G.prs;
+
+	p->lex = XC_LEX_WHITESPACE;
+	for (;;) {
+		// We depend here on input being done in whole lines:
+		// '\0' which isn't the EOF can only be seen after '\n'.
+		char c = *p->lex_inbuf;
+		if (c == '\n') // this is XC_LEX_NLINE, not XC_LEX_WHITESPACE
+			break;
+		if (!isspace(c))
+			break;
+		p->lex_inbuf++;
+	}
+}
+
+static BC_STATUS zxc_lex_number(char last)
+{
+	BcParse *p = &G.prs;
+	bool pt;
+	char last_valid_ch;
+
+	bc_vec_pop_all(&p->lex_strnumbuf);
+	bc_vec_pushByte(&p->lex_strnumbuf, last);
+
+// bc: "Input numbers may contain the characters 0-9 and A-Z.
+// (Note: They must be capitals.  Lower case letters are variable names.)
+// Single digit numbers always have the value of the digit regardless of
+// the value of ibase. (i.e. A = 10.) For multi-digit numbers, bc changes
+// all input digits greater or equal to ibase to the value of ibase-1.
+// This makes the number ZZZ always be the largest 3 digit number of the
+// input base."
+// dc only allows A-F, the rules about single-char and multi-char are the same.
+	last_valid_ch = (IS_BC ? 'Z' : 'F');
+	pt = (last == '.');
+	p->lex = XC_LEX_NUMBER;
+	for (;;) {
+		// We depend here on input being done in whole lines:
+		// '\0' which isn't the EOF can only be seen after '\n'.
+		char c = *p->lex_inbuf;
+ check_c:
+		if (c == '\0')
+			break;
+		if (c == '\\' && p->lex_inbuf[1] == '\n') {
+			p->lex_inbuf += 2;
+			p->lex_line++;
+			c = peek_inbuf(); // force next line to be read
+			goto check_c;
+		}
+		if (!isdigit(c) && (c < 'A' || c > last_valid_ch)) {
+			if (c != '.') break;
+			// if '.' was already seen, stop on second one:
+			if (pt) break;
+			pt = true;
+		}
+		// c is one of "0-9A-Z."
+		last = c;
+		bc_vec_push(&p->lex_strnumbuf, p->lex_inbuf);
+		p->lex_inbuf++;
+	}
+	if (last == '.') // remove trailing '.' if any
+		bc_vec_pop(&p->lex_strnumbuf);
+	bc_vec_pushZeroByte(&p->lex_strnumbuf);
+
+	G.err_line = G.prs.lex_line;
+	RETURN_STATUS(BC_STATUS_SUCCESS);
+}
+#define zxc_lex_number(...) (zxc_lex_number(__VA_ARGS__) COMMA_SUCCESS)
+
+static void xc_lex_name(void)
+{
+	BcParse *p = &G.prs;
+	size_t i;
+	const char *buf;
+
+	p->lex = XC_LEX_NAME;
+
+	// Since names can't cross lines with \<newline>,
+	// we depend on the fact that whole line is in the buffer
+	i = 0;
+	buf = p->lex_inbuf - 1;
+	for (;;) {
+		char c = buf[i];
+		if ((c < 'a' || c > 'z') && !isdigit(c) && c != '_') break;
+		i++;
+	}
+
+#if 0 // We do not protect against people with gigabyte-long names
+	// This check makes sense only if size_t is (much) larger than BC_MAX_STRING.
+	if (SIZE_MAX > (BC_MAX_STRING | 0xff)) {
+		if (i > BC_MAX_STRING)
+			return bc_error("name too long: must be [1,"BC_MAX_STRING_STR"]");
+	}
+#endif
+	bc_vec_string(&p->lex_strnumbuf, i, buf);
+
+	// Increment the index. We minus 1 because it has already been incremented.
+	p->lex_inbuf += i - 1;
+
+	//return BC_STATUS_SUCCESS;
+}
+
+IF_BC(static BC_STATUS zbc_lex_token(void);)
+IF_DC(static BC_STATUS zdc_lex_token(void);)
+#define zbc_lex_token(...) (zbc_lex_token(__VA_ARGS__) COMMA_SUCCESS)
+#define zdc_lex_token(...) (zdc_lex_token(__VA_ARGS__) COMMA_SUCCESS)
+
+static BC_STATUS zxc_lex_next(void)
+{
+	BcParse *p = &G.prs;
+	BcStatus s;
+
+	p->lex_last = p->lex;
+//why?
+//	if (p->lex_last == XC_LEX_EOF)
+//		RETURN_STATUS(bc_error("end of file"));
+
+	// Loop until failure or we don't have whitespace. This
+	// is so the parser doesn't get inundated with whitespace.
+	// Comments are also XC_LEX_WHITESPACE tokens and eaten here.
+	s = BC_STATUS_SUCCESS;
+	do {
+		if (*p->lex_inbuf == '\0') {
+			p->lex = XC_LEX_EOF;
+			if (peek_inbuf() == '\0')
+				RETURN_STATUS(BC_STATUS_SUCCESS);
+		}
+		p->lex_next_at = p->lex_inbuf;
+		dbg_lex("next string to parse:'%.*s'",
+			(int)(strchrnul(p->lex_next_at, '\n') - p->lex_next_at),
+			p->lex_next_at
+		);
+		if (IS_BC) {
+			IF_BC(s = zbc_lex_token());
+		} else {
+			IF_DC(s = zdc_lex_token());
+		}
+	} while (!s && p->lex == XC_LEX_WHITESPACE);
+	dbg_lex("p->lex from string:%d", p->lex);
+
+	RETURN_STATUS(s);
+}
+#define zxc_lex_next(...) (zxc_lex_next(__VA_ARGS__) COMMA_SUCCESS)
+
+#if ENABLE_BC
+static BC_STATUS zbc_lex_skip_if_at_NLINE(void)
+{
+	if (G.prs.lex == XC_LEX_NLINE)
+		RETURN_STATUS(zxc_lex_next());
+	RETURN_STATUS(BC_STATUS_SUCCESS);
+}
+#define zbc_lex_skip_if_at_NLINE(...) (zbc_lex_skip_if_at_NLINE(__VA_ARGS__) COMMA_SUCCESS)
+
+static BC_STATUS zbc_lex_next_and_skip_NLINE(void)
+{
+	BcStatus s;
+	s = zxc_lex_next();
+	if (s) RETURN_STATUS(s);
+	// if(cond)<newline>stmt is accepted too (but not 2+ newlines)
+	s = zbc_lex_skip_if_at_NLINE();
+	RETURN_STATUS(s);
+}
+#define zbc_lex_next_and_skip_NLINE(...) (zbc_lex_next_and_skip_NLINE(__VA_ARGS__) COMMA_SUCCESS)
+
+static BC_STATUS zbc_lex_identifier(void)
+{
+	BcParse *p = &G.prs;
+	BcStatus s;
+	unsigned i;
+	const char *buf = p->lex_inbuf - 1;
+
+	for (i = 0; i < ARRAY_SIZE(bc_lex_kws); ++i) {
+		const char *keyword8 = bc_lex_kws[i].name8;
+		unsigned j = 0;
+		while (buf[j] != '\0' && buf[j] == keyword8[j]) {
+			j++;
+			if (j == 8) goto match;
+		}
+		if (keyword8[j] != '\0')
+			continue;
+ match:
+		// buf starts with keyword bc_lex_kws[i]
+		if (isalnum(buf[j]) || buf[j]=='_')
+			continue; // "ifz" does not match "if" keyword, "if." does
+		p->lex = BC_LEX_KEY_1st_keyword + i;
+		if (!keyword_is_POSIX(i)) {
+			s = zbc_posix_error_fmt("%sthe '%.8s' keyword", "POSIX does not allow ", bc_lex_kws[i].name8);
+			if (s) RETURN_STATUS(s);
+		}
+
+		// We minus 1 because the index has already been incremented.
+		p->lex_inbuf += j - 1;
+		RETURN_STATUS(BC_STATUS_SUCCESS);
+	}
+
+	xc_lex_name();
+	s = BC_STATUS_SUCCESS;
+
+	if (p->lex_strnumbuf.len > 2) {
+		// Prevent this:
+		// >>> qwe=1
+		// bc: POSIX only allows one character names; this is bad: 'qwe=1
+		// '
+		unsigned len = strchrnul(buf, '\n') - buf;
+		s = zbc_posix_error_fmt("POSIX only allows one character names; this is bad: '%.*s'", len, buf);
+	}
+
+	RETURN_STATUS(s);
+}
+#define zbc_lex_identifier(...) (zbc_lex_identifier(__VA_ARGS__) COMMA_SUCCESS)
+
+static BC_STATUS zbc_lex_string(void)
+{
+	BcParse *p = &G.prs;
+
+	p->lex = XC_LEX_STR;
+	bc_vec_pop_all(&p->lex_strnumbuf);
+	for (;;) {
+		char c = peek_inbuf(); // strings can cross lines
+		if (c == '\0') {
+			RETURN_STATUS(bc_error("unterminated string"));
+		}
+		if (c == '"')
+			break;
+		if (c == '\n')
+			p->lex_line++;
+		bc_vec_push(&p->lex_strnumbuf, p->lex_inbuf);
+		p->lex_inbuf++;
+	}
+	bc_vec_pushZeroByte(&p->lex_strnumbuf);
+	p->lex_inbuf++;
+
+	G.err_line = p->lex_line;
+	RETURN_STATUS(BC_STATUS_SUCCESS);
+}
+#define zbc_lex_string(...) (zbc_lex_string(__VA_ARGS__) COMMA_SUCCESS)
+
+static void parse_lex_by_checking_eq_sign(unsigned with_and_without)
+{
+	BcParse *p = &G.prs;
+	if (*p->lex_inbuf == '=') {
+		// ^^^ not using peek_inbuf() since '==' etc can't be split across lines
+		p->lex_inbuf++;
+		with_and_without >>= 8; // store "with" value
+	} // else store "without" value
+	p->lex = (with_and_without & 0xff);
+}
+#define parse_lex_by_checking_eq_sign(with, without) \
+	parse_lex_by_checking_eq_sign(((with)<<8)|(without))
+
+static BC_STATUS zbc_lex_comment(void)
+{
+	BcParse *p = &G.prs;
+
+	p->lex = XC_LEX_WHITESPACE;
+	// here lex_inbuf is at '*' of opening comment delimiter
+	for (;;) {
+		char c;
+
+		p->lex_inbuf++;
+		c = peek_inbuf();
+ check_star:
+		if (c == '*') {
+			p->lex_inbuf++;
+			c = *p->lex_inbuf; // no need to peek_inbuf()
+			if (c == '/')
+				break;
+			goto check_star;
+		}
+		if (c == '\0') {
+			RETURN_STATUS(bc_error("unterminated comment"));
+		}
+		if (c == '\n')
+			p->lex_line++;
+	}
+	p->lex_inbuf++; // skip trailing '/'
+
+	G.err_line = p->lex_line;
+	RETURN_STATUS(BC_STATUS_SUCCESS);
+}
+#define zbc_lex_comment(...) (zbc_lex_comment(__VA_ARGS__) COMMA_SUCCESS)
+
+#undef zbc_lex_token
+static BC_STATUS zbc_lex_token(void)
+{
+	BcParse *p = &G.prs;
+	BcStatus s = BC_STATUS_SUCCESS;
+	char c = eat_inbuf();
+	char c2;
+
+	// This is the workhorse of the lexer.
+	switch (c) {
+//	case '\0': // probably never reached
+//		p->lex_inbuf--;
+//		p->lex = XC_LEX_EOF;
+//		break;
+	case '\n':
+		p->lex_line++;
+		p->lex = XC_LEX_NLINE;
+		break;
+	case '\t':
+	case '\v':
+	case '\f':
+	case '\r':
+	case ' ':
+		xc_lex_whitespace();
+		break;
+	case '!':
+		parse_lex_by_checking_eq_sign(XC_LEX_OP_REL_NE, BC_LEX_OP_BOOL_NOT);
+		if (p->lex == BC_LEX_OP_BOOL_NOT) {
+			s = zbc_POSIX_does_not_allow_bool_ops_this_is_bad("!");
+			if (s) RETURN_STATUS(s);
+		}
+		break;
+	case '"':
+		s = zbc_lex_string();
+		break;
+	case '#':
+		s = zbc_POSIX_does_not_allow("'#' script comments");
+		if (s) RETURN_STATUS(s);
+		xc_lex_lineComment();
+		break;
+	case '%':
+		parse_lex_by_checking_eq_sign(BC_LEX_OP_ASSIGN_MODULUS, XC_LEX_OP_MODULUS);
+		break;
+	case '&':
+		c2 = *p->lex_inbuf;
+		if (c2 == '&') {
+			s = zbc_POSIX_does_not_allow_bool_ops_this_is_bad("&&");
+			if (s) RETURN_STATUS(s);
+			p->lex_inbuf++;
+			p->lex = BC_LEX_OP_BOOL_AND;
+		} else {
+			p->lex = XC_LEX_INVALID;
+			s = bc_error_bad_character('&');
+		}
+		break;
+	case '(':
+	case ')':
+		p->lex = (BcLexType)(c - '(' + BC_LEX_LPAREN);
+		break;
+	case '*':
+		parse_lex_by_checking_eq_sign(BC_LEX_OP_ASSIGN_MULTIPLY, XC_LEX_OP_MULTIPLY);
+		break;
+	case '+':
+		c2 = *p->lex_inbuf;
+		if (c2 == '+') {
+			p->lex_inbuf++;
+			p->lex = BC_LEX_OP_INC;
+		} else
+			parse_lex_by_checking_eq_sign(BC_LEX_OP_ASSIGN_PLUS, XC_LEX_OP_PLUS);
+		break;
+	case ',':
+		p->lex = BC_LEX_COMMA;
+		break;
+	case '-':
+		c2 = *p->lex_inbuf;
+		if (c2 == '-') {
+			p->lex_inbuf++;
+			p->lex = BC_LEX_OP_DEC;
+		} else
+			parse_lex_by_checking_eq_sign(BC_LEX_OP_ASSIGN_MINUS, XC_LEX_OP_MINUS);
+		break;
+	case '.':
+		if (isdigit(*p->lex_inbuf))
+			s = zxc_lex_number(c);
+		else {
+			p->lex = BC_LEX_KEY_LAST;
+			s = zbc_POSIX_does_not_allow("'.' as 'last'");
+		}
+		break;
+	case '/':
+		c2 = *p->lex_inbuf;
+		if (c2 == '*')
+			s = zbc_lex_comment();
+		else
+			parse_lex_by_checking_eq_sign(BC_LEX_OP_ASSIGN_DIVIDE, XC_LEX_OP_DIVIDE);
+		break;
+	case '0':
+	case '1':
+	case '2':
+	case '3':
+	case '4':
+	case '5':
+	case '6':
+	case '7':
+	case '8':
+	case '9':
+	case 'A':
+	case 'B':
+	case 'C':
+	case 'D':
+	case 'E':
+	case 'F':
+	case 'G':
+	case 'H':
+	case 'I':
+	case 'J':
+	case 'K':
+	case 'L':
+	case 'M':
+	case 'N':
+	case 'O':
+	case 'P':
+	case 'Q':
+	case 'R':
+	case 'S':
+	case 'T':
+	case 'U':
+	case 'V':
+	case 'W':
+	case 'X':
+	case 'Y':
+	case 'Z':
+		s = zxc_lex_number(c);
+		break;
+	case ';':
+		p->lex = BC_LEX_SCOLON;
+		break;
+	case '<':
+		parse_lex_by_checking_eq_sign(XC_LEX_OP_REL_LE, XC_LEX_OP_REL_LT);
+		break;
+	case '=':
+		parse_lex_by_checking_eq_sign(XC_LEX_OP_REL_EQ, BC_LEX_OP_ASSIGN);
+		break;
+	case '>':
+		parse_lex_by_checking_eq_sign(XC_LEX_OP_REL_GE, XC_LEX_OP_REL_GT);
+		break;
+	case '[':
+	case ']':
+		p->lex = (BcLexType)(c - '[' + BC_LEX_LBRACKET);
+		break;
+	case '\\':
+		if (*p->lex_inbuf == '\n') {
+			p->lex = XC_LEX_WHITESPACE;
+			p->lex_inbuf++;
+		} else
+			s = bc_error_bad_character(c);
+		break;
+	case '^':
+		parse_lex_by_checking_eq_sign(BC_LEX_OP_ASSIGN_POWER, XC_LEX_OP_POWER);
+		break;
+	case 'a':
+	case 'b':
+	case 'c':
+	case 'd':
+	case 'e':
+	case 'f':
+	case 'g':
+	case 'h':
+	case 'i':
+	case 'j':
+	case 'k':
+	case 'l':
+	case 'm':
+	case 'n':
+	case 'o':
+	case 'p':
+	case 'q':
+	case 'r':
+	case 's':
+	case 't':
+	case 'u':
+	case 'v':
+	case 'w':
+	case 'x':
+	case 'y':
+	case 'z':
+		s = zbc_lex_identifier();
+		break;
+	case '{':
+	case '}':
+		p->lex = (BcLexType)(c - '{' + BC_LEX_LBRACE);
+		break;
+	case '|':
+		c2 = *p->lex_inbuf;
+		if (c2 == '|') {
+			s = zbc_POSIX_does_not_allow_bool_ops_this_is_bad("||");
+			if (s) RETURN_STATUS(s);
+			p->lex_inbuf++;
+			p->lex = BC_LEX_OP_BOOL_OR;
+		} else {
+			p->lex = XC_LEX_INVALID;
+			s = bc_error_bad_character(c);
+		}
+		break;
+	default:
+		p->lex = XC_LEX_INVALID;
+		s = bc_error_bad_character(c);
+		break;
+	}
+
+	RETURN_STATUS(s);
+}
+#define zbc_lex_token(...) (zbc_lex_token(__VA_ARGS__) COMMA_SUCCESS)
+#endif // ENABLE_BC
+
+#if ENABLE_DC
+static BC_STATUS zdc_lex_register(void)
+{
+	BcParse *p = &G.prs;
+	if (G_exreg && isspace(*p->lex_inbuf)) {
+		xc_lex_whitespace(); // eats whitespace (but not newline)
+		p->lex_inbuf++; // xc_lex_name() expects this
+		xc_lex_name();
+	} else {
+		bc_vec_pop_all(&p->lex_strnumbuf);
+		bc_vec_push(&p->lex_strnumbuf, p->lex_inbuf++);
+		bc_vec_pushZeroByte(&p->lex_strnumbuf);
+		p->lex = XC_LEX_NAME;
+	}
+
+	RETURN_STATUS(BC_STATUS_SUCCESS);
+}
+#define zdc_lex_register(...) (zdc_lex_register(__VA_ARGS__) COMMA_SUCCESS)
+
+static BC_STATUS zdc_lex_string(void)
+{
+	BcParse *p = &G.prs;
+	size_t depth;
+
+	p->lex = XC_LEX_STR;
+	bc_vec_pop_all(&p->lex_strnumbuf);
+
+	depth = 1;
+	for (;;) {
+		char c = peek_inbuf();
+		if (c == '\0') {
+			RETURN_STATUS(bc_error("unterminated string"));
+		}
+		if (c == '[') depth++;
+		if (c == ']')
+			if (--depth == 0)
+				break;
+		if (c == '\n')
+			p->lex_line++;
+		bc_vec_push(&p->lex_strnumbuf, p->lex_inbuf);
+		p->lex_inbuf++;
+	}
+	bc_vec_pushZeroByte(&p->lex_strnumbuf);
+	p->lex_inbuf++; // skip trailing ']'
+
+	G.err_line = p->lex_line;
+	RETURN_STATUS(BC_STATUS_SUCCESS);
+}
+#define zdc_lex_string(...) (zdc_lex_string(__VA_ARGS__) COMMA_SUCCESS)
+
+#undef zdc_lex_token
+static BC_STATUS zdc_lex_token(void)
+{
+	static const //BcLexType - should be this type, but narrower type saves size:
+	uint8_t
+	dc_lex_regs[] ALIGN1 = {
+		XC_LEX_OP_REL_EQ, XC_LEX_OP_REL_LE, XC_LEX_OP_REL_GE, XC_LEX_OP_REL_NE,
+		XC_LEX_OP_REL_LT, XC_LEX_OP_REL_GT, DC_LEX_SCOLON, DC_LEX_COLON,
+		DC_LEX_ELSE, DC_LEX_LOAD, DC_LEX_LOAD_POP, DC_LEX_OP_ASSIGN,
+		DC_LEX_STORE_PUSH,
+	};
+
+	BcParse *p = &G.prs;
+	BcStatus s;
+	char c, c2;
+	size_t i;
+
+	for (i = 0; i < ARRAY_SIZE(dc_lex_regs); ++i) {
+		if (p->lex_last == dc_lex_regs[i])
+			RETURN_STATUS(zdc_lex_register());
+	}
+
+	s = BC_STATUS_SUCCESS;
+	c = eat_inbuf();
+	if (c >= '%' && c <= '~'
+	 && (p->lex = dc_char_to_LEX[c - '%']) != XC_LEX_INVALID
+	) {
+		RETURN_STATUS(s);
+	}
+
+	// This is the workhorse of the lexer.
+	switch (c) {
+//	case '\0': // probably never reached
+//		p->lex = XC_LEX_EOF;
+//		break;
+	case '\n':
+		// '\n' is XC_LEX_NLINE, not XC_LEX_WHITESPACE
+		// (and "case '\n':" is not just empty here)
+		// only to allow interactive dc have a way to exit
+		// "parse" stage of "parse,execute" loop
+		// on <enter>, not on _next_ token (which would mean
+		// commands are not executed on pressing <enter>).
+		// IOW: typing "1p<enter>" should print "1" _at once_,
+		// not after some more input.
+		p->lex_line++;
+		p->lex = XC_LEX_NLINE;
+		break;
+	case '\t':
+	case '\v':
+	case '\f':
+	case '\r':
+	case ' ':
+		xc_lex_whitespace();
+		break;
+	case '!':
+		c2 = *p->lex_inbuf;
+		if (c2 == '=')
+			p->lex = XC_LEX_OP_REL_NE;
+		else if (c2 == '<')
+			p->lex = XC_LEX_OP_REL_LE;
+		else if (c2 == '>')
+			p->lex = XC_LEX_OP_REL_GE;
+		else
+			RETURN_STATUS(bc_error_bad_character(c));
+		p->lex_inbuf++;
+		break;
+	case '#':
+		xc_lex_lineComment();
+		break;
+	case '.':
+		if (isdigit(*p->lex_inbuf))
+			s = zxc_lex_number(c);
+		else
+			s = bc_error_bad_character(c);
+		break;
+	case '0':
+	case '1':
+	case '2':
+	case '3':
+	case '4':
+	case '5':
+	case '6':
+	case '7':
+	case '8':
+	case '9':
+	case 'A':
+	case 'B':
+	case 'C':
+	case 'D':
+	case 'E':
+	case 'F':
+		s = zxc_lex_number(c);
+		break;
+	case '[':
+		s = zdc_lex_string();
+		break;
+	default:
+		p->lex = XC_LEX_INVALID;
+		s = bc_error_bad_character(c);
+		break;
+	}
+
+	RETURN_STATUS(s);
+}
+#define zdc_lex_token(...) (zdc_lex_token(__VA_ARGS__) COMMA_SUCCESS)
+#endif // ENABLE_DC
+
+static void xc_parse_push(char i)
+{
+	BcVec *code = &G.prs.func->code;
+	dbg_compile("%s:%d pushing bytecode %zd:%d", __func__, __LINE__, code->len, i);
+	bc_vec_pushByte(code, i);
+}
+
+static void xc_parse_pushName(char *name)
+{
+#if 1
+	BcVec *code = &G.prs.func->code;
+	size_t pos = code->len;
+	size_t len = strlen(name) + 1;
+
+	bc_vec_expand(code, pos + len);
+	strcpy(code->v + pos, name);
+	code->len = pos + len;
+#else
+	// Smaller code, but way slow:
+	do {
+		xc_parse_push(*name);
+	} while (*name++);
+#endif
+}
+
+// Indexes < 0xfc are encoded verbatim, else first byte is
+// 0xfc, 0xfd, 0xfe or 0xff, encoding "1..4 bytes",
+// followed by that many bytes, lsb first.
+// (The above describes 32-bit case).
+#define SMALL_INDEX_LIMIT (0x100 - sizeof(size_t))
+
+static void xc_parse_pushIndex(size_t idx)
+{
+	size_t mask;
+	unsigned amt;
+
+	dbg_lex("%s:%d pushing index %zd", __func__, __LINE__, idx);
+	if (idx < SMALL_INDEX_LIMIT) {
+		goto push_idx;
+	}
+
+	mask = ((size_t)0xff) << (sizeof(idx) * 8 - 8);
+	amt = sizeof(idx);
+	for (;;) {
+		if (idx & mask) break;
+		mask >>= 8;
+		amt--;
+	}
+	// amt is at least 1 here - "one byte of length data follows"
+
+	xc_parse_push((SMALL_INDEX_LIMIT - 1) + amt);
+
+	while (idx != 0) {
+ push_idx:
+		xc_parse_push((unsigned char)idx);
+		idx >>= 8;
+	}
+}
+
+#if ENABLE_BC
+static void bc_parse_pushJUMP(size_t idx)
+{
+	xc_parse_push(BC_INST_JUMP);
+	xc_parse_pushIndex(idx);
+}
+
+static void bc_parse_pushJUMP_ZERO(size_t idx)
+{
+	xc_parse_push(BC_INST_JUMP_ZERO);
+	xc_parse_pushIndex(idx);
+}
+
+static BC_STATUS zbc_parse_pushSTR(void)
+{
+	BcParse *p = &G.prs;
+	char *str = xstrdup(p->lex_strnumbuf.v);
+
+	xc_parse_push(XC_INST_STR);
+	xc_parse_pushIndex(p->func->strs.len);
+	bc_vec_push(&p->func->strs, &str);
+
+	RETURN_STATUS(zxc_lex_next());
+}
+#define zbc_parse_pushSTR(...) (zbc_parse_pushSTR(__VA_ARGS__) COMMA_SUCCESS)
+#endif
+
+static void xc_parse_pushNUM(void)
+{
+	BcParse *p = &G.prs;
+	char *num = xstrdup(p->lex_strnumbuf.v);
+#if ENABLE_BC && ENABLE_DC
+	size_t idx = bc_vec_push(IS_BC ? &p->func->consts : &G.prog.consts, &num);
+#elif ENABLE_BC
+	size_t idx = bc_vec_push(&p->func->consts, &num);
+#else // DC
+	size_t idx = bc_vec_push(&G.prog.consts, &num);
+#endif
+	xc_parse_push(XC_INST_NUM);
+	xc_parse_pushIndex(idx);
+}
+
+static BC_STATUS zxc_parse_text_init(const char *text)
+{
+	G.prs.func = xc_program_func(G.prs.fidx);
+	G.prs.lex_inbuf = text;
+	G.prs.lex = G.prs.lex_last = XC_LEX_INVALID;
+	RETURN_STATUS(zxc_lex_next());
+}
+#define zxc_parse_text_init(...) (zxc_parse_text_init(__VA_ARGS__) COMMA_SUCCESS)
+
+// Called when parsing or execution detects a failure,
+// resets execution structures.
+static void xc_program_reset(void)
+{
+	BcFunc *f;
+	BcInstPtr *ip;
+
+	bc_vec_npop(&G.prog.exestack, G.prog.exestack.len - 1);
+	bc_vec_pop_all(&G.prog.results);
+
+	f = xc_program_func_BC_PROG_MAIN();
+	ip = bc_vec_top(&G.prog.exestack);
+	ip->inst_idx = f->code.len;
+}
+
+// Called when parsing code detects a failure,
+// resets parsing structures.
+static void xc_parse_reset(void)
+{
+	BcParse *p = &G.prs;
+	if (p->fidx != BC_PROG_MAIN) {
+		bc_func_free(p->func);
+		bc_func_init(p->func);
+
+		p->fidx = BC_PROG_MAIN;
+		p->func = xc_program_func_BC_PROG_MAIN();
+	}
+
+	p->lex_inbuf += strlen(p->lex_inbuf);
+	p->lex = XC_LEX_EOF;
+
+	IF_BC(bc_vec_pop_all(&p->exits);)
+	IF_BC(bc_vec_pop_all(&p->conds);)
+	IF_BC(bc_vec_pop_all(&p->ops);)
+
+	xc_program_reset();
+}
+
+static void xc_parse_free(void)
+{
+	IF_BC(bc_vec_free(&G.prs.exits);)
+	IF_BC(bc_vec_free(&G.prs.conds);)
+	IF_BC(bc_vec_free(&G.prs.ops);)
+	bc_vec_free(&G.prs.lex_strnumbuf);
+}
+
+static void xc_parse_create(size_t fidx)
+{
+	BcParse *p = &G.prs;
+	memset(p, 0, sizeof(BcParse));
+
+	bc_char_vec_init(&p->lex_strnumbuf);
+	IF_BC(bc_vec_init(&p->exits, sizeof(size_t), NULL);)
+	IF_BC(bc_vec_init(&p->conds, sizeof(size_t), NULL);)
+	IF_BC(bc_vec_init(&p->ops, sizeof(BcLexType), NULL);)
+
+	p->fidx = fidx;
+	p->func = xc_program_func(fidx);
+}
+
+static void xc_program_add_fn(void)
+{
+	//size_t idx;
+	BcFunc f;
+	bc_func_init(&f);
+	//idx =
+	bc_vec_push(&G.prog.fns, &f);
+	//return idx;
+}
+
+#if ENABLE_BC
+
+// Note: takes ownership of 'name' (must be malloced)
+static size_t bc_program_addFunc(char *name)
+{
+	size_t idx;
+	BcId entry, *entry_ptr;
+	int inserted;
+
+	entry.name = name;
+	entry.idx = G.prog.fns.len;
+
+	inserted = bc_map_insert(&G.prog.fn_map, &entry, &idx);
+	if (!inserted) free(name);
+
+	entry_ptr = bc_vec_item(&G.prog.fn_map, idx);
+	idx = entry_ptr->idx;
+
+	if (!inserted) {
+		// There is already a function with this name.
+		// It'll be redefined now, clear old definition.
+		BcFunc *func = xc_program_func(entry_ptr->idx);
+		bc_func_free(func);
+		bc_func_init(func);
+	} else {
+		xc_program_add_fn();
+	}
+
+	return idx;
+}
+
+#define BC_PARSE_TOP_OP(p) (*(BcLexType*)bc_vec_top(&(p)->ops))
+// We can calculate the conversion between tokens and exprs by subtracting the
+// position of the first operator in the lex enum and adding the position of the
+// first in the expr enum. Note: This only works for binary operators.
+#define BC_TOKEN_2_INST(t) ((char) ((t) - XC_LEX_OP_POWER + XC_INST_POWER))
+
+static BcStatus bc_parse_expr_empty_ok(uint8_t flags);
+
+static BC_STATUS zbc_parse_expr(uint8_t flags)
+{
+	BcStatus s;
+
+	s = bc_parse_expr_empty_ok(flags);
+	if (s == BC_STATUS_PARSE_EMPTY_EXP)
+		RETURN_STATUS(bc_error("empty expression"));
+	RETURN_STATUS(s);
+}
+#define zbc_parse_expr(...) (zbc_parse_expr(__VA_ARGS__) COMMA_SUCCESS)
+
+static BC_STATUS zbc_parse_stmt_possibly_auto(bool auto_allowed);
+#define zbc_parse_stmt_possibly_auto(...) (zbc_parse_stmt_possibly_auto(__VA_ARGS__) COMMA_SUCCESS)
+
+static BC_STATUS zbc_parse_stmt(void)
+{
+	RETURN_STATUS(zbc_parse_stmt_possibly_auto(false));
+}
+#define zbc_parse_stmt(...) (zbc_parse_stmt(__VA_ARGS__) COMMA_SUCCESS)
+
+static BC_STATUS zbc_parse_stmt_allow_NLINE_before(const char *after_X)
+{
+	BcParse *p = &G.prs;
+	// "if(cond)<newline>stmt" is accepted too, but not 2+ newlines.
+	// Same for "else", "while()", "for()".
+	BcStatus s = zbc_lex_next_and_skip_NLINE();
+	if (s) RETURN_STATUS(s);
+	if (p->lex == XC_LEX_NLINE)
+		RETURN_STATUS(bc_error_fmt("no statement after '%s'", after_X));
+
+	RETURN_STATUS(zbc_parse_stmt());
+}
+#define zbc_parse_stmt_allow_NLINE_before(...) (zbc_parse_stmt_allow_NLINE_before(__VA_ARGS__) COMMA_SUCCESS)
+
+static void bc_parse_operator(BcLexType type, size_t start, size_t *nexprs)
+{
+	BcParse *p = &G.prs;
+	char l, r = bc_operation_PREC(type - XC_LEX_1st_op);
+	bool left = bc_operation_LEFT(type - XC_LEX_1st_op);
+
+	while (p->ops.len > start) {
+		BcLexType t = BC_PARSE_TOP_OP(p);
+		if (t == BC_LEX_LPAREN) break;
+
+		l = bc_operation_PREC(t - XC_LEX_1st_op);
+		if (l >= r && (l != r || !left)) break;
+
+		xc_parse_push(BC_TOKEN_2_INST(t));
+		bc_vec_pop(&p->ops);
+		*nexprs -= (t != BC_LEX_OP_BOOL_NOT && t != XC_LEX_NEG);
+	}
+
+	bc_vec_push(&p->ops, &type);
+}
+
+static BC_STATUS zbc_parse_rightParen(size_t ops_bgn, size_t *nexs)
+{
+	BcParse *p = &G.prs;
+	BcLexType top;
+
+	if (p->ops.len <= ops_bgn)
+		RETURN_STATUS(bc_error_bad_expression());
+	top = BC_PARSE_TOP_OP(p);
+
+	while (top != BC_LEX_LPAREN) {
+		xc_parse_push(BC_TOKEN_2_INST(top));
+
+		bc_vec_pop(&p->ops);
+		*nexs -= (top != BC_LEX_OP_BOOL_NOT && top != XC_LEX_NEG);
+
+		if (p->ops.len <= ops_bgn)
+			RETURN_STATUS(bc_error_bad_expression());
+		top = BC_PARSE_TOP_OP(p);
+	}
+
+	bc_vec_pop(&p->ops);
+
+	RETURN_STATUS(BC_STATUS_SUCCESS);
+}
+#define zbc_parse_rightParen(...) (zbc_parse_rightParen(__VA_ARGS__) COMMA_SUCCESS)
+
+static BC_STATUS zbc_parse_params(uint8_t flags)
+{
+	BcParse *p = &G.prs;
+	BcStatus s;
+	size_t nparams;
+
+	dbg_lex("%s:%d p->lex:%d", __func__, __LINE__, p->lex);
+	flags = (flags & ~(BC_PARSE_PRINT | BC_PARSE_REL)) | BC_PARSE_ARRAY;
+
+	s = zxc_lex_next();
+	if (s) RETURN_STATUS(s);
+
+	nparams = 0;
+	if (p->lex != BC_LEX_RPAREN) {
+		for (;;) {
+			s = zbc_parse_expr(flags);
+			if (s) RETURN_STATUS(s);
+			nparams++;
+			if (p->lex != BC_LEX_COMMA) {
+				if (p->lex == BC_LEX_RPAREN)
+					break;
+				RETURN_STATUS(bc_error_bad_token());
+			}
+			s = zxc_lex_next();
+			if (s) RETURN_STATUS(s);
+		}
+	}
+
+	xc_parse_push(BC_INST_CALL);
+	xc_parse_pushIndex(nparams);
+
+	RETURN_STATUS(BC_STATUS_SUCCESS);
+}
+#define zbc_parse_params(...) (zbc_parse_params(__VA_ARGS__) COMMA_SUCCESS)
+
+// Note: takes ownership of 'name' (must be malloced)
+static BC_STATUS zbc_parse_call(char *name, uint8_t flags)
+{
+	BcParse *p = &G.prs;
+	BcStatus s;
+	BcId entry, *entry_ptr;
+	size_t idx;
+
+	entry.name = name;
+
+	s = zbc_parse_params(flags);
+	if (s) goto err;
+
+	if (p->lex != BC_LEX_RPAREN) {
+		s = bc_error_bad_token();
+		goto err;
+	}
+
+	idx = bc_map_find_exact(&G.prog.fn_map, &entry);
+
+	if (idx == BC_VEC_INVALID_IDX) {
+		// No such function exists, create an empty one
+		bc_program_addFunc(name);
+		idx = bc_map_find_exact(&G.prog.fn_map, &entry);
+	} else
+		free(name);
+
+	entry_ptr = bc_vec_item(&G.prog.fn_map, idx);
+	xc_parse_pushIndex(entry_ptr->idx);
+
+	RETURN_STATUS(zxc_lex_next());
+ err:
+	free(name);
+	RETURN_STATUS(s);
+}
+#define zbc_parse_call(...) (zbc_parse_call(__VA_ARGS__) COMMA_SUCCESS)
+
+static BC_STATUS zbc_parse_name(BcInst *type, uint8_t flags)
+{
+	BcParse *p = &G.prs;
+	BcStatus s;
+	char *name;
+
+	name = xstrdup(p->lex_strnumbuf.v);
+	s = zxc_lex_next();
+	if (s) goto err;
+
+	if (p->lex == BC_LEX_LBRACKET) {
+		s = zxc_lex_next();
+		if (s) goto err;
+
+		if (p->lex == BC_LEX_RBRACKET) {
+			if (!(flags & BC_PARSE_ARRAY)) {
+				s = bc_error_bad_expression();
+				goto err;
+			}
+			*type = XC_INST_ARRAY;
+		} else {
+			*type = XC_INST_ARRAY_ELEM;
+			flags &= ~(BC_PARSE_PRINT | BC_PARSE_REL);
+			s = zbc_parse_expr(flags);
+			if (s) goto err;
+		}
+		s = zxc_lex_next();
+		if (s) goto err;
+		xc_parse_push(*type);
+		xc_parse_pushName(name);
+		free(name);
+	} else if (p->lex == BC_LEX_LPAREN) {
+		if (flags & BC_PARSE_NOCALL) {
+			s = bc_error_bad_token();
+			goto err;
+		}
+		*type = BC_INST_CALL;
+		s = zbc_parse_call(name, flags);
+	} else {
+		*type = XC_INST_VAR;
+		xc_parse_push(XC_INST_VAR);
+		xc_parse_pushName(name);
+		free(name);
+	}
+
+	RETURN_STATUS(s);
+ err:
+	free(name);
+	RETURN_STATUS(s);
+}
+#define zbc_parse_name(...) (zbc_parse_name(__VA_ARGS__) COMMA_SUCCESS)
+
+static BC_STATUS zbc_parse_read(void)
+{
+	BcParse *p = &G.prs;
+	BcStatus s;
+
+	s = zxc_lex_next();
+	if (s) RETURN_STATUS(s);
+	if (p->lex != BC_LEX_LPAREN) RETURN_STATUS(bc_error_bad_token());
+
+	s = zxc_lex_next();
+	if (s) RETURN_STATUS(s);
+	if (p->lex != BC_LEX_RPAREN) RETURN_STATUS(bc_error_bad_token());
+
+	xc_parse_push(XC_INST_READ);
+
+	RETURN_STATUS(s);
+}
+#define zbc_parse_read(...) (zbc_parse_read(__VA_ARGS__) COMMA_SUCCESS)
+
+static BC_STATUS zbc_parse_builtin(BcLexType type, uint8_t flags, BcInst *prev)
+{
+	BcParse *p = &G.prs;
+	BcStatus s;
+
+	s = zxc_lex_next();
+	if (s) RETURN_STATUS(s);
+	if (p->lex != BC_LEX_LPAREN) RETURN_STATUS(bc_error_bad_token());
+
+	flags = (flags & ~(BC_PARSE_PRINT | BC_PARSE_REL)) | BC_PARSE_ARRAY;
+
+	s = zxc_lex_next();
+	if (s) RETURN_STATUS(s);
+
+	s = zbc_parse_expr(flags);
+	if (s) RETURN_STATUS(s);
+
+	if (p->lex != BC_LEX_RPAREN) RETURN_STATUS(bc_error_bad_token());
+
+	*prev = (type == BC_LEX_KEY_LENGTH) ? XC_INST_LENGTH : XC_INST_SQRT;
+	xc_parse_push(*prev);
+
+	RETURN_STATUS(s);
+}
+#define zbc_parse_builtin(...) (zbc_parse_builtin(__VA_ARGS__) COMMA_SUCCESS)
+
+static BC_STATUS zbc_parse_scale(BcInst *type, uint8_t flags)
+{
+	BcParse *p = &G.prs;
+	BcStatus s;
+
+	s = zxc_lex_next();
+	if (s) RETURN_STATUS(s);
+
+	if (p->lex != BC_LEX_LPAREN) {
+		*type = XC_INST_SCALE;
+		xc_parse_push(XC_INST_SCALE);
+		RETURN_STATUS(BC_STATUS_SUCCESS);
+	}
+
+	*type = XC_INST_SCALE_FUNC;
+	flags &= ~(BC_PARSE_PRINT | BC_PARSE_REL);
+
+	s = zxc_lex_next();
+	if (s) RETURN_STATUS(s);
+
+	s = zbc_parse_expr(flags);
+	if (s) RETURN_STATUS(s);
+	if (p->lex != BC_LEX_RPAREN)
+		RETURN_STATUS(bc_error_bad_token());
+	xc_parse_push(XC_INST_SCALE_FUNC);
+
+	RETURN_STATUS(zxc_lex_next());
+}
+#define zbc_parse_scale(...) (zbc_parse_scale(__VA_ARGS__) COMMA_SUCCESS)
+
+static BC_STATUS zbc_parse_incdec(BcInst *prev, bool *paren_expr,
+				size_t *nexprs, uint8_t flags)
+{
+	BcParse *p = &G.prs;
+	BcStatus s;
+	BcLexType type;
+	char inst;
+	BcInst etype = *prev;
+
+	if (etype == XC_INST_VAR || etype == XC_INST_ARRAY_ELEM
+	 || etype == XC_INST_SCALE || etype == BC_INST_LAST
+	 || etype == XC_INST_IBASE || etype == XC_INST_OBASE
+	) {
+		*prev = inst = BC_INST_INC_POST + (p->lex != BC_LEX_OP_INC);
+		xc_parse_push(inst);
+		s = zxc_lex_next();
+	} else {
+		*prev = inst = BC_INST_INC_PRE + (p->lex != BC_LEX_OP_INC);
+		*paren_expr = true;
+
+		s = zxc_lex_next();
+		if (s) RETURN_STATUS(s);
+		type = p->lex;
+
+		// Because we parse the next part of the expression
+		// right here, we need to increment this.
+		*nexprs = *nexprs + 1;
+
+		switch (type) {
+		case XC_LEX_NAME:
+			s = zbc_parse_name(prev, flags | BC_PARSE_NOCALL);
+			break;
+		case BC_LEX_KEY_IBASE:
+		case BC_LEX_KEY_LAST:
+		case BC_LEX_KEY_OBASE:
+			xc_parse_push(type - BC_LEX_KEY_IBASE + XC_INST_IBASE);
+			s = zxc_lex_next();
+			break;
+		case BC_LEX_KEY_SCALE:
+			s = zxc_lex_next();
+			if (s) RETURN_STATUS(s);
+			if (p->lex == BC_LEX_LPAREN)
+				s = bc_error_bad_token();
+			else
+				xc_parse_push(XC_INST_SCALE);
+			break;
+		default:
+			s = bc_error_bad_token();
+			break;
+		}
+
+		if (!s) xc_parse_push(inst);
+	}
+
+	RETURN_STATUS(s);
+}
+#define zbc_parse_incdec(...) (zbc_parse_incdec(__VA_ARGS__) COMMA_SUCCESS)
+
+#if 0
+#define BC_PARSE_LEAF(p, rparen) \
+	((rparen) \
+	 || ((p) >= XC_INST_NUM && (p) <= XC_INST_SQRT) \
+	 || (p) == BC_INST_INC_POST \
+	 || (p) == BC_INST_DEC_POST \
+	)
+#else
+static int ok_in_expr(BcInst p)
+{
+	return (p >= XC_INST_NUM && p <= XC_INST_SQRT)
+		|| p == BC_INST_INC_POST
+		|| p == BC_INST_DEC_POST
+		;
+}
+#define BC_PARSE_LEAF(p, rparen) ((rparen) || ok_in_expr(p))
+#endif
+
+static BC_STATUS zbc_parse_minus(BcInst *prev, size_t ops_bgn,
+				bool rparen, size_t *nexprs)
+{
+	BcParse *p = &G.prs;
+	BcStatus s;
+	BcLexType type;
+	BcInst etype = *prev;
+
+	s = zxc_lex_next();
+	if (s) RETURN_STATUS(s);
+
+	type = BC_PARSE_LEAF(etype, rparen) ? XC_LEX_OP_MINUS : XC_LEX_NEG;
+	*prev = BC_TOKEN_2_INST(type);
+
+	// We can just push onto the op stack because this is the largest
+	// precedence operator that gets pushed. Inc/dec does not.
+	if (type != XC_LEX_OP_MINUS)
+		bc_vec_push(&p->ops, &type);
+	else
+		bc_parse_operator(type, ops_bgn, nexprs);
+
+	RETURN_STATUS(s);
+}
+#define zbc_parse_minus(...) (zbc_parse_minus(__VA_ARGS__) COMMA_SUCCESS)
+
+static BC_STATUS zbc_parse_print(void)
+{
+	BcParse *p = &G.prs;
+	BcStatus s;
+	BcLexType type;
+
+	for (;;) {
+		s = zxc_lex_next();
+		if (s) RETURN_STATUS(s);
+		type = p->lex;
+		if (type == XC_LEX_STR) {
+			s = zbc_parse_pushSTR();
+		} else {
+			s = zbc_parse_expr(0);
+		}
+		if (s) RETURN_STATUS(s);
+		xc_parse_push(XC_INST_PRINT_POP);
+		if (p->lex != BC_LEX_COMMA)
+			break;
+	}
+
+	RETURN_STATUS(s);
+}
+#define zbc_parse_print(...) (zbc_parse_print(__VA_ARGS__) COMMA_SUCCESS)
+
+static BC_STATUS zbc_parse_return(void)
+{
+	BcParse *p = &G.prs;
+	BcStatus s;
+	BcLexType t;
+
+	dbg_lex_enter("%s:%d entered", __func__, __LINE__);
+	s = zxc_lex_next();
+	if (s) RETURN_STATUS(s);
+
+	t = p->lex;
+	if (t == XC_LEX_NLINE || t == BC_LEX_SCOLON)
+		xc_parse_push(BC_INST_RET0);
+	else {
+		bool paren = (t == BC_LEX_LPAREN);
+		s = bc_parse_expr_empty_ok(0);
+		if (s == BC_STATUS_PARSE_EMPTY_EXP) {
+			xc_parse_push(BC_INST_RET0);
+			s = zxc_lex_next();
+		}
+		if (s) RETURN_STATUS(s);
+
+		if (!paren || p->lex_last != BC_LEX_RPAREN) {
+			s = zbc_POSIX_requires("parentheses around return expressions");
+			if (s) RETURN_STATUS(s);
+		}
+
+		xc_parse_push(XC_INST_RET);
+	}
+
+	dbg_lex_done("%s:%d done", __func__, __LINE__);
+	RETURN_STATUS(s);
+}
+#define zbc_parse_return(...) (zbc_parse_return(__VA_ARGS__) COMMA_SUCCESS)
+
+static void rewrite_label_to_current(size_t idx)
+{
+	BcParse *p = &G.prs;
+	size_t *label = bc_vec_item(&p->func->labels, idx);
+	*label = p->func->code.len;
+}
+
+static BC_STATUS zbc_parse_if(void)
+{
+	BcParse *p = &G.prs;
+	BcStatus s;
+	size_t ip_idx;
+
+	dbg_lex_enter("%s:%d entered", __func__, __LINE__);
+	s = zxc_lex_next();
+	if (s) RETURN_STATUS(s);
+	if (p->lex != BC_LEX_LPAREN) RETURN_STATUS(bc_error_bad_token());
+
+	s = zxc_lex_next();
+	if (s) RETURN_STATUS(s);
+	s = zbc_parse_expr(BC_PARSE_REL);
+	if (s) RETURN_STATUS(s);
+	if (p->lex != BC_LEX_RPAREN) RETURN_STATUS(bc_error_bad_token());
+
+	// Encode "if zero, jump to ..."
+	// Pushed value (destination of the jump) is uninitialized,
+	// will be rewritten to be address of "end of if()" or of "else".
+	ip_idx = bc_vec_push(&p->func->labels, &ip_idx);
+	bc_parse_pushJUMP_ZERO(ip_idx);
+
+	s = zbc_parse_stmt_allow_NLINE_before(STRING_if);
+	if (s) RETURN_STATUS(s);
+
+	dbg_lex("%s:%d in if after stmt: p->lex:%d", __func__, __LINE__, p->lex);
+	if (p->lex == BC_LEX_KEY_ELSE) {
+		size_t ip2_idx;
+
+		// Encode "after then_stmt, jump to end of if()"
+		ip2_idx = bc_vec_push(&p->func->labels, &ip2_idx);
+		dbg_lex("%s:%d after if() then_stmt: BC_INST_JUMP to %zd", __func__, __LINE__, ip2_idx);
+		bc_parse_pushJUMP(ip2_idx);
+
+		dbg_lex("%s:%d rewriting 'if_zero' label to jump to 'else'-> %zd", __func__, __LINE__, p->func->code.len);
+		rewrite_label_to_current(ip_idx);
+
+		ip_idx = ip2_idx;
+
+		s = zbc_parse_stmt_allow_NLINE_before(STRING_else);
+		if (s) RETURN_STATUS(s);
+	}
+
+	dbg_lex("%s:%d rewriting label to jump after 'if' body-> %zd", __func__, __LINE__, p->func->code.len);
+	rewrite_label_to_current(ip_idx);
+
+	dbg_lex_done("%s:%d done", __func__, __LINE__);
+	RETURN_STATUS(s);
+}
+#define zbc_parse_if(...) (zbc_parse_if(__VA_ARGS__) COMMA_SUCCESS)
+
+static BC_STATUS zbc_parse_while(void)
+{
+	BcParse *p = &G.prs;
+	BcStatus s;
+	size_t cond_idx;
+	size_t ip_idx;
+
+	s = zxc_lex_next();
+	if (s) RETURN_STATUS(s);
+	if (p->lex != BC_LEX_LPAREN) RETURN_STATUS(bc_error_bad_token());
+	s = zxc_lex_next();
+	if (s) RETURN_STATUS(s);
+
+	cond_idx = bc_vec_push(&p->func->labels, &p->func->code.len);
+	ip_idx = cond_idx + 1;
+	bc_vec_push(&p->conds, &cond_idx);
+
+	bc_vec_push(&p->exits, &ip_idx);
+	bc_vec_push(&p->func->labels, &ip_idx);
+
+	s = zbc_parse_expr(BC_PARSE_REL);
+	if (s) RETURN_STATUS(s);
+	if (p->lex != BC_LEX_RPAREN) RETURN_STATUS(bc_error_bad_token());
+
+	bc_parse_pushJUMP_ZERO(ip_idx);
+
+	s = zbc_parse_stmt_allow_NLINE_before(STRING_while);
+	if (s) RETURN_STATUS(s);
+
+	dbg_lex("%s:%d BC_INST_JUMP to %zd", __func__, __LINE__, cond_idx);
+	bc_parse_pushJUMP(cond_idx);
+
+	dbg_lex("%s:%d rewriting label-> %zd", __func__, __LINE__, p->func->code.len);
+	rewrite_label_to_current(ip_idx);
+
+	bc_vec_pop(&p->exits);
+	bc_vec_pop(&p->conds);
+
+	RETURN_STATUS(s);
+}
+#define zbc_parse_while(...) (zbc_parse_while(__VA_ARGS__) COMMA_SUCCESS)
+
+static BC_STATUS zbc_parse_for(void)
+{
+	BcParse *p = &G.prs;
+	BcStatus s;
+	size_t cond_idx, exit_idx, body_idx, update_idx;
+
+	dbg_lex("%s:%d p->lex:%d", __func__, __LINE__, p->lex);
+	s = zxc_lex_next();
+	if (s) RETURN_STATUS(s);
+	if (p->lex != BC_LEX_LPAREN) RETURN_STATUS(bc_error_bad_token());
+	s = zxc_lex_next();
+	if (s) RETURN_STATUS(s);
+
+	if (p->lex != BC_LEX_SCOLON) {
+		s = zbc_parse_expr(0);
+		xc_parse_push(XC_INST_POP);
+		if (s) RETURN_STATUS(s);
+	} else {
+		s = zbc_POSIX_does_not_allow_empty_X_expression_in_for("init");
+		if (s) RETURN_STATUS(s);
+	}
+
+	if (p->lex != BC_LEX_SCOLON) RETURN_STATUS(bc_error_bad_token());
+	s = zxc_lex_next();
+	if (s) RETURN_STATUS(s);
+
+	cond_idx = bc_vec_push(&p->func->labels, &p->func->code.len);
+	update_idx = cond_idx + 1;
+	body_idx = update_idx + 1;
+	exit_idx = body_idx + 1;
+
+	if (p->lex != BC_LEX_SCOLON)
+		s = zbc_parse_expr(BC_PARSE_REL);
+	else {
+		// Set this for the next call to xc_parse_pushNUM().
+		// This is safe to set because the current token is a semicolon,
+		// which has no string requirement.
+		bc_vec_string(&p->lex_strnumbuf, 1, "1");
+		xc_parse_pushNUM();
+		s = zbc_POSIX_does_not_allow_empty_X_expression_in_for("condition");
+	}
+	if (s) RETURN_STATUS(s);
+
+	if (p->lex != BC_LEX_SCOLON) RETURN_STATUS(bc_error_bad_token());
+
+	s = zxc_lex_next();
+	if (s) RETURN_STATUS(s);
+
+	bc_parse_pushJUMP_ZERO(exit_idx);
+	bc_parse_pushJUMP(body_idx);
+
+	bc_vec_push(&p->conds, &update_idx);
+	bc_vec_push(&p->func->labels, &p->func->code.len);
+
+	if (p->lex != BC_LEX_RPAREN) {
+		s = zbc_parse_expr(0);
+		if (s) RETURN_STATUS(s);
+		if (p->lex != BC_LEX_RPAREN) RETURN_STATUS(bc_error_bad_token());
+		xc_parse_push(XC_INST_POP);
+	} else {
+		s = zbc_POSIX_does_not_allow_empty_X_expression_in_for("update");
+		if (s) RETURN_STATUS(s);
+	}
+
+	bc_parse_pushJUMP(cond_idx);
+	bc_vec_push(&p->func->labels, &p->func->code.len);
+
+	bc_vec_push(&p->exits, &exit_idx);
+	bc_vec_push(&p->func->labels, &exit_idx);
+
+	s = zbc_parse_stmt_allow_NLINE_before(STRING_for);
+	if (s) RETURN_STATUS(s);
+
+	dbg_lex("%s:%d BC_INST_JUMP to %zd", __func__, __LINE__, update_idx);
+	bc_parse_pushJUMP(update_idx);
+
+	dbg_lex("%s:%d rewriting label-> %zd", __func__, __LINE__, p->func->code.len);
+	rewrite_label_to_current(exit_idx);
+
+	bc_vec_pop(&p->exits);
+	bc_vec_pop(&p->conds);
+
+	RETURN_STATUS(BC_STATUS_SUCCESS);
+}
+#define zbc_parse_for(...) (zbc_parse_for(__VA_ARGS__) COMMA_SUCCESS)
+
+static BC_STATUS zbc_parse_break_or_continue(BcLexType type)
+{
+	BcParse *p = &G.prs;
+	size_t i;
+
+	if (type == BC_LEX_KEY_BREAK) {
+		if (p->exits.len == 0) // none of the enclosing blocks is a loop
+			RETURN_STATUS(bc_error_bad_token());
+		i = *(size_t*)bc_vec_top(&p->exits);
+	} else {
+		i = *(size_t*)bc_vec_top(&p->conds);
+	}
+	bc_parse_pushJUMP(i);
+
+	RETURN_STATUS(zxc_lex_next());
+}
+#define zbc_parse_break_or_continue(...) (zbc_parse_break_or_continue(__VA_ARGS__) COMMA_SUCCESS)
+
+static BC_STATUS zbc_func_insert(BcFunc *f, char *name, bool var)
+{
+	BcId *autoid;
+	BcId a;
+	size_t i;
+
+	autoid = (void*)f->autos.v;
+	for (i = 0; i < f->autos.len; i++, autoid++) {
+		if (strcmp(name, autoid->name) == 0)
+			RETURN_STATUS(bc_error("duplicate function parameter or auto name"));
+	}
+
+	a.idx = var;
+	a.name = name;
+
+	bc_vec_push(&f->autos, &a);
+
+	RETURN_STATUS(BC_STATUS_SUCCESS);
+}
+#define zbc_func_insert(...) (zbc_func_insert(__VA_ARGS__) COMMA_SUCCESS)
+
+static BC_STATUS zbc_parse_funcdef(void)
+{
+	BcParse *p = &G.prs;
+	BcStatus s;
+	bool var, comma = false;
+	char *name;
+
+	dbg_lex_enter("%s:%d entered", __func__, __LINE__);
+	s = zxc_lex_next();
+	if (s) RETURN_STATUS(s);
+	if (p->lex != XC_LEX_NAME)
+		RETURN_STATUS(bc_error("bad function definition"));
+
+	name = xstrdup(p->lex_strnumbuf.v);
+	p->fidx = bc_program_addFunc(name);
+	p->func = xc_program_func(p->fidx);
+
+	s = zxc_lex_next();
+	if (s) RETURN_STATUS(s);
+	if (p->lex != BC_LEX_LPAREN)
+		RETURN_STATUS(bc_error("bad function definition"));
+	s = zxc_lex_next();
+	if (s) RETURN_STATUS(s);
+
+	while (p->lex != BC_LEX_RPAREN) {
+		if (p->lex != XC_LEX_NAME)
+			RETURN_STATUS(bc_error("bad function definition"));
+
+		++p->func->nparams;
+
+		name = xstrdup(p->lex_strnumbuf.v);
+		s = zxc_lex_next();
+		if (s) goto err;
+
+		var = p->lex != BC_LEX_LBRACKET;
+
+		if (!var) {
+			s = zxc_lex_next();
+			if (s) goto err;
+
+			if (p->lex != BC_LEX_RBRACKET) {
+				s = bc_error("bad function definition");
+				goto err;
+			}
+
+			s = zxc_lex_next();
+			if (s) goto err;
+		}
+
+		comma = p->lex == BC_LEX_COMMA;
+		if (comma) {
+			s = zxc_lex_next();
+			if (s) goto err;
+		}
+
+		s = zbc_func_insert(p->func, name, var);
+		if (s) goto err;
+	}
+
+	if (comma) RETURN_STATUS(bc_error("bad function definition"));
+
+	s = zxc_lex_next();
+	if (s) RETURN_STATUS(s);
+
+	if (p->lex != BC_LEX_LBRACE) {
+		s = zbc_POSIX_requires("the left brace be on the same line as the function header");
+		if (s) RETURN_STATUS(s);
+	}
+
+	// Prevent "define z()<newline>" from being interpreted as function with empty stmt as body
+	s = zbc_lex_skip_if_at_NLINE();
+	if (s) RETURN_STATUS(s);
+	//GNU bc requires a {} block even if function body has single stmt, enforce this?
+	if (p->lex != BC_LEX_LBRACE)
+		RETURN_STATUS(bc_error("function { body } expected"));
+
+	p->in_funcdef++; // to determine whether "return" stmt is allowed, and such
+	s = zbc_parse_stmt_possibly_auto(true);
+	p->in_funcdef--;
+	if (s) RETURN_STATUS(s);
+
+	xc_parse_push(BC_INST_RET0);
+
+	// Subsequent code generation is into main program
+	p->fidx = BC_PROG_MAIN;
+	p->func = xc_program_func_BC_PROG_MAIN();
+
+	dbg_lex_done("%s:%d done", __func__, __LINE__);
+	RETURN_STATUS(s);
+ err:
+	dbg_lex_done("%s:%d done (error)", __func__, __LINE__);
+	free(name);
+	RETURN_STATUS(s);
+}
+#define zbc_parse_funcdef(...) (zbc_parse_funcdef(__VA_ARGS__) COMMA_SUCCESS)
+
+static BC_STATUS zbc_parse_auto(void)
+{
+	BcParse *p = &G.prs;
+	BcStatus s;
+	char *name;
+
+	dbg_lex_enter("%s:%d entered", __func__, __LINE__);
+	s = zxc_lex_next();
+	if (s) RETURN_STATUS(s);
+
+	for (;;) {
+		bool var;
+
+		if (p->lex != XC_LEX_NAME)
+			RETURN_STATUS(bc_error("bad 'auto' syntax"));
+
+		name = xstrdup(p->lex_strnumbuf.v);
+		s = zxc_lex_next();
+		if (s) goto err;
+
+		var = (p->lex != BC_LEX_LBRACKET);
+		if (!var) {
+			s = zxc_lex_next();
+			if (s) goto err;
+
+			if (p->lex != BC_LEX_RBRACKET) {
+				s = bc_error("bad 'auto' syntax");
+				goto err;
+			}
+			s = zxc_lex_next();
+			if (s) goto err;
+		}
+
+		s = zbc_func_insert(p->func, name, var);
+		if (s) goto err;
+
+		if (p->lex == XC_LEX_NLINE
+		 || p->lex == BC_LEX_SCOLON
+		//|| p->lex == BC_LEX_RBRACE // allow "define f() {auto a}"
+		) {
+			break;
+		}
+		if (p->lex != BC_LEX_COMMA)
+			RETURN_STATUS(bc_error("bad 'auto' syntax"));
+		s = zxc_lex_next(); // skip comma
+		if (s) RETURN_STATUS(s);
+	}
+
+	dbg_lex_done("%s:%d done", __func__, __LINE__);
+	RETURN_STATUS(BC_STATUS_SUCCESS);
+ err:
+	free(name);
+	dbg_lex_done("%s:%d done (ERROR)", __func__, __LINE__);
+	RETURN_STATUS(s);
+}
+#define zbc_parse_auto(...) (zbc_parse_auto(__VA_ARGS__) COMMA_SUCCESS)
+
+#undef zbc_parse_stmt_possibly_auto
+static BC_STATUS zbc_parse_stmt_possibly_auto(bool auto_allowed)
+{
+	BcParse *p = &G.prs;
+	BcStatus s = BC_STATUS_SUCCESS;
+
+	dbg_lex_enter("%s:%d entered, p->lex:%d", __func__, __LINE__, p->lex);
+
+	if (p->lex == XC_LEX_NLINE) {
+		dbg_lex_done("%s:%d done (seen XC_LEX_NLINE)", __func__, __LINE__);
+		RETURN_STATUS(zxc_lex_next());
+	}
+	if (p->lex == BC_LEX_SCOLON) {
+		dbg_lex_done("%s:%d done (seen BC_LEX_SCOLON)", __func__, __LINE__);
+		RETURN_STATUS(zxc_lex_next());
+	}
+
+	if (p->lex == BC_LEX_LBRACE) {
+		dbg_lex("%s:%d BC_LEX_LBRACE: (auto_allowed:%d)", __func__, __LINE__, auto_allowed);
+		do {
+			s = zxc_lex_next();
+			if (s) RETURN_STATUS(s);
+		} while (p->lex == XC_LEX_NLINE);
+		if (auto_allowed && p->lex == BC_LEX_KEY_AUTO) {
+			dbg_lex("%s:%d calling zbc_parse_auto()", __func__, __LINE__);
+			s = zbc_parse_auto();
+			if (s) RETURN_STATUS(s);
+		}
+		while (p->lex != BC_LEX_RBRACE) {
+			dbg_lex("%s:%d block parsing loop", __func__, __LINE__);
+			s = zbc_parse_stmt();
+			if (s) RETURN_STATUS(s);
+		}
+		s = zxc_lex_next();
+		dbg_lex_done("%s:%d done (seen BC_LEX_RBRACE)", __func__, __LINE__);
+		RETURN_STATUS(s);
+	}
+
+	dbg_lex("%s:%d p->lex:%d", __func__, __LINE__, p->lex);
+	switch (p->lex) {
+	case XC_LEX_OP_MINUS:
+	case BC_LEX_OP_INC:
+	case BC_LEX_OP_DEC:
+	case BC_LEX_OP_BOOL_NOT:
+	case BC_LEX_LPAREN:
+	case XC_LEX_NAME:
+	case XC_LEX_NUMBER:
+	case BC_LEX_KEY_IBASE:
+	case BC_LEX_KEY_LAST:
+	case BC_LEX_KEY_LENGTH:
+	case BC_LEX_KEY_OBASE:
+	case BC_LEX_KEY_READ:
+	case BC_LEX_KEY_SCALE:
+	case BC_LEX_KEY_SQRT:
+		s = zbc_parse_expr(BC_PARSE_PRINT);
+		break;
+	case XC_LEX_STR:
+		s = zbc_parse_pushSTR();
+		xc_parse_push(XC_INST_PRINT_STR);
+		break;
+	case BC_LEX_KEY_BREAK:
+	case BC_LEX_KEY_CONTINUE:
+		s = zbc_parse_break_or_continue(p->lex);
+		break;
+	case BC_LEX_KEY_FOR:
+		s = zbc_parse_for();
+		break;
+	case BC_LEX_KEY_HALT:
+		xc_parse_push(BC_INST_HALT);
+		s = zxc_lex_next();
+		break;
+	case BC_LEX_KEY_IF:
+		s = zbc_parse_if();
+		break;
+	case BC_LEX_KEY_LIMITS:
+		// "limits" is a compile-time command,
+		// the output is produced at _parse time_.
+		printf(
+			"BC_BASE_MAX     = "BC_MAX_OBASE_STR "\n"
+			"BC_DIM_MAX      = "BC_MAX_DIM_STR   "\n"
+			"BC_SCALE_MAX    = "BC_MAX_SCALE_STR "\n"
+			"BC_STRING_MAX   = "BC_MAX_STRING_STR"\n"
+			"BC_NAME_MAX     = "BC_MAX_NAME_STR  "\n"
+			"BC_NUM_MAX      = "BC_MAX_NUM_STR   "\n"
+			"MAX Exponent    = "BC_MAX_EXP_STR   "\n"
+			"Number of vars  = "BC_MAX_VARS_STR  "\n"
+		);
+		s = zxc_lex_next();
+		break;
+	case BC_LEX_KEY_PRINT:
+		s = zbc_parse_print();
+		break;
+	case BC_LEX_KEY_QUIT:
+		// "quit" is a compile-time command. For example,
+		// "if (0 == 1) quit" terminates when parsing the statement,
+		// not when it is executed
+		QUIT_OR_RETURN_TO_MAIN;
+	case BC_LEX_KEY_RETURN:
+		if (!p->in_funcdef)
+			RETURN_STATUS(bc_error("'return' not in a function"));
+		s = zbc_parse_return();
+		break;
+	case BC_LEX_KEY_WHILE:
+		s = zbc_parse_while();
+		break;
+	default:
+		s = bc_error_bad_token();
+		break;
+	}
+
+	dbg_lex_done("%s:%d done", __func__, __LINE__);
+	RETURN_STATUS(s);
+}
+#define zbc_parse_stmt_possibly_auto(...) (zbc_parse_stmt_possibly_auto(__VA_ARGS__) COMMA_SUCCESS)
+
+static BC_STATUS zbc_parse_stmt_or_funcdef(void)
+{
+	BcParse *p = &G.prs;
+	BcStatus s;
+
+	dbg_lex_enter("%s:%d entered", __func__, __LINE__);
+	if (p->lex == XC_LEX_EOF)
+		s = bc_error("end of file");
+	else if (p->lex == BC_LEX_KEY_DEFINE) {
+		dbg_lex("%s:%d p->lex:BC_LEX_KEY_DEFINE", __func__, __LINE__);
+		s = zbc_parse_funcdef();
+	} else {
+		dbg_lex("%s:%d p->lex:%d (not BC_LEX_KEY_DEFINE)", __func__, __LINE__, p->lex);
+		s = zbc_parse_stmt();
+	}
+
+	dbg_lex_done("%s:%d done", __func__, __LINE__);
+	RETURN_STATUS(s);
+}
+#define zbc_parse_stmt_or_funcdef(...) (zbc_parse_stmt_or_funcdef(__VA_ARGS__) COMMA_SUCCESS)
+
+// This is not a "z" function: can also return BC_STATUS_PARSE_EMPTY_EXP
+static BcStatus bc_parse_expr_empty_ok(uint8_t flags)
+{
+	BcParse *p = &G.prs;
+	BcInst prev = XC_INST_PRINT;
+	size_t nexprs = 0, ops_bgn = p->ops.len;
+	unsigned nparens, nrelops;
+	bool paren_first, paren_expr, rprn, assign, bin_last;
+
+	dbg_lex_enter("%s:%d entered", __func__, __LINE__);
+	paren_first = (p->lex == BC_LEX_LPAREN);
+	nparens = nrelops = 0;
+	paren_expr = rprn = assign = false;
+	bin_last = true;
+
+	for (;;) {
+		bool get_token;
+		BcStatus s;
+		BcLexType t = p->lex;
+
+		if (!lex_allowed_in_bc_expr(t))
+			break;
+
+		dbg_lex("%s:%d t:%d", __func__, __LINE__, t);
+		get_token = false;
+		s = BC_STATUS_SUCCESS;
+		switch (t) {
+		case BC_LEX_OP_INC:
+		case BC_LEX_OP_DEC:
+			dbg_lex("%s:%d LEX_OP_INC/DEC", __func__, __LINE__);
+			s = zbc_parse_incdec(&prev, &paren_expr, &nexprs, flags);
+			rprn = bin_last = false;
+			//get_token = false; - already is
+			break;
+		case XC_LEX_OP_MINUS:
+			dbg_lex("%s:%d LEX_OP_MINUS", __func__, __LINE__);
+			s = zbc_parse_minus(&prev, ops_bgn, rprn, &nexprs);
+			rprn = false;
+			//get_token = false; - already is
+			bin_last = (prev == XC_INST_MINUS);
+			break;
+		case BC_LEX_OP_ASSIGN_POWER:
+		case BC_LEX_OP_ASSIGN_MULTIPLY:
+		case BC_LEX_OP_ASSIGN_DIVIDE:
+		case BC_LEX_OP_ASSIGN_MODULUS:
+		case BC_LEX_OP_ASSIGN_PLUS:
+		case BC_LEX_OP_ASSIGN_MINUS:
+		case BC_LEX_OP_ASSIGN:
+			dbg_lex("%s:%d LEX_ASSIGNxyz", __func__, __LINE__);
+			if (prev != XC_INST_VAR && prev != XC_INST_ARRAY_ELEM
+			 && prev != XC_INST_SCALE && prev != XC_INST_IBASE
+			 && prev != XC_INST_OBASE && prev != BC_INST_LAST
+			) {
+				return bc_error("bad assignment:"
+					" left side must be variable"
+					" or array element"
+				); // note: shared string
+			}
+		// Fallthrough.
+		case XC_LEX_OP_POWER:
+		case XC_LEX_OP_MULTIPLY:
+		case XC_LEX_OP_DIVIDE:
+		case XC_LEX_OP_MODULUS:
+		case XC_LEX_OP_PLUS:
+		case XC_LEX_OP_REL_EQ:
+		case XC_LEX_OP_REL_LE:
+		case XC_LEX_OP_REL_GE:
+		case XC_LEX_OP_REL_NE:
+		case XC_LEX_OP_REL_LT:
+		case XC_LEX_OP_REL_GT:
+		case BC_LEX_OP_BOOL_NOT:
+		case BC_LEX_OP_BOOL_OR:
+		case BC_LEX_OP_BOOL_AND:
+			dbg_lex("%s:%d LEX_OP_xyz", __func__, __LINE__);
+			if (((t == BC_LEX_OP_BOOL_NOT) != bin_last)
+			 || (t != BC_LEX_OP_BOOL_NOT && prev == XC_INST_BOOL_NOT)
+			) {
+				return bc_error_bad_expression();
+			}
+			nrelops += (t >= XC_LEX_OP_REL_EQ && t <= XC_LEX_OP_REL_GT);
+			prev = BC_TOKEN_2_INST(t);
+			bc_parse_operator(t, ops_bgn, &nexprs);
+			s = zxc_lex_next();
+			rprn = false;
+			//get_token = false; - already is
+			bin_last = (t != BC_LEX_OP_BOOL_NOT);
+			break;
+		case BC_LEX_LPAREN:
+			dbg_lex("%s:%d LEX_LPAREN", __func__, __LINE__);
+			if (BC_PARSE_LEAF(prev, rprn))
+				return bc_error_bad_expression();
+			bc_vec_push(&p->ops, &t);
+			nparens++;
+			get_token = true;
+			paren_expr = false;
+			rprn = bin_last = false;
+			break;
+		case BC_LEX_RPAREN:
+			dbg_lex("%s:%d LEX_RPAREN", __func__, __LINE__);
+			if (bin_last || prev == XC_INST_BOOL_NOT)
+				return bc_error_bad_expression();
+			if (nparens == 0) {
+				goto exit_loop;
+			}
+			if (!paren_expr) {
+				dbg_lex_done("%s:%d done (returning EMPTY_EXP)", __func__, __LINE__);
+				return BC_STATUS_PARSE_EMPTY_EXP;
+			}
+			s = zbc_parse_rightParen(ops_bgn, &nexprs);
+			nparens--;
+			get_token = true;
+			paren_expr = rprn = true;
+			bin_last = false;
+			break;
+		case XC_LEX_NAME:
+			dbg_lex("%s:%d LEX_NAME", __func__, __LINE__);
+			if (BC_PARSE_LEAF(prev, rprn))
+				return bc_error_bad_expression();
+			s = zbc_parse_name(&prev, flags & ~BC_PARSE_NOCALL);
+			paren_expr = true;
+			rprn = bin_last = false;
+			//get_token = false; - already is
+			nexprs++;
+			break;
+		case XC_LEX_NUMBER:
+			dbg_lex("%s:%d LEX_NUMBER", __func__, __LINE__);
+			if (BC_PARSE_LEAF(prev, rprn))
+				return bc_error_bad_expression();
+			xc_parse_pushNUM();
+			prev = XC_INST_NUM;
+			get_token = true;
+			paren_expr = true;
+			rprn = bin_last = false;
+			nexprs++;
+			break;
+		case BC_LEX_KEY_IBASE:
+		case BC_LEX_KEY_LAST:
+		case BC_LEX_KEY_OBASE:
+			dbg_lex("%s:%d LEX_IBASE/LAST/OBASE", __func__, __LINE__);
+			if (BC_PARSE_LEAF(prev, rprn))
+				return bc_error_bad_expression();
+			prev = (char) (t - BC_LEX_KEY_IBASE + XC_INST_IBASE);
+			xc_parse_push((char) prev);
+			get_token = true;
+			paren_expr = true;
+			rprn = bin_last = false;
+			nexprs++;
+			break;
+		case BC_LEX_KEY_LENGTH:
+		case BC_LEX_KEY_SQRT:
+			dbg_lex("%s:%d LEX_LEN/SQRT", __func__, __LINE__);
+			if (BC_PARSE_LEAF(prev, rprn))
+				return bc_error_bad_expression();
+			s = zbc_parse_builtin(t, flags, &prev);
+			get_token = true;
+			paren_expr = true;
+			rprn = bin_last = false;
+			nexprs++;
+			break;
+		case BC_LEX_KEY_READ:
+			dbg_lex("%s:%d LEX_READ", __func__, __LINE__);
+			if (BC_PARSE_LEAF(prev, rprn))
+				return bc_error_bad_expression();
+			s = zbc_parse_read();
+			prev = XC_INST_READ;
+			get_token = true;
+			paren_expr = true;
+			rprn = bin_last = false;
+			nexprs++;
+			break;
+		case BC_LEX_KEY_SCALE:
+			dbg_lex("%s:%d LEX_SCALE", __func__, __LINE__);
+			if (BC_PARSE_LEAF(prev, rprn))
+				return bc_error_bad_expression();
+			s = zbc_parse_scale(&prev, flags);
+			prev = XC_INST_SCALE;
+			//get_token = false; - already is
+			paren_expr = true;
+			rprn = bin_last = false;
+			nexprs++;
+			break;
+		default:
+			return bc_error_bad_token();
+		}
+
+		if (s || G_interrupt) // error, or ^C: stop parsing
+			return BC_STATUS_FAILURE;
+		if (get_token) {
+			s = zxc_lex_next();
+			if (s) return s;
+		}
+	}
+ exit_loop:
+
+	while (p->ops.len > ops_bgn) {
+		BcLexType top = BC_PARSE_TOP_OP(p);
+		assign = (top >= BC_LEX_OP_ASSIGN_POWER && top <= BC_LEX_OP_ASSIGN);
+
+		if (top == BC_LEX_LPAREN || top == BC_LEX_RPAREN)
+			return bc_error_bad_expression();
+
+		xc_parse_push(BC_TOKEN_2_INST(top));
+
+		nexprs -= (top != BC_LEX_OP_BOOL_NOT && top != XC_LEX_NEG);
+		bc_vec_pop(&p->ops);
+	}
+
+	if (prev == XC_INST_BOOL_NOT || nexprs != 1)
+		return bc_error_bad_expression();
+
+	if (!(flags & BC_PARSE_REL) && nrelops) {
+		BcStatus s;
+		s = zbc_POSIX_does_not_allow("comparison operators outside if or loops");
+		if (s) return s;
+	} else if ((flags & BC_PARSE_REL) && nrelops > 1) {
+		BcStatus s;
+		s = zbc_POSIX_requires("exactly one comparison operator per condition");
+		if (s) return s;
+	}
+
+	if (flags & BC_PARSE_PRINT) {
+		if (paren_first || !assign)
+			xc_parse_push(XC_INST_PRINT);
+		xc_parse_push(XC_INST_POP);
+	}
+
+	dbg_lex_done("%s:%d done", __func__, __LINE__);
+	return BC_STATUS_SUCCESS;
+}
+
+#endif // ENABLE_BC
+
+#if ENABLE_DC
+
+static BC_STATUS zdc_parse_register(void)
+{
+	BcParse *p = &G.prs;
+	BcStatus s;
+
+	s = zxc_lex_next();
+	if (s) RETURN_STATUS(s);
+	if (p->lex != XC_LEX_NAME) RETURN_STATUS(bc_error_bad_token());
+
+	xc_parse_pushName(p->lex_strnumbuf.v);
+
+	RETURN_STATUS(s);
+}
+#define zdc_parse_register(...) (zdc_parse_register(__VA_ARGS__) COMMA_SUCCESS)
+
+static void dc_parse_string(void)
+{
+	BcParse *p = &G.prs;
+	char *str;
+	size_t len = G.prog.strs.len;
+
+	dbg_lex_enter("%s:%d entered", __func__, __LINE__);
+
+	str = xstrdup(p->lex_strnumbuf.v);
+	xc_parse_push(XC_INST_STR);
+	xc_parse_pushIndex(len);
+	bc_vec_push(&G.prog.strs, &str);
+
+	// Explanation needed here
+	xc_program_add_fn();
+	p->func = xc_program_func(p->fidx);
+
+	dbg_lex_done("%s:%d done", __func__, __LINE__);
+}
+
+static BC_STATUS zdc_parse_mem(uint8_t inst, bool name, bool store)
+{
+	BcStatus s;
+
+	xc_parse_push(inst);
+	if (name) {
+		s = zdc_parse_register();
+		if (s) RETURN_STATUS(s);
+	}
+
+	if (store) {
+		xc_parse_push(DC_INST_SWAP);
+		xc_parse_push(XC_INST_ASSIGN);
+		xc_parse_push(XC_INST_POP);
+	}
+
+	RETURN_STATUS(BC_STATUS_SUCCESS);
+}
+#define zdc_parse_mem(...) (zdc_parse_mem(__VA_ARGS__) COMMA_SUCCESS)
+
+static BC_STATUS zdc_parse_cond(uint8_t inst)
+{
+	BcParse *p = &G.prs;
+	BcStatus s;
+
+	xc_parse_push(inst);
+	xc_parse_push(DC_INST_EXEC_COND);
+
+	s = zdc_parse_register();
+	if (s) RETURN_STATUS(s);
+
+	s = zxc_lex_next();
+	if (s) RETURN_STATUS(s);
+
+	// Note that 'else' part can not be on the next line:
+	// echo -e '[1p]sa [2p]sb 2 1>a eb' | dc - OK, prints "2"
+	// echo -e '[1p]sa [2p]sb 2 1>a\neb' | dc - parse error
+	if (p->lex == DC_LEX_ELSE) {
+		s = zdc_parse_register();
+		if (s) RETURN_STATUS(s);
+		s = zxc_lex_next();
+	} else {
+		xc_parse_push('\0');
+	}
+
+	RETURN_STATUS(s);
+}
+#define zdc_parse_cond(...) (zdc_parse_cond(__VA_ARGS__) COMMA_SUCCESS)
+
+static BC_STATUS zdc_parse_token(BcLexType t)
+{
+	BcStatus s;
+	uint8_t inst;
+	bool assign, get_token;
+
+	dbg_lex_enter("%s:%d entered", __func__, __LINE__);
+	s = BC_STATUS_SUCCESS;
+	get_token = true;
+	switch (t) {
+	case XC_LEX_OP_REL_EQ:
+	case XC_LEX_OP_REL_LE:
+	case XC_LEX_OP_REL_GE:
+	case XC_LEX_OP_REL_NE:
+	case XC_LEX_OP_REL_LT:
+	case XC_LEX_OP_REL_GT:
+		dbg_lex("%s:%d LEX_OP_REL_xyz", __func__, __LINE__);
+		s = zdc_parse_cond(t - XC_LEX_OP_REL_EQ + XC_INST_REL_EQ);
+		get_token = false;
+		break;
+	case DC_LEX_SCOLON:
+	case DC_LEX_COLON:
+		dbg_lex("%s:%d LEX_[S]COLON", __func__, __LINE__);
+		s = zdc_parse_mem(XC_INST_ARRAY_ELEM, true, t == DC_LEX_COLON);
+		break;
+	case XC_LEX_STR:
+		dbg_lex("%s:%d LEX_STR", __func__, __LINE__);
+		dc_parse_string();
+		break;
+	case XC_LEX_NEG:
+		dbg_lex("%s:%d LEX_NEG", __func__, __LINE__);
+		s = zxc_lex_next();
+		if (s) RETURN_STATUS(s);
+		if (G.prs.lex != XC_LEX_NUMBER)
+			RETURN_STATUS(bc_error_bad_token());
+		xc_parse_pushNUM();
+		xc_parse_push(XC_INST_NEG);
+		break;
+	case XC_LEX_NUMBER:
+		dbg_lex("%s:%d LEX_NUMBER", __func__, __LINE__);
+		xc_parse_pushNUM();
+		break;
+	case DC_LEX_READ:
+		dbg_lex("%s:%d LEX_KEY_READ", __func__, __LINE__);
+		xc_parse_push(XC_INST_READ);
+		break;
+	case DC_LEX_OP_ASSIGN:
+	case DC_LEX_STORE_PUSH:
+		dbg_lex("%s:%d LEX_OP_ASSIGN/STORE_PUSH", __func__, __LINE__);
+		assign = (t == DC_LEX_OP_ASSIGN);
+		inst = assign ? XC_INST_VAR : DC_INST_PUSH_TO_VAR;
+		s = zdc_parse_mem(inst, true, assign);
+		break;
+	case DC_LEX_LOAD:
+	case DC_LEX_LOAD_POP:
+		dbg_lex("%s:%d LEX_OP_LOAD[_POP]", __func__, __LINE__);
+		inst = t == DC_LEX_LOAD_POP ? DC_INST_PUSH_VAR : DC_INST_LOAD;
+		s = zdc_parse_mem(inst, true, false);
+		break;
+	case DC_LEX_STORE_IBASE:
+	case DC_LEX_STORE_SCALE:
+	case DC_LEX_STORE_OBASE:
+		dbg_lex("%s:%d LEX_OP_STORE_I/OBASE/SCALE", __func__, __LINE__);
+		inst = t - DC_LEX_STORE_IBASE + XC_INST_IBASE;
+		s = zdc_parse_mem(inst, false, true);
+		break;
+	default:
+		dbg_lex_done("%s:%d done (bad token)", __func__, __LINE__);
+		RETURN_STATUS(bc_error_bad_token());
+	}
+
+	if (!s && get_token) s = zxc_lex_next();
+
+	dbg_lex_done("%s:%d done", __func__, __LINE__);
+	RETURN_STATUS(s);
+}
+#define zdc_parse_token(...) (zdc_parse_token(__VA_ARGS__) COMMA_SUCCESS)
+
+static BC_STATUS zdc_parse_expr(void)
+{
+	BcParse *p = &G.prs;
+	int i;
+
+	i = (int)p->lex - (int)XC_LEX_OP_POWER;
+	if (i >= 0) {
+		BcInst inst = dc_LEX_to_INST[i];
+		if (inst != DC_INST_INVALID) {
+			xc_parse_push(inst);
+			RETURN_STATUS(zxc_lex_next());
+		}
+	}
+	RETURN_STATUS(zdc_parse_token(p->lex));
+}
+#define zdc_parse_expr(...) (zdc_parse_expr(__VA_ARGS__) COMMA_SUCCESS)
+
+static BC_STATUS zdc_parse_exprs_until_eof(void)
+{
+	BcParse *p = &G.prs;
+	dbg_lex_enter("%s:%d entered, p->lex:%d", __func__, __LINE__, p->lex);
+	while (p->lex != XC_LEX_EOF) {
+		BcStatus s = zdc_parse_expr();
+		if (s) RETURN_STATUS(s);
+	}
+
+	dbg_lex_done("%s:%d done", __func__, __LINE__);
+	RETURN_STATUS(BC_STATUS_SUCCESS);
+}
+#define zdc_parse_exprs_until_eof(...) (zdc_parse_exprs_until_eof(__VA_ARGS__) COMMA_SUCCESS)
+
+#endif // ENABLE_DC
+
+//
+// Execution engine
+//
+
+#define BC_PROG_STR(n) (!(n)->num && !(n)->cap)
+#define BC_PROG_NUM(r, n) \
+	((r)->t != XC_RESULT_ARRAY && (r)->t != XC_RESULT_STR && !BC_PROG_STR(n))
+
+#define STACK_HAS_MORE_THAN(s, n)          ((s)->len > ((size_t)(n)))
+#define STACK_HAS_EQUAL_OR_MORE_THAN(s, n) ((s)->len >= ((size_t)(n)))
+
+static BcVec* xc_program_search(char *id, bool var)
+{
+	BcId e, *ptr;
+	BcVec *v, *map;
+	size_t i;
+	int new;
+
+	v = var ? &G.prog.vars : &G.prog.arrs;
+	map = var ? &G.prog.var_map : &G.prog.arr_map;
+
+	e.name = id;
+	e.idx = v->len;
+	new = bc_map_insert(map, &e, &i); // 1 if insertion was successful
+
+	if (new) {
+		BcVec v2;
+		bc_array_init(&v2, var);
+		bc_vec_push(v, &v2);
+	}
+
+	ptr = bc_vec_item(map, i);
+	if (new) ptr->name = xstrdup(e.name);
+	return bc_vec_item(v, ptr->idx);
+}
+
+// 'num' need not be initialized on entry
+static BC_STATUS zxc_program_num(BcResult *r, BcNum **num)
+{
+	switch (r->t) {
+	case XC_RESULT_STR:
+	case XC_RESULT_TEMP:
+	case XC_RESULT_IBASE:
+	case XC_RESULT_SCALE:
+	case XC_RESULT_OBASE:
+		*num = &r->d.n;
+		break;
+	case XC_RESULT_CONSTANT: {
+		BcStatus s;
+		char *str;
+		size_t len;
+
+		str = *xc_program_const(r->d.id.idx);
+		len = strlen(str);
+
+		bc_num_init(&r->d.n, len);
+
+		s = zxc_num_parse(&r->d.n, str, G.prog.ib_t);
+		if (s) {
+			bc_num_free(&r->d.n);
+			RETURN_STATUS(s);
+		}
+		*num = &r->d.n;
+		r->t = XC_RESULT_TEMP;
+		break;
+	}
+	case XC_RESULT_VAR:
+	case XC_RESULT_ARRAY:
+	case XC_RESULT_ARRAY_ELEM: {
+		BcVec *v;
+		void *p;
+		v = xc_program_search(r->d.id.name, r->t == XC_RESULT_VAR);
+// dc variables are all stacks, so here we have this:
+		p = bc_vec_top(v);
+// TODO: eliminate these stacks for bc-only config?
+		if (r->t == XC_RESULT_ARRAY_ELEM) {
+			v = p;
+			if (v->len <= r->d.id.idx)
+				bc_array_expand(v, r->d.id.idx + 1);
+			*num = bc_vec_item(v, r->d.id.idx);
+		} else {
+			*num = p;
+		}
+		break;
+	}
+#if ENABLE_BC
+	case BC_RESULT_LAST:
+		*num = &G.prog.last;
+		break;
+	case BC_RESULT_ONE:
+		*num = &G.prog.one;
+		break;
+#endif
+#if SANITY_CHECKS
+	default:
+		// Testing the theory that dc does not reach LAST/ONE
+		bb_error_msg_and_die("BUG:%d", r->t);
+#endif
+	}
+
+	RETURN_STATUS(BC_STATUS_SUCCESS);
+}
+#define zxc_program_num(...) (zxc_program_num(__VA_ARGS__) COMMA_SUCCESS)
+
+static BC_STATUS zxc_program_binOpPrep(BcResult **l, BcNum **ln,
+                                     BcResult **r, BcNum **rn, bool assign)
+{
+	BcStatus s;
+	BcResultType lt, rt;
+
+	if (!STACK_HAS_MORE_THAN(&G.prog.results, 1))
+		RETURN_STATUS(bc_error_stack_has_too_few_elements());
+
+	*r = bc_vec_item_rev(&G.prog.results, 0);
+	*l = bc_vec_item_rev(&G.prog.results, 1);
+
+	s = zxc_program_num(*l, ln);
+	if (s) RETURN_STATUS(s);
+	s = zxc_program_num(*r, rn);
+	if (s) RETURN_STATUS(s);
+
+	lt = (*l)->t;
+	rt = (*r)->t;
+
+	// We run this again under these conditions in case any vector has been
+	// reallocated out from under the BcNums or arrays we had.
+	if (lt == rt && (lt == XC_RESULT_VAR || lt == XC_RESULT_ARRAY_ELEM)) {
+		s = zxc_program_num(*l, ln);
+		if (s) RETURN_STATUS(s);
+	}
+
+	if (!BC_PROG_NUM((*l), (*ln)) && (!assign || (*l)->t != XC_RESULT_VAR))
+		RETURN_STATUS(bc_error_variable_is_wrong_type());
+	if (!assign && !BC_PROG_NUM((*r), (*ln)))
+		RETURN_STATUS(bc_error_variable_is_wrong_type());
+
+	RETURN_STATUS(s);
+}
+#define zxc_program_binOpPrep(...) (zxc_program_binOpPrep(__VA_ARGS__) COMMA_SUCCESS)
+
+static void xc_program_binOpRetire(BcResult *r)
+{
+	r->t = XC_RESULT_TEMP;
+	bc_vec_pop(&G.prog.results);
+	bc_result_pop_and_push(r);
+}
+
+// Note: *r and *n need not be initialized by caller
+static BC_STATUS zxc_program_prep(BcResult **r, BcNum **n)
+{
+	BcStatus s;
+
+	if (!STACK_HAS_MORE_THAN(&G.prog.results, 0))
+		RETURN_STATUS(bc_error_stack_has_too_few_elements());
+	*r = bc_vec_top(&G.prog.results);
+
+	s = zxc_program_num(*r, n);
+	if (s) RETURN_STATUS(s);
+
+	if (!BC_PROG_NUM((*r), (*n)))
+		RETURN_STATUS(bc_error_variable_is_wrong_type());
+
+	RETURN_STATUS(s);
+}
+#define zxc_program_prep(...) (zxc_program_prep(__VA_ARGS__) COMMA_SUCCESS)
+
+static void xc_program_retire(BcResult *r, BcResultType t)
+{
+	r->t = t;
+	bc_result_pop_and_push(r);
+}
+
+static BC_STATUS zxc_program_op(char inst)
+{
+	BcStatus s;
+	BcResult *opd1, *opd2, res;
+	BcNum *n1, *n2;
+
+	s = zxc_program_binOpPrep(&opd1, &n1, &opd2, &n2, false);
+	if (s) RETURN_STATUS(s);
+	bc_num_init_DEF_SIZE(&res.d.n);
+
+	s = BC_STATUS_SUCCESS;
+	IF_ERROR_RETURN_POSSIBLE(s =) zxc_program_ops[inst - XC_INST_POWER](n1, n2, &res.d.n, G.prog.scale);
+	if (s) goto err;
+	xc_program_binOpRetire(&res);
+
+	RETURN_STATUS(s);
+ err:
+	bc_num_free(&res.d.n);
+	RETURN_STATUS(s);
+}
+#define zxc_program_op(...) (zxc_program_op(__VA_ARGS__) COMMA_SUCCESS)
+
+static BC_STATUS zxc_program_read(void)
+{
+	BcStatus s;
+	BcParse sv_parse;
+	BcVec buf;
+	BcInstPtr ip;
+	BcFunc *f;
+
+	bc_char_vec_init(&buf);
+	xc_read_line(&buf, stdin);
+
+	f = xc_program_func(BC_PROG_READ);
+	bc_vec_pop_all(&f->code);
+
+	sv_parse = G.prs; // struct copy
+	xc_parse_create(BC_PROG_READ);
+	//G.err_line = G.prs.lex_line = 1; - not needed, error line info is not printed for read()
+
+	s = zxc_parse_text_init(buf.v);
+	if (s) goto exec_err;
+	if (IS_BC) {
+		IF_BC(s = zbc_parse_expr(0));
+	} else {
+		IF_DC(s = zdc_parse_exprs_until_eof());
+	}
+	if (s) goto exec_err;
+
+	if (G.prs.lex != XC_LEX_NLINE && G.prs.lex != XC_LEX_EOF) {
+		s = bc_error("bad read() expression");
+		goto exec_err;
+	}
+
+	ip.func = BC_PROG_READ;
+	ip.inst_idx = 0;
+	IF_BC(ip.results_len_before_call = G.prog.results.len;)
+
+	xc_parse_push(XC_INST_RET);
+	bc_vec_push(&G.prog.exestack, &ip);
+
+ exec_err:
+	xc_parse_free();
+	G.prs = sv_parse; // struct copy
+	bc_vec_free(&buf);
+	RETURN_STATUS(s);
+}
+#define zxc_program_read(...) (zxc_program_read(__VA_ARGS__) COMMA_SUCCESS)
+
+static size_t xc_program_index(char *code, size_t *bgn)
+{
+	unsigned char *bytes = (void*)(code + *bgn);
+	unsigned amt;
+	unsigned i;
+	size_t res;
+
+	amt = *bytes++;
+	if (amt < SMALL_INDEX_LIMIT) {
+		*bgn += 1;
+		return amt;
+	}
+	amt -= (SMALL_INDEX_LIMIT - 1); // amt is 1 or more here
+	*bgn += amt + 1;
+
+	res = 0;
+	i = 0;
+	do {
+		res |= (size_t)(*bytes++) << i;
+		i += 8;
+	} while (--amt != 0);
+
+	return res;
+}
+
+static char *xc_program_name(char *code, size_t *bgn)
+{
+	code += *bgn;
+	*bgn += strlen(code) + 1;
+
+	return xstrdup(code);
+}
+
+static void xc_program_printString(const char *str)
+{
+#if ENABLE_DC
+	if (!str[0]) {
+		// Example: echo '[]ap' | dc
+		// should print two bytes: 0x00, 0x0A
+		bb_putchar('\0');
+		return;
+	}
+#endif
+	while (*str) {
+		int c = *str++;
+		if (c != '\\' || !*str)
+			bb_putchar(c);
+		else {
+			c = *str++;
+			switch (c) {
+			case 'a':
+				bb_putchar('\a');
+				break;
+			case 'b':
+				bb_putchar('\b');
+				break;
+			case '\\':
+			case 'e':
+				bb_putchar('\\');
+				break;
+			case 'f':
+				bb_putchar('\f');
+				break;
+			case 'n':
+				bb_putchar('\n');
+				G.prog.nchars = SIZE_MAX;
+				break;
+			case 'r':
+				bb_putchar('\r');
+				break;
+			case 'q':
+				bb_putchar('"');
+				break;
+			case 't':
+				bb_putchar('\t');
+				break;
+			default:
+				// Just print the backslash and following character.
+				bb_putchar('\\');
+				++G.prog.nchars;
+				bb_putchar(c);
+				break;
+			}
+		}
+		++G.prog.nchars;
+	}
+}
+
+static void bc_num_printNewline(void)
+{
+	if (G.prog.nchars == G.prog.len - 1) {
+		bb_putchar('\\');
+		bb_putchar('\n');
+		G.prog.nchars = 0;
+	}
+}
+
+#if ENABLE_DC
+static FAST_FUNC void dc_num_printChar(size_t num, size_t width, bool radix)
+{
+	(void) radix;
+	bb_putchar((char) num);
+	G.prog.nchars += width;
+}
+#endif
+
+static FAST_FUNC void bc_num_printDigits(size_t num, size_t width, bool radix)
+{
+	size_t exp, pow;
+
+	bc_num_printNewline();
+	bb_putchar(radix ? '.' : ' ');
+	++G.prog.nchars;
+
+	bc_num_printNewline();
+	for (exp = 0, pow = 1; exp < width - 1; ++exp, pow *= 10)
+		continue;
+
+	for (exp = 0; exp < width; pow /= 10, ++G.prog.nchars, ++exp) {
+		size_t dig;
+		bc_num_printNewline();
+		dig = num / pow;
+		num -= dig * pow;
+		bb_putchar(((char) dig) + '0');
+	}
+}
+
+static FAST_FUNC void bc_num_printHex(size_t num, size_t width, bool radix)
+{
+	if (radix) {
+		bc_num_printNewline();
+		bb_putchar('.');
+		G.prog.nchars++;
+	}
+
+	bc_num_printNewline();
+	bb_putchar(bb_hexdigits_upcase[num]);
+	G.prog.nchars += width;
+}
+
+static void bc_num_printDecimal(BcNum *n)
+{
+	size_t i, rdx = n->rdx - 1;
+
+	if (n->neg) {
+		bb_putchar('-');
+		G.prog.nchars++;
+	}
+
+	for (i = n->len - 1; i < n->len; --i)
+		bc_num_printHex((size_t) n->num[i], 1, i == rdx);
+}
+
+typedef void (*BcNumDigitOp)(size_t, size_t, bool) FAST_FUNC;
+
+static BC_STATUS zxc_num_printNum(BcNum *n, unsigned base_t, size_t width, BcNumDigitOp print)
+{
+	BcStatus s;
+	BcVec stack;
+	BcNum base;
+	BcDig base_digs[ULONG_NUM_BUFSIZE];
+	BcNum intp, fracp, digit, frac_len;
+	unsigned long dig, *ptr;
+	size_t i;
+	bool radix;
+
+	if (n->len == 0) {
+		print(0, width, false);
+		RETURN_STATUS(BC_STATUS_SUCCESS);
+	}
+
+	bc_vec_init(&stack, sizeof(long), NULL);
+	bc_num_init(&intp, n->len);
+	bc_num_init(&fracp, n->rdx);
+	bc_num_init(&digit, width);
+	bc_num_init(&frac_len, BC_NUM_INT(n));
+	bc_num_copy(&intp, n);
+	bc_num_one(&frac_len);
+	base.cap = ARRAY_SIZE(base_digs);
+	base.num = base_digs;
+	bc_num_ulong2num(&base, base_t);
+
+	bc_num_truncate(&intp, intp.rdx);
+	s = zbc_num_sub(n, &intp, &fracp, 0);
+	if (s) goto err;
+
+	while (intp.len != 0) {
+		s = zbc_num_divmod(&intp, &base, &intp, &digit, 0);
+		if (s) goto err;
+		s = zbc_num_ulong(&digit, &dig);
+		if (s) goto err;
+		bc_vec_push(&stack, &dig);
+	}
+
+	for (i = 0; i < stack.len; ++i) {
+		ptr = bc_vec_item_rev(&stack, i);
+		print(*ptr, width, false);
+	}
+
+	if (!n->rdx) goto err;
+
+	for (radix = true; frac_len.len <= n->rdx; radix = false) {
+		s = zbc_num_mul(&fracp, &base, &fracp, n->rdx);
+		if (s) goto err;
+		s = zbc_num_ulong(&fracp, &dig);
+		if (s) goto err;
+		bc_num_ulong2num(&intp, dig);
+		s = zbc_num_sub(&fracp, &intp, &fracp, 0);
+		if (s) goto err;
+		print(dig, width, radix);
+		s = zbc_num_mul(&frac_len, &base, &frac_len, 0);
+		if (s) goto err;
+	}
+ err:
+	bc_num_free(&frac_len);
+	bc_num_free(&digit);
+	bc_num_free(&fracp);
+	bc_num_free(&intp);
+	bc_vec_free(&stack);
+	RETURN_STATUS(s);
+}
+#define zxc_num_printNum(...) (zxc_num_printNum(__VA_ARGS__) COMMA_SUCCESS)
+
+static BC_STATUS zxc_num_printBase(BcNum *n)
+{
+	BcStatus s;
+	size_t width;
+	BcNumDigitOp print;
+	bool neg = n->neg;
+
+	if (neg) {
+		bb_putchar('-');
+		G.prog.nchars++;
+	}
+
+	n->neg = false;
+
+	if (G.prog.ob_t <= BC_NUM_MAX_IBASE) {
+		width = 1;
+		print = bc_num_printHex;
+	} else {
+		unsigned i = G.prog.ob_t - 1;
+		width = 0;
+		for (;;) {
+			width++;
+			i /= 10;
+			if (i == 0)
+				break;
+		}
+		print = bc_num_printDigits;
+	}
+
+	s = zxc_num_printNum(n, G.prog.ob_t, width, print);
+	n->neg = neg;
+
+	RETURN_STATUS(s);
+}
+#define zxc_num_printBase(...) (zxc_num_printBase(__VA_ARGS__) COMMA_SUCCESS)
+
+static BC_STATUS zxc_num_print(BcNum *n, bool newline)
+{
+	BcStatus s = BC_STATUS_SUCCESS;
+
+	bc_num_printNewline();
+
+	if (n->len == 0) {
+		bb_putchar('0');
+		++G.prog.nchars;
+	} else if (G.prog.ob_t == 10)
+		bc_num_printDecimal(n);
+	else
+		s = zxc_num_printBase(n);
+
+	if (newline) {
+		bb_putchar('\n');
+		G.prog.nchars = 0;
+	}
+
+	RETURN_STATUS(s);
+}
+#define zxc_num_print(...) (zxc_num_print(__VA_ARGS__) COMMA_SUCCESS)
+
+static BC_STATUS zxc_program_print(char inst, size_t idx)
+{
+	BcStatus s;
+	BcResult *r;
+	BcNum *num;
+	bool pop = (inst != XC_INST_PRINT);
+
+	if (!STACK_HAS_MORE_THAN(&G.prog.results, idx))
+		RETURN_STATUS(bc_error_stack_has_too_few_elements());
+
+	r = bc_vec_item_rev(&G.prog.results, idx);
+	s = zxc_program_num(r, &num);
+	if (s) RETURN_STATUS(s);
+
+	if (BC_PROG_NUM(r, num)) {
+		s = zxc_num_print(num, !pop);
+#if ENABLE_BC
+		if (!s && IS_BC) bc_num_copy(&G.prog.last, num);
+#endif
+	} else {
+		char *str;
+
+		idx = (r->t == XC_RESULT_STR) ? r->d.id.idx : num->rdx;
+		str = *xc_program_str(idx);
+
+		if (inst == XC_INST_PRINT_STR) {
+			for (;;) {
+				char c = *str++;
+				if (c == '\0') break;
+				bb_putchar(c);
+				++G.prog.nchars;
+				if (c == '\n') G.prog.nchars = 0;
+			}
+		} else {
+			xc_program_printString(str);
+			if (inst == XC_INST_PRINT) bb_putchar('\n');
+		}
+	}
+
+	if (!s && pop) bc_vec_pop(&G.prog.results);
+
+	RETURN_STATUS(s);
+}
+#define zxc_program_print(...) (zxc_program_print(__VA_ARGS__) COMMA_SUCCESS)
+
+static BC_STATUS zxc_program_negate(void)
+{
+	BcStatus s;
+	BcResult res, *ptr;
+	BcNum *num;
+
+	s = zxc_program_prep(&ptr, &num);
+	if (s) RETURN_STATUS(s);
+
+	bc_num_init(&res.d.n, num->len);
+	bc_num_copy(&res.d.n, num);
+	if (res.d.n.len) res.d.n.neg = !res.d.n.neg;
+
+	xc_program_retire(&res, XC_RESULT_TEMP);
+
+	RETURN_STATUS(s);
+}
+#define zxc_program_negate(...) (zxc_program_negate(__VA_ARGS__) COMMA_SUCCESS)
+
+static BC_STATUS zxc_program_logical(char inst)
+{
+	BcStatus s;
+	BcResult *opd1, *opd2, res;
+	BcNum *n1, *n2;
+	ssize_t cond;
+
+	s = zxc_program_binOpPrep(&opd1, &n1, &opd2, &n2, false);
+	if (s) RETURN_STATUS(s);
+
+	bc_num_init_DEF_SIZE(&res.d.n);
+
+	if (inst == XC_INST_BOOL_AND)
+		cond = bc_num_cmp(n1, &G.prog.zero) && bc_num_cmp(n2, &G.prog.zero);
+	else if (inst == XC_INST_BOOL_OR)
+		cond = bc_num_cmp(n1, &G.prog.zero) || bc_num_cmp(n2, &G.prog.zero);
+	else {
+		cond = bc_num_cmp(n1, n2);
+		switch (inst) {
+		case XC_INST_REL_EQ:
+			cond = (cond == 0);
+			break;
+		case XC_INST_REL_LE:
+			cond = (cond <= 0);
+			break;
+		case XC_INST_REL_GE:
+			cond = (cond >= 0);
+			break;
+		case XC_INST_REL_LT:
+			cond = (cond < 0);
+			break;
+		case XC_INST_REL_GT:
+			cond = (cond > 0);
+			break;
+		default: // = case XC_INST_REL_NE:
+			//cond = (cond != 0); - not needed
+			break;
+		}
+	}
+
+	if (cond) bc_num_one(&res.d.n);
+	//else bc_num_zero(&res.d.n); - already is
+
+	xc_program_binOpRetire(&res);
+
+	RETURN_STATUS(s);
+}
+#define zxc_program_logical(...) (zxc_program_logical(__VA_ARGS__) COMMA_SUCCESS)
+
+#if ENABLE_DC
+static BC_STATUS zdc_program_assignStr(BcResult *r, BcVec *v, bool push)
+{
+	BcNum n2;
+	BcResult res;
+
+	memset(&n2, 0, sizeof(BcNum));
+	n2.rdx = res.d.id.idx = r->d.id.idx;
+	res.t = XC_RESULT_STR;
+
+	if (!push) {
+		if (!STACK_HAS_MORE_THAN(&G.prog.results, 1))
+			RETURN_STATUS(bc_error_stack_has_too_few_elements());
+		bc_vec_pop(v);
+		bc_vec_pop(&G.prog.results);
+	}
+
+	bc_result_pop_and_push(&res);
+	bc_vec_push(v, &n2);
+
+	RETURN_STATUS(BC_STATUS_SUCCESS);
+}
+#define zdc_program_assignStr(...) (zdc_program_assignStr(__VA_ARGS__) COMMA_SUCCESS)
+#endif // ENABLE_DC
+
+static BC_STATUS zxc_program_copyToVar(char *name, bool var)
+{
+	BcStatus s;
+	BcResult *ptr, r;
+	BcVec *v;
+	BcNum *n;
+
+	if (!STACK_HAS_MORE_THAN(&G.prog.results, 0))
+		RETURN_STATUS(bc_error_stack_has_too_few_elements());
+
+	ptr = bc_vec_top(&G.prog.results);
+	if ((ptr->t == XC_RESULT_ARRAY) != !var)
+		RETURN_STATUS(bc_error_variable_is_wrong_type());
+	v = xc_program_search(name, var);
+
+#if ENABLE_DC
+	if (ptr->t == XC_RESULT_STR && !var)
+		RETURN_STATUS(bc_error_variable_is_wrong_type());
+	if (ptr->t == XC_RESULT_STR)
+		RETURN_STATUS(zdc_program_assignStr(ptr, v, true));
+#endif
+
+	s = zxc_program_num(ptr, &n);
+	if (s) RETURN_STATUS(s);
+
+	// Do this once more to make sure that pointers were not invalidated.
+	v = xc_program_search(name, var);
+
+	if (var) {
+		bc_num_init_DEF_SIZE(&r.d.n);
+		bc_num_copy(&r.d.n, n);
+	} else {
+		bc_array_init(&r.d.v, true);
+		bc_array_copy(&r.d.v, (BcVec *) n);
+	}
+
+	bc_vec_push(v, &r.d);
+	bc_vec_pop(&G.prog.results);
+
+	RETURN_STATUS(s);
+}
+#define zxc_program_copyToVar(...) (zxc_program_copyToVar(__VA_ARGS__) COMMA_SUCCESS)
+
+static BC_STATUS zxc_program_assign(char inst)
+{
+	BcStatus s;
+	BcResult *left, *right, res;
+	BcNum *l, *r;
+	bool assign = (inst == XC_INST_ASSIGN);
+	bool ib, sc;
+
+	s = zxc_program_binOpPrep(&left, &l, &right, &r, assign);
+	if (s) RETURN_STATUS(s);
+
+	ib = left->t == XC_RESULT_IBASE;
+	sc = left->t == XC_RESULT_SCALE;
+
+#if ENABLE_DC
+	if (right->t == XC_RESULT_STR) {
+		BcVec *v;
+
+		if (left->t != XC_RESULT_VAR)
+			RETURN_STATUS(bc_error_variable_is_wrong_type());
+		v = xc_program_search(left->d.id.name, true);
+
+		RETURN_STATUS(zdc_program_assignStr(right, v, false));
+	}
+#endif
+
+	if (left->t == XC_RESULT_CONSTANT || left->t == XC_RESULT_TEMP)
+		RETURN_STATUS(bc_error("bad assignment:"
+				" left side must be variable"
+				" or array element"
+		)); // note: shared string
+
+#if ENABLE_BC
+	if (inst == BC_INST_ASSIGN_DIVIDE && !bc_num_cmp(r, &G.prog.zero))
+		RETURN_STATUS(bc_error("divide by zero"));
+
+	if (assign)
+		bc_num_copy(l, r);
+	else {
+		s = BC_STATUS_SUCCESS;
+		IF_ERROR_RETURN_POSSIBLE(s =) zxc_program_ops[inst - BC_INST_ASSIGN_POWER](l, r, l, G.prog.scale);
+	}
+	if (s) RETURN_STATUS(s);
+#else
+	bc_num_copy(l, r);
+#endif
+
+	if (ib || sc || left->t == XC_RESULT_OBASE) {
+		static const char *const msg[] = {
+			"bad ibase; must be [2,16]",                 //XC_RESULT_IBASE
+			"bad obase; must be [2,"BC_MAX_OBASE_STR"]", //XC_RESULT_OBASE
+			"bad scale; must be [0,"BC_MAX_SCALE_STR"]", //XC_RESULT_SCALE
+		};
+		size_t *ptr;
+		size_t max;
+		unsigned long val;
+
+		s = zbc_num_ulong(l, &val);
+		if (s) RETURN_STATUS(s);
+		s = left->t - XC_RESULT_IBASE;
+		if (sc) {
+			max = BC_MAX_SCALE;
+			ptr = &G.prog.scale;
+		} else {
+			if (val < 2)
+				RETURN_STATUS(bc_error(msg[s]));
+			max = ib ? BC_NUM_MAX_IBASE : BC_MAX_OBASE;
+			ptr = ib ? &G.prog.ib_t : &G.prog.ob_t;
+		}
+
+		if (val > max)
+			RETURN_STATUS(bc_error(msg[s]));
+
+		*ptr = (size_t) val;
+		s = BC_STATUS_SUCCESS;
+	}
+
+	bc_num_init(&res.d.n, l->len);
+	bc_num_copy(&res.d.n, l);
+	xc_program_binOpRetire(&res);
+
+	RETURN_STATUS(s);
+}
+#define zxc_program_assign(...) (zxc_program_assign(__VA_ARGS__) COMMA_SUCCESS)
+
+#if !ENABLE_DC
+#define xc_program_pushVar(code, bgn, pop, copy) \
+	xc_program_pushVar(code, bgn)
+// for bc, 'pop' and 'copy' are always false
+#endif
+static BC_STATUS xc_program_pushVar(char *code, size_t *bgn,
+                                   bool pop, bool copy)
+{
+	BcResult r;
+	char *name = xc_program_name(code, bgn);
+
+	r.t = XC_RESULT_VAR;
+	r.d.id.name = name;
+
+#if ENABLE_DC
+	if (pop || copy) {
+		BcVec *v = xc_program_search(name, true);
+		BcNum *num = bc_vec_top(v);
+
+		free(name);
+		if (!STACK_HAS_MORE_THAN(v, 1 - copy)) {
+			RETURN_STATUS(bc_error_stack_has_too_few_elements());
+		}
+
+		if (!BC_PROG_STR(num)) {
+			r.t = XC_RESULT_TEMP;
+			bc_num_init_DEF_SIZE(&r.d.n);
+			bc_num_copy(&r.d.n, num);
+		} else {
+			r.t = XC_RESULT_STR;
+			r.d.id.idx = num->rdx;
+		}
+
+		if (!copy) bc_vec_pop(v);
+	}
+#endif // ENABLE_DC
+
+	bc_vec_push(&G.prog.results, &r);
+
+	RETURN_STATUS(BC_STATUS_SUCCESS);
+}
+#define zxc_program_pushVar(...) (xc_program_pushVar(__VA_ARGS__) COMMA_SUCCESS)
+
+static BC_STATUS zbc_program_pushArray(char *code, size_t *bgn, char inst)
+{
+	BcStatus s = BC_STATUS_SUCCESS;
+	BcResult r;
+	BcNum *num;
+
+	r.d.id.name = xc_program_name(code, bgn);
+
+	if (inst == XC_INST_ARRAY) {
+		r.t = XC_RESULT_ARRAY;
+		bc_vec_push(&G.prog.results, &r);
+	} else {
+		BcResult *operand;
+		unsigned long temp;
+
+		s = zxc_program_prep(&operand, &num);
+		if (s) goto err;
+		s = zbc_num_ulong(num, &temp);
+		if (s) goto err;
+
+		if (temp > BC_MAX_DIM) {
+			s = bc_error("array too long; must be [1,"BC_MAX_DIM_STR"]");
+			goto err;
+		}
+
+		r.d.id.idx = (size_t) temp;
+		xc_program_retire(&r, XC_RESULT_ARRAY_ELEM);
+	}
+ err:
+	if (s) free(r.d.id.name);
+	RETURN_STATUS(s);
+}
+#define zbc_program_pushArray(...) (zbc_program_pushArray(__VA_ARGS__) COMMA_SUCCESS)
+
+#if ENABLE_BC
+static BC_STATUS zbc_program_incdec(char inst)
+{
+	BcStatus s;
+	BcResult *ptr, res, copy;
+	BcNum *num;
+	char inst2 = inst;
+
+	s = zxc_program_prep(&ptr, &num);
+	if (s) RETURN_STATUS(s);
+
+	if (inst == BC_INST_INC_POST || inst == BC_INST_DEC_POST) {
+		copy.t = XC_RESULT_TEMP;
+		bc_num_init(&copy.d.n, num->len);
+		bc_num_copy(&copy.d.n, num);
+	}
+
+	res.t = BC_RESULT_ONE;
+	inst = (inst == BC_INST_INC_PRE || inst == BC_INST_INC_POST)
+			? BC_INST_ASSIGN_PLUS
+			: BC_INST_ASSIGN_MINUS;
+
+	bc_vec_push(&G.prog.results, &res);
+	s = zxc_program_assign(inst);
+	if (s) RETURN_STATUS(s);
+
+	if (inst2 == BC_INST_INC_POST || inst2 == BC_INST_DEC_POST) {
+		bc_result_pop_and_push(&copy);
+	}
+
+	RETURN_STATUS(s);
+}
+#define zbc_program_incdec(...) (zbc_program_incdec(__VA_ARGS__) COMMA_SUCCESS)
+
+static BC_STATUS zbc_program_call(char *code, size_t *idx)
+{
+	BcInstPtr ip;
+	size_t i, nparams;
+	BcFunc *func;
+	BcId *a;
+	BcResult *arg;
+
+	nparams = xc_program_index(code, idx);
+	ip.inst_idx = 0;
+	ip.func = xc_program_index(code, idx);
+	func = xc_program_func(ip.func);
+
+	if (func->code.len == 0) {
+		RETURN_STATUS(bc_error("undefined function"));
+	}
+	if (nparams != func->nparams) {
+		RETURN_STATUS(bc_error_fmt("function has %u parameters, but called with %u", func->nparams, nparams));
+	}
+	ip.results_len_before_call = G.prog.results.len - nparams;
+
+	for (i = 0; i < nparams; ++i) {
+		BcStatus s;
+
+		a = bc_vec_item(&func->autos, nparams - 1 - i);
+		arg = bc_vec_top(&G.prog.results);
+
+		if ((!a->idx) != (arg->t == XC_RESULT_ARRAY) || arg->t == XC_RESULT_STR)
+			RETURN_STATUS(bc_error_variable_is_wrong_type());
+
+		s = zxc_program_copyToVar(a->name, a->idx);
+		if (s) RETURN_STATUS(s);
+	}
+
+	a = bc_vec_item(&func->autos, i);
+	for (; i < func->autos.len; i++, a++) {
+		BcVec *v;
+
+		v = xc_program_search(a->name, a->idx);
+		if (a->idx) {
+			BcNum n2;
+			bc_num_init_DEF_SIZE(&n2);
+			bc_vec_push(v, &n2);
+		} else {
+			BcVec v2;
+			bc_array_init(&v2, true);
+			bc_vec_push(v, &v2);
+		}
+	}
+
+	bc_vec_push(&G.prog.exestack, &ip);
+
+	RETURN_STATUS(BC_STATUS_SUCCESS);
+}
+#define zbc_program_call(...) (zbc_program_call(__VA_ARGS__) COMMA_SUCCESS)
+
+static BC_STATUS zbc_program_return(char inst)
+{
+	BcResult res;
+	BcFunc *f;
+	BcId *a;
+	size_t i;
+	BcInstPtr *ip = bc_vec_top(&G.prog.exestack);
+
+	if (!STACK_HAS_EQUAL_OR_MORE_THAN(&G.prog.results, ip->results_len_before_call + (inst == XC_INST_RET)))
+		RETURN_STATUS(bc_error_stack_has_too_few_elements());
+
+	f = xc_program_func(ip->func);
+	res.t = XC_RESULT_TEMP;
+
+	if (inst == XC_INST_RET) {
+		BcStatus s;
+		BcNum *num;
+		BcResult *operand = bc_vec_top(&G.prog.results);
+
+		s = zxc_program_num(operand, &num);
+		if (s) RETURN_STATUS(s);
+		bc_num_init(&res.d.n, num->len);
+		bc_num_copy(&res.d.n, num);
+	} else {
+		bc_num_init_DEF_SIZE(&res.d.n);
+		//bc_num_zero(&res.d.n); - already is
+	}
+
+	// We need to pop arguments as well, so this takes that into account.
+	a = (void*)f->autos.v;
+	for (i = 0; i < f->autos.len; i++, a++) {
+		BcVec *v;
+		v = xc_program_search(a->name, a->idx);
+		bc_vec_pop(v);
+	}
+
+	bc_vec_npop(&G.prog.results, G.prog.results.len - ip->results_len_before_call);
+	bc_vec_push(&G.prog.results, &res);
+	bc_vec_pop(&G.prog.exestack);
+
+	RETURN_STATUS(BC_STATUS_SUCCESS);
+}
+#define zbc_program_return(...) (zbc_program_return(__VA_ARGS__) COMMA_SUCCESS)
+#endif // ENABLE_BC
+
+static unsigned long xc_program_scale(BcNum *n)
+{
+	return (unsigned long) n->rdx;
+}
+
+static unsigned long xc_program_len(BcNum *n)
+{
+	size_t len = n->len;
+
+	if (n->rdx != len) return len;
+	for (;;) {
+		if (len == 0) break;
+		len--;
+		if (n->num[len] != 0) break;
+	}
+	return len;
+}
+
+static BC_STATUS zxc_program_builtin(char inst)
+{
+	BcStatus s;
+	BcResult *opnd;
+	BcNum *num;
+	BcResult res;
+	bool len = (inst == XC_INST_LENGTH);
+
+	if (!STACK_HAS_MORE_THAN(&G.prog.results, 0))
+		RETURN_STATUS(bc_error_stack_has_too_few_elements());
+	opnd = bc_vec_top(&G.prog.results);
+
+	s = zxc_program_num(opnd, &num);
+	if (s) RETURN_STATUS(s);
+
+#if ENABLE_DC
+	if (!BC_PROG_NUM(opnd, num) && !len)
+		RETURN_STATUS(bc_error_variable_is_wrong_type());
+#endif
+
+	bc_num_init_DEF_SIZE(&res.d.n);
+
+	if (inst == XC_INST_SQRT)
+		s = zbc_num_sqrt(num, &res.d.n, G.prog.scale);
+#if ENABLE_BC
+	else if (len != 0 && opnd->t == XC_RESULT_ARRAY) {
+		bc_num_ulong2num(&res.d.n, (unsigned long) ((BcVec *) num)->len);
+	}
+#endif
+#if ENABLE_DC
+	else if (len != 0 && !BC_PROG_NUM(opnd, num)) {
+		char **str;
+		size_t idx = opnd->t == XC_RESULT_STR ? opnd->d.id.idx : num->rdx;
+
+		str = xc_program_str(idx);
+		bc_num_ulong2num(&res.d.n, strlen(*str));
+	}
+#endif
+	else {
+		bc_num_ulong2num(&res.d.n, len ? xc_program_len(num) : xc_program_scale(num));
+	}
+
+	xc_program_retire(&res, XC_RESULT_TEMP);
+
+	RETURN_STATUS(s);
+}
+#define zxc_program_builtin(...) (zxc_program_builtin(__VA_ARGS__) COMMA_SUCCESS)
+
+#if ENABLE_DC
+static BC_STATUS zdc_program_divmod(void)
+{
+	BcStatus s;
+	BcResult *opd1, *opd2, res, res2;
+	BcNum *n1, *n2;
+
+	s = zxc_program_binOpPrep(&opd1, &n1, &opd2, &n2, false);
+	if (s) RETURN_STATUS(s);
+
+	bc_num_init_DEF_SIZE(&res.d.n);
+	bc_num_init(&res2.d.n, n2->len);
+
+	s = zbc_num_divmod(n1, n2, &res2.d.n, &res.d.n, G.prog.scale);
+	if (s) goto err;
+
+	xc_program_binOpRetire(&res2);
+	res.t = XC_RESULT_TEMP;
+	bc_vec_push(&G.prog.results, &res);
+
+	RETURN_STATUS(s);
+ err:
+	bc_num_free(&res2.d.n);
+	bc_num_free(&res.d.n);
+	RETURN_STATUS(s);
+}
+#define zdc_program_divmod(...) (zdc_program_divmod(__VA_ARGS__) COMMA_SUCCESS)
+
+static BC_STATUS zdc_program_modexp(void)
+{
+	BcStatus s;
+	BcResult *r1, *r2, *r3, res;
+	BcNum *n1, *n2, *n3;
+
+	if (!STACK_HAS_MORE_THAN(&G.prog.results, 2))
+		RETURN_STATUS(bc_error_stack_has_too_few_elements());
+	s = zxc_program_binOpPrep(&r2, &n2, &r3, &n3, false);
+	if (s) RETURN_STATUS(s);
+
+	r1 = bc_vec_item_rev(&G.prog.results, 2);
+	s = zxc_program_num(r1, &n1);
+	if (s) RETURN_STATUS(s);
+	if (!BC_PROG_NUM(r1, n1))
+		RETURN_STATUS(bc_error_variable_is_wrong_type());
+
+	// Make sure that the values have their pointers updated, if necessary.
+	if (r1->t == XC_RESULT_VAR || r1->t == XC_RESULT_ARRAY_ELEM) {
+		if (r1->t == r2->t) {
+			s = zxc_program_num(r2, &n2);
+			if (s) RETURN_STATUS(s);
+		}
+		if (r1->t == r3->t) {
+			s = zxc_program_num(r3, &n3);
+			if (s) RETURN_STATUS(s);
+		}
+	}
+
+	bc_num_init(&res.d.n, n3->len);
+	s = zdc_num_modexp(n1, n2, n3, &res.d.n);
+	if (s) goto err;
+
+	bc_vec_pop(&G.prog.results);
+	xc_program_binOpRetire(&res);
+
+	RETURN_STATUS(s);
+ err:
+	bc_num_free(&res.d.n);
+	RETURN_STATUS(s);
+}
+#define zdc_program_modexp(...) (zdc_program_modexp(__VA_ARGS__) COMMA_SUCCESS)
+
+static void dc_program_stackLen(void)
+{
+	BcResult res;
+	size_t len = G.prog.results.len;
+
+	res.t = XC_RESULT_TEMP;
+
+	bc_num_init_DEF_SIZE(&res.d.n);
+	bc_num_ulong2num(&res.d.n, len);
+	bc_vec_push(&G.prog.results, &res);
+}
+
+static BC_STATUS zdc_program_asciify(void)
+{
+	BcStatus s;
+	BcResult *r, res;
+	BcNum *num, n;
+	char **strs;
+	char *str;
+	char c;
+	size_t idx;
+
+	if (!STACK_HAS_MORE_THAN(&G.prog.results, 0))
+		RETURN_STATUS(bc_error_stack_has_too_few_elements());
+
+	r = bc_vec_top(&G.prog.results);
+	s = zxc_program_num(r, &num);
+	if (s) RETURN_STATUS(s);
+
+	if (BC_PROG_NUM(r, num)) {
+		unsigned long val;
+		BcNum strmb;
+		BcDig strmb_digs[ULONG_NUM_BUFSIZE];
+
+		bc_num_init_DEF_SIZE(&n);
+		bc_num_copy(&n, num);
+		bc_num_truncate(&n, n.rdx);
+
+		strmb.cap = ARRAY_SIZE(strmb_digs);
+		strmb.num = strmb_digs;
+		bc_num_ulong2num(&strmb, 0x100);
+
+		s = zbc_num_mod(&n, &strmb, &n, 0);
+		if (s) goto num_err;
+		s = zbc_num_ulong(&n, &val);
+		if (s) goto num_err;
+
+		c = (char) val;
+
+		bc_num_free(&n);
+	} else {
+		char *sp;
+		idx = (r->t == XC_RESULT_STR) ? r->d.id.idx : num->rdx;
+		sp = *xc_program_str(idx);
+		c = sp[0];
+	}
+
+	strs = (void*)G.prog.strs.v;
+	for (idx = 0; idx < G.prog.strs.len; idx++) {
+		if (strs[idx][0] == c && strs[idx][1] == '\0') {
+			goto dup;
+		}
+	}
+	str = xzalloc(2);
+	str[0] = c;
+	//str[1] = '\0'; - already is
+	bc_vec_push(&G.prog.strs, &str);
+ dup:
+	res.t = XC_RESULT_STR;
+	res.d.id.idx = idx;
+	bc_result_pop_and_push(&res);
+
+	RETURN_STATUS(BC_STATUS_SUCCESS);
+ num_err:
+	bc_num_free(&n);
+	RETURN_STATUS(s);
+}
+#define zdc_program_asciify(...) (zdc_program_asciify(__VA_ARGS__) COMMA_SUCCESS)
+
+static BC_STATUS zdc_program_printStream(void)
+{
+	BcStatus s;
+	BcResult *r;
+	BcNum *n;
+	size_t idx;
+
+	if (!STACK_HAS_MORE_THAN(&G.prog.results, 0))
+		RETURN_STATUS(bc_error_stack_has_too_few_elements());
+	r = bc_vec_top(&G.prog.results);
+
+	s = zxc_program_num(r, &n);
+	if (s) RETURN_STATUS(s);
+
+	if (BC_PROG_NUM(r, n)) {
+		s = zxc_num_printNum(n, 0x100, 1, dc_num_printChar);
+	} else {
+		char *str;
+		idx = (r->t == XC_RESULT_STR) ? r->d.id.idx : n->rdx;
+		str = *xc_program_str(idx);
+		fputs(str, stdout);
+	}
+
+	RETURN_STATUS(s);
+}
+#define zdc_program_printStream(...) (zdc_program_printStream(__VA_ARGS__) COMMA_SUCCESS)
+
+static BC_STATUS zdc_program_nquit(void)
+{
+	BcStatus s;
+	BcResult *opnd;
+	BcNum *num;
+	unsigned long val;
+
+	s = zxc_program_prep(&opnd, &num);
+	if (s) RETURN_STATUS(s);
+	s = zbc_num_ulong(num, &val);
+	if (s) RETURN_STATUS(s);
+
+	bc_vec_pop(&G.prog.results);
+
+	if (G.prog.exestack.len < val)
+		RETURN_STATUS(bc_error_stack_has_too_few_elements());
+	if (G.prog.exestack.len == val) {
+		QUIT_OR_RETURN_TO_MAIN;
+	}
+
+	bc_vec_npop(&G.prog.exestack, val);
+
+	RETURN_STATUS(s);
+}
+#define zdc_program_nquit(...) (zdc_program_nquit(__VA_ARGS__) COMMA_SUCCESS)
+
+static BC_STATUS zdc_program_execStr(char *code, size_t *bgn, bool cond)
+{
+	BcStatus s = BC_STATUS_SUCCESS;
+	BcResult *r;
+	BcFunc *f;
+	BcInstPtr ip;
+	size_t fidx, sidx;
+
+	if (!STACK_HAS_MORE_THAN(&G.prog.results, 0))
+		RETURN_STATUS(bc_error_stack_has_too_few_elements());
+
+	r = bc_vec_top(&G.prog.results);
+
+	if (cond) {
+		BcNum *n = n; // for compiler
+		bool exec;
+		char *name;
+		char *then_name = xc_program_name(code, bgn);
+		char *else_name = NULL;
+
+		if (code[*bgn] == '\0')
+			(*bgn) += 1;
+		else
+			else_name = xc_program_name(code, bgn);
+
+		exec = r->d.n.len != 0;
+		name = then_name;
+		if (!exec && else_name != NULL) {
+			exec = true;
+			name = else_name;
+		}
+
+		if (exec) {
+			BcVec *v;
+			v = xc_program_search(name, true);
+			n = bc_vec_top(v);
+		}
+
+		free(then_name);
+		free(else_name);
+
+		if (!exec) goto exit;
+		if (!BC_PROG_STR(n)) {
+			s = bc_error_variable_is_wrong_type();
+			goto exit;
+		}
+
+		sidx = n->rdx;
+	} else {
+		if (r->t == XC_RESULT_STR) {
+			sidx = r->d.id.idx;
+		} else if (r->t == XC_RESULT_VAR) {
+			BcNum *n;
+			s = zxc_program_num(r, &n);
+			if (s || !BC_PROG_STR(n)) goto exit;
+			sidx = n->rdx;
+		} else
+			goto exit;
+	}
+
+	fidx = sidx + BC_PROG_REQ_FUNCS;
+
+	f = xc_program_func(fidx);
+
+	if (f->code.len == 0) {
+		BcParse sv_parse;
+		char *str;
+
+		sv_parse = G.prs; // struct copy
+		xc_parse_create(fidx);
+		str = *xc_program_str(sidx);
+		s = zxc_parse_text_init(str);
+		if (s) goto err;
+
+		s = zdc_parse_exprs_until_eof();
+		if (s) goto err;
+		xc_parse_push(DC_INST_POP_EXEC);
+		if (G.prs.lex != XC_LEX_EOF)
+			s = bc_error_bad_expression();
+		xc_parse_free();
+		G.prs = sv_parse; // struct copy
+		if (s) {
+ err:
+			bc_vec_pop_all(&f->code);
+			goto exit;
+		}
+	}
+
+	ip.inst_idx = 0;
+	ip.func = fidx;
+
+	bc_vec_pop(&G.prog.results);
+	bc_vec_push(&G.prog.exestack, &ip);
+
+	RETURN_STATUS(BC_STATUS_SUCCESS);
+ exit:
+	bc_vec_pop(&G.prog.results);
+	RETURN_STATUS(s);
+}
+#define zdc_program_execStr(...) (zdc_program_execStr(__VA_ARGS__) COMMA_SUCCESS)
+#endif // ENABLE_DC
+
+static void xc_program_pushGlobal(char inst)
+{
+	BcResult res;
+	unsigned long val;
+
+	res.t = inst - XC_INST_IBASE + XC_RESULT_IBASE;
+	if (inst == XC_INST_IBASE)
+		val = (unsigned long) G.prog.ib_t;
+	else if (inst == XC_INST_SCALE)
+		val = (unsigned long) G.prog.scale;
+	else
+		val = (unsigned long) G.prog.ob_t;
+
+	bc_num_init_DEF_SIZE(&res.d.n);
+	bc_num_ulong2num(&res.d.n, val);
+	bc_vec_push(&G.prog.results, &res);
+}
+
+static BC_STATUS zxc_program_exec(void)
+{
+	BcResult r, *ptr;
+	BcInstPtr *ip = bc_vec_top(&G.prog.exestack);
+	BcFunc *func = xc_program_func(ip->func);
+	char *code = func->code.v;
+
+	dbg_exec("func:%zd bytes:%zd ip:%zd results.len:%d",
+			ip->func, func->code.len, ip->inst_idx, G.prog.results.len);
+	while (ip->inst_idx < func->code.len) {
+		BcStatus s = BC_STATUS_SUCCESS;
+		char inst = code[ip->inst_idx++];
+
+		dbg_exec("inst at %zd:%d results.len:%d", ip->inst_idx - 1, inst, G.prog.results.len);
+		switch (inst) {
+#if ENABLE_BC
+		case BC_INST_JUMP_ZERO: {
+			BcNum *num;
+			bool zero;
+			dbg_exec("BC_INST_JUMP_ZERO:");
+			s = zxc_program_prep(&ptr, &num);
+			if (s) RETURN_STATUS(s);
+			zero = (bc_num_cmp(num, &G.prog.zero) == 0);
+			bc_vec_pop(&G.prog.results);
+			if (!zero) {
+				xc_program_index(code, &ip->inst_idx);
+				break;
+			}
+			// else: fall through
+		}
+		case BC_INST_JUMP: {
+			size_t idx = xc_program_index(code, &ip->inst_idx);
+			size_t *addr = bc_vec_item(&func->labels, idx);
+			dbg_exec("BC_INST_JUMP: to %ld", (long)*addr);
+			ip->inst_idx = *addr;
+			break;
+		}
+		case BC_INST_CALL:
+			dbg_exec("BC_INST_CALL:");
+			s = zbc_program_call(code, &ip->inst_idx);
+			goto read_updated_ip;
+		case BC_INST_INC_PRE:
+		case BC_INST_DEC_PRE:
+		case BC_INST_INC_POST:
+		case BC_INST_DEC_POST:
+			dbg_exec("BC_INST_INCDEC:");
+			s = zbc_program_incdec(inst);
+			break;
+		case BC_INST_HALT:
+			dbg_exec("BC_INST_HALT:");
+			QUIT_OR_RETURN_TO_MAIN;
+			break;
+		case XC_INST_RET:
+		case BC_INST_RET0:
+			dbg_exec("BC_INST_RET[0]:");
+			s = zbc_program_return(inst);
+			goto read_updated_ip;
+		case XC_INST_BOOL_OR:
+		case XC_INST_BOOL_AND:
+#endif // ENABLE_BC
+		case XC_INST_REL_EQ:
+		case XC_INST_REL_LE:
+		case XC_INST_REL_GE:
+		case XC_INST_REL_NE:
+		case XC_INST_REL_LT:
+		case XC_INST_REL_GT:
+			dbg_exec("BC_INST_BOOL:");
+			s = zxc_program_logical(inst);
+			break;
+		case XC_INST_READ:
+			dbg_exec("XC_INST_READ:");
+			s = zxc_program_read();
+			goto read_updated_ip;
+		case XC_INST_VAR:
+			dbg_exec("XC_INST_VAR:");
+			s = zxc_program_pushVar(code, &ip->inst_idx, false, false);
+			break;
+		case XC_INST_ARRAY_ELEM:
+		case XC_INST_ARRAY:
+			dbg_exec("XC_INST_ARRAY[_ELEM]:");
+			s = zbc_program_pushArray(code, &ip->inst_idx, inst);
+			break;
+#if ENABLE_BC
+		case BC_INST_LAST:
+			dbg_exec("BC_INST_LAST:");
+			r.t = BC_RESULT_LAST;
+			bc_vec_push(&G.prog.results, &r);
+			break;
+#endif
+		case XC_INST_IBASE:
+		case XC_INST_OBASE:
+		case XC_INST_SCALE:
+			dbg_exec("XC_INST_internalvar(%d):", inst - XC_INST_IBASE);
+			xc_program_pushGlobal(inst);
+			break;
+		case XC_INST_SCALE_FUNC:
+		case XC_INST_LENGTH:
+		case XC_INST_SQRT:
+			dbg_exec("BC_INST_builtin:");
+			s = zxc_program_builtin(inst);
+			break;
+		case XC_INST_NUM:
+			dbg_exec("XC_INST_NUM:");
+			r.t = XC_RESULT_CONSTANT;
+			r.d.id.idx = xc_program_index(code, &ip->inst_idx);
+			bc_vec_push(&G.prog.results, &r);
+			break;
+		case XC_INST_POP:
+			dbg_exec("XC_INST_POP:");
+			if (!STACK_HAS_MORE_THAN(&G.prog.results, 0))
+				s = bc_error_stack_has_too_few_elements();
+			else
+				bc_vec_pop(&G.prog.results);
+			break;
+		case XC_INST_PRINT:
+		case XC_INST_PRINT_POP:
+		case XC_INST_PRINT_STR:
+			dbg_exec("XC_INST_PRINTxyz:");
+			s = zxc_program_print(inst, 0);
+			break;
+		case XC_INST_STR:
+			dbg_exec("XC_INST_STR:");
+			r.t = XC_RESULT_STR;
+			r.d.id.idx = xc_program_index(code, &ip->inst_idx);
+			bc_vec_push(&G.prog.results, &r);
+			break;
+		case XC_INST_POWER:
+		case XC_INST_MULTIPLY:
+		case XC_INST_DIVIDE:
+		case XC_INST_MODULUS:
+		case XC_INST_PLUS:
+		case XC_INST_MINUS:
+			dbg_exec("BC_INST_binaryop:");
+			s = zxc_program_op(inst);
+			break;
+		case XC_INST_BOOL_NOT: {
+			BcNum *num;
+			dbg_exec("XC_INST_BOOL_NOT:");
+			s = zxc_program_prep(&ptr, &num);
+			if (s) RETURN_STATUS(s);
+			bc_num_init_DEF_SIZE(&r.d.n);
+			if (bc_num_cmp(num, &G.prog.zero) == 0)
+				bc_num_one(&r.d.n);
+			//else bc_num_zero(&r.d.n); - already is
+			xc_program_retire(&r, XC_RESULT_TEMP);
+			break;
+		}
+		case XC_INST_NEG:
+			dbg_exec("XC_INST_NEG:");
+			s = zxc_program_negate();
+			break;
+#if ENABLE_BC
+		case BC_INST_ASSIGN_POWER:
+		case BC_INST_ASSIGN_MULTIPLY:
+		case BC_INST_ASSIGN_DIVIDE:
+		case BC_INST_ASSIGN_MODULUS:
+		case BC_INST_ASSIGN_PLUS:
+		case BC_INST_ASSIGN_MINUS:
+#endif
+		case XC_INST_ASSIGN:
+			dbg_exec("BC_INST_ASSIGNxyz:");
+			s = zxc_program_assign(inst);
+			break;
+#if ENABLE_DC
+		case DC_INST_POP_EXEC:
+			dbg_exec("DC_INST_POP_EXEC:");
+			bc_vec_pop(&G.prog.exestack);
+			goto read_updated_ip;
+		case DC_INST_MODEXP:
+			dbg_exec("DC_INST_MODEXP:");
+			s = zdc_program_modexp();
+			break;
+		case DC_INST_DIVMOD:
+			dbg_exec("DC_INST_DIVMOD:");
+			s = zdc_program_divmod();
+			break;
+		case DC_INST_EXECUTE:
+		case DC_INST_EXEC_COND:
+			dbg_exec("DC_INST_EXEC[_COND]:");
+			s = zdc_program_execStr(code, &ip->inst_idx, inst == DC_INST_EXEC_COND);
+			goto read_updated_ip;
+		case DC_INST_PRINT_STACK: {
+			size_t idx;
+			dbg_exec("DC_INST_PRINT_STACK:");
+			for (idx = 0; idx < G.prog.results.len; ++idx) {
+				s = zxc_program_print(XC_INST_PRINT, idx);
+				if (s) break;
+			}
+			break;
+		}
+		case DC_INST_CLEAR_STACK:
+			dbg_exec("DC_INST_CLEAR_STACK:");
+			bc_vec_pop_all(&G.prog.results);
+			break;
+		case DC_INST_STACK_LEN:
+			dbg_exec("DC_INST_STACK_LEN:");
+			dc_program_stackLen();
+			break;
+		case DC_INST_DUPLICATE:
+			dbg_exec("DC_INST_DUPLICATE:");
+			if (!STACK_HAS_MORE_THAN(&G.prog.results, 0))
+				RETURN_STATUS(bc_error_stack_has_too_few_elements());
+			ptr = bc_vec_top(&G.prog.results);
+			dc_result_copy(&r, ptr);
+			bc_vec_push(&G.prog.results, &r);
+			break;
+		case DC_INST_SWAP: {
+			BcResult *ptr2;
+			dbg_exec("DC_INST_SWAP:");
+			if (!STACK_HAS_MORE_THAN(&G.prog.results, 1))
+				RETURN_STATUS(bc_error_stack_has_too_few_elements());
+			ptr = bc_vec_item_rev(&G.prog.results, 0);
+			ptr2 = bc_vec_item_rev(&G.prog.results, 1);
+			memcpy(&r, ptr, sizeof(BcResult));
+			memcpy(ptr, ptr2, sizeof(BcResult));
+			memcpy(ptr2, &r, sizeof(BcResult));
+			break;
+		}
+		case DC_INST_ASCIIFY:
+			dbg_exec("DC_INST_ASCIIFY:");
+			s = zdc_program_asciify();
+			break;
+		case DC_INST_PRINT_STREAM:
+			dbg_exec("DC_INST_PRINT_STREAM:");
+			s = zdc_program_printStream();
+			break;
+		case DC_INST_LOAD:
+		case DC_INST_PUSH_VAR: {
+			bool copy = inst == DC_INST_LOAD;
+			s = zxc_program_pushVar(code, &ip->inst_idx, true, copy);
+			break;
+		}
+		case DC_INST_PUSH_TO_VAR: {
+			char *name = xc_program_name(code, &ip->inst_idx);
+			s = zxc_program_copyToVar(name, true);
+			free(name);
+			break;
+		}
+		case DC_INST_QUIT:
+			dbg_exec("DC_INST_QUIT:");
+			if (G.prog.exestack.len <= 2)
+				QUIT_OR_RETURN_TO_MAIN;
+			bc_vec_npop(&G.prog.exestack, 2);
+			goto read_updated_ip;
+		case DC_INST_NQUIT:
+			dbg_exec("DC_INST_NQUIT:");
+			s = zdc_program_nquit();
+			//goto read_updated_ip; - just fall through to it
+#endif // ENABLE_DC
+ read_updated_ip:
+			// Instruction stack has changed, read new pointers
+			ip = bc_vec_top(&G.prog.exestack);
+			func = xc_program_func(ip->func);
+			code = func->code.v;
+			dbg_exec("func:%zd bytes:%zd ip:%zd", ip->func, func->code.len, ip->inst_idx);
+		}
+
+		if (s || G_interrupt) {
+			xc_program_reset();
+			RETURN_STATUS(s);
+		}
+
+		fflush_and_check();
+	}
+
+	RETURN_STATUS(BC_STATUS_SUCCESS);
+}
+#define zxc_program_exec(...) (zxc_program_exec(__VA_ARGS__) COMMA_SUCCESS)
+
+static unsigned xc_vm_envLen(const char *var)
+{
+	char *lenv;
+	unsigned len;
+
+	lenv = getenv(var);
+	len = BC_NUM_PRINT_WIDTH;
+	if (!lenv) return len;
+
+	len = bb_strtou(lenv, NULL, 10) - 1;
+	if (errno || len < 2 || len >= INT_MAX)
+		len = BC_NUM_PRINT_WIDTH;
+
+	return len;
+}
+
+static BC_STATUS zxc_vm_process(const char *text)
+{
+	BcStatus s;
+
+	dbg_lex_enter("%s:%d entered", __func__, __LINE__);
+	s = zxc_parse_text_init(text); // does the first zxc_lex_next()
+	if (s) RETURN_STATUS(s);
+
+ IF_BC(check_eof:)
+	while (G.prs.lex != XC_LEX_EOF) {
+		BcInstPtr *ip;
+		BcFunc *f;
+
+		dbg_lex("%s:%d G.prs.lex:%d, parsing...", __func__, __LINE__, G.prs.lex);
+		if (IS_BC) {
+#if ENABLE_BC
+			if (G.prs.lex == BC_LEX_SCOLON
+			 || G.prs.lex == XC_LEX_NLINE
+			) {
+				s = zxc_lex_next();
+				if (s) goto err;
+				goto check_eof;
+			}
+
+			s = zbc_parse_stmt_or_funcdef();
+			if (s) goto err;
+
+			// Check that next token is a correct stmt delimiter -
+			// disallows "print 1 print 2" and such.
+			if (G.prs.lex != BC_LEX_SCOLON
+			 && G.prs.lex != XC_LEX_NLINE
+			 && G.prs.lex != XC_LEX_EOF
+			) {
+				const char *err_at;
+//TODO: commonalize for other parse errors:
+				err_at = G.prs.lex_next_at ? G.prs.lex_next_at : "UNKNOWN";
+				bc_error_fmt("bad statement terminator at '%.*s'",
+					(int)(strchrnul(err_at, '\n') - err_at),
+					err_at
+				);
+				goto err;
+			}
+			// The above logic is fragile. Check these examples:
+			// - interactive read() still works
+#endif
+		} else {
+#if ENABLE_DC
+			// Most of dc parsing assumes all whitespace,
+			// including '\n', is eaten.
+			while (G.prs.lex == XC_LEX_NLINE) {
+				s = zxc_lex_next();
+				if (s) goto err;
+				if (G.prs.lex == XC_LEX_EOF)
+					goto done;
+			}
+			s = zdc_parse_expr();
+#endif
+		}
+		if (s || G_interrupt) {
+ err:
+			xc_parse_reset(); // includes xc_program_reset()
+			RETURN_STATUS(BC_STATUS_FAILURE);
+		}
+
+		dbg_lex("%s:%d executing...", __func__, __LINE__);
+		s = zxc_program_exec();
+		if (s) {
+			xc_program_reset();
+			break;
+		}
+
+		ip = (void*)G.prog.exestack.v;
+#if SANITY_CHECKS
+		if (G.prog.exestack.len != 1) // should have only main's IP
+			bb_error_msg_and_die("BUG:call stack");
+		if (ip->func != BC_PROG_MAIN)
+			bb_error_msg_and_die("BUG:not MAIN");
+#endif
+		f = xc_program_func_BC_PROG_MAIN();
+		// bc discards strings, constants and code after each
+		// top-level statement in the "main program".
+		// This prevents "yes 1 | bc" from growing its memory
+		// without bound. This can be done because data stack
+		// is empty and thus can't hold any references to
+		// strings or constants, there is no generated code
+		// which can hold references (after we discard one
+		// we just executed). Code of functions can have references,
+		// but bc stores function strings/constants in per-function
+		// storage.
+		if (IS_BC) {
+#if SANITY_CHECKS
+			if (G.prog.results.len != 0) // should be empty
+				bb_error_msg_and_die("BUG:data stack");
+#endif
+			IF_BC(bc_vec_pop_all(&f->strs);)
+			IF_BC(bc_vec_pop_all(&f->consts);)
+		} else {
+			if (G.prog.results.len == 0
+			 && G.prog.vars.len == 0
+			) {
+				// If stack is empty and no registers exist (TODO: or they are all empty),
+				// we can get rid of accumulated strings and constants.
+				// In this example dc process should not grow
+				// its memory consumption with time:
+				// yes 1pc | dc
+				IF_DC(bc_vec_pop_all(&G.prog.strs);)
+				IF_DC(bc_vec_pop_all(&G.prog.consts);)
+			}
+			// The code is discarded always (below), thus this example
+			// should also not grow its memory consumption with time,
+			// even though its data stack is not empty:
+			// { echo 1; yes dk; } | dc
+		}
+		// We drop generated and executed code for both bc and dc:
+		bc_vec_pop_all(&f->code);
+		ip->inst_idx = 0;
+	}
+ IF_DC(done:)
+	dbg_lex_done("%s:%d done", __func__, __LINE__);
+	RETURN_STATUS(s);
+}
+#define zxc_vm_process(...) (zxc_vm_process(__VA_ARGS__) COMMA_SUCCESS)
+
+static BC_STATUS zxc_vm_execute_FILE(FILE *fp, const char *filename)
+{
+	// So far bc/dc have no way to include a file from another file,
+	// therefore we know G.prs.lex_filename == NULL on entry
+	//const char *sv_file;
+	BcStatus s;
+
+	G.prs.lex_filename = filename;
+	G.prs.lex_input_fp = fp;
+	G.err_line = G.prs.lex_line = 1;
+
+	do {
+		s = zxc_vm_process("");
+		// We do not stop looping on errors here if reading stdin.
+		// Example: start interactive bc and enter "return".
+		// It should say "'return' not in a function"
+		// but should not exit.
+	} while (G.prs.lex_input_fp == stdin);
+	G.prs.lex_filename = NULL;
+	RETURN_STATUS(s);
+}
+#define zxc_vm_execute_FILE(...) (zxc_vm_execute_FILE(__VA_ARGS__) COMMA_SUCCESS)
+
+static BC_STATUS zxc_vm_file(const char *file)
+{
+	BcStatus s;
+	FILE *fp;
+
+	fp = xfopen_for_read(file);
+	s = zxc_vm_execute_FILE(fp, file);
+	fclose(fp);
+
+	RETURN_STATUS(s);
+}
+#define zxc_vm_file(...) (zxc_vm_file(__VA_ARGS__) COMMA_SUCCESS)
+
+#if ENABLE_BC
+static void bc_vm_info(void)
+{
+	printf("%s "BB_VER"\n"
+		"Adapted from https://github.com/gavinhoward/bc\n"
+		"Original code (c) 2018 Gavin D. Howard and contributors\n"
+	, applet_name);
+}
+
+static void bc_args(char **argv)
+{
+	unsigned opts;
+	int i;
+
+	GETOPT_RESET();
+#if ENABLE_FEATURE_BC_LONG_OPTIONS
+	opts = option_mask32 |= getopt32long(argv, "wvsqli",
+		"warn\0"              No_argument "w"
+		"version\0"           No_argument "v"
+		"standard\0"          No_argument "s"
+		"quiet\0"             No_argument "q"
+		"mathlib\0"           No_argument "l"
+		"interactive\0"       No_argument "i"
+	);
+#else
+	opts = option_mask32 |= getopt32(argv, "wvsqli");
+#endif
+	if (getenv("POSIXLY_CORRECT"))
+		option_mask32 |= BC_FLAG_S;
+
+	if (opts & BC_FLAG_V) {
+		bc_vm_info();
+		exit(0);
+	}
+
+	for (i = optind; argv[i]; ++i)
+		bc_vec_push(&G.files, argv + i);
+}
+
+static void bc_vm_envArgs(void)
+{
+	BcVec v;
+	char *buf;
+	char *env_args = getenv("BC_ENV_ARGS");
+
+	if (!env_args) return;
+
+	G.env_args = xstrdup(env_args);
+	buf = G.env_args;
+
+	bc_vec_init(&v, sizeof(char *), NULL);
+
+	while (*(buf = skip_whitespace(buf)) != '\0') {
+		bc_vec_push(&v, &buf);
+		buf = skip_non_whitespace(buf);
+		if (!*buf)
+			break;
+		*buf++ = '\0';
+	}
+
+	// NULL terminate, and pass argv[] so that first arg is argv[1]
+	if (sizeof(int) == sizeof(char*)) {
+		bc_vec_push(&v, &const_int_0);
+	} else {
+		static char *const nullptr = NULL;
+		bc_vec_push(&v, &nullptr);
+	}
+	bc_args(((char **)v.v) - 1);
+
+	bc_vec_free(&v);
+}
+
+static const char bc_lib[] ALIGN1 = {
+	"scale=20"
+"\n"	"define e(x){"
+"\n"		"auto b,s,n,r,d,i,p,f,v"
+////////////////"if(x<0)return(1/e(-x))" // and drop 'n' and x<0 logic below
+//^^^^^^^^^^^^^^^^ this would work, and is even more precise than GNU bc:
+//e(-.998896): GNU:.36828580434569428695
+//      above code:.36828580434569428696
+//    actual value:.3682858043456942869594...
+// but for now let's be "GNU compatible"
+"\n"		"b=ibase"
+"\n"		"ibase=A"
+"\n"		"if(x<0){"
+"\n"			"n=1"
+"\n"			"x=-x"
+"\n"		"}"
+"\n"		"s=scale"
+"\n"		"r=6+s+.44*x"
+"\n"		"scale=scale(x)+1"
+"\n"		"while(x>1){"
+"\n"			"d+=1"
+"\n"			"x/=2"
+"\n"			"scale+=1"
+"\n"		"}"
+"\n"		"scale=r"
+"\n"		"r=x+1"
+"\n"		"p=x"
+"\n"		"f=v=1"
+"\n"		"for(i=2;v;++i){"
+"\n"			"p*=x"
+"\n"			"f*=i"
+"\n"			"v=p/f"
+"\n"			"r+=v"
+"\n"		"}"
+"\n"		"while(d--)r*=r"
+"\n"		"scale=s"
+"\n"		"ibase=b"
+"\n"		"if(n)return(1/r)"
+"\n"		"return(r/1)"
+"\n"	"}"
+"\n"	"define l(x){"
+"\n"		"auto b,s,r,p,a,q,i,v"
+"\n"		"b=ibase"
+"\n"		"ibase=A"
+"\n"		"if(x<=0){"
+"\n"			"r=(1-10^scale)/1"
+"\n"			"ibase=b"
+"\n"			"return(r)"
+"\n"		"}"
+"\n"		"s=scale"
+"\n"		"scale+=6"
+"\n"		"p=2"
+"\n"		"while(x>=2){"
+"\n"			"p*=2"
+"\n"			"x=sqrt(x)"
+"\n"		"}"
+"\n"		"while(x<=.5){"
+"\n"			"p*=2"
+"\n"			"x=sqrt(x)"
+"\n"		"}"
+"\n"		"r=a=(x-1)/(x+1)"
+"\n"		"q=a*a"
+"\n"		"v=1"
+"\n"		"for(i=3;v;i+=2){"
+"\n"			"a*=q"
+"\n"			"v=a/i"
+"\n"			"r+=v"
+"\n"		"}"
+"\n"		"r*=p"
+"\n"		"scale=s"
+"\n"		"ibase=b"
+"\n"		"return(r/1)"
+"\n"	"}"
+"\n"	"define s(x){"
+"\n"		"auto b,s,r,a,q,i"
+"\n"		"if(x<0)return(-s(-x))"
+"\n"		"b=ibase"
+"\n"		"ibase=A"
+"\n"		"s=scale"
+"\n"		"scale=1.1*s+2"
+"\n"		"a=a(1)"
+"\n"		"scale=0"
+"\n"		"q=(x/a+2)/4"
+"\n"		"x-=4*q*a"
+"\n"		"if(q%2)x=-x"
+"\n"		"scale=s+2"
+"\n"		"r=a=x"
+"\n"		"q=-x*x"
+"\n"		"for(i=3;a;i+=2){"
+"\n"			"a*=q/(i*(i-1))"
+"\n"			"r+=a"
+"\n"		"}"
+"\n"		"scale=s"
+"\n"		"ibase=b"
+"\n"		"return(r/1)"
+"\n"	"}"
+"\n"	"define c(x){"
+"\n"		"auto b,s"
+"\n"		"b=ibase"
+"\n"		"ibase=A"
+"\n"		"s=scale"
+"\n"		"scale*=1.2"
+"\n"		"x=s(2*a(1)+x)"
+"\n"		"scale=s"
+"\n"		"ibase=b"
+"\n"		"return(x/1)"
+"\n"	"}"
+"\n"	"define a(x){"
+"\n"		"auto b,s,r,n,a,m,t,f,i,u"
+"\n"		"b=ibase"
+"\n"		"ibase=A"
+"\n"		"n=1"
+"\n"		"if(x<0){"
+"\n"			"n=-1"
+"\n"			"x=-x"
+"\n"		"}"
+"\n"		"if(scale<65){"
+"\n"			"if(x==1)return(.7853981633974483096156608458198757210492923498437764552437361480/n)"
+"\n"			"if(x==.2)return(.1973955598498807583700497651947902934475851037878521015176889402/n)"
+"\n"		"}"
+"\n"		"s=scale"
+"\n"		"if(x>.2){"
+"\n"			"scale+=5"
+"\n"			"a=a(.2)"
+"\n"		"}"
+"\n"		"scale=s+3"
+"\n"		"while(x>.2){"
+"\n"			"m+=1"
+"\n"			"x=(x-.2)/(1+.2*x)"
+"\n"		"}"
+"\n"		"r=u=x"
+"\n"		"f=-x*x"
+"\n"		"t=1"
+"\n"		"for(i=3;t;i+=2){"
+"\n"			"u*=f"
+"\n"			"t=u/i"
+"\n"			"r+=t"
+"\n"		"}"
+"\n"		"scale=s"
+"\n"		"ibase=b"
+"\n"		"return((m*a+r)/n)"
+"\n"	"}"
+"\n"	"define j(n,x){"
+"\n"		"auto b,s,o,a,i,v,f"
+"\n"		"b=ibase"
+"\n"		"ibase=A"
+"\n"		"s=scale"
+"\n"		"scale=0"
+"\n"		"n/=1"
+"\n"		"if(n<0){"
+"\n"			"n=-n"
+"\n"			"o=n%2"
+"\n"		"}"
+"\n"		"a=1"
+"\n"		"for(i=2;i<=n;++i)a*=i"
+"\n"		"scale=1.5*s"
+"\n"		"a=(x^n)/2^n/a"
+"\n"		"r=v=1"
+"\n"		"f=-x*x/4"
+"\n"		"scale+=length(a)-scale(a)"
+"\n"		"for(i=1;v;++i){"
+"\n"			"v=v*f/i/(n+i)"
+"\n"			"r+=v"
+"\n"		"}"
+"\n"		"scale=s"
+"\n"		"ibase=b"
+"\n"		"if(o)a=-a"
+"\n"		"return(a*r/1)"
+"\n"	"}"
+};
+#endif // ENABLE_BC
+
+static BC_STATUS zxc_vm_exec(void)
+{
+	char **fname;
+	BcStatus s;
+	size_t i;
+
+#if ENABLE_BC
+	if (option_mask32 & BC_FLAG_L) {
+		// We know that internal library is not buggy,
+		// thus error checking is normally disabled.
+# define DEBUG_LIB 0
+		s = zxc_vm_process(bc_lib);
+		if (DEBUG_LIB && s) RETURN_STATUS(s);
+	}
+#endif
+
+	s = BC_STATUS_SUCCESS;
+	fname = (void*)G.files.v;
+	for (i = 0; i < G.files.len; i++) {
+		s = zxc_vm_file(*fname++);
+		if (ENABLE_FEATURE_CLEAN_UP && !G_ttyin && s) {
+			// Debug config, non-interactive mode:
+			// return all the way back to main.
+			// Non-debug builds do not come here
+			// in non-interactive mode, they exit.
+			RETURN_STATUS(s);
+		}
+	}
+
+	if (IS_BC || (option_mask32 & BC_FLAG_I))
+		s = zxc_vm_execute_FILE(stdin, /*filename:*/ NULL);
+
+	RETURN_STATUS(s);
+}
+#define zxc_vm_exec(...) (zxc_vm_exec(__VA_ARGS__) COMMA_SUCCESS)
+
+#if ENABLE_FEATURE_CLEAN_UP
+static void xc_program_free(void)
+{
+	bc_vec_free(&G.prog.fns);
+	IF_BC(bc_vec_free(&G.prog.fn_map);)
+	bc_vec_free(&G.prog.vars);
+	bc_vec_free(&G.prog.var_map);
+	bc_vec_free(&G.prog.arrs);
+	bc_vec_free(&G.prog.arr_map);
+	IF_DC(bc_vec_free(&G.prog.strs);)
+	IF_DC(bc_vec_free(&G.prog.consts);)
+	bc_vec_free(&G.prog.results);
+	bc_vec_free(&G.prog.exestack);
+	IF_BC(bc_num_free(&G.prog.last);)
+	//IF_BC(bc_num_free(&G.prog.zero);)
+	IF_BC(bc_num_free(&G.prog.one);)
+	bc_vec_free(&G.input_buffer);
+}
+#endif
+
+static void xc_program_init(void)
+{
+	BcInstPtr ip;
+
+	// memset(&G.prog, 0, sizeof(G.prog)); - already is
+	memset(&ip, 0, sizeof(BcInstPtr));
+
+	// G.prog.nchars = G.prog.scale = 0; - already is
+	G.prog.ib_t = 10;
+	G.prog.ob_t = 10;
+
+	IF_BC(bc_num_init_DEF_SIZE(&G.prog.last);)
+	//IF_BC(bc_num_zero(&G.prog.last);) - already is
+
+	//bc_num_init_DEF_SIZE(&G.prog.zero); - not needed
+	//bc_num_zero(&G.prog.zero); - already is
+
+	IF_BC(bc_num_init_DEF_SIZE(&G.prog.one);)
+	IF_BC(bc_num_one(&G.prog.one);)
+
+	bc_vec_init(&G.prog.fns, sizeof(BcFunc), bc_func_free);
+	IF_BC(bc_vec_init(&G.prog.fn_map, sizeof(BcId), bc_id_free);)
+
+	if (IS_BC) {
+		// Names are chosen simply to be distinct and never match
+		// a valid function name (and be short)
+		IF_BC(bc_program_addFunc(xstrdup(""))); // func #0: main
+		IF_BC(bc_program_addFunc(xstrdup("1"))); // func #1: for read()
+	} else {
+		// in dc, functions have no names
+		xc_program_add_fn();
+		xc_program_add_fn();
+	}
+
+	bc_vec_init(&G.prog.vars, sizeof(BcVec), bc_vec_free);
+	bc_vec_init(&G.prog.var_map, sizeof(BcId), bc_id_free);
+
+	bc_vec_init(&G.prog.arrs, sizeof(BcVec), bc_vec_free);
+	bc_vec_init(&G.prog.arr_map, sizeof(BcId), bc_id_free);
+
+	IF_DC(bc_vec_init(&G.prog.strs, sizeof(char *), bc_string_free);)
+	IF_DC(bc_vec_init(&G.prog.consts, sizeof(char *), bc_string_free);)
+	bc_vec_init(&G.prog.results, sizeof(BcResult), bc_result_free);
+	bc_vec_init(&G.prog.exestack, sizeof(BcInstPtr), NULL);
+	bc_vec_push(&G.prog.exestack, &ip);
+
+	bc_char_vec_init(&G.input_buffer);
+}
+
+static int xc_vm_init(const char *env_len)
+{
+	G.prog.len = xc_vm_envLen(env_len);
+#if ENABLE_FEATURE_EDITING
+	G.line_input_state = new_line_input_t(DO_HISTORY);
+#endif
+	bc_vec_init(&G.files, sizeof(char *), NULL);
+
+	xc_program_init();
+	IF_BC(if (IS_BC) bc_vm_envArgs();)
+	xc_parse_create(BC_PROG_MAIN);
+
+//TODO: in GNU bc, the check is (isatty(0) && isatty(1)),
+//-i option unconditionally enables this regardless of isatty():
+	if (isatty(0)) {
+#if ENABLE_FEATURE_BC_INTERACTIVE
+		G_ttyin = 1;
+		// With SA_RESTART, most system calls will restart
+		// (IOW: they won't fail with EINTR).
+		// In particular, this means ^C won't cause
+		// stdout to get into "error state" if SIGINT hits
+		// within write() syscall.
+		//
+		// The downside is that ^C while tty input is taken
+		// will only be handled after [Enter] since read()
+		// from stdin is not interrupted by ^C either,
+		// it restarts, thus fgetc() does not return on ^C.
+		// (This problem manifests only if line editing is disabled)
+		signal_SA_RESTART_empty_mask(SIGINT, record_signo);
+
+		// Without SA_RESTART, this exhibits a bug:
+		// "while (1) print 1" and try ^C-ing it.
+		// Intermittently, instead of returning to input line,
+		// you'll get "output error: Interrupted system call"
+		// and exit.
+		//signal_no_SA_RESTART_empty_mask(SIGINT, record_signo);
+#endif
+		return 1; // "tty"
+	}
+	return 0; // "not a tty"
+}
+
+static BcStatus xc_vm_run(void)
+{
+	BcStatus st = zxc_vm_exec();
+#if ENABLE_FEATURE_CLEAN_UP
+	if (G_exiting) // it was actually "halt" or "quit"
+		st = EXIT_SUCCESS;
+
+	bc_vec_free(&G.files);
+	xc_program_free();
+	xc_parse_free();
+	free(G.env_args);
+# if ENABLE_FEATURE_EDITING
+	free_line_input_t(G.line_input_state);
+# endif
+	FREE_G();
+#endif
+	dbg_exec("exiting with exitcode %d", st);
+	return st;
+}
+
+#if ENABLE_BC
+int bc_main(int argc, char **argv) MAIN_EXTERNALLY_VISIBLE;
+int bc_main(int argc UNUSED_PARAM, char **argv)
+{
+	int is_tty;
+
+	INIT_G();
+
+	is_tty = xc_vm_init("BC_LINE_LENGTH");
+
+	bc_args(argv);
+
+	if (is_tty && !(option_mask32 & BC_FLAG_Q))
+		bc_vm_info();
+
+	return xc_vm_run();
+}
+#endif
+
+#if ENABLE_DC
+int dc_main(int argc, char **argv) MAIN_EXTERNALLY_VISIBLE;
+int dc_main(int argc UNUSED_PARAM, char **argv)
+{
+	int noscript;
+
+	INIT_G();
+
+	// TODO: dc (GNU bc 1.07.1) 1.4.1 seems to use width
+	// 1 char wider than bc from the same package.
+	// Both default width, and xC_LINE_LENGTH=N are wider:
+	// "DC_LINE_LENGTH=5 dc -e'123456 p'" prints:
+	//	|1234\   |
+	//	|56      |
+	// "echo '123456' | BC_LINE_LENGTH=5 bc" prints:
+	//	|123\    |
+	//	|456     |
+	// Do the same, or it's a bug?
+	xc_vm_init("DC_LINE_LENGTH");
+
+	// Run -e'SCRIPT' and -fFILE in order of appearance, then handle FILEs
+	noscript = BC_FLAG_I;
+	for (;;) {
+		int n = getopt(argc, argv, "e:f:x");
+		if (n <= 0)
+			break;
+		switch (n) {
+		case 'e':
+			noscript = 0;
+			n = zxc_vm_process(optarg);
+			if (n) return n;
+			break;
+		case 'f':
+			noscript = 0;
+			n = zxc_vm_file(optarg);
+			if (n) return n;
+			break;
+		case 'x':
+			option_mask32 |= DC_FLAG_X;
+			break;
+		default:
+			bb_show_usage();
+		}
+	}
+	argv += optind;
+
+	while (*argv) {
+		noscript = 0;
+		bc_vec_push(&G.files, argv++);
+	}
+
+	option_mask32 |= noscript; // set BC_FLAG_I if we need to interpret stdin
+
+	return xc_vm_run();
+}
+#endif
+
+#endif // DC_BIG
+
diff -urpN busybox-1.29.3/miscutils/beep.c busybox-1.30.0/miscutils/beep.c
--- busybox-1.29.3/miscutils/beep.c	2018-07-02 13:23:06.000000000 +0200
+++ busybox-1.30.0/miscutils/beep.c	2018-12-30 16:14:20.000000000 +0100
@@ -7,7 +7,7 @@
  * Licensed under GPLv2 or later, see file LICENSE in this source tree.
  */
 //config:config BEEP
-//config:	bool "beep (3 kb)"
+//config:	bool "beep (2.4 kb)"
 //config:	default y
 //config:	select PLATFORM_LINUX
 //config:	help
diff -urpN busybox-1.29.3/miscutils/chat.c busybox-1.30.0/miscutils/chat.c
--- busybox-1.29.3/miscutils/chat.c	2018-07-02 13:23:06.000000000 +0200
+++ busybox-1.30.0/miscutils/chat.c	2018-12-30 16:14:20.000000000 +0100
@@ -8,7 +8,7 @@
  * Licensed under GPLv2, see file LICENSE in this source tree.
  */
 //config:config CHAT
-//config:	bool "chat (6.6 kb)"
+//config:	bool "chat (6.3 kb)"
 //config:	default y
 //config:	help
 //config:	Simple chat utility.
diff -urpN busybox-1.29.3/miscutils/crond.c busybox-1.30.0/miscutils/crond.c
--- busybox-1.29.3/miscutils/crond.c	2018-07-02 13:23:06.000000000 +0200
+++ busybox-1.30.0/miscutils/crond.c	2018-12-30 16:14:20.000000000 +0100
@@ -9,7 +9,7 @@
  * Licensed under GPLv2 or later, see file LICENSE in this source tree.
  */
 //config:config CROND
-//config:	bool "crond (13 kb)"
+//config:	bool "crond (14 kb)"
 //config:	default y
 //config:	select FEATURE_SYSLOG
 //config:	help
diff -urpN busybox-1.29.3/miscutils/crontab.c busybox-1.30.0/miscutils/crontab.c
--- busybox-1.29.3/miscutils/crontab.c	2018-07-02 13:23:06.000000000 +0200
+++ busybox-1.30.0/miscutils/crontab.c	2018-12-30 16:14:20.000000000 +0100
@@ -10,7 +10,7 @@
  * Licensed under GPLv2 or later, see file LICENSE in this source tree.
  */
 //config:config CRONTAB
-//config:	bool "crontab (9.7 kb)"
+//config:	bool "crontab (10 kb)"
 //config:	default y
 //config:	help
 //config:	Crontab manipulates the crontab for a particular user. Only
diff -urpN busybox-1.29.3/miscutils/dc.c busybox-1.30.0/miscutils/dc.c
--- busybox-1.29.3/miscutils/dc.c	2018-07-02 13:23:06.000000000 +0200
+++ busybox-1.30.0/miscutils/dc.c	2018-12-30 16:14:20.000000000 +0100
@@ -2,50 +2,11 @@
 /*
  * Licensed under GPLv2 or later, see file LICENSE in this source tree.
  */
-//config:config DC
-//config:	bool "dc (4.2 kb)"
-//config:	default y
-//config:	help
-//config:	Dc is a reverse-polish desk calculator which supports unlimited
-//config:	precision arithmetic.
-//config:
-//config:config FEATURE_DC_LIBM
-//config:	bool "Enable power and exp functions (requires libm)"
-//config:	default y
-//config:	depends on DC
-//config:	help
-//config:	Enable power and exp functions.
-//config:	NOTE: This will require libm to be present for linking.
-
-//applet:IF_DC(APPLET(dc, BB_DIR_USR_BIN, BB_SUID_DROP))
-
-//kbuild:lib-$(CONFIG_DC) += dc.o
-
-//usage:#define dc_trivial_usage
-//usage:       "EXPRESSION..."
-//usage:
-//usage:#define dc_full_usage "\n\n"
-//usage:       "Tiny RPN calculator. Operations:\n"
-//usage:       "+, add, -, sub, *, mul, /, div, %, mod, "IF_FEATURE_DC_LIBM("**, exp, ")"and, or, not, xor,\n"
-//usage:       "p - print top of the stack (without popping),\n"
-//usage:       "f - print entire stack,\n"
-//usage:       "o - pop the value and set output radix (must be 10, 16, 8 or 2).\n"
-//usage:       "Examples: 'dc 2 2 add p' -> 4, 'dc 8 8 mul 2 2 + / p' -> 16"
-//usage:
-//usage:#define dc_example_usage
-//usage:       "$ dc 2 2 + p\n"
-//usage:       "4\n"
-//usage:       "$ dc 8 8 \\* 2 2 + / p\n"
-//usage:       "16\n"
-//usage:       "$ dc 0 1 and p\n"
-//usage:       "0\n"
-//usage:       "$ dc 0 1 or p\n"
-//usage:       "1\n"
-//usage:       "$ echo 72 9 div 8 mul p | dc\n"
-//usage:       "64\n"
 
-#include "libbb.h"
-#include "common_bufsiz.h"
+/* config/applet/usage bits are in bc.c */
+
+//#include "libbb.h"
+//#include "common_bufsiz.h"
 #include <math.h>
 
 #if 0
@@ -59,7 +20,6 @@ typedef unsigned long long data_t;
 #define DATA_FMT "ll"
 #endif
 
-
 struct globals {
 	unsigned pointer;
 	unsigned base;
@@ -75,7 +35,6 @@ enum { STACK_SIZE = (COMMON_BUFSIZE - of
 	base = 10; \
 } while (0)
 
-
 static void check_under(void)
 {
 	if (pointer == 0)
@@ -223,25 +182,25 @@ struct op {
 
 static const struct op operators[] = {
 #if ENABLE_FEATURE_DC_LIBM
-	{"**",  power},
-	{"exp", power},
-	{"pow", power},
+	{"^",   power},
+//	{"exp", power},
+//	{"pow", power},
 #endif
 	{"%",   mod},
-	{"mod", mod},
+//	{"mod", mod},
+	// logic ops are not standard, remove?
 	{"and", and},
 	{"or",  or},
 	{"not", not},
-	{"eor", eor},
 	{"xor", eor},
 	{"+",   add},
-	{"add", add},
+//	{"add", add},
 	{"-",   sub},
-	{"sub", sub},
+//	{"sub", sub},
 	{"*",   mul},
-	{"mul", mul},
+//	{"mul", mul},
 	{"/",   divide},
-	{"div", divide},
+//	{"div", divide},
 	{"p", print_no_pop},
 	{"f", print_stack_no_pop},
 	{"o", set_output_base},
@@ -282,23 +241,50 @@ static void stack_machine(const char *ar
 	bb_error_msg_and_die("syntax error at '%s'", argument);
 }
 
+static void process_file(FILE *fp)
+{
+	char *line;
+	while ((line = xmalloc_fgetline(fp)) != NULL) {
+		stack_machine(line);
+		free(line);
+	}
+}
+
 int dc_main(int argc, char **argv) MAIN_EXTERNALLY_VISIBLE;
 int dc_main(int argc UNUSED_PARAM, char **argv)
 {
+	bool script = 0;
+
 	INIT_G();
 
-	argv++;
-	if (!argv[0]) {
-		/* take stuff from stdin if no args are given */
-		char *line;
-		while ((line = xmalloc_fgetline(stdin)) != NULL) {
-			stack_machine(line);
-			free(line);
+	/* Run -e'SCRIPT' and -fFILE in order of appearance, then handle FILEs */
+	for (;;) {
+		int n = getopt(argc, argv, "e:f:");
+		if (n <= 0)
+			break;
+		switch (n) {
+		case 'e':
+			script = 1;
+			stack_machine(optarg);
+			break;
+		case 'f':
+			script = 1;
+			process_file(xfopen_for_read(optarg));
+			break;
+		default:
+			bb_show_usage();
 		}
-	} else {
-		do {
-			stack_machine(*argv);
-		} while (*++argv);
 	}
+	argv += optind;
+
+	if (*argv) {
+		do
+			process_file(xfopen_for_read(*argv++));
+		while (*argv);
+	} else if (!script) {
+		/* Take stuff from stdin if no args are given */
+		process_file(stdin);
+	}
+
 	return EXIT_SUCCESS;
 }
diff -urpN busybox-1.29.3/miscutils/devfsd.c busybox-1.30.0/miscutils/devfsd.c
--- busybox-1.29.3/miscutils/devfsd.c	2018-07-02 13:23:06.000000000 +0200
+++ busybox-1.30.0/miscutils/devfsd.c	2018-12-30 16:14:20.000000000 +0100
@@ -694,7 +694,7 @@ static void process_config_line(const ch
 	return;
 
  process_config_line_err:
-	msg_logger_and_die(LOG_ERR, bb_msg_bad_config, msg , line);
+	msg_logger_and_die(LOG_ERR, bb_msg_bad_config, msg, line);
 }  /*  End Function process_config_line   */
 
 static int do_servicing(int fd, unsigned long event_mask)
diff -urpN busybox-1.29.3/miscutils/fbsplash.c busybox-1.30.0/miscutils/fbsplash.c
--- busybox-1.29.3/miscutils/fbsplash.c	2018-07-02 13:23:06.000000000 +0200
+++ busybox-1.30.0/miscutils/fbsplash.c	2018-12-30 16:14:20.000000000 +0100
@@ -21,7 +21,7 @@
  *   "exit" (or just close fifo) - well you guessed it.
  */
 //config:config FBSPLASH
-//config:	bool "fbsplash (27 kb)"
+//config:	bool "fbsplash (26 kb)"
 //config:	default y
 //config:	select PLATFORM_LINUX
 //config:	help
diff -urpN busybox-1.29.3/miscutils/flash_eraseall.c busybox-1.30.0/miscutils/flash_eraseall.c
--- busybox-1.29.3/miscutils/flash_eraseall.c	2018-07-02 13:23:06.000000000 +0200
+++ busybox-1.30.0/miscutils/flash_eraseall.c	2018-12-30 16:14:20.000000000 +0100
@@ -11,7 +11,7 @@
  * Licensed under GPLv2 or later, see file LICENSE in this source tree.
  */
 //config:config FLASH_ERASEALL
-//config:	bool "flash_eraseall (5.5 kb)"
+//config:	bool "flash_eraseall (5.9 kb)"
 //config:	default n  # doesn't build on Ubuntu 8.04
 //config:	help
 //config:	The flash_eraseall binary from mtd-utils as of git head c4c6a59eb.
diff -urpN busybox-1.29.3/miscutils/flashcp.c busybox-1.30.0/miscutils/flashcp.c
--- busybox-1.29.3/miscutils/flashcp.c	2018-07-02 13:23:06.000000000 +0200
+++ busybox-1.30.0/miscutils/flashcp.c	2018-12-30 16:14:20.000000000 +0100
@@ -7,7 +7,7 @@
  * Licensed under GPLv2, see file LICENSE in this source tree.
  */
 //config:config FLASHCP
-//config:	bool "flashcp (5.4 kb)"
+//config:	bool "flashcp (5.3 kb)"
 //config:	default n  # doesn't build on Ubuntu 8.04
 //config:	help
 //config:	The flashcp binary, inspired by mtd-utils as of git head 5eceb74f7.
diff -urpN busybox-1.29.3/miscutils/hdparm.c busybox-1.30.0/miscutils/hdparm.c
--- busybox-1.29.3/miscutils/hdparm.c	2018-07-02 13:23:06.000000000 +0200
+++ busybox-1.30.0/miscutils/hdparm.c	2018-12-30 16:14:20.000000000 +0100
@@ -12,7 +12,7 @@
  *          - by Mark Lord (C) 1994-2002 -- freely distributable
  */
 //config:config HDPARM
-//config:	bool "hdparm (23 kb)"
+//config:	bool "hdparm (25 kb)"
 //config:	default y
 //config:	select PLATFORM_LINUX
 //config:	help
diff -urpN busybox-1.29.3/miscutils/hexedit.c busybox-1.30.0/miscutils/hexedit.c
--- busybox-1.29.3/miscutils/hexedit.c	2018-07-30 18:02:27.000000000 +0200
+++ busybox-1.30.0/miscutils/hexedit.c	2018-12-30 16:14:20.000000000 +0100
@@ -4,7 +4,7 @@
  * Licensed under GPLv2, see file LICENSE in this source tree.
  */
 //config:config HEXEDIT
-//config:	bool "hexedit (20 kb)"
+//config:	bool "hexedit (21 kb)"
 //config:	default y
 //config:	help
 //config:	Edit file in hexadecimal.
diff -urpN busybox-1.29.3/miscutils/i2c_tools.c busybox-1.30.0/miscutils/i2c_tools.c
--- busybox-1.29.3/miscutils/i2c_tools.c	2018-07-02 13:23:06.000000000 +0200
+++ busybox-1.30.0/miscutils/i2c_tools.c	2018-12-30 16:14:20.000000000 +0100
@@ -9,28 +9,28 @@
  * Licensed under GPLv2 or later, see file LICENSE in this source tree.
  */
 //config:config I2CGET
-//config:	bool "i2cget (5.6 kb)"
+//config:	bool "i2cget (5.5 kb)"
 //config:	default y
 //config:	select PLATFORM_LINUX
 //config:	help
 //config:	Read from I2C/SMBus chip registers.
 //config:
 //config:config I2CSET
-//config:	bool "i2cset (6.9 kb)"
+//config:	bool "i2cset (6.7 kb)"
 //config:	default y
 //config:	select PLATFORM_LINUX
 //config:	help
 //config:	Set I2C registers.
 //config:
 //config:config I2CDUMP
-//config:	bool "i2cdump (7.2 kb)"
+//config:	bool "i2cdump (7.1 kb)"
 //config:	default y
 //config:	select PLATFORM_LINUX
 //config:	help
 //config:	Examine I2C registers.
 //config:
 //config:config I2CDETECT
-//config:	bool "i2cdetect (7.2 kb)"
+//config:	bool "i2cdetect (7.1 kb)"
 //config:	default y
 //config:	select PLATFORM_LINUX
 //config:	help
diff -urpN busybox-1.29.3/miscutils/inotifyd.c busybox-1.30.0/miscutils/inotifyd.c
--- busybox-1.29.3/miscutils/inotifyd.c	2018-07-02 13:23:06.000000000 +0200
+++ busybox-1.30.0/miscutils/inotifyd.c	2018-12-30 16:14:20.000000000 +0100
@@ -27,7 +27,7 @@
  * See below for mask names explanation.
  */
 //config:config INOTIFYD
-//config:	bool "inotifyd (3.5 kb)"
+//config:	bool "inotifyd (3.6 kb)"
 //config:	default n  # doesn't build on Knoppix 5
 //config:	help
 //config:	Simple inotify daemon. Reports filesystem changes. Requires
diff -urpN busybox-1.29.3/miscutils/less.c busybox-1.30.0/miscutils/less.c
--- busybox-1.29.3/miscutils/less.c	2018-07-02 13:23:06.000000000 +0200
+++ busybox-1.30.0/miscutils/less.c	2018-12-30 16:14:20.000000000 +0100
@@ -20,7 +20,7 @@
  *   redirected input has been read from stdin
  */
 //config:config LESS
-//config:	bool "less (15 kb)"
+//config:	bool "less (16 kb)"
 //config:	default y
 //config:	help
 //config:	'less' is a pager, meaning that it displays text files. It possesses
diff -urpN busybox-1.29.3/miscutils/lsscsi.c busybox-1.30.0/miscutils/lsscsi.c
--- busybox-1.29.3/miscutils/lsscsi.c	2018-07-02 13:23:06.000000000 +0200
+++ busybox-1.30.0/miscutils/lsscsi.c	2018-12-30 16:14:20.000000000 +0100
@@ -7,7 +7,7 @@
  * Licensed under GPLv2 or later, see file LICENSE in this source tree.
  */
 //config:config LSSCSI
-//config:	bool "lsscsi (2.4 kb)"
+//config:	bool "lsscsi (2.5 kb)"
 //config:	default y
 //config:	#select PLATFORM_LINUX
 //config:	help
diff -urpN busybox-1.29.3/miscutils/makedevs.c busybox-1.30.0/miscutils/makedevs.c
--- busybox-1.29.3/miscutils/makedevs.c	2018-07-02 13:23:06.000000000 +0200
+++ busybox-1.30.0/miscutils/makedevs.c	2018-12-30 16:14:20.000000000 +0100
@@ -7,7 +7,7 @@
  * known bugs: can't deal with alpha ranges
  */
 //config:config MAKEDEVS
-//config:	bool "makedevs (9.3 kb)"
+//config:	bool "makedevs (9.2 kb)"
 //config:	default y
 //config:	help
 //config:	'makedevs' is a utility used to create a batch of devices with
diff -urpN busybox-1.29.3/miscutils/man.c busybox-1.30.0/miscutils/man.c
--- busybox-1.29.3/miscutils/man.c	2018-07-02 13:23:06.000000000 +0200
+++ busybox-1.30.0/miscutils/man.c	2018-12-30 16:14:20.000000000 +0100
@@ -3,7 +3,7 @@
  * Licensed under GPLv2, see file LICENSE in this source tree.
  */
 //config:config MAN
-//config:	bool "man (27 kb)"
+//config:	bool "man (26 kb)"
 //config:	default y
 //config:	help
 //config:	Format and display manual pages.
diff -urpN busybox-1.29.3/miscutils/microcom.c busybox-1.30.0/miscutils/microcom.c
--- busybox-1.29.3/miscutils/microcom.c	2018-07-02 13:23:06.000000000 +0200
+++ busybox-1.30.0/miscutils/microcom.c	2018-12-30 16:14:20.000000000 +0100
@@ -8,7 +8,7 @@
  * Licensed under GPLv2, see file LICENSE in this source tree.
  */
 //config:config MICROCOM
-//config:	bool "microcom (5.6 kb)"
+//config:	bool "microcom (5.7 kb)"
 //config:	default y
 //config:	help
 //config:	The poor man's minicom utility for chatting with serial port devices.
diff -urpN busybox-1.29.3/miscutils/mt.c busybox-1.30.0/miscutils/mt.c
--- busybox-1.29.3/miscutils/mt.c	2018-07-02 13:23:06.000000000 +0200
+++ busybox-1.30.0/miscutils/mt.c	2018-12-30 16:14:20.000000000 +0100
@@ -3,7 +3,7 @@
  * Licensed under GPLv2 or later, see file LICENSE in this source tree.
  */
 //config:config MT
-//config:	bool "mt (2.6 kb)"
+//config:	bool "mt (2.5 kb)"
 //config:	default y
 //config:	help
 //config:	mt is used to control tape devices. You can use the mt utility
diff -urpN busybox-1.29.3/miscutils/nandwrite.c busybox-1.30.0/miscutils/nandwrite.c
--- busybox-1.29.3/miscutils/nandwrite.c	2018-07-02 13:23:06.000000000 +0200
+++ busybox-1.30.0/miscutils/nandwrite.c	2018-12-30 16:14:20.000000000 +0100
@@ -8,14 +8,14 @@
  * TODO: add support for large (>4GB) MTD devices
  */
 //config:config NANDWRITE
-//config:	bool "nandwrite (5.9 kb)"
+//config:	bool "nandwrite (4.8 kb)"
 //config:	default y
 //config:	select PLATFORM_LINUX
 //config:	help
 //config:	Write to the specified MTD device, with bad blocks awareness
 //config:
 //config:config NANDDUMP
-//config:	bool "nanddump (6.3 kb)"
+//config:	bool "nanddump (5.2 kb)"
 //config:	default y
 //config:	select PLATFORM_LINUX
 //config:	help
diff -urpN busybox-1.29.3/miscutils/partprobe.c busybox-1.30.0/miscutils/partprobe.c
--- busybox-1.29.3/miscutils/partprobe.c	2018-07-02 13:23:06.000000000 +0200
+++ busybox-1.30.0/miscutils/partprobe.c	2018-12-30 16:14:20.000000000 +0100
@@ -5,7 +5,7 @@
  * Licensed under GPLv2, see file LICENSE in this source tree.
  */
 //config:config PARTPROBE
-//config:	bool "partprobe (3.6 kb)"
+//config:	bool "partprobe (3.5 kb)"
 //config:	default y
 //config:	select PLATFORM_LINUX
 //config:	help
diff -urpN busybox-1.29.3/miscutils/raidautorun.c busybox-1.30.0/miscutils/raidautorun.c
--- busybox-1.29.3/miscutils/raidautorun.c	2018-07-02 13:23:06.000000000 +0200
+++ busybox-1.30.0/miscutils/raidautorun.c	2018-12-30 16:14:20.000000000 +0100
@@ -7,7 +7,7 @@
  * Licensed under GPLv2 or later, see file LICENSE in this source tree.
  */
 //config:config RAIDAUTORUN
-//config:	bool "raidautorun (1.4 kb)"
+//config:	bool "raidautorun (1.3 kb)"
 //config:	default y
 //config:	select PLATFORM_LINUX
 //config:	help
diff -urpN busybox-1.29.3/miscutils/readahead.c busybox-1.30.0/miscutils/readahead.c
--- busybox-1.29.3/miscutils/readahead.c	2018-07-02 13:23:06.000000000 +0200
+++ busybox-1.30.0/miscutils/readahead.c	2018-12-30 16:14:20.000000000 +0100
@@ -10,7 +10,7 @@
  * Licensed under GPLv2 or later, see file LICENSE in this source tree.
  */
 //config:config READAHEAD
-//config:	bool "readahead (2 kb)"
+//config:	bool "readahead (1.5 kb)"
 //config:	default y
 //config:	depends on LFS
 //config:	select PLATFORM_LINUX
diff -urpN busybox-1.29.3/miscutils/rfkill.c busybox-1.30.0/miscutils/rfkill.c
--- busybox-1.29.3/miscutils/rfkill.c	2018-07-02 13:23:06.000000000 +0200
+++ busybox-1.30.0/miscutils/rfkill.c	2018-12-30 16:14:20.000000000 +0100
@@ -7,7 +7,7 @@
  * Licensed under GPLv2 or later, see file LICENSE in this source tree.
  */
 //config:config RFKILL
-//config:	bool "rfkill (5.3 kb)"
+//config:	bool "rfkill (4.4 kb)"
 //config:	default n # doesn't build on Ubuntu 9.04
 //config:	select PLATFORM_LINUX
 //config:	help
diff -urpN busybox-1.29.3/miscutils/runlevel.c busybox-1.30.0/miscutils/runlevel.c
--- busybox-1.29.3/miscutils/runlevel.c	2018-07-02 13:23:06.000000000 +0200
+++ busybox-1.30.0/miscutils/runlevel.c	2018-12-30 16:14:20.000000000 +0100
@@ -12,11 +12,11 @@
  * initially busyboxified by Bernhard Reutner-Fischer
  */
 //config:config RUNLEVEL
-//config:	bool "runlevel (518 bytes)"
+//config:	bool "runlevel (559 bytes)"
 //config:	default y
 //config:	depends on FEATURE_UTMP
 //config:	help
-//config:	find the current and previous system runlevel.
+//config:	Find the current and previous system runlevel.
 //config:
 //config:	This applet uses utmp but does not rely on busybox supporing
 //config:	utmp on purpose. It is used by e.g. emdebian via /etc/init.d/rc.
diff -urpN busybox-1.29.3/miscutils/setfattr.c busybox-1.30.0/miscutils/setfattr.c
--- busybox-1.29.3/miscutils/setfattr.c	2018-07-02 13:23:06.000000000 +0200
+++ busybox-1.30.0/miscutils/setfattr.c	2018-12-30 16:14:20.000000000 +0100
@@ -6,7 +6,7 @@
  * Licensed under GPLv2, see file LICENSE in this source tree.
  */
 //config:config SETFATTR
-//config:	bool "setfattr (3.6 kb)"
+//config:	bool "setfattr (3.7 kb)"
 //config:	default y
 //config:	help
 //config:	Set/delete extended attributes on files
diff -urpN busybox-1.29.3/miscutils/setserial.c busybox-1.30.0/miscutils/setserial.c
--- busybox-1.29.3/miscutils/setserial.c	2018-07-02 13:23:06.000000000 +0200
+++ busybox-1.30.0/miscutils/setserial.c	2018-12-30 16:14:20.000000000 +0100
@@ -8,7 +8,7 @@
  * Licensed under GPLv2 or later, see file LICENSE in this source tree.
  */
 //config:config SETSERIAL
-//config:	bool "setserial (6.6 kb)"
+//config:	bool "setserial (6.9 kb)"
 //config:	default y
 //config:	select PLATFORM_LINUX
 //config:	help
diff -urpN busybox-1.29.3/miscutils/strings.c busybox-1.30.0/miscutils/strings.c
--- busybox-1.29.3/miscutils/strings.c	2018-07-02 13:23:06.000000000 +0200
+++ busybox-1.30.0/miscutils/strings.c	2018-12-30 16:14:20.000000000 +0100
@@ -7,7 +7,7 @@
  * Licensed under GPLv2 or later, see file LICENSE in this source tree.
  */
 //config:config STRINGS
-//config:	bool "strings (4.3 kb)"
+//config:	bool "strings (4.6 kb)"
 //config:	default y
 //config:	help
 //config:	strings prints the printable character sequences for each file
diff -urpN busybox-1.29.3/miscutils/time.c busybox-1.30.0/miscutils/time.c
--- busybox-1.29.3/miscutils/time.c	2018-07-02 13:23:06.000000000 +0200
+++ busybox-1.30.0/miscutils/time.c	2018-12-30 16:14:20.000000000 +0100
@@ -10,7 +10,7 @@
  * Heavily modified for busybox by Erik Andersen <andersen@codepoet.org>
  */
 //config:config TIME
-//config:	bool "time (7 kb)"
+//config:	bool "time (6.8 kb)"
 //config:	default y
 //config:	help
 //config:	The time command runs the specified program with the given arguments.
diff -urpN busybox-1.29.3/miscutils/ttysize.c busybox-1.30.0/miscutils/ttysize.c
--- busybox-1.29.3/miscutils/ttysize.c	2018-07-02 13:23:06.000000000 +0200
+++ busybox-1.30.0/miscutils/ttysize.c	2018-12-30 16:14:20.000000000 +0100
@@ -10,7 +10,7 @@
  * Licensed under GPLv2, see file LICENSE in this source tree.
  */
 //config:config TTYSIZE
-//config:	bool "ttysize (372 bytes)"
+//config:	bool "ttysize (432 bytes)"
 //config:	default y
 //config:	help
 //config:	A replacement for "stty size". Unlike stty, can report only width,
diff -urpN busybox-1.29.3/miscutils/ubi_tools.c busybox-1.30.0/miscutils/ubi_tools.c
--- busybox-1.29.3/miscutils/ubi_tools.c	2018-07-02 13:23:06.000000000 +0200
+++ busybox-1.30.0/miscutils/ubi_tools.c	2018-12-30 16:14:20.000000000 +0100
@@ -4,42 +4,42 @@
  * Licensed under GPLv2, see file LICENSE in this source tree.
  */
 //config:config UBIATTACH
-//config:	bool "ubiattach (4.7 kb)"
+//config:	bool "ubiattach (4.2 kb)"
 //config:	default y
 //config:	select PLATFORM_LINUX
 //config:	help
 //config:	Attach MTD device to an UBI device.
 //config:
 //config:config UBIDETACH
-//config:	bool "ubidetach (4.6 kb)"
+//config:	bool "ubidetach (4.1 kb)"
 //config:	default y
 //config:	select PLATFORM_LINUX
 //config:	help
 //config:	Detach MTD device from an UBI device.
 //config:
 //config:config UBIMKVOL
-//config:	bool "ubimkvol (5.8 kb)"
+//config:	bool "ubimkvol (5.3 kb)"
 //config:	default y
 //config:	select PLATFORM_LINUX
 //config:	help
 //config:	Create a UBI volume.
 //config:
 //config:config UBIRMVOL
-//config:	bool "ubirmvol (5.2 kb)"
+//config:	bool "ubirmvol (4.9 kb)"
 //config:	default y
 //config:	select PLATFORM_LINUX
 //config:	help
 //config:	Delete a UBI volume.
 //config:
 //config:config UBIRSVOL
-//config:	bool "ubirsvol (4.6 kb)"
+//config:	bool "ubirsvol (4.2 kb)"
 //config:	default y
 //config:	select PLATFORM_LINUX
 //config:	help
 //config:	Resize a UBI volume.
 //config:
 //config:config UBIUPDATEVOL
-//config:	bool "ubiupdatevol (5.6 kb)"
+//config:	bool "ubiupdatevol (5.2 kb)"
 //config:	default y
 //config:	select PLATFORM_LINUX
 //config:	help
diff -urpN busybox-1.29.3/miscutils/ubirename.c busybox-1.30.0/miscutils/ubirename.c
--- busybox-1.29.3/miscutils/ubirename.c	2018-07-02 13:23:06.000000000 +0200
+++ busybox-1.30.0/miscutils/ubirename.c	2018-12-30 16:14:20.000000000 +0100
@@ -7,7 +7,7 @@
  * Licensed under GPLv2, see file LICENSE in this source tree.
  */
 //config:config UBIRENAME
-//config:	bool "ubirename (2.2 kb)"
+//config:	bool "ubirename (2.4 kb)"
 //config:	default y
 //config:	select PLATFORM_LINUX
 //config:	help
diff -urpN busybox-1.29.3/miscutils/volname.c busybox-1.30.0/miscutils/volname.c
--- busybox-1.29.3/miscutils/volname.c	2018-07-02 13:23:06.000000000 +0200
+++ busybox-1.30.0/miscutils/volname.c	2018-12-30 16:14:20.000000000 +0100
@@ -28,7 +28,7 @@
  * Matthew Stoltenberg <d3matt@gmail.com>
  */
 //config:config VOLNAME
-//config:	bool "volname (1.7 kb)"
+//config:	bool "volname (1.6 kb)"
 //config:	default y
 //config:	help
 //config:	Prints a CD-ROM volume name.
diff -urpN busybox-1.29.3/miscutils/watchdog.c busybox-1.30.0/miscutils/watchdog.c
--- busybox-1.29.3/miscutils/watchdog.c	2018-07-02 13:23:06.000000000 +0200
+++ busybox-1.30.0/miscutils/watchdog.c	2018-12-30 16:14:20.000000000 +0100
@@ -9,7 +9,7 @@
  * Licensed under GPLv2 or later, see file LICENSE in this source tree.
  */
 //config:config WATCHDOG
-//config:	bool "watchdog (5.1 kb)"
+//config:	bool "watchdog (5.3 kb)"
 //config:	default y
 //config:	select PLATFORM_LINUX
 //config:	help
diff -urpN busybox-1.29.3/modutils/depmod.c busybox-1.30.0/modutils/depmod.c
--- busybox-1.29.3/modutils/depmod.c	2018-07-02 13:23:06.000000000 +0200
+++ busybox-1.30.0/modutils/depmod.c	2018-12-30 16:14:20.000000000 +0100
@@ -8,7 +8,7 @@
  * Licensed under GPLv2 or later, see file LICENSE in this source tree.
  */
 //config:config DEPMOD
-//config:	bool "depmod (26 kb)"
+//config:	bool "depmod (27 kb)"
 //config:	default y
 //config:	select PLATFORM_LINUX
 //config:	help
diff -urpN busybox-1.29.3/modutils/lsmod.c busybox-1.30.0/modutils/lsmod.c
--- busybox-1.29.3/modutils/lsmod.c	2018-07-02 13:23:06.000000000 +0200
+++ busybox-1.30.0/modutils/lsmod.c	2018-12-30 16:14:20.000000000 +0100
@@ -8,7 +8,7 @@
  * Licensed under GPLv2 or later, see file LICENSE in this source tree.
  */
 //config:config LSMOD
-//config:	bool "lsmod (4.3 kb)"
+//config:	bool "lsmod (1.9 kb)"
 //config:	default y
 //config:	select PLATFORM_LINUX
 //config:	help
diff -urpN busybox-1.29.3/modutils/modinfo.c busybox-1.30.0/modutils/modinfo.c
--- busybox-1.29.3/modutils/modinfo.c	2018-07-02 13:23:06.000000000 +0200
+++ busybox-1.30.0/modutils/modinfo.c	2018-12-30 16:14:20.000000000 +0100
@@ -6,7 +6,7 @@
  * Licensed under GPLv2 or later, see file LICENSE in this source tree.
  */
 //config:config MODINFO
-//config:	bool "modinfo (25 kb)"
+//config:	bool "modinfo (24 kb)"
 //config:	default y
 //config:	select PLATFORM_LINUX
 //config:	help
diff -urpN busybox-1.29.3/modutils/modprobe.c busybox-1.30.0/modutils/modprobe.c
--- busybox-1.29.3/modutils/modprobe.c	2018-07-02 13:23:06.000000000 +0200
+++ busybox-1.30.0/modutils/modprobe.c	2018-12-30 16:14:20.000000000 +0100
@@ -8,7 +8,7 @@
  * Licensed under GPLv2 or later, see file LICENSE in this source tree.
  */
 //config:config MODPROBE
-//config:	bool "modprobe (29 kb)"
+//config:	bool "modprobe (28 kb)"
 //config:	default y
 //config:	select PLATFORM_LINUX
 //config:	help
@@ -245,7 +245,7 @@ static int FAST_FUNC config_file_action(
 	parser_t *p;
 	struct module_entry *m;
 	int rc = TRUE;
-	const char *base, *ext;
+	const char *base;
 
 	/* Skip files that begin with a "." */
 	base = bb_basename(filename);
@@ -266,8 +266,7 @@ static int FAST_FUNC config_file_action(
 	 * "include FILE_NOT_ENDING_IN_CONF" must work too.
 	 */
 	if (depth != 0) {
-		ext = strrchr(base, '.');
-		if (ext == NULL || strcmp(ext + 1, "conf"))
+		if (!is_suffixed_with(base, ".conf"))
 			goto error;
 	}
 
diff -urpN busybox-1.29.3/modutils/rmmod.c busybox-1.30.0/modutils/rmmod.c
--- busybox-1.29.3/modutils/rmmod.c	2018-07-02 13:23:06.000000000 +0200
+++ busybox-1.30.0/modutils/rmmod.c	2018-12-30 16:14:20.000000000 +0100
@@ -8,7 +8,7 @@
  * Licensed under GPLv2 or later, see file LICENSE in this source tree.
  */
 //config:config RMMOD
-//config:	bool "rmmod (3.6 kb)"
+//config:	bool "rmmod (3.3 kb)"
 //config:	default y
 //config:	select PLATFORM_LINUX
 //config:	help
diff -urpN busybox-1.29.3/networking/Config.src busybox-1.30.0/networking/Config.src
--- busybox-1.29.3/networking/Config.src	2018-07-02 13:23:06.000000000 +0200
+++ busybox-1.30.0/networking/Config.src	2018-12-30 16:14:20.000000000 +0100
@@ -46,6 +46,17 @@ config VERBOSE_RESOLUTION_ERRORS
 	"can't resolve 'hostname.com'" and want to know more.
 	This may increase size of your executable a bit.
 
+config FEATURE_TLS_SHA1
+	bool "In TLS code, support ciphers which use deprecated SHA1"
+	depends on TLS
+	default n
+	help
+	Selecting this option increases interoperability with very old
+	servers, but slightly increases code size.
+
+	Most TLS servers support SHA256 today (2018), since SHA1 is
+	considered possibly insecure (although not yet definitely broken).
+
 INSERT
 
 source networking/udhcp/Config.in
diff -urpN busybox-1.29.3/networking/arp.c busybox-1.30.0/networking/arp.c
--- busybox-1.29.3/networking/arp.c	2018-07-02 13:23:06.000000000 +0200
+++ busybox-1.30.0/networking/arp.c	2018-12-30 16:14:20.000000000 +0100
@@ -13,7 +13,7 @@
  * modified for getopt32 by Arne Bernin <arne [at] alamut.de>
  */
 //config:config ARP
-//config:	bool "arp (11 kb)"
+//config:	bool "arp (10 kb)"
 //config:	default y
 //config:	select PLATFORM_LINUX
 //config:	help
diff -urpN busybox-1.29.3/networking/arping.c busybox-1.30.0/networking/arping.c
--- busybox-1.29.3/networking/arping.c	2018-07-02 13:23:06.000000000 +0200
+++ busybox-1.30.0/networking/arping.c	2018-12-30 16:14:20.000000000 +0100
@@ -6,7 +6,7 @@
  * Busybox port: Nick Fedchik <nick@fedchik.org.ua>
  */
 //config:config ARPING
-//config:	bool "arping (9.3 kb)"
+//config:	bool "arping (9 kb)"
 //config:	default y
 //config:	select PLATFORM_LINUX
 //config:	help
diff -urpN busybox-1.29.3/networking/brctl.c busybox-1.30.0/networking/brctl.c
--- busybox-1.29.3/networking/brctl.c	2018-07-02 13:23:06.000000000 +0200
+++ busybox-1.30.0/networking/brctl.c	2018-12-05 15:44:34.000000000 +0100
@@ -241,7 +241,7 @@ int brctl_main(int argc UNUSED_PARAM, ch
 
 #if ENABLE_FEATURE_BRCTL_SHOW
 		if (key == ARG_show) { /* show */
-			char brname[IFNAMSIZ];
+			char buf[IFNAMSIZ];
 			int bridx[MAX_PORTS];
 			int i, num;
 			arm_ioctl(args, BRCTL_GET_BRIDGES,
@@ -249,19 +249,18 @@ int brctl_main(int argc UNUSED_PARAM, ch
 			num = xioctl(fd, SIOCGIFBR, args);
 			puts("bridge name\tbridge id\t\tSTP enabled\tinterfaces");
 			for (i = 0; i < num; i++) {
-				char ifname[IFNAMSIZ];
 				int j, tabs;
 				struct __bridge_info bi;
 				unsigned char *x;
 
-				if (!if_indextoname(bridx[i], brname))
+				if (!if_indextoname(bridx[i], buf))
 					bb_perror_msg_and_die("can't get bridge name for index %d", i);
-				strncpy_IFNAMSIZ(ifr.ifr_name, brname);
+				strncpy_IFNAMSIZ(ifr.ifr_name, buf);
 
 				arm_ioctl(args, BRCTL_GET_BRIDGE_INFO,
 							(unsigned long) &bi, 0);
 				xioctl(fd, SIOCDEVPRIVATE, &ifr);
-				printf("%s\t\t", brname);
+				printf("%s\t\t", buf);
 
 				/* print bridge id */
 				x = (unsigned char *) &bi.bridge_id;
@@ -280,13 +279,13 @@ int brctl_main(int argc UNUSED_PARAM, ch
 				for (j = 0; j < MAX_PORTS; j++) {
 					if (!ifidx[j])
 						continue;
-					if (!if_indextoname(ifidx[j], ifname))
+					if (!if_indextoname(ifidx[j], buf))
 						bb_perror_msg_and_die("can't get interface name for index %d", j);
 					if (tabs)
 						printf("\t\t\t\t\t");
 					else
 						tabs = 1;
-					printf("\t\t%s\n", ifname);
+					printf("\t\t%s\n", buf);
 				}
 				if (!tabs)  /* bridge has no interfaces */
 					bb_putchar('\n');
diff -urpN busybox-1.29.3/networking/ether-wake.c busybox-1.30.0/networking/ether-wake.c
--- busybox-1.29.3/networking/ether-wake.c	2018-07-02 13:23:06.000000000 +0200
+++ busybox-1.30.0/networking/ether-wake.c	2018-12-30 16:14:20.000000000 +0100
@@ -64,7 +64,7 @@
  *   filter.  That configuration consumes more power.
  */
 //config:config ETHER_WAKE
-//config:	bool "ether-wake (6.6 kb)"
+//config:	bool "ether-wake (4.9 kb)"
 //config:	default y
 //config:	select PLATFORM_LINUX
 //config:	help
diff -urpN busybox-1.29.3/networking/ftpgetput.c busybox-1.30.0/networking/ftpgetput.c
--- busybox-1.29.3/networking/ftpgetput.c	2018-07-02 13:23:06.000000000 +0200
+++ busybox-1.30.0/networking/ftpgetput.c	2018-12-30 16:14:20.000000000 +0100
@@ -13,13 +13,13 @@
  * Licensed under GPLv2 or later, see file LICENSE in this source tree.
  */
 //config:config FTPGET
-//config:	bool "ftpget (8 kb)"
+//config:	bool "ftpget (7.8 kb)"
 //config:	default y
 //config:	help
 //config:	Retrieve a remote file via FTP.
 //config:
 //config:config FTPPUT
-//config:	bool "ftpput (7.7 kb)"
+//config:	bool "ftpput (7.5 kb)"
 //config:	default y
 //config:	help
 //config:	Store a remote file via FTP.
diff -urpN busybox-1.29.3/networking/hostname.c busybox-1.30.0/networking/hostname.c
--- busybox-1.29.3/networking/hostname.c	2018-07-02 13:23:06.000000000 +0200
+++ busybox-1.30.0/networking/hostname.c	2018-12-30 16:14:20.000000000 +0100
@@ -10,7 +10,7 @@
  * Licensed under GPLv2 or later, see file LICENSE in this source tree.
  */
 //config:config HOSTNAME
-//config:	bool "hostname (5.6 kb)"
+//config:	bool "hostname (5.5 kb)"
 //config:	default y
 //config:	help
 //config:	Show or set the system's host name.
diff -urpN busybox-1.29.3/networking/ifplugd.c busybox-1.30.0/networking/ifplugd.c
--- busybox-1.29.3/networking/ifplugd.c	2018-07-02 13:23:06.000000000 +0200
+++ busybox-1.30.0/networking/ifplugd.c	2018-12-30 16:14:20.000000000 +0100
@@ -7,7 +7,7 @@
  * Licensed under GPLv2 or later, see file LICENSE in this source tree.
  */
 //config:config IFPLUGD
-//config:	bool "ifplugd (9.9 kb)"
+//config:	bool "ifplugd (10 kb)"
 //config:	default y
 //config:	select PLATFORM_LINUX
 //config:	help
diff -urpN busybox-1.29.3/networking/ifupdown.c busybox-1.30.0/networking/ifupdown.c
--- busybox-1.29.3/networking/ifupdown.c	2018-07-02 13:23:06.000000000 +0200
+++ busybox-1.30.0/networking/ifupdown.c	2018-12-30 16:14:20.000000000 +0100
@@ -17,7 +17,7 @@
  * Licensed under GPLv2 or later, see file LICENSE in this source tree.
  */
 //config:config IFUP
-//config:	bool "ifup (17 kb)"
+//config:	bool "ifup (14 kb)"
 //config:	default y
 //config:	help
 //config:	Activate the specified interfaces. This applet makes use
@@ -33,7 +33,7 @@
 //config:	via busybox or via standalone utilities.
 //config:
 //config:config IFDOWN
-//config:	bool "ifdown (15 kb)"
+//config:	bool "ifdown (13 kb)"
 //config:	default y
 //config:	help
 //config:	Deactivate the specified interfaces.
@@ -1022,6 +1022,22 @@ static struct interfaces_file_t *read_in
 			currently_processing = NONE;
 		} else if (strcmp(first_word, "source") == 0) {
 			read_interfaces(next_word(&rest_of_line), defn);
+		} else if (is_prefixed_with(first_word, "source-dir")) {
+			const char *dirpath;
+			DIR *dir;
+			struct dirent *entry;
+
+			dirpath = next_word(&rest_of_line);
+			dir = xopendir(dirpath);
+			while ((entry = readdir(dir)) != NULL) {
+				char *path;
+				if (entry->d_name[0] == '.')
+					continue;
+				path = concat_path_file(dirpath, entry->d_name);
+				read_interfaces(path, defn);
+				free(path);
+			}
+			closedir(dir);
 		} else {
 			switch (currently_processing) {
 			case IFACE:
diff -urpN busybox-1.29.3/networking/inetd.c busybox-1.30.0/networking/inetd.c
--- busybox-1.29.3/networking/inetd.c	2018-07-02 13:23:06.000000000 +0200
+++ busybox-1.30.0/networking/inetd.c	2018-12-30 16:14:20.000000000 +0100
@@ -488,7 +488,7 @@ static void block_CHLD_HUP_ALRM(sigset_t
 	sigaddset(m, SIGCHLD);
 	sigaddset(m, SIGHUP);
 	sigaddset(m, SIGALRM);
-	sigprocmask(SIG_BLOCK, m, m); /* old sigmask is stored in m */
+	sigprocmask2(SIG_BLOCK, m); /* old sigmask is stored in m */
 }
 
 static void restore_sigmask(sigset_t *m)
diff -urpN busybox-1.29.3/networking/ip.c busybox-1.30.0/networking/ip.c
--- busybox-1.29.3/networking/ip.c	2018-07-02 13:23:06.000000000 +0200
+++ busybox-1.30.0/networking/ip.c	2018-12-30 16:14:20.000000000 +0100
@@ -9,7 +9,7 @@
  * Bernhard Reutner-Fischer rewrote to use index_in_substr_array
  */
 //config:config IP
-//config:	bool "ip (34 kb)"
+//config:	bool "ip (35 kb)"
 //config:	default y
 //config:	select PLATFORM_LINUX
 //config:	help
@@ -28,7 +28,7 @@
 //config:	Short form of "ip addr"
 //config:
 //config:config IPLINK
-//config:	bool "iplink (16 kb)"
+//config:	bool "iplink (17 kb)"
 //config:	default y
 //config:	select FEATURE_IP_LINK
 //config:	select PLATFORM_LINUX
@@ -267,8 +267,7 @@
 //--------------123456789.123456789.123456789.123456789.123456789.123456789.123456789.123....79
 //usage:#define iptunnel_trivial_usage
 //usage:       "add|change|del|show [NAME]\n"
-//usage:       "	[mode ipip|gre|sit]\n"
-//usage:       "	[remote ADDR] [local ADDR] [ttl TTL]"
+//usage:       "	[mode ipip|gre|sit] [remote ADDR] [local ADDR] [ttl TTL]"
 //usage:#define iptunnel_full_usage "\n\n"
 //usage:       "iptunnel add|change|del|show [NAME]\n"
 //usage:       "	[mode ipip|gre|sit] [remote ADDR] [local ADDR]\n"
@@ -308,10 +307,9 @@
 //usage:	IF_FEATURE_IP_TUNNEL( IP_BAR_TUNNEL"tunnel")
 //usage:	IF_FEATURE_IP_NEIGH(  IP_BAR_NEIGH "neigh")
 //usage:	IF_FEATURE_IP_RULE(   IP_BAR_RULE  "rule")
-//usage:       " [COMMAND]"
+//usage:       " [ARGS]"
 //usage:#define ip_full_usage "\n\n"
 //usage:       "OPTIONS := -f[amily] inet|inet6|link | -o[neline]\n"
-//usage:       "COMMAND :="
 //usage:	IF_FEATURE_IP_ADDRESS("\n"
 //usage:	"ip addr "ipaddr_trivial_usage)
 //usage:	IF_FEATURE_IP_ROUTE("\n"
diff -urpN busybox-1.29.3/networking/ipcalc.c busybox-1.30.0/networking/ipcalc.c
--- busybox-1.29.3/networking/ipcalc.c	2018-07-02 13:23:06.000000000 +0200
+++ busybox-1.30.0/networking/ipcalc.c	2018-12-30 16:14:20.000000000 +0100
@@ -12,7 +12,7 @@
  * Licensed under GPLv2 or later, see file LICENSE in this source tree.
  */
 //config:config IPCALC
-//config:	bool "ipcalc (4.3 kb)"
+//config:	bool "ipcalc (4.4 kb)"
 //config:	default y
 //config:	help
 //config:	ipcalc takes an IP address and netmask and calculates the
diff -urpN busybox-1.29.3/networking/isrv_identd.c busybox-1.30.0/networking/isrv_identd.c
--- busybox-1.29.3/networking/isrv_identd.c	2018-07-02 13:23:06.000000000 +0200
+++ busybox-1.30.0/networking/isrv_identd.c	2018-12-30 16:14:20.000000000 +0100
@@ -7,7 +7,7 @@
  * Licensed under GPLv2, see file LICENSE in this source tree.
  */
 //config:config FAKEIDENTD
-//config:	bool "fakeidentd (8.9 kb)"
+//config:	bool "fakeidentd (8.7 kb)"
 //config:	default y
 //config:	select FEATURE_SYSLOG
 //config:	help
diff -urpN busybox-1.29.3/networking/nbd-client.c busybox-1.30.0/networking/nbd-client.c
--- busybox-1.29.3/networking/nbd-client.c	2018-07-02 13:23:06.000000000 +0200
+++ busybox-1.30.0/networking/nbd-client.c	2018-12-30 16:14:20.000000000 +0100
@@ -4,7 +4,7 @@
  * Licensed under GPLv2, see file LICENSE in this source tree.
  */
 //config:config NBDCLIENT
-//config:	bool "nbd-client (4.6 kb)"
+//config:	bool "nbd-client (6 kb)"
 //config:	default y
 //config:	help
 //config:	Network block device client
@@ -16,6 +16,7 @@
 #include "libbb.h"
 #include <netinet/tcp.h>
 #include <linux/fs.h>
+#include <getopt.h>
 
 #define NBD_SET_SOCK          _IO(0xab, 0)
 #define NBD_SET_BLKSIZE       _IO(0xab, 1)
@@ -27,57 +28,146 @@
 #define NBD_SET_SIZE_BLOCKS   _IO(0xab, 7)
 #define NBD_DISCONNECT        _IO(0xab, 8)
 #define NBD_SET_TIMEOUT       _IO(0xab, 9)
+#define NBD_SET_FLAGS         _IO(0xab, 10)
 
 //usage:#define nbdclient_trivial_usage
-//usage:       "HOST PORT BLOCKDEV"
+//usage:       "{ [-b BLKSIZE] [-N NAME] [-t SEC] [-p] HOST [PORT] | -d } BLOCKDEV"
 //usage:#define nbdclient_full_usage "\n\n"
-//usage:       "Connect to HOST and provide a network block device on BLOCKDEV"
+//usage:       "Connect to HOST and provide network block device on BLOCKDEV"
 
-//TODO: more compat with nbd-client version 2.9.13 -
-//Usage: nbd-client [bs=blocksize] [timeout=sec] host port nbd_device [-swap] [-persist] [-nofork]
-//Or   : nbd-client -d nbd_device
-//Or   : nbd-client -c nbd_device
-//Default value for blocksize is 1024 (recommended for ethernet)
+//TODO: more compat with nbd-client version 3.17 -
+//nbd-client host [ port ] nbd-device [ -connections num ] [ -sdp ] [ -swap ]
+//	[ -persist ] [ -nofork ] [ -nonetlink ] [ -systemd-mark ]
+//	[ -block-size block size ] [ -timeout seconds ] [ -name name ]
+//	[ -certfile certfile ] [ -keyfile keyfile ] [ -cacertfile cacertfile ]
+//	[ -tlshostname hostname ]
+//nbd-client -unix path nbd-device [ -connections num ] [ -sdp ] [ -swap ]
+//	[ -persist ] [ -nofork ] [ -nonetlink ] [ -systemd-mark ]
+//	[ -block-size block size ] [ -timeout seconds ] [ -name name ]
+//nbd-client nbd-device
+//nbd-client -d nbd-device
+//nbd-client -c nbd-device
+//nbd-client -l host [ port ]
+//nbd-client [ -netlink ] -l host
+//
+//Default value for blocksize is 4096
 //Allowed values for blocksize are 512,1024,2048,4096
-//Note, that kernel 2.4.2 and older ones do not work correctly with
-//blocksizes other than 1024 without patches
 
 int nbdclient_main(int argc, char **argv) MAIN_EXTERNALLY_VISIBLE;
-int nbdclient_main(int argc UNUSED_PARAM, char **argv)
+int nbdclient_main(int argc, char **argv)
 {
-	unsigned long timeout = 0;
 #if BB_MMU
-	int nofork = 0;
+	bool nofork;
 #endif
-	char *host, *port, *device;
+	bool opt_d;
+	bool opt_p;
+	const char *host, *port, *device;
+	const char *name;
+	unsigned blksize, size_blocks;
+	unsigned timeout;
+	int ch;
 	struct nbd_header_t {
 		uint64_t magic1; // "NBDMAGIC"
-		uint64_t magic2; // 0x420281861253 big endian
+		uint64_t magic2; // old style: 0x420281861253 big endian
+		//               // new style: 0x49484156454F5054 (IHAVEOPT)
+	} nbd_header;
+	struct old_nbd_header_t {
 		uint64_t devsize;
 		uint32_t flags;
 		char data[124];
-	} nbd_header;
-
-	BUILD_BUG_ON(offsetof(struct nbd_header_t, data) != 8+8+8+4);
+	} old_nbd_header;
+	struct new_nbd_header_t {
+		uint64_t devsize;
+		uint16_t transmission_flags;
+		char data[124];
+	} new_nbd_header;
+	struct nbd_opt_t {
+		uint64_t magic;
+		uint32_t opt;
+		uint32_t len;
+	} nbd_opts;
+
+	static const struct option long_options[] = {
+		{ "block-size", required_argument, NULL, 'b' },
+		{ "timeout"   , required_argument, NULL, 't' },
+		{ "name"      , required_argument, NULL, 'n' },
+		{ "persist"   , no_argument      , NULL, 'p' },
+		{ NULL }
+	};
 
-	// Parse command line stuff (just a stub now)
-	if (!argv[1] || !argv[2] || !argv[3] || argv[4])
-		bb_show_usage();
+	BUILD_BUG_ON(offsetof(struct old_nbd_header_t, data) != 8 + 4);
+	BUILD_BUG_ON(offsetof(struct new_nbd_header_t, data) != 8 + 2);
 
 #if !BB_MMU
 	bb_daemonize_or_rexec(DAEMON_CLOSE_EXTRA_FDS, argv);
 #endif
 
-	host = argv[1];
-	port = argv[2];
-	device = argv[3];
+	// Parse args. nbd-client uses stupid "one-dash long options" style :(
+	// Even though short forms (-b,-t,-N,-p) exist for all long opts,
+	// older manpages only contained long forms, which probably resulted
+	// in many scripts using them.
+	blksize = 4096;
+	timeout = 0;
+	name = ""; // use of "" instead of NULL simplifies strlen() later
+	opt_d = opt_p = 0;
+	while ((ch = getopt_long_only(argc, argv, "dN:", long_options, NULL)) != -1) {
+		switch (ch) {
+		case 'p':	// -persist
+			opt_p = 1;
+			break;
+		case 'd':	// -d
+			opt_d = 1;
+			break;
+		case 'b':	// -block-size
+			blksize = xatou(optarg);
+			break;
+		case 't':	// -timeout
+			timeout = xatou(optarg);
+			break;
+		case 'N':	// -N
+		case 'n':	// -name
+			name = optarg;
+			break;
+		default:
+			bb_show_usage();
+		}
+	}
+	argv += optind;
+
+	if (opt_d) { // -d
+		if (argv[0] && !argv[1]) {
+			int nbd = xopen(argv[0], O_RDWR);
+			ioctl(nbd, NBD_DISCONNECT);
+			ioctl(nbd, NBD_CLEAR_SOCK);
+			if (ENABLE_FEATURE_CLEAN_UP)
+				close(nbd);
+			return 0;
+		}
+		bb_show_usage();
+	}
+
+	// Allow only argv[] of: HOST [PORT] BLOCKDEV
+	if (!argv[0] || !argv[1] || (argv[2] && argv[3])) {
+		bb_show_usage();
+	}
+
+	host = argv[0];
+	port = argv[2] ? argv[1] : "10809";
+	device = argv[2] ? argv[2] : argv[1];
 
-	// Repeat until spanked (-persist behavior)
-	for (;;) {
+	// Repeat until spanked if -persist
+#if BB_MMU
+	nofork = 0;
+#endif
+	do {
 		int sock, nbd;
 		int ro;
+		int proto_new; // 0 for old, 1 for new
+#if BB_MMU
+		char *data;
+#endif
 
-		// Make sure the /dev/nbd exists
+		// Make sure BLOCKDEV exists
 		nbd = xopen(device, O_RDWR);
 
 		// Find and connect to server
@@ -85,40 +175,99 @@ int nbdclient_main(int argc UNUSED_PARAM
 		setsockopt_1(sock, IPPROTO_TCP, TCP_NODELAY);
 
 		// Log on to the server
-		xread(sock, &nbd_header, 8+8+8+4 + 124);
-		if (memcmp(&nbd_header.magic1, "NBDMAGIC""\x00\x00\x42\x02\x81\x86\x12\x53", 16) != 0)
+		xread(sock, &nbd_header, 8 + 8);
+		if (memcmp(&nbd_header.magic1, "NBDMAGIC",
+				sizeof(nbd_header.magic1)) != 0
+		) {
+			bb_error_msg_and_die("login failed");
+		}
+		if (memcmp(&nbd_header.magic2,
+				"\x00\x00\x42\x02\x81\x86\x12\x53",
+				sizeof(nbd_header.magic2)) == 0
+		) {
+			proto_new = 0;
+		} else if (memcmp(&nbd_header.magic2, "IHAVEOPT", 8) == 0) {
+			proto_new = 1;
+		} else {
 			bb_error_msg_and_die("login failed");
+		}
 
-		// Set 4k block size.  Everything uses that these days
-		ioctl(nbd, NBD_SET_BLKSIZE, 4096);
-		ioctl(nbd, NBD_SET_SIZE_BLOCKS, SWAP_BE64(nbd_header.devsize) / 4096);
-		ioctl(nbd, NBD_CLEAR_SOCK);
-
-		// If the sucker was exported read only, respect that locally
-		ro = (nbd_header.flags & SWAP_BE32(2)) / SWAP_BE32(2);
-		if (ioctl(nbd, BLKROSET, &ro) < 0)
+		if (!proto_new) {
+			xread(sock, &old_nbd_header,
+					sizeof(old_nbd_header.devsize) +
+					sizeof(old_nbd_header.flags) +
+					sizeof(old_nbd_header.data));
+			size_blocks = SWAP_BE64(old_nbd_header.devsize) / blksize;
+			ioctl(nbd, NBD_SET_BLKSIZE, (unsigned long) blksize);
+			ioctl(nbd, NBD_SET_SIZE_BLOCKS, size_blocks);
+			ioctl(nbd, NBD_CLEAR_SOCK);
+			ro = !!(old_nbd_header.flags & htons(2));
+#if BB_MMU
+			data = old_nbd_header.data;
+#endif
+		} else {
+			unsigned namelen;
+			uint16_t handshake_flags;
+
+			xread(sock, &handshake_flags, sizeof(handshake_flags));
+			xwrite(sock, &const_int_0, sizeof(const_int_0)); // client_flags
+
+			memcpy(&nbd_opts.magic, "IHAVEOPT",
+					sizeof(nbd_opts.magic));
+			nbd_opts.opt = htonl(1); // NBD_OPT_EXPORT_NAME
+			namelen = strlen(name);
+			nbd_opts.len = htonl(namelen);
+			xwrite(sock, &nbd_opts,
+					sizeof(nbd_opts.magic) +
+					sizeof(nbd_opts.opt) +
+					sizeof(nbd_opts.len));
+			xwrite(sock, name, namelen);
+
+			xread(sock, &new_nbd_header,
+					sizeof(new_nbd_header.devsize) +
+					sizeof(new_nbd_header.transmission_flags) +
+					sizeof(new_nbd_header.data));
+			size_blocks = SWAP_BE64(new_nbd_header.devsize) / blksize;
+			ioctl(nbd, NBD_SET_BLKSIZE, (unsigned long) blksize);
+			ioctl(nbd, NBD_SET_SIZE_BLOCKS, size_blocks);
+			ioctl(nbd, NBD_CLEAR_SOCK);
+			ioctl(nbd, NBD_SET_FLAGS,
+					ntohs(new_nbd_header.transmission_flags));
+			ro = !!(new_nbd_header.transmission_flags & htons(2));
+#if BB_MMU
+			data = new_nbd_header.data;
+#endif
+		}
+
+		if (ioctl(nbd, BLKROSET, &ro) < 0) {
 			bb_perror_msg_and_die("BLKROSET");
+		}
 
-		if (timeout)
-			if (ioctl(nbd, NBD_SET_TIMEOUT, timeout))
+		if (timeout) {
+			if (ioctl(nbd, NBD_SET_TIMEOUT, (unsigned long) timeout)) {
 				bb_perror_msg_and_die("NBD_SET_TIMEOUT");
-		if (ioctl(nbd, NBD_SET_SOCK, sock))
-			bb_perror_msg_and_die("NBD_SET_SOCK");
+			}
+		}
 
-		// if (swap) mlockall(MCL_CURRENT|MCL_FUTURE);
+		if (ioctl(nbd, NBD_SET_SOCK, sock)) {
+			bb_perror_msg_and_die("NBD_SET_SOCK");
+		}
 
+		//if (swap) mlockall(MCL_CURRENT|MCL_FUTURE);
 #if BB_MMU
 		// Open the device to force reread of the partition table.
 		// Need to do it in a separate process, since open(device)
 		// needs some other process to sit in ioctl(nbd, NBD_DO_IT).
 		if (fork() == 0) {
+			/* child */
 			char *s = strrchr(device, '/');
-			sprintf(nbd_header.data, "/sys/block/%.32s/pid", s ? s + 1 : device);
+			sprintf(data, "/sys/block/%.32s/pid", s ? s + 1 : device);
 			// Is it up yet?
 			for (;;) {
-				int fd = open(nbd_header.data, O_RDONLY);
+				int fd = open(data, O_RDONLY);
 				if (fd >= 0) {
-					//close(fd);
+					if (ENABLE_FEATURE_CLEAN_UP)
+						close(fd);
 					break;
 				}
 				sleep(1);
@@ -133,7 +282,6 @@ int nbdclient_main(int argc UNUSED_PARAM
 			nofork = 1;
 		}
 #endif
-
 		// This turns us (the process that calls this ioctl)
 		// into a dedicated NBD request handler.
 		// We block here for a long time.
@@ -148,7 +296,7 @@ int nbdclient_main(int argc UNUSED_PARAM
 
 		close(sock);
 		close(nbd);
-	}
+	} while (opt_p);
 
 	return 0;
 }
diff -urpN busybox-1.29.3/networking/nslookup.c busybox-1.30.0/networking/nslookup.c
--- busybox-1.29.3/networking/nslookup.c	2018-07-02 13:23:06.000000000 +0200
+++ busybox-1.30.0/networking/nslookup.c	2018-12-30 16:14:20.000000000 +0100
@@ -1,7 +1,7 @@
 /* vi: set sw=4 ts=4: */
 
 //config:config NSLOOKUP
-//config:	bool "nslookup (4.5 kb)"
+//config:	bool "nslookup (9.7 kb)"
 //config:	default y
 //config:	help
 //config:	nslookup is a tool to query Internet name servers.
@@ -318,6 +318,8 @@ struct globals {
 	unsigned serv_count;
 	struct ns *server;
 	struct query *query;
+	char *search;
+	smalluint have_search_directive;
 } FIX_ALIASING;
 #define G (*(struct globals*)bb_common_bufsiz1)
 #define INIT_G() do { \
@@ -667,24 +669,60 @@ static void parse_resolvconf(void)
 
 	resolv = fopen("/etc/resolv.conf", "r");
 	if (resolv) {
-		char line[128], *p;
+		char line[512];	/* "search" is defined to be up to 256 chars */
 
 		while (fgets(line, sizeof(line), resolv)) {
-			p = strtok(line, " \t\n");
+			char *p, *arg;
 
-			if (!p || strcmp(p, "nameserver") != 0)
+			p = strtok(line, " \t\n");
+			if (!p)
+				continue;
+			dbg("resolv_key:'%s'\n", p);
+			arg = strtok(NULL, "\n");
+			dbg("resolv_arg:'%s'\n", arg);
+			if (!arg)
 				continue;
 
-			p = strtok(NULL, " \t\n");
+			if (strcmp(p, "domain") == 0) {
+				/* domain DOM */
+				if (!G.have_search_directive)
+					goto set_search;
+				continue;
+			}
+			if (strcmp(p, "search") == 0) {
+				/* search DOM1 DOM2... */
+				G.have_search_directive = 1;
+ set_search:
+				free(G.search);
+				G.search = xstrdup(arg);
+				dbg("search='%s'\n", G.search);
+				continue;
+			}
 
-			if (!p)
+			if (strcmp(p, "nameserver") != 0)
 				continue;
 
-			add_ns(xstrdup(p));
+			/* nameserver DNS */
+			add_ns(xstrdup(arg));
 		}
 
 		fclose(resolv);
 	}
+
+	if (!G.search) {
+		/* default search domain is domain part of hostname */
+		char *h = safe_gethostname();
+		char *d = strchr(h, '.');
+		if (d) {
+			G.search = d + 1;
+			dbg("search='%s' (from hostname)\n", G.search);
+		}
+		/* else free(h); */
+	}
+
+	/* Cater for case of "domain ." in resolv.conf */
+	if (G.search && LONE_CHAR(G.search, '.'))
+		G.search = NULL;
 }
 
 static void add_query(int type, const char *dname)
@@ -695,7 +733,7 @@ static void add_query(int type, const ch
 
 	count = G.query_count++;
 
-	G.query = xrealloc_vector(G.query, /*2=2^1:*/ 1, count);
+	G.query = xrealloc_vector(G.query, /*4=2^2:*/ 2, count);
 	new_q = &G.query[count];
 
 	dbg("new query#%u type %u for '%s'\n", count, type, dname);
@@ -709,6 +747,28 @@ static void add_query(int type, const ch
 	new_q->qlen = qlen;
 }
 
+static void add_query_with_search(int type, const char *dname)
+{
+	char *s;
+
+	if (type == T_PTR || !G.search || strchr(dname, '.')) {
+		add_query(type, dname);
+		return;
+	}
+
+	s = G.search;
+	for (;;) {
+		char *fullname, *e;
+
+		e = skip_non_whitespace(s);
+		fullname = xasprintf("%s.%.*s", dname, (int)(e - s), s);
+		add_query(type, fullname);
+		s = skip_whitespace(e);
+		if (!*s)
+			break;
+	}
+}
+
 static char *make_ptr(const char *addrstr)
 {
 	unsigned char addr[16];
@@ -833,6 +893,18 @@ int nslookup_main(int argc UNUSED_PARAM,
 		}
 	}
 
+	/* Use given DNS server if present */
+	if (argv[1]) {
+		if (argv[2])
+			bb_show_usage();
+		add_ns(argv[1]);
+	} else {
+		parse_resolvconf();
+		/* Fall back to localhost if we could not find NS in resolv.conf */
+		if (G.serv_count == 0)
+			add_ns("127.0.0.1");
+	}
+
 	if (types == 0) {
 		/* No explicit type given, guess query type.
 		 * If we can convert the domain argument into a ptr (means that
@@ -846,31 +918,19 @@ int nslookup_main(int argc UNUSED_PARAM,
 		if (ptr) {
 			add_query(T_PTR, ptr);
 		} else {
-			add_query(T_A, argv[0]);
+			add_query_with_search(T_A, argv[0]);
 #if ENABLE_FEATURE_IPV6
-			add_query(T_AAAA, argv[0]);
+			add_query_with_search(T_AAAA, argv[0]);
 #endif
 		}
 	} else {
 		int c;
 		for (c = 0; c < ARRAY_SIZE(qtypes); c++) {
 			if (types & (1 << c))
-				add_query(qtypes[c].type, argv[0]);
+				add_query_with_search(qtypes[c].type, argv[0]);
 		}
 	}
 
-	/* Use given DNS server if present */
-	if (argv[1]) {
-		if (argv[2])
-			bb_show_usage();
-		add_ns(argv[1]);
-	} else {
-		parse_resolvconf();
-		/* Fall back to localhost if we could not find NS in resolv.conf */
-		if (G.serv_count == 0)
-			add_ns("127.0.0.1");
-	}
-
 	for (rc = 0; rc < G.serv_count;) {
 		int c;
 
diff -urpN busybox-1.29.3/networking/ntpd.c busybox-1.30.0/networking/ntpd.c
--- busybox-1.29.3/networking/ntpd.c	2018-07-02 13:23:06.000000000 +0200
+++ busybox-1.30.0/networking/ntpd.c	2018-12-30 16:14:20.000000000 +0100
@@ -41,7 +41,7 @@
  ***********************************************************************
  */
 //config:config NTPD
-//config:	bool "ntpd (17 kb)"
+//config:	bool "ntpd (22 kb)"
 //config:	default y
 //config:	select PLATFORM_LINUX
 //config:	help
@@ -62,13 +62,20 @@
 //config:	help
 //config:	Make ntpd look in /etc/ntp.conf for peers. Only "server address"
 //config:	is supported.
+//config:
+//config:config FEATURE_NTP_AUTH
+//config:	bool "Support md5/sha1 message authentication codes"
+//config:	default y
+//config:	depends on NTPD
 
 //applet:IF_NTPD(APPLET(ntpd, BB_DIR_USR_SBIN, BB_SUID_DROP))
 
 //kbuild:lib-$(CONFIG_NTPD) += ntpd.o
 
 //usage:#define ntpd_trivial_usage
-//usage:	"[-dnqNw"IF_FEATURE_NTPD_SERVER("l -I IFACE")"] [-S PROG] [-p PEER]..."
+//usage:	"[-dnqNw"IF_FEATURE_NTPD_SERVER("l] [-I IFACE")"] [-S PROG]"
+//usage:	IF_NOT_FEATURE_NTP_AUTH(" [-p PEER]...")
+//usage:	IF_FEATURE_NTP_AUTH(" [-k KEYFILE] [-p [keyno:N:]PEER]...")
 //usage:#define ntpd_full_usage "\n\n"
 //usage:       "NTP client/server\n"
 //usage:     "\n	-d	Verbose (may be repeated)"
@@ -76,8 +83,16 @@
 //usage:     "\n	-q	Quit after clock is set"
 //usage:     "\n	-N	Run at high priority"
 //usage:     "\n	-w	Do not set time (only query peers), implies -n"
-//usage:     "\n	-S PROG	Run PROG after stepping time, stratum change, and every 11 mins"
+//usage:     "\n	-S PROG	Run PROG after stepping time, stratum change, and every 11 min"
+//usage:	IF_NOT_FEATURE_NTP_AUTH(
 //usage:     "\n	-p PEER	Obtain time from PEER (may be repeated)"
+//usage:	)
+//usage:	IF_FEATURE_NTP_AUTH(
+//usage:     "\n	-k FILE	Key file (ntp.keys compatible)"
+//usage:     "\n	-p [keyno:NUM:]PEER"
+//usage:     "\n		Obtain time from PEER (may be repeated)"
+//usage:     "\n		Use key NUM for authentication"
+//usage:	)
 //usage:	IF_FEATURE_NTPD_CONF(
 //usage:     "\n		If -p is not given, 'server HOST' lines"
 //usage:     "\n		from /etc/ntp.conf are used"
@@ -149,7 +164,8 @@
  */
 
 #define INITIAL_SAMPLES    4    /* how many samples do we want for init */
-#define BAD_DELAY_GROWTH   4    /* drop packet if its delay grew by more than this */
+#define MIN_FREQHOLD      12    /* adjust offset, but not freq in this many first adjustments */
+#define BAD_DELAY_GROWTH   4    /* drop packet if its delay grew by more than this factor */
 
 #define RETRY_INTERVAL    32    /* on send/recv error, retry in N secs (need to be power of 2) */
 #define NOREPLY_INTERVAL 512    /* sent, but got no reply: cap next query by this many seconds */
@@ -227,14 +243,18 @@
 /* Parameter averaging constant */
 #define AVG             4
 
+#define MAX_KEY_NUMBER  65535
+#define KEYID_SIZE      sizeof(uint32_t)
 
 enum {
 	NTP_VERSION     = 4,
 	NTP_MAXSTRATUM  = 15,
 
-	NTP_DIGESTSIZE     = 16,
-	NTP_MSGSIZE_NOAUTH = 48,
-	NTP_MSGSIZE        = (NTP_MSGSIZE_NOAUTH + 4 + NTP_DIGESTSIZE),
+	NTP_MD5_DIGESTSIZE    = 16,
+	NTP_MSGSIZE_NOAUTH    = 48,
+	NTP_MSGSIZE_MD5_AUTH  = NTP_MSGSIZE_NOAUTH + KEYID_SIZE + NTP_MD5_DIGESTSIZE,
+	NTP_SHA1_DIGESTSIZE   = 20,
+	NTP_MSGSIZE_SHA1_AUTH = NTP_MSGSIZE_NOAUTH + KEYID_SIZE + NTP_SHA1_DIGESTSIZE,
 
 	/* Status Masks */
 	MODE_MASK       = (7 << 0),
@@ -287,7 +307,7 @@ typedef struct {
 	l_fixedpt_t m_rectime;
 	l_fixedpt_t m_xmttime;
 	uint32_t    m_keyid;
-	uint8_t     m_digest[NTP_DIGESTSIZE];
+	uint8_t     m_digest[ENABLE_FEATURE_NTP_AUTH ? NTP_SHA1_DIGESTSIZE : NTP_MD5_DIGESTSIZE];
 } msg_t;
 
 typedef struct {
@@ -296,9 +316,26 @@ typedef struct {
 	double d_dispersion;
 } datapoint_t;
 
+#if ENABLE_FEATURE_NTP_AUTH
+enum {
+	HASH_MD5,
+	HASH_SHA1,
+};
+typedef struct {
+	unsigned id; //try uint16_t?
+	smalluint type;
+	smalluint msg_size;
+	smalluint key_length;
+	char key[0];
+} key_entry_t;
+#endif
+
 typedef struct {
 	len_and_sockaddr *p_lsa;
 	char             *p_dotted;
+#if ENABLE_FEATURE_NTP_AUTH
+	key_entry_t      *key_entry;
+#endif
 	int              p_fd;
 	int              datapoint_idx;
 	uint32_t         lastpkt_refid;
@@ -336,13 +373,14 @@ enum {
 	OPT_q = (1 << 1),
 	OPT_N = (1 << 2),
 	OPT_x = (1 << 3),
+	OPT_k = (1 << 4) * ENABLE_FEATURE_NTP_AUTH,
 	/* Insert new options above this line. */
 	/* Non-compat options: */
-	OPT_w = (1 << 4),
-	OPT_p = (1 << 5),
-	OPT_S = (1 << 6),
-	OPT_l = (1 << 7) * ENABLE_FEATURE_NTPD_SERVER,
-	OPT_I = (1 << 8) * ENABLE_FEATURE_NTPD_SERVER,
+	OPT_w = (1 << (4+ENABLE_FEATURE_NTP_AUTH)),
+	OPT_p = (1 << (5+ENABLE_FEATURE_NTP_AUTH)),
+	OPT_S = (1 << (6+ENABLE_FEATURE_NTP_AUTH)),
+	OPT_l = (1 << (7+ENABLE_FEATURE_NTP_AUTH)) * ENABLE_FEATURE_NTPD_SERVER,
+	OPT_I = (1 << (8+ENABLE_FEATURE_NTP_AUTH)) * ENABLE_FEATURE_NTPD_SERVER,
 	/* We hijack some bits for other purposes */
 	OPT_qq = (1 << 31),
 };
@@ -815,8 +853,12 @@ resolve_peer_hostname(peer_t *p)
 	return lsa;
 }
 
+#if !ENABLE_FEATURE_NTP_AUTH
+#define add_peers(s, key_entry) \
+	add_peers(s)
+#endif
 static void
-add_peers(const char *s)
+add_peers(const char *s, key_entry_t *key_entry)
 {
 	llist_t *item;
 	peer_t *p;
@@ -845,6 +887,7 @@ add_peers(const char *s)
 		}
 	}
 
+	IF_FEATURE_NTP_AUTH(p->key_entry = key_entry;)
 	llist_add_to(&G.ntp_peers, p);
 	G.peer_cnt++;
 }
@@ -869,6 +912,48 @@ do_sendto(int fd,
 	return 0;
 }
 
+#if ENABLE_FEATURE_NTP_AUTH
+static void
+hash(key_entry_t *key_entry, const msg_t *msg, uint8_t *output)
+{
+	union {
+		md5_ctx_t m;
+		sha1_ctx_t s;
+	} ctx;
+	unsigned hash_size = sizeof(*msg) - sizeof(msg->m_keyid) - sizeof(msg->m_digest);
+
+	switch (key_entry->type) {
+	case HASH_MD5:
+		md5_begin(&ctx.m);
+		md5_hash(&ctx.m, key_entry->key, key_entry->key_length);
+		md5_hash(&ctx.m, msg, hash_size);
+		md5_end(&ctx.m, output);
+		break;
+	default: /* it's HASH_SHA1 */
+		sha1_begin(&ctx.s);
+		sha1_hash(&ctx.s, key_entry->key, key_entry->key_length);
+		sha1_hash(&ctx.s, msg, hash_size);
+		sha1_end(&ctx.s, output);
+		break;
+	}
+}
+
+static void
+hash_peer(peer_t *p)
+{
+	p->p_xmt_msg.m_keyid = htonl(p->key_entry->id);
+	hash(p->key_entry, &p->p_xmt_msg, p->p_xmt_msg.m_digest);
+}
+
+static int
+hashes_differ(peer_t *p, const msg_t *msg)
+{
+	uint8_t digest[NTP_SHA1_DIGESTSIZE];
+	hash(p->key_entry, msg, digest);
+	return memcmp(digest, msg->m_digest, p->key_entry->msg_size - NTP_MSGSIZE_NOAUTH - KEYID_SIZE);
+}
+#endif
+
 static void
 send_query_to_peer(peer_t *p)
 {
@@ -945,9 +1030,18 @@ send_query_to_peer(peer_t *p)
 	 */
 	p->reachable_bits <<= 1;
 
+#if ENABLE_FEATURE_NTP_AUTH
+	if (p->key_entry)
+		hash_peer(p);
 	if (do_sendto(p->p_fd, /*from:*/ NULL, /*to:*/ &p->p_lsa->u.sa, /*addrlen:*/ p->p_lsa->len,
-			&p->p_xmt_msg, NTP_MSGSIZE_NOAUTH) == -1
-	) {
+		&p->p_xmt_msg, !p->key_entry ? NTP_MSGSIZE_NOAUTH : p->key_entry->msg_size) == -1
+	)
+#else
+	if (do_sendto(p->p_fd, /*from:*/ NULL, /*to:*/ &p->p_lsa->u.sa, /*addrlen:*/ p->p_lsa->len,
+		&p->p_xmt_msg, NTP_MSGSIZE_NOAUTH) == -1
+	)
+#endif
+	{
 		close(p->p_fd);
 		p->p_fd = -1;
 		/*
@@ -1115,20 +1209,25 @@ fit(peer_t *p, double rd)
 {
 	if ((p->reachable_bits & (p->reachable_bits-1)) == 0) {
 		/* One or zero bits in reachable_bits */
-		VERB4 bb_error_msg("peer %s unfit for selection: unreachable", p->p_dotted);
+		VERB4 bb_error_msg("peer %s unfit for selection: "
+				"unreachable", p->p_dotted);
 		return 0;
 	}
 #if 0 /* we filter out such packets earlier */
 	if ((p->lastpkt_status & LI_ALARM) == LI_ALARM
 	 || p->lastpkt_stratum >= MAXSTRAT
 	) {
-		VERB4 bb_error_msg("peer %s unfit for selection: bad status/stratum", p->p_dotted);
+		VERB4 bb_error_msg("peer %s unfit for selection: "
+				"bad status/stratum", p->p_dotted);
 		return 0;
 	}
 #endif
 	/* rd is root_distance(p) */
 	if (rd > MAXDIST + FREQ_TOLERANCE * (1 << G.poll_exp)) {
-		VERB4 bb_error_msg("peer %s unfit for selection: root distance too high", p->p_dotted);
+		VERB3 bb_error_msg("peer %s unfit for selection: "
+			"root distance %f too high, jitter:%f",
+			p->p_dotted, rd, p->filter_jitter
+		);
 		return 0;
 	}
 //TODO
@@ -1753,7 +1852,7 @@ update_local_clock(peer_t *p)
 //15:19:39.114 update from:<IP> offset:+0.327022 delay:0.158384 jitter:0.108538 clock drift:-1.393ppm tc:4
 //15:20:12.715 update from:<IP> offset:+0.275596 delay:0.158297 jitter:0.097292 clock drift:-1.393ppm tc:4
 //15:20:45.111 update from:<IP> offset:+0.225715 delay:0.158271 jitter:0.087841 clock drift:-1.393ppm tc:4
-// If allwed to continue, it would start increasing tmx.freq now.
+// If allowed to continue, it would start increasing tmx.freq now.
 // Instead, it was ^Ced, and started anew:
 //15:21:15.043 no valid datapoints, no peer selected
 //15:21:17.408 update from:<IP> offset:+0.175910 delay:0.158314 jitter:0.076683 clock drift:-1.393ppm tc:4
@@ -1776,9 +1875,9 @@ update_local_clock(peer_t *p)
 //15:31:53.473 update from:<IP> offset:+0.000007 delay:0.158142 jitter:0.010922 clock drift:+9.343ppm tc:6
 //15:32:58.902 update from:<IP> offset:-0.000728 delay:0.158222 jitter:0.009454 clock drift:+9.298ppm tc:6
 			/*
-			 * This expression would choose 15 in the above example.
+			 * This expression would choose MIN_FREQHOLD + 8 in the above example.
 			 */
-			G.FREQHOLD_cnt = 8 + ((unsigned)(abs(tmx.offset)) >> 16);
+			G.FREQHOLD_cnt = 1 + MIN_FREQHOLD + ((unsigned)(abs(tmx.offset)) >> 16);
 		}
 		G.FREQHOLD_cnt--;
 		tmx.status |= STA_FREQHOLD;
@@ -1818,7 +1917,7 @@ update_local_clock(peer_t *p)
 	VERB2 bb_error_msg("update from:%s offset:%+f delay:%f jitter:%f clock drift:%+.3fppm tc:%d",
 			p->p_dotted,
 			offset,
-			p->lastpkt_delay,
+			p->p_raw_delay,
 			G.discipline_jitter,
 			(double)tmx.freq / 65536,
 			(int)tmx.constant
@@ -1918,10 +2017,21 @@ recv_and_process_peer_pkt(peer_t *p)
 		bb_perror_msg_and_die("recv(%s) error", p->p_dotted);
 	}
 
-	if (size != NTP_MSGSIZE_NOAUTH && size != NTP_MSGSIZE) {
+#if ENABLE_FEATURE_NTP_AUTH
+	if (size != NTP_MSGSIZE_NOAUTH && size != NTP_MSGSIZE_MD5_AUTH && size != NTP_MSGSIZE_SHA1_AUTH) {
+		bb_error_msg("malformed packet received from %s", p->p_dotted);
+		return;
+	}
+	if (p->key_entry && hashes_differ(p, &msg)) {
+		bb_error_msg("invalid cryptographic hash received from %s", p->p_dotted);
+		return;
+	}
+#else
+	if (size != NTP_MSGSIZE_NOAUTH && size != NTP_MSGSIZE_MD5_AUTH) {
 		bb_error_msg("malformed packet received from %s", p->p_dotted);
 		return;
 	}
+#endif
 
 	if (msg.m_orgtime.int_partl != p->p_xmt_msg.m_xmttime.int_partl
 	 || msg.m_orgtime.fractionl != p->p_xmt_msg.m_xmttime.fractionl
@@ -1975,27 +2085,30 @@ recv_and_process_peer_pkt(peer_t *p)
 	T2 = lfp_to_d(msg.m_rectime);
 	T3 = lfp_to_d(msg.m_xmttime);
 	T4 = G.cur_time;
-
-	/* The delay calculation is a special case. In cases where the
-	 * server and client clocks are running at different rates and
-	 * with very fast networks, the delay can appear negative. In
-	 * order to avoid violating the Principle of Least Astonishment,
-	 * the delay is clamped not less than the system precision.
-	 */
 	delay = (T4 - T1) - (T3 - T2);
-	if (delay < G_precision_sec)
-		delay = G_precision_sec;
+
 	/*
 	 * If this packet's delay is much bigger than the last one,
 	 * it's better to just ignore it than use its much less precise value.
 	 */
 	prev_delay = p->p_raw_delay;
-	p->p_raw_delay = delay;
-	if (p->reachable_bits && delay > prev_delay * BAD_DELAY_GROWTH) {
+	p->p_raw_delay = (delay < 0 ? 0.0 : delay);
+	if (p->reachable_bits
+	 && delay > prev_delay * BAD_DELAY_GROWTH
+	 && delay > 1.0 / (8 * 1024) /* larger than ~0.000122 */
+	) {
 		bb_error_msg("reply from %s: delay %f is too high, ignoring", p->p_dotted, delay);
 		goto pick_normal_interval;
 	}
 
+	/* The delay calculation is a special case. In cases where the
+	 * server and client clocks are running at different rates and
+	 * with very fast networks, the delay can appear negative. In
+	 * order to avoid violating the Principle of Least Astonishment,
+	 * the delay is clamped not less than the system precision.
+	 */
+	if (delay < G_precision_sec)
+		delay = G_precision_sec;
 	p->lastpkt_delay = delay;
 	p->lastpkt_recv_time = T4;
 	VERB6 bb_error_msg("%s->lastpkt_recv_time=%f", p->p_dotted, p->lastpkt_recv_time);
@@ -2023,7 +2136,7 @@ recv_and_process_peer_pkt(peer_t *p)
 		bb_error_msg("reply from %s: offset:%+f delay:%f status:0x%02x strat:%d refid:0x%08x rootdelay:%f reach:0x%02x",
 			p->p_dotted,
 			offset,
-			p->lastpkt_delay,
+			p->p_raw_delay,
 			p->lastpkt_status,
 			p->lastpkt_stratum,
 			p->lastpkt_refid,
@@ -2126,7 +2239,12 @@ recv_and_process_client_pkt(void /*int f
 	from = xzalloc(to->len);
 
 	size = recv_from_to(G_listen_fd, &msg, sizeof(msg), MSG_DONTWAIT, from, &to->u.sa, to->len);
-	if (size != NTP_MSGSIZE_NOAUTH && size != NTP_MSGSIZE) {
+#if ENABLE_FEATURE_NTP_AUTH
+	if (size != NTP_MSGSIZE_NOAUTH && size != NTP_MSGSIZE_MD5_AUTH && size != NTP_MSGSIZE_SHA1_AUTH)
+#else
+	if (size != NTP_MSGSIZE_NOAUTH && size != NTP_MSGSIZE_MD5_AUTH)
+#endif
+	{
 		char *addr;
 		if (size < 0) {
 			if (errno == EAGAIN)
@@ -2269,6 +2387,19 @@ recv_and_process_client_pkt(void /*int f
  *      with the -g and -q options. See the tinker command for other options.
  *      Note: The kernel time discipline is disabled with this option.
  */
+#if ENABLE_FEATURE_NTP_AUTH
+static key_entry_t *
+find_key_entry(llist_t *key_entries, unsigned id)
+{
+	while (key_entries) {
+		key_entry_t *cur = (key_entry_t*) key_entries->data;
+		if (cur->id == id)
+			return cur;
+		key_entries = key_entries->link;
+	}
+	bb_error_msg_and_die("key %u is not defined", id);
+}
+#endif
 
 /* By doing init in a separate function we decrease stack usage
  * in main loop.
@@ -2277,6 +2408,10 @@ static NOINLINE void ntp_init(char **arg
 {
 	unsigned opts;
 	llist_t *peers;
+#if ENABLE_FEATURE_NTP_AUTH
+	llist_t *key_entries;
+	char *key_file_path;
+#endif
 
 	srand(getpid());
 
@@ -2293,8 +2428,10 @@ static NOINLINE void ntp_init(char **arg
 
 	/* Parse options */
 	peers = NULL;
+	IF_FEATURE_NTP_AUTH(key_entries = NULL;)
 	opts = getopt32(argv, "^"
 			"nqNx" /* compat */
+			IF_FEATURE_NTP_AUTH("k:")  /* compat */
 			"wp:*S:"IF_FEATURE_NTPD_SERVER("l") /* NOT compat */
 			IF_FEATURE_NTPD_SERVER("I:") /* compat */
 			"d" /* compat */
@@ -2302,11 +2439,11 @@ static NOINLINE void ntp_init(char **arg
 				"\0"
 				"dd:wn"  /* -d: counter; -p: list; -w implies -n */
 				IF_FEATURE_NTPD_SERVER(":Il") /* -I implies -l */
-			, &peers, &G.script_name,
-#if ENABLE_FEATURE_NTPD_SERVER
-			&G.if_name,
-#endif
-			&G.verbose);
+			IF_FEATURE_NTP_AUTH(, &key_file_path)
+			, &peers, &G.script_name
+			IF_FEATURE_NTPD_SERVER(, &G.if_name)
+			, &G.verbose
+	);
 
 //	if (opts & OPT_x) /* disable stepping, only slew is allowed */
 //		G.time_was_stepped = 1;
@@ -2332,19 +2469,108 @@ static NOINLINE void ntp_init(char **arg
 		logmode = LOGMODE_NONE;
 	}
 
+#if ENABLE_FEATURE_NTP_AUTH
+	if (opts & OPT_k) {
+		char *tokens[4];
+		parser_t *parser;
+
+		parser = config_open(key_file_path);
+		while (config_read(parser, tokens, 4, 3, "# \t", PARSE_NORMAL | PARSE_MIN_DIE) == 3) {
+			key_entry_t *key_entry;
+			char buffer[40];
+			smalluint hash_type;
+			smalluint msg_size;
+			smalluint key_length;
+			char *key;
+
+			if ((tokens[1][0] | 0x20) == 'm')
+				/* supports 'M' and 'md5' formats */
+				hash_type = HASH_MD5;
+			else
+			if (strncasecmp(tokens[1], "sha", 3) == 0)
+				/* supports 'sha' and 'sha1' formats */
+				hash_type = HASH_SHA1;
+			else
+				bb_error_msg_and_die("only MD5 and SHA1 keys supported");
+/* man ntp.keys:
+ *  MD5    The key is 1 to 16 printable characters terminated by an EOL,
+ *         whitespace, or a # (which is the "start of comment" character).
+ *  SHA
+ *  SHA1
+ *  RMD160 The key is a hex-encoded ASCII string of 40 characters, which
+ *         is truncated as necessary.
+ */
+			key_length = strnlen(tokens[2], sizeof(buffer)+1);
+			if (key_length >= sizeof(buffer)+1) {
+ err:
+				bb_error_msg_and_die("malformed key at line %u", parser->lineno);
+			}
+			if (hash_type == HASH_MD5) {
+				key = tokens[2];
+				msg_size = NTP_MSGSIZE_MD5_AUTH;
+			} else /* it's hash_type == HASH_SHA1 */
+			if (!(key_length & 1)) {
+				key_length >>= 1;
+				if (!hex2bin(buffer, tokens[2], key_length))
+					goto err;
+				key = buffer;
+				msg_size = NTP_MSGSIZE_SHA1_AUTH;
+			} else {
+				goto err;
+			}
+			key_entry = xzalloc(sizeof(*key_entry) + key_length);
+			key_entry->type = hash_type;
+			key_entry->msg_size = msg_size;
+			key_entry->key_length = key_length;
+			memcpy(key_entry->key, key, key_length);
+			key_entry->id = xatou_range(tokens[0], 1, MAX_KEY_NUMBER);
+			llist_add_to(&key_entries, key_entry);
+		}
+		config_close(parser);
+	}
+#endif
 	if (peers) {
+#if ENABLE_FEATURE_NTP_AUTH
+		while (peers) {
+			char *peer = llist_pop(&peers);
+			key_entry_t *key_entry = NULL;
+			if (strncmp(peer, "keyno:", 6) == 0) {
+				char *end;
+				int key_id;
+				peer += 6;
+				end = strchr(peer, ':');
+				if (!end) bb_show_usage();
+				*end = '\0';
+				key_id = xatou_range(peer, 1, MAX_KEY_NUMBER);
+				*end = ':';
+				key_entry = find_key_entry(key_entries, key_id);
+				peer = end + 1;
+			}
+			add_peers(peer, key_entry);
+		}
+#else
 		while (peers)
-			add_peers(llist_pop(&peers));
+			add_peers(llist_pop(&peers), NULL);
+#endif
 	}
 #if ENABLE_FEATURE_NTPD_CONF
 	else {
 		parser_t *parser;
-		char *token[3];
+		char *token[3 + 2*ENABLE_FEATURE_NTP_AUTH];
 
 		parser = config_open("/etc/ntp.conf");
-		while (config_read(parser, token, 3, 1, "# \t", PARSE_NORMAL)) {
+		while (config_read(parser, token, 3 + 2*ENABLE_FEATURE_NTP_AUTH, 1, "# \t", PARSE_NORMAL)) {
 			if (strcmp(token[0], "server") == 0 && token[1]) {
-				add_peers(token[1]);
+# if ENABLE_FEATURE_NTP_AUTH
+				key_entry_t *key_entry = NULL;
+				if (token[2] && token[3] && strcmp(token[2], "key") == 0) {
+					unsigned key_id = xatou_range(token[3], 1, MAX_KEY_NUMBER);
+					key_entry = find_key_entry(key_entries, key_id);
+				}
+				add_peers(token[1], key_entry);
+# else
+				add_peers(token[1], NULL);
+# endif
 				continue;
 			}
 			bb_error_msg("skipping %s:%u: unimplemented command '%s'",
@@ -2385,6 +2611,7 @@ static NOINLINE void ntp_init(char **arg
 		| (1 << SIGCHLD)
 		, SIG_IGN
 	);
+//TODO: free unused elements of key_entries?
 }
 
 int ntpd_main(int argc UNUSED_PARAM, char **argv) MAIN_EXTERNALLY_VISIBLE;
diff -urpN busybox-1.29.3/networking/ping.c busybox-1.30.0/networking/ping.c
--- busybox-1.29.3/networking/ping.c	2018-07-02 13:23:06.000000000 +0200
+++ busybox-1.30.0/networking/ping.c	2018-12-30 16:14:20.000000000 +0100
@@ -25,7 +25,7 @@
  * The code was modified by Bart Visscher <magick@linux-fan.com>
  */
 //config:config PING
-//config:	bool "ping (9.5 kb)"
+//config:	bool "ping (10 kb)"
 //config:	default y
 //config:	select PLATFORM_LINUX
 //config:	help
@@ -33,7 +33,7 @@
 //config:	elicit an ICMP ECHO_RESPONSE from a host or gateway.
 //config:
 //config:config PING6
-//config:	bool "ping6 (10 kb)"
+//config:	bool "ping6 (11 kb)"
 //config:	default y
 //config:	depends on FEATURE_IPV6
 //config:	help
@@ -74,6 +74,7 @@
 //usage:	)
 //usage:     "\n	-c CNT		Send only CNT pings"
 //usage:     "\n	-s SIZE		Send SIZE data bytes in packets (default 56)"
+//usage:     "\n	-i SECS		Interval"
 //usage:     "\n	-A		Ping as soon as reply is recevied"
 //usage:     "\n	-t TTL		Set TTL"
 //usage:     "\n	-I IFACE/IP	Source interface or IP address"
@@ -91,6 +92,7 @@
 //usage:       "Send ICMP ECHO_REQUEST packets to network hosts\n"
 //usage:     "\n	-c CNT		Send only CNT pings"
 //usage:     "\n	-s SIZE		Send SIZE data bytes in packets (default 56)"
+//usage:     "\n	-i SECS		Interval"
 //usage:     "\n	-A		Ping as soon as reply is recevied"
 //usage:     "\n	-I IFACE/IP	Source interface or IP address"
 //usage:     "\n	-q		Quiet, only display output at start"
@@ -350,7 +352,7 @@ static int common_ping_main(sa_family_t
 /* Full(er) version */
 
 /* -c NUM, -t NUM, -w NUM, -W NUM */
-#define OPT_STRING "qvAc:+s:t:+w:+W:+I:np:4"IF_PING6("6")
+#define OPT_STRING "qvAc:+s:t:+w:+W:+I:np:i:4"IF_PING6("6")
 enum {
 	OPT_QUIET = 1 << 0,
 	OPT_VERBOSE = 1 << 1,
@@ -363,8 +365,9 @@ enum {
 	OPT_I = 1 << 8,
 	/*OPT_n = 1 << 9, - ignored */
 	OPT_p = 1 << 10,
-	OPT_IPV4 = 1 << 11,
-	OPT_IPV6 = (1 << 12) * ENABLE_PING6,
+	OPT_i = 1 << 11,
+	OPT_IPV4 = 1 << 12,
+	OPT_IPV6 = (1 << 13) * ENABLE_PING6,
 };
 
 
@@ -382,6 +385,7 @@ struct globals {
 	unsigned long long tsum; /* in us, sum of all times */
 	unsigned cur_us; /* low word only, we don't need more */
 	unsigned deadline_us;
+	unsigned interval_us;
 	unsigned timeout;
 	unsigned sizeof_rcv_packet;
 	char *rcv_packet; /* [datalen + MAXIPLEN + MAXICMPLEN] */
@@ -481,9 +485,15 @@ static void sendping_tail(void (*sp)(int
 		bb_error_msg_and_die(bb_msg_write_error);
 
 	if (pingcount == 0 || G.ntransmitted < pingcount) {
-		/* Didn't send all pings yet - schedule next in 1s */
+		/* Didn't send all pings yet - schedule next in -i SEC interval */
+		struct itimerval i;
 		signal(SIGALRM, sp);
-		alarm(PINGINTERVAL);
+		/*ualarm(G.interval_us, 0); - does not work for >=1sec on some libc */
+		i.it_interval.tv_sec = 0;
+		i.it_interval.tv_usec = 0;
+		i.it_value.tv_sec = G.interval_us / 1000000;
+		i.it_value.tv_usec = G.interval_us % 1000000;
+		setitimer(ITIMER_REAL, &i, NULL);
 	} else { /* -c NN, and all NN are sent */
 		/* Wait for the last ping to come back.
 		 * -W timeout: wait for a response in seconds.
@@ -885,6 +895,8 @@ static int common_ping_main(int opt, cha
 {
 	len_and_sockaddr *lsa;
 	char *str_s, *str_p;
+	char *str_i = (char*)"1";
+	duration_t interval;
 
 	INIT_G();
 
@@ -892,7 +904,7 @@ static int common_ping_main(int opt, cha
 			OPT_STRING
 			/* exactly one arg; -v and -q don't mix */
 			"\0" "=1:q--v:v--q",
-			&pingcount, &str_s, &opt_ttl, &G.deadline_us, &timeout, &str_I, &str_p
+			&pingcount, &str_s, &opt_ttl, &G.deadline_us, &timeout, &str_I, &str_p, &str_i
 	);
 	if (opt & OPT_s)
 		datalen = xatou16(str_s); // -s
@@ -910,6 +922,10 @@ static int common_ping_main(int opt, cha
 		unsigned d = G.deadline_us < INT_MAX/1000000 ? G.deadline_us : INT_MAX/1000000;
 		G.deadline_us = 1 | ((d * 1000000) + monotonic_us());
 	}
+	interval = parse_duration_str(str_i);
+	if (interval > INT_MAX/1000000)
+		interval = INT_MAX/1000000;
+	G.interval_us = interval * 1000000;
 
 	myid = (uint16_t) getpid();
 	hostname = argv[optind];
diff -urpN busybox-1.29.3/networking/pscan.c busybox-1.30.0/networking/pscan.c
--- busybox-1.29.3/networking/pscan.c	2018-07-02 13:23:06.000000000 +0200
+++ busybox-1.30.0/networking/pscan.c	2018-12-30 16:14:20.000000000 +0100
@@ -6,7 +6,7 @@
  * Licensed under GPLv2 or later, see file LICENSE in this source tree.
  */
 //config:config PSCAN
-//config:	bool "pscan (6.6 kb)"
+//config:	bool "pscan (6 kb)"
 //config:	default y
 //config:	help
 //config:	Simple network port scanner.
diff -urpN busybox-1.29.3/networking/route.c busybox-1.30.0/networking/route.c
--- busybox-1.29.3/networking/route.c	2018-07-02 13:23:06.000000000 +0200
+++ busybox-1.30.0/networking/route.c	2018-12-30 16:14:20.000000000 +0100
@@ -25,7 +25,7 @@
  * remove ridiculous amounts of bloat.
  */
 //config:config ROUTE
-//config:	bool "route (8.9 kb)"
+//config:	bool "route (8.7 kb)"
 //config:	default y
 //config:	select PLATFORM_LINUX
 //config:	help
diff -urpN busybox-1.29.3/networking/slattach.c busybox-1.30.0/networking/slattach.c
--- busybox-1.29.3/networking/slattach.c	2018-07-02 13:23:06.000000000 +0200
+++ busybox-1.30.0/networking/slattach.c	2018-12-30 16:14:20.000000000 +0100
@@ -13,7 +13,7 @@
  * - The -F options allows disabling of RTS/CTS flow control.
  */
 //config:config SLATTACH
-//config:	bool "slattach (6.1 kb)"
+//config:	bool "slattach (6.2 kb)"
 //config:	default y
 //config:	select PLATFORM_LINUX
 //config:	help
diff -urpN busybox-1.29.3/networking/ssl_client.c busybox-1.30.0/networking/ssl_client.c
--- busybox-1.29.3/networking/ssl_client.c	2018-07-02 13:23:06.000000000 +0200
+++ busybox-1.30.0/networking/ssl_client.c	2018-12-30 16:14:20.000000000 +0100
@@ -4,7 +4,7 @@
  * Licensed under GPLv2, see file LICENSE in this source tree.
  */
 //config:config SSL_CLIENT
-//config:	bool "ssl_client (23 kb)"
+//config:	bool "ssl_client (25 kb)"
 //config:	default y
 //config:	select TLS
 //config:	help
diff -urpN busybox-1.29.3/networking/tc.c busybox-1.30.0/networking/tc.c
--- busybox-1.29.3/networking/tc.c	2018-07-02 13:23:06.000000000 +0200
+++ busybox-1.30.0/networking/tc.c	2018-12-30 16:14:20.000000000 +0100
@@ -7,7 +7,7 @@
  * Bernhard Reutner-Fischer adjusted for busybox
  */
 //config:config TC
-//config:	bool "tc (3.1 kb)"
+//config:	bool "tc (8.3 kb)"
 //config:	default y
 //config:	help
 //config:	Show / manipulate traffic control settings
diff -urpN busybox-1.29.3/networking/tcpudp.c busybox-1.30.0/networking/tcpudp.c
--- busybox-1.29.3/networking/tcpudp.c	2018-07-02 13:23:06.000000000 +0200
+++ busybox-1.30.0/networking/tcpudp.c	2018-12-30 16:14:20.000000000 +0100
@@ -29,7 +29,7 @@
  * - don't know how to retrieve ORIGDST for udp.
  */
 //config:config TCPSVD
-//config:	bool "tcpsvd (13 kb)"
+//config:	bool "tcpsvd (14 kb)"
 //config:	default y
 //config:	help
 //config:	tcpsvd listens on a TCP port and runs a program for each new
diff -urpN busybox-1.29.3/networking/telnet.c busybox-1.30.0/networking/telnet.c
--- busybox-1.29.3/networking/telnet.c	2018-07-02 13:23:06.000000000 +0200
+++ busybox-1.30.0/networking/telnet.c	2018-12-30 16:14:20.000000000 +0100
@@ -20,7 +20,7 @@
  * by Fernando Silveira <swrh@gmx.net>
  */
 //config:config TELNET
-//config:	bool "telnet (8.7 kb)"
+//config:	bool "telnet (8.8 kb)"
 //config:	default y
 //config:	help
 //config:	Telnet is an interface to the TELNET protocol, but is also commonly
diff -urpN busybox-1.29.3/networking/tftp.c busybox-1.30.0/networking/tftp.c
--- busybox-1.29.3/networking/tftp.c	2018-07-02 13:23:06.000000000 +0200
+++ busybox-1.30.0/networking/tftp.c	2018-12-30 16:14:20.000000000 +0100
@@ -19,7 +19,7 @@
  * Licensed under GPLv2 or later, see file LICENSE in this source tree.
  */
 //config:config TFTP
-//config:	bool "tftp (12 kb)"
+//config:	bool "tftp (11 kb)"
 //config:	default y
 //config:	help
 //config:	Trivial File Transfer Protocol client. TFTP is usually used
@@ -41,9 +41,6 @@
 //config:	In other words: it should be run from inetd in nowait mode,
 //config:	or from udpsvd. Example: "udpsvd -E 0 69 tftpd DIR"
 //config:
-//config:comment "Common options for tftp/tftpd"
-//config:	depends on TFTP || TFTPD
-//config:
 //config:config FEATURE_TFTP_GET
 //config:	bool "Enable 'tftp get' and/or tftpd upload code"
 //config:	default y
diff -urpN busybox-1.29.3/networking/tls.c busybox-1.30.0/networking/tls.c
--- busybox-1.29.3/networking/tls.c	2018-07-02 13:23:06.000000000 +0200
+++ busybox-1.30.0/networking/tls.c	2018-12-30 16:14:20.000000000 +0100
@@ -6,22 +6,26 @@
 //config:config TLS
 //config:	bool #No description makes it a hidden option
 //config:	default n
+//Note:
+//Config.src also defines FEATURE_TLS_SHA1 option
 
 //kbuild:lib-$(CONFIG_TLS) += tls.o
 //kbuild:lib-$(CONFIG_TLS) += tls_pstm.o
 //kbuild:lib-$(CONFIG_TLS) += tls_pstm_montgomery_reduce.o
 //kbuild:lib-$(CONFIG_TLS) += tls_pstm_mul_comba.o
 //kbuild:lib-$(CONFIG_TLS) += tls_pstm_sqr_comba.o
-//kbuild:lib-$(CONFIG_TLS) += tls_rsa.o
 //kbuild:lib-$(CONFIG_TLS) += tls_aes.o
-////kbuild:lib-$(CONFIG_TLS) += tls_aes_gcm.o
+//kbuild:lib-$(CONFIG_TLS) += tls_aesgcm.o
+//kbuild:lib-$(CONFIG_TLS) += tls_rsa.o
+//kbuild:lib-$(CONFIG_TLS) += tls_fe.o
 
 #include "tls.h"
 
+// works against "openssl s_server -cipher NULL"
+// and against wolfssl-3.9.10-stable/examples/server/server.c:
+#define ALLOW_RSA_NULL_SHA256  0  // for testing (does everything except encrypting)
+
 //Tested against kernel.org:
-//TLS 1.2
-#define TLS_MAJ 3
-#define TLS_MIN 3
 //#define CIPHER_ID TLS_ECDHE_RSA_WITH_AES_128_CBC_SHA // ok, recvs SERVER_KEY_EXCHANGE *** matrixssl uses this on my box
 //#define CIPHER_ID TLS_RSA_WITH_AES_256_CBC_SHA256 // ok, no SERVER_KEY_EXCHANGE
 //#define CIPHER_ID TLS_DH_anon_WITH_AES_256_CBC_SHA // SSL_ALERT_HANDSHAKE_FAILURE
@@ -35,26 +39,28 @@
 //#define CIPHER_ID TLS_ECDH_RSA_WITH_AES_256_GCM_SHA384
 //#define CIPHER_ID TLS_ECDH_RSA_WITH_AES_128_GCM_SHA256 // SSL_ALERT_HANDSHAKE_FAILURE
 //#define CIPHER_ID TLS_RSA_WITH_AES_256_GCM_SHA384 // ok, no SERVER_KEY_EXCHANGE
-//#define CIPHER_ID TLS_RSA_WITH_AES_128_GCM_SHA256 // ok, no SERVER_KEY_EXCHANGE *** select this?
-
-// works against "openssl s_server -cipher NULL"
-// and against wolfssl-3.9.10-stable/examples/server/server.c:
-//#define CIPHER_ID1 TLS_RSA_WITH_NULL_SHA256 // for testing (does everything except encrypting)
+//#define CIPHER_ID TLS_RSA_WITH_AES_128_GCM_SHA256 // ok, no SERVER_KEY_EXCHANGE
 
 // works against wolfssl-3.9.10-stable/examples/server/server.c
 // works for kernel.org
 // does not work for cdn.kernel.org (e.g. downloading an actual tarball, not a web page)
 //  getting alert 40 "handshake failure" at once
 //  with GNU Wget 1.18, they agree on TLS_ECDHE_RSA_WITH_AES_128_GCM_SHA256 (0xC02F) cipher
-//  fail: openssl s_client -connect cdn.kernel.org:443 -debug -tls1_2 -no_tls1 -no_tls1_1 -cipher AES256-SHA256
-//  fail: openssl s_client -connect cdn.kernel.org:443 -debug -tls1_2 -no_tls1 -no_tls1_1 -cipher AES256-GCM-SHA384
-//  fail: openssl s_client -connect cdn.kernel.org:443 -debug -tls1_2 -no_tls1 -no_tls1_1 -cipher AES128-SHA256
-//  ok:   openssl s_client -connect cdn.kernel.org:443 -debug -tls1_2 -no_tls1 -no_tls1_1 -cipher AES128-GCM-SHA256
-//  ok:   openssl s_client -connect cdn.kernel.org:443 -debug -tls1_2 -no_tls1 -no_tls1_1 -cipher AES128-SHA
+//  fail: openssl s_client -connect cdn.kernel.org:443 -debug -tls1_2 -cipher AES256-SHA256
+//  fail: openssl s_client -connect cdn.kernel.org:443 -debug -tls1_2 -cipher AES256-GCM-SHA384
+//  fail: openssl s_client -connect cdn.kernel.org:443 -debug -tls1_2 -cipher AES128-SHA256
+//  ok:   openssl s_client -connect cdn.kernel.org:443 -debug -tls1_2 -cipher AES128-GCM-SHA256
+//  ok:   openssl s_client -connect cdn.kernel.org:443 -debug -tls1_2 -cipher AES128-SHA
 //        (TLS_RSA_WITH_AES_128_CBC_SHA - in TLS 1.2 it's mandated to be always supported)
-#define CIPHER_ID1  TLS_RSA_WITH_AES_256_CBC_SHA256 // no SERVER_KEY_EXCHANGE from peer
+//#define CIPHER_ID1  TLS_RSA_WITH_AES_256_CBC_SHA256 //0x003D
 // Works with "wget https://cdn.kernel.org/pub/linux/kernel/v4.x/linux-4.9.5.tar.xz"
-#define CIPHER_ID2  TLS_RSA_WITH_AES_128_CBC_SHA
+//#define CIPHER_ID2  TLS_RSA_WITH_AES_128_CBC_SHA    //0x002F
+
+// bug #11456:
+// ftp.openbsd.org only supports ECDHE-RSA-AESnnn-GCM-SHAnnn or ECDHE-RSA-CHACHA20-POLY1305
+//#define CIPHER_ID3  TLS_ECDHE_RSA_WITH_AES_128_GCM_SHA256 //0xC02F
+// host is.gd accepts only ECDHE-ECDSA-foo (the simplest which works: ECDHE-ECDSA-AES128-SHA 0xC009)
+//#define CIPHER_ID4  TLS_ECDHE_ECDSA_WITH_AES_128_CBC_SHA  //0xC009
 
 
 #define TLS_DEBUG      0
@@ -84,6 +90,11 @@
 # define dbg_der(...) ((void)0)
 #endif
 
+
+//TLS 1.2
+#define TLS_MAJ 3
+#define TLS_MIN 3
+
 #define RECORD_TYPE_CHANGE_CIPHER_SPEC  20 /* 0x14 */
 #define RECORD_TYPE_ALERT               21 /* 0x15 */
 #define RECORD_TYPE_HANDSHAKE           22 /* 0x16 */
@@ -102,66 +113,98 @@
 #define HANDSHAKE_CLIENT_KEY_EXCHANGE   16 /* 0x10 */
 #define HANDSHAKE_FINISHED              20 /* 0x14 */
 
+#define TLS_EMPTY_RENEGOTIATION_INFO_SCSV       0x00FF /* not a real cipher id... */
+
 #define SSL_NULL_WITH_NULL_NULL                 0x0000
 #define SSL_RSA_WITH_NULL_MD5                   0x0001
 #define SSL_RSA_WITH_NULL_SHA                   0x0002
 #define SSL_RSA_WITH_RC4_128_MD5                0x0004
 #define SSL_RSA_WITH_RC4_128_SHA                0x0005
+#define TLS_RSA_WITH_IDEA_CBC_SHA               0x0007  /* 7 */
 #define SSL_RSA_WITH_3DES_EDE_CBC_SHA           0x000A  /* 10 */
-#define TLS_RSA_WITH_AES_128_CBC_SHA            0x002F  /* 47 */
-#define TLS_RSA_WITH_AES_256_CBC_SHA            0x0035  /* 53 */
-#define TLS_RSA_WITH_NULL_SHA256                0x003B  /* 59 */
-
-#define TLS_EMPTY_RENEGOTIATION_INFO_SCSV       0x00FF
 
-#define TLS_RSA_WITH_IDEA_CBC_SHA               0x0007  /* 7 */
 #define SSL_DHE_RSA_WITH_3DES_EDE_CBC_SHA       0x0016  /* 22 */
 #define SSL_DH_anon_WITH_RC4_128_MD5            0x0018  /* 24 */
 #define SSL_DH_anon_WITH_3DES_EDE_CBC_SHA       0x001B  /* 27 */
+#define TLS_RSA_WITH_AES_128_CBC_SHA            0x002F  /*SSLv3   Kx=RSA   Au=RSA   Enc=AES(128) Mac=SHA1 */
 #define TLS_DHE_RSA_WITH_AES_128_CBC_SHA        0x0033  /* 51 */
-#define TLS_DHE_RSA_WITH_AES_256_CBC_SHA        0x0039  /* 57 */
-#define TLS_DHE_RSA_WITH_AES_128_CBC_SHA256     0x0067  /* 103 */
-#define TLS_DHE_RSA_WITH_AES_256_CBC_SHA256     0x006B  /* 107 */
 #define TLS_DH_anon_WITH_AES_128_CBC_SHA        0x0034  /* 52 */
+#define TLS_RSA_WITH_AES_256_CBC_SHA            0x0035  /* 53 */
+#define TLS_DHE_RSA_WITH_AES_256_CBC_SHA        0x0039  /* 57 */
 #define TLS_DH_anon_WITH_AES_256_CBC_SHA        0x003A  /* 58 */
+#define TLS_RSA_WITH_NULL_SHA256                0x003B  /* 59 */
 #define TLS_RSA_WITH_AES_128_CBC_SHA256         0x003C  /* 60 */
 #define TLS_RSA_WITH_AES_256_CBC_SHA256         0x003D  /* 61 */
-#define TLS_RSA_WITH_SEED_CBC_SHA               0x0096  /* 150 */
+#define TLS_DHE_RSA_WITH_AES_128_CBC_SHA256     0x0067  /* 103 */
+#define TLS_DHE_RSA_WITH_AES_256_CBC_SHA256     0x006B  /* 107 */
 #define TLS_PSK_WITH_AES_128_CBC_SHA            0x008C  /* 140 */
-#define TLS_PSK_WITH_AES_128_CBC_SHA256         0x00AE  /* 174 */
-#define TLS_PSK_WITH_AES_256_CBC_SHA384         0x00AF  /* 175 */
 #define TLS_PSK_WITH_AES_256_CBC_SHA            0x008D  /* 141 */
 #define TLS_DHE_PSK_WITH_AES_128_CBC_SHA        0x0090  /* 144 */
 #define TLS_DHE_PSK_WITH_AES_256_CBC_SHA        0x0091  /* 145 */
+#define TLS_RSA_WITH_SEED_CBC_SHA               0x0096  /* 150 */
+#define TLS_RSA_WITH_AES_128_GCM_SHA256         0x009C  /*TLSv1.2 Kx=RSA   Au=RSA   Enc=AESGCM(128) Mac=AEAD */
+#define TLS_RSA_WITH_AES_256_GCM_SHA384         0x009D  /*TLSv1.2 Kx=RSA   Au=RSA   Enc=AESGCM(256) Mac=AEAD */
+#define TLS_DHE_RSA_WITH_AES_128_GCM_SHA256     0x009E  /*TLSv1.2 Kx=DH    Au=RSA   Enc=AESGCM(128) Mac=AEAD */
+#define TLS_DHE_RSA_WITH_AES_256_GCM_SHA384     0x009F  /*TLSv1.2 Kx=DH    Au=RSA   Enc=AESGCM(256) Mac=AEAD */
+#define TLS_DH_anon_WITH_AES_128_GCM_SHA256     0x00A6  /* RFC 5288 */
+#define TLS_DH_anon_WITH_AES_256_GCM_SHA384     0x00A7  /* RFC 5288 */
+#define TLS_PSK_WITH_AES_128_CBC_SHA256         0x00AE  /* 174 */
+#define TLS_PSK_WITH_AES_256_CBC_SHA384         0x00AF  /* 175 */
 #define TLS_ECDH_ECDSA_WITH_AES_128_CBC_SHA     0xC004  /* 49156 */
 #define TLS_ECDH_ECDSA_WITH_AES_256_CBC_SHA     0xC005  /* 49157 */
-#define TLS_ECDHE_ECDSA_WITH_AES_128_CBC_SHA    0xC009  /* 49161 */
-#define TLS_ECDHE_ECDSA_WITH_AES_256_CBC_SHA    0xC00A  /* 49162 */
-#define TLS_ECDHE_RSA_WITH_3DES_EDE_CBC_SHA     0xC012  /* 49170 */
-#define TLS_ECDHE_RSA_WITH_AES_128_CBC_SHA      0xC013  /* 49171 */
-#define TLS_ECDHE_RSA_WITH_AES_256_CBC_SHA      0xC014  /* 49172 */
+#define TLS_ECDHE_ECDSA_WITH_AES_128_CBC_SHA    0xC009  /*TLSv1   Kx=ECDH  Au=ECDSA Enc=AES(128) Mac=SHA1 */
+#define TLS_ECDHE_ECDSA_WITH_AES_256_CBC_SHA    0xC00A  /*TLSv1   Kx=ECDH  Au=ECDSA Enc=AES(256) Mac=SHA1 */
 #define TLS_ECDH_RSA_WITH_AES_128_CBC_SHA       0xC00E  /* 49166 */
 #define TLS_ECDH_RSA_WITH_AES_256_CBC_SHA       0xC00F  /* 49167 */
-#define TLS_ECDHE_ECDSA_WITH_AES_128_CBC_SHA256 0xC023  /* 49187 */
-#define TLS_ECDHE_ECDSA_WITH_AES_256_CBC_SHA384 0xC024  /* 49188 */
+#define TLS_ECDHE_RSA_WITH_3DES_EDE_CBC_SHA     0xC012  /* 49170 */
+#define TLS_ECDHE_RSA_WITH_AES_128_CBC_SHA      0xC013  /*TLSv1   Kx=ECDH  Au=RSA   Enc=AES(128) Mac=SHA1 */
+#define TLS_ECDHE_RSA_WITH_AES_256_CBC_SHA      0xC014  /*TLSv1   Kx=ECDH  Au=RSA   Enc=AES(256) Mac=SHA1 */
+#define TLS_ECDH_anon_WITH_AES_128_CBC_SHA      0xC018  /* RFC 4492 */
+#define TLS_ECDH_anon_WITH_AES_256_CBC_SHA      0xC019  /* RFC 4492 */
+#define TLS_ECDHE_ECDSA_WITH_AES_128_CBC_SHA256 0xC023  /*TLSv1.2 Kx=ECDH  Au=ECDSA Enc=AES(128) Mac=SHA256 */
+#define TLS_ECDHE_ECDSA_WITH_AES_256_CBC_SHA384 0xC024  /*TLSv1.2 Kx=ECDH  Au=ECDSA Enc=AES(256) Mac=SHA384 */
 #define TLS_ECDH_ECDSA_WITH_AES_128_CBC_SHA256  0xC025  /* 49189 */
 #define TLS_ECDH_ECDSA_WITH_AES_256_CBC_SHA384  0xC026  /* 49190 */
-#define TLS_ECDHE_RSA_WITH_AES_128_CBC_SHA256   0xC027  /* 49191 */
-#define TLS_ECDHE_RSA_WITH_AES_256_CBC_SHA384   0xC028  /* 49192 */
+#define TLS_ECDHE_RSA_WITH_AES_128_CBC_SHA256   0xC027  /*TLSv1.2 Kx=ECDH  Au=RSA   Enc=AES(128) Mac=SHA256 */
+#define TLS_ECDHE_RSA_WITH_AES_256_CBC_SHA384   0xC028  /*TLSv1.2 Kx=ECDH  Au=RSA   Enc=AES(256) Mac=SHA384 */
 #define TLS_ECDH_RSA_WITH_AES_128_CBC_SHA256    0xC029  /* 49193 */
 #define TLS_ECDH_RSA_WITH_AES_256_CBC_SHA384    0xC02A  /* 49194 */
-
 /* RFC 5288 "AES Galois Counter Mode (GCM) Cipher Suites for TLS" */
-#define TLS_RSA_WITH_AES_128_GCM_SHA256         0x009C  /* 156 */
-#define TLS_RSA_WITH_AES_256_GCM_SHA384         0x009D  /* 157 */
-#define TLS_ECDHE_ECDSA_WITH_AES_128_GCM_SHA256 0xC02B  /* 49195 */
-#define TLS_ECDHE_ECDSA_WITH_AES_256_GCM_SHA384 0xC02C  /* 49196 */
+#define TLS_ECDHE_ECDSA_WITH_AES_128_GCM_SHA256 0xC02B  /*TLSv1.2 Kx=ECDH  Au=ECDSA Enc=AESGCM(128) Mac=AEAD */
+#define TLS_ECDHE_ECDSA_WITH_AES_256_GCM_SHA384 0xC02C  /*TLSv1.2 Kx=ECDH  Au=ECDSA Enc=AESGCM(256) Mac=AEAD */
 #define TLS_ECDH_ECDSA_WITH_AES_128_GCM_SHA256  0xC02D  /* 49197 */
 #define TLS_ECDH_ECDSA_WITH_AES_256_GCM_SHA384  0xC02E  /* 49198 */
-#define TLS_ECDHE_RSA_WITH_AES_128_GCM_SHA256   0xC02F  /* 49199 */
-#define TLS_ECDHE_RSA_WITH_AES_256_GCM_SHA384   0xC030  /* 49200 */
+#define TLS_ECDHE_RSA_WITH_AES_128_GCM_SHA256   0xC02F  /*TLSv1.2 Kx=ECDH  Au=RSA   Enc=AESGCM(128) Mac=AEAD */
+#define TLS_ECDHE_RSA_WITH_AES_256_GCM_SHA384   0xC030  /*TLSv1.2 Kx=ECDH  Au=RSA   Enc=AESGCM(256) Mac=AEAD */
 #define TLS_ECDH_RSA_WITH_AES_128_GCM_SHA256    0xC031  /* 49201 */
 #define TLS_ECDH_RSA_WITH_AES_256_GCM_SHA384    0xC032  /* 49202 */
+#define TLS_ECDHE_PSK_WITH_AES_128_CBC_SHA      0xC035
+#define TLS_ECDHE_PSK_WITH_AES_256_CBC_SHA      0xC036
+#define TLS_ECDHE_PSK_WITH_AES_128_CBC_SHA256   0xC037
+#define TLS_ECDHE_PSK_WITH_AES_256_CBC_SHA384   0xC038
+
+/* From http://wiki.mozilla.org/Security/Server_Side_TLS */
+/* and 'openssl ciphers -V -stdname' */
+#define TLS_RSA_WITH_AES_128_CCM                      0xC09C /*TLSv1.2 Kx=RSA   Au=RSA   Enc=AESCCM(128) Mac=AEAD */
+#define TLS_RSA_WITH_AES_256_CCM                      0xC09D /*TLSv1.2 Kx=RSA   Au=RSA   Enc=AESCCM(256) Mac=AEAD */
+#define TLS_DHE_RSA_WITH_AES_128_CCM                  0xC09E /*TLSv1.2 Kx=DH    Au=RSA   Enc=AESCCM(128) Mac=AEAD */
+#define TLS_DHE_RSA_WITH_AES_256_CCM                  0xC09F /*TLSv1.2 Kx=DH    Au=RSA   Enc=AESCCM(256) Mac=AEAD */
+#define TLS_RSA_WITH_AES_128_CCM_8                    0xC0A0 /*TLSv1.2 Kx=RSA   Au=RSA   Enc=AESCCM8(128) Mac=AEAD */
+#define TLS_RSA_WITH_AES_256_CCM_8                    0xC0A1 /*TLSv1.2 Kx=RSA   Au=RSA   Enc=AESCCM8(256) Mac=AEAD */
+#define TLS_DHE_RSA_WITH_AES_128_CCM_8                0xC0A2 /*TLSv1.2 Kx=DH    Au=RSA   Enc=AESCCM8(128) Mac=AEAD */
+#define TLS_DHE_RSA_WITH_AES_256_CCM_8                0xC0A3 /*TLSv1.2 Kx=DH    Au=RSA   Enc=AESCCM8(256) Mac=AEAD */
+#define TLS_ECDHE_ECDSA_WITH_AES_128_CCM              0xC0AC /*TLSv1.2 Kx=ECDH  Au=ECDSA Enc=AESCCM(128) Mac=AEAD */
+#define TLS_ECDHE_ECDSA_WITH_AES_256_CCM              0xC0AD /*TLSv1.2 Kx=ECDH  Au=ECDSA Enc=AESCCM(256) Mac=AEAD */
+#define TLS_ECDHE_ECDSA_WITH_AES_128_CCM_8            0xC0AE /*TLSv1.2 Kx=ECDH  Au=ECDSA Enc=AESCCM8(128) Mac=AEAD */
+#define TLS_ECDHE_ECDSA_WITH_AES_256_CCM_8            0xC0AF /*TLSv1.2 Kx=ECDH  Au=ECDSA Enc=AESCCM8(256) Mac=AEAD */
+#define TLS_ECDHE_RSA_WITH_CHACHA20_POLY1305_SHA256   0xCCA8 /*TLSv1.2 Kx=ECDH  Au=RSA   Enc=CHACHA20/POLY1305(256) Mac=AEAD */
+#define TLS_ECDHE_ECDSA_WITH_CHACHA20_POLY1305_SHA256 0xCCA9 /*TLSv1.2 Kx=ECDH  Au=ECDSA Enc=CHACHA20/POLY1305(256) Mac=AEAD */
+#define TLS_DHE_RSA_WITH_CHACHA20_POLY1305_SHA256     0xCCAA /*TLSv1.2 Kx=DH    Au=RSA   Enc=CHACHA20/POLY1305(256) Mac=AEAD */
+
+#define TLS_AES_128_GCM_SHA256                        0x1301 /*TLSv1.3 Kx=any   Au=any   Enc=AESGCM(128) Mac=AEAD */
+#define TLS_AES_256_GCM_SHA384                        0x1302 /*TLSv1.3 Kx=any   Au=any   Enc=AESGCM(256) Mac=AEAD */
+#define TLS_CHACHA20_POLY1305_SHA256                  0x1303 /*TLSv1.3 Kx=any   Au=any   Enc=CHACHA20/POLY1305(256) Mac=AEAD */
+#define TLS_AES_128_CCM_SHA256                        0x1304 /*TLSv1.3 Kx=any   Au=any   Enc=AESCCM(128) Mac=AEAD */
 
 /* Might go to libbb.h */
 #define TLS_MAX_CRYPTBLOCK_SIZE 16
@@ -172,7 +215,6 @@ enum {
 	SHA1_OUTSIZE   = 20,
 	SHA256_OUTSIZE = 32,
 
-	AES_BLOCKSIZE  = 16,
 	AES128_KEYSIZE = 16,
 	AES256_KEYSIZE = 32,
 
@@ -181,10 +223,10 @@ enum {
 	RECHDR_LEN = 5,
 
 	/* 8 = 3+5. 3 extra bytes result in record data being 32-bit aligned */
-	OUTBUF_PFX = 8 + AES_BLOCKSIZE, /* header + IV */
+	OUTBUF_PFX = 8 + AES_BLOCK_SIZE, /* header + IV */
 	OUTBUF_SFX = TLS_MAX_MAC_SIZE + TLS_MAX_CRYPTBLOCK_SIZE, /* MAC + padding */
 
-	// RFC 5246
+	// RFC 5246:
 	// | 6.2.1. Fragmentation
 	// |  The record layer fragments information blocks into TLSPlaintext
 	// |  records carrying data in chunks of 2^14 bytes or less.  Client
@@ -219,6 +261,14 @@ enum {
 	// |    The length (in bytes) of the following TLSCiphertext.fragment.
 	// |    The length MUST NOT exceed 2^14 + 2048.
 	MAX_INBUF = RECHDR_LEN + (1 << 14) + 2048,
+
+	/* Bits for tls->flags */
+	NEED_EC_KEY            = 1 << 0,
+	GOT_CERT_RSA_KEY_ALG   = 1 << 1,
+	GOT_CERT_ECDSA_KEY_ALG = 1 << 2, // so far unused
+	GOT_EC_KEY             = 1 << 3,
+	ENCRYPTION_AESGCM      = 1 << 4, // else AES-SHA (or NULL-SHA if ALLOW_RSA_NULL_SHA256=1)
+	ENCRYPT_ON_WRITE       = 1 << 5,
 };
 
 struct record_hdr {
@@ -233,12 +283,15 @@ struct tls_handshake_data {
 
 	uint8_t client_and_server_rand32[2 * 32];
 	uint8_t master_secret[48];
+
 //TODO: store just the DER key here, parse/use/delete it when sending client key
 //this way it will stay key type agnostic here.
 	psRsaKey_t server_rsa_pub_key;
+	uint8_t ecc_pub_key32[32];
 
-	unsigned saved_client_hello_size;
-	uint8_t saved_client_hello[1];
+/* HANDSHAKE HASH: */
+	//unsigned saved_client_hello_size;
+	//uint8_t saved_client_hello[1];
 };
 
 
@@ -248,6 +301,15 @@ static unsigned get24be(const uint8_t *p
 }
 
 #if TLS_DEBUG
+/* Nondestructively see the current hash value */
+# if TLS_DEBUG_HASH
+static unsigned sha_peek(md5sha_ctx_t *ctx, void *buffer)
+{
+	md5sha_ctx_t ctx_copy = *ctx; /* struct copy */
+	return sha_end(&ctx_copy, buffer);
+}
+# endif
+
 static void dump_hex(const char *fmt, const void *vp, int len)
 {
 	char hexbuf[32 * 1024 + 4];
@@ -287,22 +349,38 @@ static void dump_tls_record(const void *
 # define dump_tls_record(...) ((void)0)
 #endif
 
-void tls_get_random(void *buf, unsigned len)
+void FAST_FUNC tls_get_random(void *buf, unsigned len)
 {
 	if (len != open_read_close("/dev/urandom", buf, len))
 		xfunc_die();
 }
 
-/* Nondestructively see the current hash value */
-static unsigned sha_peek(md5sha_ctx_t *ctx, void *buffer)
+static void xorbuf3(void *dst, const void *src1, const void *src2, unsigned count)
 {
-	md5sha_ctx_t ctx_copy = *ctx; /* struct copy */
-	return sha_end(&ctx_copy, buffer);
+	uint8_t *d = dst;
+	const uint8_t *s1 = src1;
+	const uint8_t* s2 = src2;
+	while (count--)
+		*d++ = *s1++ ^ *s2++;
 }
 
-static ALWAYS_INLINE unsigned get_handshake_hash(tls_state_t *tls, void *buffer)
+void FAST_FUNC xorbuf(void *dst, const void *src, unsigned count)
 {
-	return sha_peek(&tls->hsd->handshake_hash_ctx, buffer);
+	xorbuf3(dst, dst, src, count);
+}
+
+void FAST_FUNC xorbuf_aligned_AES_BLOCK_SIZE(void *dst, const void *src)
+{
+	unsigned long *d = dst;
+	const unsigned long *s = src;
+	d[0] ^= s[0];
+#if ULONG_MAX <= 0xffffffffffffffff
+	d[1] ^= s[1];
+ #if ULONG_MAX == 0xffffffff
+	d[2] ^= s[2];
+	d[3] ^= s[3];
+ #endif
+#endif
 }
 
 #if !TLS_DEBUG_HASH
@@ -318,7 +396,7 @@ static void hash_handshake(tls_state_t *
 		dump_hex(fmt, buffer, len);
 		dbg(" (%u bytes) ", (int)len);
 		len = sha_peek(&tls->hsd->handshake_hash_ctx, h);
-		if (len == SHA1_OUTSIZE)
+		if (ENABLE_FEATURE_TLS_SHA1 && len == SHA1_OUTSIZE)
 			dump_hex("sha1:%s\n", h, len);
 		else
 		if (len == SHA256_OUTSIZE)
@@ -329,7 +407,13 @@ static void hash_handshake(tls_state_t *
 #endif
 }
 
-// RFC 2104
+#if !ENABLE_FEATURE_TLS_SHA1
+# define TLS_MAC_SIZE(tls) SHA256_OUTSIZE
+#else
+# define TLS_MAC_SIZE(tls) (tls)->MAC_size
+#endif
+
+// RFC 2104:
 // HMAC(key, text) based on a hash H (say, sha256) is:
 // ipad = [0x36 x INSIZE]
 // opad = [0x5c x INSIZE]
@@ -344,35 +428,17 @@ typedef struct hmac_precomputed {
 	md5sha_ctx_t hashed_key_xor_opad;
 } hmac_precomputed_t;
 
-static unsigned hmac_sha_precomputed_v(
-		hmac_precomputed_t *pre,
-		uint8_t *out,
-		va_list va)
-{
-	uint8_t *text;
-	unsigned len;
-
-	/* pre->hashed_key_xor_ipad contains unclosed "H((key XOR ipad) +" state */
-	/* pre->hashed_key_xor_opad contains unclosed "H((key XOR opad) +" state */
-
-	/* calculate out = H((key XOR ipad) + text) */
-	while ((text = va_arg(va, uint8_t*)) != NULL) {
-		unsigned text_size = va_arg(va, unsigned);
-		md5sha_hash(&pre->hashed_key_xor_ipad, text, text_size);
-	}
-	len = sha_end(&pre->hashed_key_xor_ipad, out);
-
-	/* out = H((key XOR opad) + out) */
-	md5sha_hash(&pre->hashed_key_xor_opad, out, len);
-	return sha_end(&pre->hashed_key_xor_opad, out);
-}
-
 typedef void md5sha_begin_func(md5sha_ctx_t *ctx) FAST_FUNC;
+#if !ENABLE_FEATURE_TLS_SHA1
+#define hmac_begin(pre,key,key_size,begin) \
+	hmac_begin(pre,key,key_size)
+#define begin sha256_begin
+#endif
 static void hmac_begin(hmac_precomputed_t *pre, uint8_t *key, unsigned key_size, md5sha_begin_func *begin)
 {
 	uint8_t key_xor_ipad[SHA_INSIZE];
 	uint8_t key_xor_opad[SHA_INSIZE];
-	uint8_t tempkey[SHA1_OUTSIZE < SHA256_OUTSIZE ? SHA256_OUTSIZE : SHA1_OUTSIZE];
+//	uint8_t tempkey[SHA1_OUTSIZE < SHA256_OUTSIZE ? SHA256_OUTSIZE : SHA1_OUTSIZE];
 	unsigned i;
 
 	// "The authentication key can be of any length up to INSIZE, the
@@ -380,10 +446,18 @@ static void hmac_begin(hmac_precomputed_
 	// than INSIZE bytes will first hash the key using H and then use the
 	// resultant OUTSIZE byte string as the actual key to HMAC."
 	if (key_size > SHA_INSIZE) {
-		md5sha_ctx_t ctx;
-		begin(&ctx);
-		md5sha_hash(&ctx, key, key_size);
-		key_size = sha_end(&ctx, tempkey);
+		bb_error_msg_and_die("HMAC key>64"); //does not happen (yet?)
+//		md5sha_ctx_t ctx;
+//		begin(&ctx);
+//		md5sha_hash(&ctx, key, key_size);
+//		key_size = sha_end(&ctx, tempkey);
+//		//key = tempkey; - right? RIGHT? why does it work without this?
+//		// because SHA_INSIZE is 64, but hmac() is always called with
+//		// key_size = tls->MAC_size = SHA1/256_OUTSIZE (20 or 32),
+//		// and prf_hmac_sha256() -> hmac_sha256() key sizes are:
+//		// - RSA_PREMASTER_SIZE is 48
+//		// - CURVE25519_KEYSIZE is 32
+//		// - master_secret[] is 48
 	}
 
 	for (i = 0; i < key_size; i++) {
@@ -400,27 +474,49 @@ static void hmac_begin(hmac_precomputed_
 	md5sha_hash(&pre->hashed_key_xor_ipad, key_xor_ipad, SHA_INSIZE);
 	md5sha_hash(&pre->hashed_key_xor_opad, key_xor_opad, SHA_INSIZE);
 }
+#undef begin
 
-static unsigned hmac(tls_state_t *tls, uint8_t *out, uint8_t *key, unsigned key_size, ...)
+static unsigned hmac_sha_precomputed_v(
+		hmac_precomputed_t *pre,
+		uint8_t *out,
+		va_list va)
+{
+	uint8_t *text;
+	unsigned len;
+
+	/* pre->hashed_key_xor_ipad contains unclosed "H((key XOR ipad) +" state */
+	/* pre->hashed_key_xor_opad contains unclosed "H((key XOR opad) +" state */
+
+	/* calculate out = H((key XOR ipad) + text) */
+	while ((text = va_arg(va, uint8_t*)) != NULL) {
+		unsigned text_size = va_arg(va, unsigned);
+		md5sha_hash(&pre->hashed_key_xor_ipad, text, text_size);
+	}
+	len = sha_end(&pre->hashed_key_xor_ipad, out);
+
+	/* out = H((key XOR opad) + out) */
+	md5sha_hash(&pre->hashed_key_xor_opad, out, len);
+	return sha_end(&pre->hashed_key_xor_opad, out);
+}
+
+static unsigned hmac_sha_precomputed(hmac_precomputed_t *pre_init, uint8_t *out, ...)
 {
 	hmac_precomputed_t pre;
 	va_list va;
 	unsigned len;
 
-	va_start(va, key_size);
-
-	hmac_begin(&pre, key, key_size,
-			(tls->MAC_size == SHA256_OUTSIZE)
-				? sha256_begin
-				: sha1_begin
-	);
+	va_start(va, out);
+	pre = *pre_init; /* struct copy */
 	len = hmac_sha_precomputed_v(&pre, out, va);
-
 	va_end(va);
 	return len;
 }
 
-static unsigned hmac_sha256(/*tls_state_t *tls,*/ uint8_t *out, uint8_t *key, unsigned key_size, ...)
+#if !ENABLE_FEATURE_TLS_SHA1
+#define hmac(tls,out,key,key_size,...) \
+	hmac(out,key,key_size, __VA_ARGS__)
+#endif
+static unsigned hmac(tls_state_t *tls, uint8_t *out, uint8_t *key, unsigned key_size, ...)
 {
 	hmac_precomputed_t pre;
 	va_list va;
@@ -428,7 +524,11 @@ static unsigned hmac_sha256(/*tls_state_
 
 	va_start(va, key_size);
 
-	hmac_begin(&pre, key, key_size, sha256_begin);
+	hmac_begin(&pre, key, key_size,
+			(ENABLE_FEATURE_TLS_SHA1 && tls->MAC_size == SHA1_OUTSIZE)
+				? sha1_begin
+				: sha256_begin
+	);
 	len = hmac_sha_precomputed_v(&pre, out, va);
 
 	va_end(va);
@@ -443,8 +543,9 @@ static unsigned hmac_sha256(/*tls_state_
 // document and in TLS documents published prior to this document when
 // TLS 1.2 is negotiated.
 // ^^^^^^^^^^^^^ IMPORTANT!
-//               PRF uses sha256 regardless of cipher (at least for all ciphers
-//               defined by RFC5246). It's not sha1 for AES_128_CBC_SHA!
+//               PRF uses sha256 regardless of cipher for all ciphers
+//               defined by RFC 5246. It's not sha1 for AES_128_CBC_SHA!
+//               However, for _SHA384 ciphers, it's sha384. See RFC 5288,5289.
 //...
 //    P_hash(secret, seed) = HMAC_hash(secret, A(1) + seed) +
 //                           HMAC_hash(secret, A(2) + seed) +
@@ -466,12 +567,19 @@ static unsigned hmac_sha256(/*tls_state_
 //    PRF(secret, label, seed) = P_<hash>(secret, label + seed)
 //
 // The label is an ASCII string.
+//
+// RFC 5288:
+// For cipher suites ending with _SHA256, the PRF is the TLS PRF
+// with SHA-256 as the hash function.
+// For cipher suites ending with _SHA384, the PRF is the TLS PRF
+// with SHA-384 as the hash function.
 static void prf_hmac_sha256(/*tls_state_t *tls,*/
 		uint8_t *outbuf, unsigned outbuf_size,
 		uint8_t *secret, unsigned secret_size,
 		const char *label,
 		uint8_t *seed, unsigned seed_size)
 {
+	hmac_precomputed_t pre;
 	uint8_t a[TLS_MAX_MAC_SIZE];
 	uint8_t *out_p = outbuf;
 	unsigned label_size = strlen(label);
@@ -479,28 +587,28 @@ static void prf_hmac_sha256(/*tls_state_
 
 	/* In P_hash() calculation, "seed" is "label + seed": */
 #define SEED   label, label_size, seed, seed_size
-#define SECRET secret, secret_size
 #define A      a, MAC_size
 
+	hmac_begin(&pre, secret, secret_size, sha256_begin);
+
 	/* A(1) = HMAC_hash(secret, seed) */
-	hmac_sha256(/*tls,*/ a, SECRET, SEED, NULL);
-//TODO: convert hmac to precomputed
+	hmac_sha_precomputed(&pre, a, SEED, NULL);
 
 	for (;;) {
 		/* HMAC_hash(secret, A(1) + seed) */
 		if (outbuf_size <= MAC_size) {
 			/* Last, possibly incomplete, block */
 			/* (use a[] as temp buffer) */
-			hmac_sha256(/*tls,*/ a, SECRET, A, SEED, NULL);
+			hmac_sha_precomputed(&pre, a, A, SEED, NULL);
 			memcpy(out_p, a, outbuf_size);
 			return;
 		}
 		/* Not last block. Store directly to result buffer */
-		hmac_sha256(/*tls,*/ out_p, SECRET, A, SEED, NULL);
+		hmac_sha_precomputed(&pre, out_p, A, SEED, NULL);
 		out_p += MAC_size;
 		outbuf_size -= MAC_size;
 		/* A(2) = HMAC_hash(secret, A(1)) */
-		hmac_sha256(/*tls,*/ a, SECRET, A, NULL);
+		hmac_sha_precomputed(&pre, a, A, NULL);
 	}
 #undef A
 #undef SECRET
@@ -560,17 +668,24 @@ static void *tls_get_outbuf(tls_state_t
 	return tls->outbuf + OUTBUF_PFX;
 }
 
-static void xwrite_encrypted(tls_state_t *tls, unsigned size, unsigned type)
+static void *tls_get_zeroed_outbuf(tls_state_t *tls, int len)
+{
+	void *record = tls_get_outbuf(tls, len);
+	memset(record, 0, len);
+	return record;
+}
+
+static void xwrite_encrypted_and_hmac_signed(tls_state_t *tls, unsigned size, unsigned type)
 {
 	uint8_t *buf = tls->outbuf + OUTBUF_PFX;
 	struct record_hdr *xhdr;
 	uint8_t padding_length;
 
 	xhdr = (void*)(buf - RECHDR_LEN);
-	if (CIPHER_ID1 != TLS_RSA_WITH_NULL_SHA256 /* if "no encryption" can't be selected */
+	if (!ALLOW_RSA_NULL_SHA256 /* if "no encryption" can't be selected */
 	 || tls->cipher_id != TLS_RSA_WITH_NULL_SHA256 /* or if it wasn't selected */
 	) {
-		xhdr = (void*)(buf - RECHDR_LEN - AES_BLOCKSIZE); /* place for IV */
+		xhdr = (void*)(buf - RECHDR_LEN - AES_BLOCK_SIZE); /* place for IV */
 	}
 
 	xhdr->type = type;
@@ -582,7 +697,7 @@ static void xwrite_encrypted(tls_state_t
 
 	/* Calculate MAC signature */
 	hmac(tls, buf + size, /* result */
-		tls->client_write_MAC_key, tls->MAC_size,
+		tls->client_write_MAC_key, TLS_MAC_SIZE(tls),
 		&tls->write_seq64_be, sizeof(tls->write_seq64_be),
 		xhdr, RECHDR_LEN,
 		buf, size,
@@ -590,9 +705,9 @@ static void xwrite_encrypted(tls_state_t
 	);
 	tls->write_seq64_be = SWAP_BE64(1 + SWAP_BE64(tls->write_seq64_be));
 
-	size += tls->MAC_size;
+	size += TLS_MAC_SIZE(tls);
 
-	// RFC 5246
+	// RFC 5246:
 	// 6.2.3.1.  Null or Standard Stream Cipher
 	//
 	// Stream ciphers (including BulkCipherAlgorithm.null; see Appendix A.6)
@@ -625,7 +740,7 @@ static void xwrite_encrypted(tls_state_t
 	// --------  -----------  ----------  --------------
 	// SHA       HMAC-SHA1       20            20
 	// SHA256    HMAC-SHA256     32            32
-	if (CIPHER_ID1 == TLS_RSA_WITH_NULL_SHA256
+	if (ALLOW_RSA_NULL_SHA256
 	 && tls->cipher_id == TLS_RSA_WITH_NULL_SHA256
 	) {
 		/* No encryption, only signing */
@@ -673,9 +788,9 @@ static void xwrite_encrypted(tls_state_t
 	// AES_128_CBC   Block      16      16     16
 	// AES_256_CBC   Block      32      16     16
 
-	tls_get_random(buf - AES_BLOCKSIZE, AES_BLOCKSIZE); /* IV */
+	tls_get_random(buf - AES_BLOCK_SIZE, AES_BLOCK_SIZE); /* IV */
 	dbg("before crypt: 5 hdr + %u data + %u hash bytes\n",
-			size - tls->MAC_size, tls->MAC_size);
+			size - TLS_MAC_SIZE(tls), TLS_MAC_SIZE(tls));
 
 	/* Fill IV and padding in outbuf */
 	// RFC is talking nonsense:
@@ -693,23 +808,23 @@ static void xwrite_encrypted(tls_state_t
 	// If you need no bytes to reach BLOCKSIZE, you have to pad a full
 	// BLOCKSIZE with bytes of value (BLOCKSIZE-1).
 	// It's ok to have more than minimum padding, but we do minimum.
-	padding_length = (~size) & (AES_BLOCKSIZE - 1);
+	padding_length = (~size) & (AES_BLOCK_SIZE - 1);
 	do {
 		buf[size++] = padding_length; /* padding */
-	} while ((size & (AES_BLOCKSIZE - 1)) != 0);
+	} while ((size & (AES_BLOCK_SIZE - 1)) != 0);
 
 	/* Encrypt content+MAC+padding in place */
 	aes_cbc_encrypt(
-		tls->client_write_key, tls->key_size, /* selects 128/256 */
-		buf - AES_BLOCKSIZE, /* IV */
+		&tls->aes_encrypt, /* selects 128/256 */
+		buf - AES_BLOCK_SIZE, /* IV */
 		buf, size, /* plaintext */
 		buf /* ciphertext */
 	);
 
 	/* Write out */
 	dbg("writing 5 + %u IV + %u encrypted bytes, padding_length:0x%02x\n",
-			AES_BLOCKSIZE, size, padding_length);
-	size += AES_BLOCKSIZE;     /* + IV */
+			AES_BLOCK_SIZE, size, padding_length);
+	size += AES_BLOCK_SIZE;     /* + IV */
 	xhdr->len16_hi = size >> 8;
 	xhdr->len16_lo = size & 0xff;
 	dump_raw_out(">> %s\n", xhdr, RECHDR_LEN + size);
@@ -717,28 +832,114 @@ static void xwrite_encrypted(tls_state_t
 	dbg("wrote %u bytes\n", (int)RECHDR_LEN + size);
 }
 
+/* Example how GCM encryption combines nonce, aad, input and generates
+ * "header | exp_nonce | encrypted output | tag":
+ * nonce:0d 6a 26 31 00 00 00 00 00 00 00 01 (implicit 4 bytes (derived from master secret), then explicit 8 bytes)
+ * aad:  00 00 00 00 00 00 00 01 17 03 03 00 1c
+ * in:   47 45 54 20 2f 69 6e 64 65 78 2e 68 74 6d 6c 20 48 54 54 50 2f 31 2e 30 0d 0a 0d 0a "GET /index.html HTTP/1.0\r\n\r\n" (0x1c bytes)
+ * out:  f7 8a b2 8f 78 0e f6 d5 76 17 2e b5 6d 46 59 56 8b 46 9f 0b d9 2c 35 28 13 66 19 be
+ * tag:  c2 86 ce 4a 50 4a d0 aa 50 b3 76 5c 49 2a 3f 33
+ * sent: 17 03 03 00 34|00 00 00 00 00 00 00 01|f7 8a b2 8f 78 0e f6 d5 76 17 2e b5 6d 46 59 56 8b 46 9f 0b d9 2c 35 28 13 66 19 be|c2 86 ce 4a 50 4a d0 aa 50 b3 76 5c 49 2a 3f 33
+ * .............................................^^ buf points here
+ */
+static void xwrite_encrypted_aesgcm(tls_state_t *tls, unsigned size, unsigned type)
+{
+#define COUNTER(v) (*(uint32_t*)(v + 12))
+
+	uint8_t aad[13 + 3] ALIGNED_long;   /* +3 creates [16] buffer, simplifying GHASH() */
+	uint8_t nonce[12 + 4] ALIGNED_long; /* +4 creates space for AES block counter */
+	uint8_t scratch[AES_BLOCK_SIZE] ALIGNED_long; //[16]
+	uint8_t authtag[AES_BLOCK_SIZE] ALIGNED_long; //[16]
+	uint8_t *buf;
+	struct record_hdr *xhdr;
+	unsigned remaining;
+	unsigned cnt;
+	uint64_t t64;
+
+	buf = tls->outbuf + OUTBUF_PFX; /* see above for the byte it points to */
+	dump_hex("xwrite_encrypted_aesgcm plaintext:%s\n", buf, size);
+
+	xhdr = (void*)(buf - 8 - RECHDR_LEN);
+	xhdr->type = type; /* do it here so that "type" param no longer used */
+
+	aad[8] = type;
+	aad[9] = TLS_MAJ;
+	aad[10] = TLS_MIN;
+	aad[11] = size >> 8;
+	/* set aad[12], and clear aad[13..15] */
+	COUNTER(aad) = SWAP_LE32(size & 0xff);
+
+	memcpy(nonce, tls->client_write_IV, 4);
+	t64 = tls->write_seq64_be;
+	move_to_unaligned64(nonce + 4, t64);
+	move_to_unaligned64(aad,       t64);
+	move_to_unaligned64(buf - 8,   t64);
+	/* seq64 is not used later in this func, can increment here */
+	tls->write_seq64_be = SWAP_BE64(1 + SWAP_BE64(t64));
+
+	cnt = 1;
+	remaining = size;
+	while (remaining != 0) {
+		unsigned n;
+
+		cnt++;
+		COUNTER(nonce) = htonl(cnt); /* yes, first cnt here is 2 (!) */
+		aes_encrypt_one_block(&tls->aes_encrypt, nonce, scratch);
+		n = remaining > AES_BLOCK_SIZE ? AES_BLOCK_SIZE : remaining;
+		xorbuf(buf, scratch, n);
+		buf += n;
+		remaining -= n;
+	}
+
+	aesgcm_GHASH(tls->H, aad, /*sizeof(aad),*/ tls->outbuf + OUTBUF_PFX, size, authtag /*, sizeof(authtag)*/);
+	COUNTER(nonce) = htonl(1);
+	aes_encrypt_one_block(&tls->aes_encrypt, nonce, scratch);
+	xorbuf_aligned_AES_BLOCK_SIZE(authtag, scratch);
+
+	memcpy(buf, authtag, sizeof(authtag));
+
+	/* Write out */
+	xhdr = (void*)(tls->outbuf + OUTBUF_PFX - 8 - RECHDR_LEN);
+	size += 8 + sizeof(authtag);
+	/*xhdr->type = type; - already is */
+	xhdr->proto_maj = TLS_MAJ;
+	xhdr->proto_min = TLS_MIN;
+	xhdr->len16_hi = size >> 8;
+	xhdr->len16_lo = size & 0xff;
+	size += RECHDR_LEN;
+	dump_raw_out(">> %s\n", xhdr, size);
+	xwrite(tls->ofd, xhdr, size);
+	dbg("wrote %u bytes\n", size);
+#undef COUNTER
+}
+
+static void xwrite_encrypted(tls_state_t *tls, unsigned size, unsigned type)
+{
+	if (!(tls->flags & ENCRYPTION_AESGCM)) {
+		xwrite_encrypted_and_hmac_signed(tls, size, type);
+		return;
+	}
+	xwrite_encrypted_aesgcm(tls, size, type);
+}
+
 static void xwrite_handshake_record(tls_state_t *tls, unsigned size)
 {
-	//if (!tls->encrypt_on_write) {
-		uint8_t *buf = tls->outbuf + OUTBUF_PFX;
-		struct record_hdr *xhdr = (void*)(buf - RECHDR_LEN);
-
-		xhdr->type = RECORD_TYPE_HANDSHAKE;
-		xhdr->proto_maj = TLS_MAJ;
-		xhdr->proto_min = TLS_MIN;
-		xhdr->len16_hi = size >> 8;
-		xhdr->len16_lo = size & 0xff;
-		dump_raw_out(">> %s\n", xhdr, RECHDR_LEN + size);
-		xwrite(tls->ofd, xhdr, RECHDR_LEN + size);
-		dbg("wrote %u bytes\n", (int)RECHDR_LEN + size);
-	//	return;
-	//}
-	//xwrite_encrypted(tls, size, RECORD_TYPE_HANDSHAKE);
+	uint8_t *buf = tls->outbuf + OUTBUF_PFX;
+	struct record_hdr *xhdr = (void*)(buf - RECHDR_LEN);
+
+	xhdr->type = RECORD_TYPE_HANDSHAKE;
+	xhdr->proto_maj = TLS_MAJ;
+	xhdr->proto_min = TLS_MIN;
+	xhdr->len16_hi = size >> 8;
+	xhdr->len16_lo = size & 0xff;
+	dump_raw_out(">> %s\n", xhdr, RECHDR_LEN + size);
+	xwrite(tls->ofd, xhdr, RECHDR_LEN + size);
+	dbg("wrote %u bytes\n", (int)RECHDR_LEN + size);
 }
 
 static void xwrite_and_update_handshake_hash(tls_state_t *tls, unsigned size)
 {
-	if (!tls->encrypt_on_write) {
+	if (!(tls->flags & ENCRYPT_ON_WRITE)) {
 		uint8_t *buf;
 
 		xwrite_handshake_record(tls, size);
@@ -777,6 +978,51 @@ static const char *alert_text(int code)
 	return itoa(code);
 }
 
+static void tls_aesgcm_decrypt(tls_state_t *tls, uint8_t *buf, int size)
+{
+#define COUNTER(v) (*(uint32_t*)(v + 12))
+
+	//uint8_t aad[13 + 3] ALIGNED_long; /* +3 creates [16] buffer, simplifying GHASH() */
+	uint8_t nonce[12 + 4] ALIGNED_long; /* +4 creates space for AES block counter */
+	uint8_t scratch[AES_BLOCK_SIZE] ALIGNED_long; //[16]
+	//uint8_t authtag[AES_BLOCK_SIZE] ALIGNED_long; //[16]
+	unsigned remaining;
+	unsigned cnt;
+
+	//memcpy(aad, buf, 8);
+	//aad[8] = type;
+	//aad[9] = TLS_MAJ;
+	//aad[10] = TLS_MIN;
+	//aad[11] = size >> 8;
+	///* set aad[12], and clear aad[13..15] */
+	//COUNTER(aad) = SWAP_LE32(size & 0xff);
+
+	memcpy(nonce,     tls->server_write_IV, 4);
+	memcpy(nonce + 4, buf, 8);
+
+	cnt = 1;
+	remaining = size;
+	while (remaining != 0) {
+		unsigned n;
+
+		cnt++;
+		COUNTER(nonce) = htonl(cnt); /* yes, first cnt here is 2 (!) */
+		aes_encrypt_one_block(&tls->aes_decrypt, nonce, scratch);
+		n = remaining > AES_BLOCK_SIZE ? AES_BLOCK_SIZE : remaining;
+		xorbuf3(buf, scratch, buf + 8, n);
+		buf += n;
+		remaining -= n;
+	}
+
+	//aesgcm_GHASH(tls->H, aad, tls->inbuf + RECHDR_LEN, size, authtag);
+	//COUNTER(nonce) = htonl(1);
+	//aes_encrypt_one_block(&tls->aes_encrypt, nonce, scratch);
+	//xorbuf_aligned_AES_BLOCK_SIZE(authtag, scratch);
+
+	//memcmp(buf, authtag, sizeof(authtag)) || DIE("HASH DOES NOT MATCH!");
+#undef COUNTER
+}
+
 static int tls_xread_record(tls_state_t *tls, const char *expected)
 {
 	struct record_hdr *xhdr;
@@ -847,34 +1093,43 @@ static int tls_xread_record(tls_state_t
 	sz = target - RECHDR_LEN;
 
 	/* Needs to be decrypted? */
-	if (tls->min_encrypted_len_on_read > tls->MAC_size) {
-		uint8_t *p = tls->inbuf + RECHDR_LEN;
-		int padding_len;
-
-		if (sz & (AES_BLOCKSIZE-1)
-		 || sz < (int)tls->min_encrypted_len_on_read
-		) {
-			bb_error_msg_and_die("bad encrypted len:%u < %u",
-				sz, tls->min_encrypted_len_on_read);
+	if (tls->min_encrypted_len_on_read != 0) {
+		if (sz < (int)tls->min_encrypted_len_on_read)
+			bb_error_msg_and_die("bad encrypted len:%u", sz);
+
+		if (tls->flags & ENCRYPTION_AESGCM) {
+			/* AESGCM */
+			uint8_t *p = tls->inbuf + RECHDR_LEN;
+
+			sz -= 8 + AES_BLOCK_SIZE; /* we will overwrite nonce, drop hash */
+			tls_aesgcm_decrypt(tls, p, sz);
+			dbg("encrypted size:%u\n", sz);
+		} else
+		if (tls->min_encrypted_len_on_read > TLS_MAC_SIZE(tls)) {
+			/* AES+SHA */
+			uint8_t *p = tls->inbuf + RECHDR_LEN;
+			int padding_len;
+
+			if (sz & (AES_BLOCK_SIZE-1))
+				bb_error_msg_and_die("bad encrypted len:%u", sz);
+
+			/* Decrypt content+MAC+padding, moving it over IV in the process */
+			sz -= AES_BLOCK_SIZE; /* we will overwrite IV now */
+			aes_cbc_decrypt(
+				&tls->aes_decrypt, /* selects 128/256 */
+				p, /* IV */
+				p + AES_BLOCK_SIZE, sz, /* ciphertext */
+				p /* plaintext */
+			);
+			padding_len = p[sz - 1];
+			dbg("encrypted size:%u type:0x%02x padding_length:0x%02x\n", sz, p[0], padding_len);
+			padding_len++;
+			sz -= TLS_MAC_SIZE(tls) + padding_len; /* drop MAC and padding */
+		} else {
+			/* if nonzero, then it's TLS_RSA_WITH_NULL_SHA256: drop MAC */
+			/* else: no encryption yet on input, subtract zero = NOP */
+			sz -= tls->min_encrypted_len_on_read;
 		}
-		/* Decrypt content+MAC+padding, moving it over IV in the process */
-		sz -= AES_BLOCKSIZE; /* we will overwrite IV now */
-		aes_cbc_decrypt(
-			tls->server_write_key, tls->key_size, /* selects 128/256 */
-			p, /* IV */
-			p + AES_BLOCKSIZE, sz, /* ciphertext */
-			p /* plaintext */
-		);
-		padding_len = p[sz - 1];
-		dbg("encrypted size:%u type:0x%02x padding_length:0x%02x\n", sz, p[0], padding_len);
-		padding_len++;
-		sz -= tls->MAC_size + padding_len; /* drop MAC and padding */
-		//if (sz < 0)
-		//	bb_error_msg_and_die("bad padding size:%u", padding_len);
-	} else {
-		/* if nonzero, then it's TLS_RSA_WITH_NULL_SHA256: drop MAC */
-		/* else: no encryption yet on input, subtract zero = NOP */
-		sz -= tls->min_encrypted_len_on_read;
 	}
 	if (sz < 0)
 		bb_error_msg_and_die("encrypted data too short");
@@ -915,7 +1170,8 @@ static int tls_xread_record(tls_state_t
 	 * in our FINISHED record must include data of incoming packets too!
 	 */
 	if (tls->inbuf[0] == RECORD_TYPE_HANDSHAKE
-	 && tls->MAC_size != 0 /* do we know which hash to use? (server_hello() does not!) */
+/* HANDSHAKE HASH: */
+	// && do_we_know_which_hash_to_use /* server_hello() might not know it in the future! */
 	) {
 		hash_handshake(tls, "<< hash:%s", tls->inbuf + RECHDR_LEN, sz);
 	}
@@ -924,6 +1180,13 @@ static int tls_xread_record(tls_state_t
 	return sz;
 }
 
+static void binary_to_pstm(pstm_int *pstm_n, uint8_t *bin_ptr, unsigned len)
+{
+	pstm_init_for_read_unsigned_bin(/*pool:*/ NULL, pstm_n, len);
+	pstm_read_unsigned_bin(pstm_n, bin_ptr, len);
+	//return bin_ptr + len;
+}
+
 /*
  * DER parsing routines
  */
@@ -995,9 +1258,7 @@ static void der_binary_to_pstm(pstm_int
 	unsigned len = get_der_len(&bin_ptr, der, end);
 
 	dbg_der("binary bytes:%u, first:0x%02x\n", len, bin_ptr[0]);
-	pstm_init_for_read_unsigned_bin(/*pool:*/ NULL, pstm_n, len);
-	pstm_read_unsigned_bin(pstm_n, bin_ptr, len);
-	//return bin + len;
+	binary_to_pstm(pstm_n, bin_ptr, len);
 }
 
 static void find_key_in_der_cert(tls_state_t *tls, uint8_t *der, int len)
@@ -1080,10 +1341,20 @@ static void find_key_in_der_cert(tls_sta
  *	publicKey (BIT STRING)
  *
  * We need Certificate.tbsCertificate.subjectPublicKeyInfo.publicKey
+ *
+ * Example of an ECDSA key:
+ *      SEQ 0x59 bytes (subjectPublicKeyInfo): 3059
+ *        SEQ 0x13 bytes (algorithm): 3013
+ *          OID 7 bytes: 0607 2a8648ce3d0201   (OID_ECDSA_KEY_ALG 42.134.72.206.61.2.1)
+ *          OID 8 bytes: 0608 2a8648ce3d030107 (OID_EC_prime256v1 42.134.72.206.61.3.1.7)
+ *        BITSTRING 0x42 bytes (publicKey): 0342
+ *          0004 53af f65e 50cc 7959 7e29 0171 c75c
+ *          7335 e07d f45b 9750 b797 3a38 aebb 2ac6
+ *          8329 2748 e77e 41cb d482 2ce6 05ec a058
+ *          f3ab d561 2f4c d845 9ad3 7252 e3de bd3b
+ *          9012
  */
 	uint8_t *end = der + len;
-	uint8_t tag_class, pc, tag_number;
-	int version_present;
 
 	/* enter "Certificate" item: [der, end) will be only Cert */
 	der = enter_der_item(der, &end);
@@ -1100,13 +1371,11 @@ static void find_key_in_der_cert(tls_sta
 	 * (constructed), and a tag number of 0 (see ITU-T X.690 sections 8.1.2
 	 * and 8.14).
 	 */
-	tag_class = der[0] >> 6; /* bits 8-7 */
-	pc = (der[0] & 32) >> 5; /* bit 6 */
-	tag_number = der[0] & 31; /* bits 5-1 */
-	version_present = tag_class == 2 && pc == 1 && tag_number == 0;
-	if (version_present) {
+	/* bits 7-6: 10 */
+	/* bit 5: 1 */
+	/* bits 4-0: 00000 */
+	if (der[0] == 0xa0)
 		der = skip_der_item(der, end); /* version */
-	}
 
 	/* skip up to subjectPublicKeyInfo */
 	der = skip_der_item(der, end); /* serialNumber */
@@ -1118,40 +1387,67 @@ static void find_key_in_der_cert(tls_sta
 	/* enter subjectPublicKeyInfo */
 	der = enter_der_item(der, &end);
 	{ /* check subjectPublicKeyInfo.algorithm */
-		static const uint8_t expected[] = {
+		static const uint8_t OID_RSA_KEY_ALG[] = {
 			0x30,0x0d, // SEQ 13 bytes
-			0x06,0x09, 0x2a,0x86,0x48,0x86,0xf7,0x0d,0x01,0x01,0x01, // OID RSA_KEY_ALG 42.134.72.134.247.13.1.1.1
+			0x06,0x09, 0x2a,0x86,0x48,0x86,0xf7,0x0d,0x01,0x01,0x01, //OID_RSA_KEY_ALG 42.134.72.134.247.13.1.1.1
 			//0x05,0x00, // NULL
 		};
-		if (memcmp(der, expected, sizeof(expected)) != 0)
-			bb_error_msg_and_die("not RSA key");
-	}
-	/* skip subjectPublicKeyInfo.algorithm */
-	der = skip_der_item(der, end);
-	/* enter subjectPublicKeyInfo.publicKey */
-//	die_if_not_this_der_type(der, end, 0x03); /* must be BITSTRING */
-	der = enter_der_item(der, &end);
+		static const uint8_t OID_ECDSA_KEY_ALG[] = {
+			0x30,0x13, // SEQ 0x13 bytes
+			0x06,0x07, 0x2a,0x86,0x48,0xce,0x3d,0x02,0x01,      //OID_ECDSA_KEY_ALG 42.134.72.206.61.2.1
+		//allow any curve code for now...
+		//	0x06,0x08, 0x2a,0x86,0x48,0xce,0x3d,0x03,0x01,0x07, //OID_EC_prime256v1 42.134.72.206.61.3.1.7
+			//RFC 3279:
+			//42.134.72.206.61.3     is ellipticCurve
+			//42.134.72.206.61.3.0   is c-TwoCurve
+			//42.134.72.206.61.3.1   is primeCurve
+			//42.134.72.206.61.3.1.7 is curve_secp256r1
+		};
+		if (memcmp(der, OID_RSA_KEY_ALG, sizeof(OID_RSA_KEY_ALG)) == 0) {
+			dbg("RSA key\n");
+			tls->flags |= GOT_CERT_RSA_KEY_ALG;
+		} else
+		if (memcmp(der, OID_ECDSA_KEY_ALG, sizeof(OID_ECDSA_KEY_ALG)) == 0) {
+			dbg("ECDSA key\n");
+			//UNUSED: tls->flags |= GOT_CERT_ECDSA_KEY_ALG;
+		} else
+			bb_error_msg_and_die("not RSA or ECDSA cert");
+	}
+
+	if (tls->flags & GOT_CERT_RSA_KEY_ALG) {
+		/* parse RSA key: */
+	//based on getAsnRsaPubKey(), pkcs1ParsePrivBin() is also of note
+		/* skip subjectPublicKeyInfo.algorithm */
+		der = skip_der_item(der, end);
+		/* enter subjectPublicKeyInfo.publicKey */
+		//die_if_not_this_der_type(der, end, 0x03); /* must be BITSTRING */
+		der = enter_der_item(der, &end);
 
-	/* parse RSA key: */
-//based on getAsnRsaPubKey(), pkcs1ParsePrivBin() is also of note
-	dbg("key bytes:%u, first:0x%02x\n", (int)(end - der), der[0]);
-	if (end - der < 14) xfunc_die();
-	/* example format:
-	 * ignore bits: 00
-	 * SEQ 0x018a/394 bytes: 3082018a
-	 *   INTEGER 0x0181/385 bytes (modulus): 02820181 XX...XXX
-	 *   INTEGER 3 bytes (exponent): 0203 010001
+		dbg("key bytes:%u, first:0x%02x\n", (int)(end - der), der[0]);
+		if (end - der < 14)
+			xfunc_die();
+		/* example format:
+		 * ignore bits: 00
+		 * SEQ 0x018a/394 bytes: 3082018a
+		 *   INTEGER 0x0181/385 bytes (modulus): 02820181 XX...XXX
+		 *   INTEGER 3 bytes (exponent): 0203 010001
+		 */
+		if (*der != 0) /* "ignore bits", should be 0 */
+			xfunc_die();
+		der++;
+		der = enter_der_item(der, &end); /* enter SEQ */
+		/* memset(tls->hsd->server_rsa_pub_key, 0, sizeof(tls->hsd->server_rsa_pub_key)); - already is */
+		der_binary_to_pstm(&tls->hsd->server_rsa_pub_key.N, der, end); /* modulus */
+		der = skip_der_item(der, end);
+		der_binary_to_pstm(&tls->hsd->server_rsa_pub_key.e, der, end); /* exponent */
+		tls->hsd->server_rsa_pub_key.size = pstm_unsigned_bin_size(&tls->hsd->server_rsa_pub_key.N);
+		dbg("server_rsa_pub_key.size:%d\n", tls->hsd->server_rsa_pub_key.size);
+	}
+	/* else: ECDSA key. It is not used for generating encryption keys,
+	 * it is used only to sign the EC public key (which comes in ServerKey message).
+	 * Since we do not verify cert validity, verifying signature on EC public key
+	 * wouldn't add any security. Thus, we do nothing here.
 	 */
-	if (*der != 0) /* "ignore bits", should be 0 */
-		xfunc_die();
-	der++;
-	der = enter_der_item(der, &end); /* enter SEQ */
-	/* memset(tls->hsd->server_rsa_pub_key, 0, sizeof(tls->hsd->server_rsa_pub_key)); - already is */
-	der_binary_to_pstm(&tls->hsd->server_rsa_pub_key.N, der, end); /* modulus */
-	der = skip_der_item(der, end);
-	der_binary_to_pstm(&tls->hsd->server_rsa_pub_key.e, der, end); /* exponent */
-	tls->hsd->server_rsa_pub_key.size = pstm_unsigned_bin_size(&tls->hsd->server_rsa_pub_key.N);
-	dbg("server_rsa_pub_key.size:%d\n", tls->hsd->server_rsa_pub_key.size);
 }
 
 /*
@@ -1188,6 +1484,64 @@ static ALWAYS_INLINE void fill_handshake
 
 static void send_client_hello_and_alloc_hsd(tls_state_t *tls, const char *sni)
 {
+#define NUM_CIPHERS (7 + 6 * ENABLE_FEATURE_TLS_SHA1 + ALLOW_RSA_NULL_SHA256)
+	static const uint8_t ciphers[] = {
+		0x00,2 + NUM_CIPHERS*2, //len16_be
+		0x00,0xFF, //not a cipher - TLS_EMPTY_RENEGOTIATION_INFO_SCSV
+		/* ^^^^^^ RFC 5746 Renegotiation Indication Extension - some servers will refuse to work with us otherwise */
+#if ENABLE_FEATURE_TLS_SHA1
+		0xC0,0x09, // 1 TLS_ECDHE_ECDSA_WITH_AES_128_CBC_SHA - ok: wget https://is.gd/
+		0xC0,0x0A, // 2 TLS_ECDHE_ECDSA_WITH_AES_256_CBC_SHA - ok: wget https://is.gd/
+		0xC0,0x13, // 3 TLS_ECDHE_RSA_WITH_AES_128_CBC_SHA - ok: openssl s_server ... -cipher ECDHE-RSA-AES128-SHA
+		0xC0,0x14, // 4 TLS_ECDHE_RSA_WITH_AES_256_CBC_SHA - ok: openssl s_server ... -cipher ECDHE-RSA-AES256-SHA (might fail with older openssl)
+	//	0xC0,0x18, //   TLS_ECDH_anon_WITH_AES_128_CBC_SHA
+	//	0xC0,0x19, //   TLS_ECDH_anon_WITH_AES_256_CBC_SHA
+#endif
+		0xC0,0x23, // 5 TLS_ECDHE_ECDSA_WITH_AES_128_CBC_SHA256 - ok: wget https://is.gd/
+	//	0xC0,0x24, //   TLS_ECDHE_ECDSA_WITH_AES_256_CBC_SHA384 - can't do SHA384 yet
+		0xC0,0x27, // 6 TLS_ECDHE_RSA_WITH_AES_128_CBC_SHA256 - ok: openssl s_server ... -cipher ECDHE-RSA-AES128-SHA256
+	//	0xC0,0x28, //   TLS_ECDHE_RSA_WITH_AES_256_CBC_SHA384 - can't do SHA384 yet
+		0xC0,0x2B, // 7 TLS_ECDHE_ECDSA_WITH_AES_128_GCM_SHA256 - ok: wget https://is.gd/
+	//	0xC0,0x2C, //   TLS_ECDHE_ECDSA_WITH_AES_256_GCM_SHA384 - wget https://is.gd/: "TLS error from peer (alert code 20): bad MAC"
+//TODO: GCM_SHA384 ciphers can be supported, only need sha384-based PRF?
+		0xC0,0x2F, // 8 TLS_ECDHE_RSA_WITH_AES_128_GCM_SHA256 - ok: openssl s_server ... -cipher ECDHE-RSA-AES128-GCM-SHA256
+	//	0xC0,0x30, //   TLS_ECDHE_RSA_WITH_AES_256_GCM_SHA384 - openssl s_server ... -cipher ECDHE-RSA-AES256-GCM-SHA384: "decryption failed or bad record mac"
+	//possibly these too:
+#if ENABLE_FEATURE_TLS_SHA1
+	//	0xC0,0x35, //   TLS_ECDHE_PSK_WITH_AES_128_CBC_SHA
+	//	0xC0,0x36, //   TLS_ECDHE_PSK_WITH_AES_256_CBC_SHA
+#endif
+	//	0xC0,0x37, //   TLS_ECDHE_PSK_WITH_AES_128_CBC_SHA256
+	//	0xC0,0x38, //   TLS_ECDHE_PSK_WITH_AES_256_CBC_SHA384 - can't do SHA384 yet
+#if ENABLE_FEATURE_TLS_SHA1
+		0x00,0x2F, // 9 TLS_RSA_WITH_AES_128_CBC_SHA - ok: openssl s_server ... -cipher AES128-SHA
+		0x00,0x35, //10 TLS_RSA_WITH_AES_256_CBC_SHA - ok: openssl s_server ... -cipher AES256-SHA
+#endif
+		0x00,0x3C, //11 TLS_RSA_WITH_AES_128_CBC_SHA256 - ok: openssl s_server ... -cipher AES128-SHA256
+		0x00,0x3D, //12 TLS_RSA_WITH_AES_256_CBC_SHA256 - ok: openssl s_server ... -cipher AES256-SHA256
+		0x00,0x9C, //13 TLS_RSA_WITH_AES_128_GCM_SHA256 - ok: openssl s_server ... -cipher AES128-GCM-SHA256
+	//	0x00,0x9D, //   TLS_RSA_WITH_AES_256_GCM_SHA384 - openssl s_server ... -cipher AES256-GCM-SHA384: "decryption failed or bad record mac"
+#if ALLOW_RSA_NULL_SHA256
+		0x00,0x3B, //   TLS_RSA_WITH_NULL_SHA256
+#endif
+		0x01,0x00, //not a cipher - comprtypes_len, comprtype
+	};
+	static const uint8_t supported_groups[] = {
+		0x00,0x0a, //extension_type: "supported_groups"
+		0x00,0x04, //ext len
+		0x00,0x02, //list len
+		0x00,0x1d, //curve_x25519 (RFC 7748)
+		//0x00,0x17, //curve_secp256r1
+		//0x00,0x18, //curve_secp384r1
+		//0x00,0x19, //curve_secp521r1
+	};
+	//static const uint8_t signature_algorithms[] = {
+	//	000d
+	//	0020
+	//	001e
+	//	0601 0602 0603 0501 0502 0503 0401 0402 0403 0301 0302 0303 0201 0202 0203
+	//};
+
 	struct client_hello {
 		uint8_t type;
 		uint8_t len24_hi, len24_mid, len24_lo;
@@ -1196,7 +1550,7 @@ static void send_client_hello_and_alloc_
 		uint8_t session_id_len;
 		/* uint8_t session_id[]; */
 		uint8_t cipherid_len16_hi, cipherid_len16_lo;
-		uint8_t cipherid[2 * (2 + !!CIPHER_ID2)]; /* actually variable */
+		uint8_t cipherid[2 + NUM_CIPHERS*2]; /* actually variable */
 		uint8_t comprtypes_len;
 		uint8_t comprtypes[1]; /* actually variable */
 		/* Extensions (SNI shown):
@@ -1221,14 +1575,20 @@ static void send_client_hello_and_alloc_
 //   0017 0000 - extended master secret
 	};
 	struct client_hello *record;
+	uint8_t *ptr;
 	int len;
-	int sni_len = sni ? strnlen(sni, 127 - 9) : 0;
+	int ext_len;
+	int sni_len = sni ? strnlen(sni, 127 - 5) : 0;
 
-	len = sizeof(*record);
+	ext_len = 0;
+	/* is.gd responds with "handshake failure" to our hello if there's no supported_groups element */
+	ext_len += sizeof(supported_groups);
 	if (sni_len)
-		len += 11 + sni_len;
-	record = tls_get_outbuf(tls, len);
-	memset(record, 0, len);
+		ext_len += 9 + sni_len;
+
+	/* +2 is for "len of all extensions" 2-byte field */
+	len = sizeof(*record) + 2 + ext_len;
+	record = tls_get_zeroed_outbuf(tls, len);
 
 	fill_handshake_record_hdr(record, HANDSHAKE_CLIENT_HELLO, len);
 	record->proto_maj = TLS_MAJ;	/* the "requested" version of the protocol, */
@@ -1238,46 +1598,43 @@ static void send_client_hello_and_alloc_
 		memset(record->rand32, 0x11, sizeof(record->rand32));
 	/* record->session_id_len = 0; - already is */
 
-	/* record->cipherid_len16_hi = 0; */
-	record->cipherid_len16_lo = sizeof(record->cipherid);
-	/* RFC 5746 Renegotiation Indication Extension - some servers will refuse to work with us otherwise */
-	/*record->cipherid[0] = TLS_EMPTY_RENEGOTIATION_INFO_SCSV >> 8; - zero */
-	record->cipherid[1] = TLS_EMPTY_RENEGOTIATION_INFO_SCSV & 0xff;
-	if ((CIPHER_ID1 >> 8) != 0) record->cipherid[2] = CIPHER_ID1 >> 8;
-	/*************************/ record->cipherid[3] = CIPHER_ID1 & 0xff;
-#if CIPHER_ID2
-	if ((CIPHER_ID2 >> 8) != 0) record->cipherid[4] = CIPHER_ID2 >> 8;
-	/*************************/ record->cipherid[5] = CIPHER_ID2 & 0xff;
-#endif
-
-	record->comprtypes_len = 1;
-	/* record->comprtypes[0] = 0; */
+	BUILD_BUG_ON(sizeof(ciphers) != 2 + 2 + NUM_CIPHERS*2 + 2);
+	memcpy(&record->cipherid_len16_hi, ciphers, sizeof(ciphers));
 
+	ptr = (void*)(record + 1);
+	*ptr++ = ext_len >> 8;
+	*ptr++ = ext_len;
 	if (sni_len) {
-		uint8_t *p = (void*)(record + 1);
-		//p[0] = 0;         //
-		p[1] = sni_len + 9; //ext_len
-		//p[2] = 0;             //
-		//p[3] = 0;             //extension_type
-		//p[4] = 0;         //
-		p[5] = sni_len + 5; //list len
-		//p[6] = 0;             //
-		p[7] = sni_len + 3;     //len of 1st SNI
-		//p[8] = 0;         //name type
-		//p[9] = 0;             //
-		p[10] = sni_len;        //name len
-		memcpy(&p[11], sni, sni_len);
+		//ptr[0] = 0;             //
+		//ptr[1] = 0;             //extension_type
+		//ptr[2] = 0;         //
+		ptr[3] = sni_len + 5; //list len
+		//ptr[4] = 0;             //
+		ptr[5] = sni_len + 3;     //len of 1st SNI
+		//ptr[6] = 0;         //name type
+		//ptr[7] = 0;             //
+		ptr[8] = sni_len;         //name len
+		ptr = mempcpy(&ptr[9], sni, sni_len);
 	}
+	memcpy(ptr, supported_groups, sizeof(supported_groups));
 
-	dbg(">> CLIENT_HELLO\n");
-	/* Can hash it only when we know which MAC hash to use */
-	/*xwrite_and_update_handshake_hash(tls, len); - WRONG! */
-	xwrite_handshake_record(tls, len);
-
-	tls->hsd = xzalloc(sizeof(*tls->hsd) + len);
+	tls->hsd = xzalloc(sizeof(*tls->hsd));
+	/* HANDSHAKE HASH: ^^^ + len if need to save saved_client_hello */
+	memcpy(tls->hsd->client_and_server_rand32, record->rand32, sizeof(record->rand32));
+/* HANDSHAKE HASH:
 	tls->hsd->saved_client_hello_size = len;
 	memcpy(tls->hsd->saved_client_hello, record, len);
-	memcpy(tls->hsd->client_and_server_rand32, record->rand32, sizeof(record->rand32));
+ */
+	dbg(">> CLIENT_HELLO\n");
+	/* Can hash immediately only if we know which MAC hash to use.
+	 * So far we do know: it's sha256:
+	 */
+	sha256_begin(&tls->hsd->handshake_hash_ctx);
+	xwrite_and_update_handshake_hash(tls, len);
+	/* if this would become infeasible: save tls->hsd->saved_client_hello,
+	 * use "xwrite_handshake_record(tls, len)" here,
+	 * and hash saved_client_hello later.
+	 */
 }
 
 static void get_server_hello(tls_state_t *tls)
@@ -1297,7 +1654,7 @@ static void get_server_hello(tls_state_t
 
 	struct server_hello *hp;
 	uint8_t *cipherid;
-	unsigned cipher;
+	uint8_t cipherid1;
 	int len, len24;
 
 	len = tls_xread_handshake_block(tls, 74 - 32);
@@ -1330,33 +1687,98 @@ static void get_server_hello(tls_state_t
 		len24 += 32; /* what len would be if session id would be present */
 	}
 
-	if (len24 < 70
-//	 || cipherid[0]  != (CIPHER_ID >> 8)
-//	 || cipherid[1]  != (CIPHER_ID & 0xff)
-//	 || cipherid[2]  != 0 /* comprtype */
-	) {
+	if (len24 < 70)
 		bad_record_die(tls, "'server hello'", len);
-	}
 	dbg("<< SERVER_HELLO\n");
 
 	memcpy(tls->hsd->client_and_server_rand32 + 32, hp->rand32, sizeof(hp->rand32));
 
-	tls->cipher_id = cipher = 0x100 * cipherid[0] + cipherid[1];
-	dbg("server chose cipher %04x\n", cipher);
-
-	if (cipher == TLS_RSA_WITH_AES_128_CBC_SHA) {
-		tls->key_size = AES128_KEYSIZE;
-		tls->MAC_size = SHA1_OUTSIZE;
-	}
-	else { /* TLS_RSA_WITH_AES_256_CBC_SHA256 */
-		tls->key_size = AES256_KEYSIZE;
-		tls->MAC_size = SHA256_OUTSIZE;
+	/* Set up encryption params based on selected cipher */
+#if 0
+#if ENABLE_FEATURE_TLS_SHA1
+		0xC0,0x09, // 1 TLS_ECDHE_ECDSA_WITH_AES_128_CBC_SHA - ok: wget https://is.gd/
+		0xC0,0x0A, // 2 TLS_ECDHE_ECDSA_WITH_AES_256_CBC_SHA - ok: wget https://is.gd/
+		0xC0,0x13, // 3 TLS_ECDHE_RSA_WITH_AES_128_CBC_SHA - ok: openssl s_server ... -cipher ECDHE-RSA-AES128-SHA
+		0xC0,0x14, // 4 TLS_ECDHE_RSA_WITH_AES_256_CBC_SHA - ok: openssl s_server ... -cipher ECDHE-RSA-AES256-SHA (might fail with older openssl)
+	//	0xC0,0x18, //   TLS_ECDH_anon_WITH_AES_128_CBC_SHA
+	//	0xC0,0x19, //   TLS_ECDH_anon_WITH_AES_256_CBC_SHA
+#endif
+		0xC0,0x23, // 5 TLS_ECDHE_ECDSA_WITH_AES_128_CBC_SHA256 - ok: wget https://is.gd/
+	//	0xC0,0x24, //   TLS_ECDHE_ECDSA_WITH_AES_256_CBC_SHA384 - can't do SHA384 yet
+		0xC0,0x27, // 6 TLS_ECDHE_RSA_WITH_AES_128_CBC_SHA256 - ok: openssl s_server ... -cipher ECDHE-RSA-AES128-SHA256
+	//	0xC0,0x28, //   TLS_ECDHE_RSA_WITH_AES_256_CBC_SHA384 - can't do SHA384 yet
+		0xC0,0x2B, // 7 TLS_ECDHE_ECDSA_WITH_AES_128_GCM_SHA256 - ok: wget https://is.gd/
+	//	0xC0,0x2C, //   TLS_ECDHE_ECDSA_WITH_AES_256_GCM_SHA384 - wget https://is.gd/: "TLS error from peer (alert code 20): bad MAC"
+//TODO: GCM_SHA384 ciphers can be supported, only need sha384-based PRF?
+		0xC0,0x2F, // 8 TLS_ECDHE_RSA_WITH_AES_128_GCM_SHA256 - ok: openssl s_server ... -cipher ECDHE-RSA-AES128-GCM-SHA256
+	//	0xC0,0x30, //   TLS_ECDHE_RSA_WITH_AES_256_GCM_SHA384 - openssl s_server ... -cipher ECDHE-RSA-AES256-GCM-SHA384: "decryption failed or bad record mac"
+	//possibly these too:
+#if ENABLE_FEATURE_TLS_SHA1
+	//	0xC0,0x35, //   TLS_ECDHE_PSK_WITH_AES_128_CBC_SHA
+	//	0xC0,0x36, //   TLS_ECDHE_PSK_WITH_AES_256_CBC_SHA
+#endif
+	//	0xC0,0x37, //   TLS_ECDHE_PSK_WITH_AES_128_CBC_SHA256
+	//	0xC0,0x38, //   TLS_ECDHE_PSK_WITH_AES_256_CBC_SHA384 - can't do SHA384 yet
+#if ENABLE_FEATURE_TLS_SHA1
+		0x00,0x2F, // 9 TLS_RSA_WITH_AES_128_CBC_SHA - ok: openssl s_server ... -cipher AES128-SHA
+		0x00,0x35, //10 TLS_RSA_WITH_AES_256_CBC_SHA - ok: openssl s_server ... -cipher AES256-SHA
+#endif
+		0x00,0x3C, //11 TLS_RSA_WITH_AES_128_CBC_SHA256 - ok: openssl s_server ... -cipher AES128-SHA256
+		0x00,0x3D, //12 TLS_RSA_WITH_AES_256_CBC_SHA256 - ok: openssl s_server ... -cipher AES256-SHA256
+		0x00,0x9C, //13 TLS_RSA_WITH_AES_128_GCM_SHA256 - ok: openssl s_server ... -cipher AES128-GCM-SHA256
+	//	0x00,0x9D, //   TLS_RSA_WITH_AES_256_GCM_SHA384 - openssl s_server ... -cipher AES256-GCM-SHA384: "decryption failed or bad record mac"
+#if ALLOW_RSA_NULL_SHA256
+		0x00,0x3B, //   TLS_RSA_WITH_NULL_SHA256
+#endif
+#endif
+	cipherid1 = cipherid[1];
+	tls->cipher_id = 0x100 * cipherid[0] + cipherid1;
+	tls->key_size = AES256_KEYSIZE;
+	tls->MAC_size = SHA256_OUTSIZE;
+	/*tls->IV_size = 0; - already is */
+	if (cipherid[0] == 0xC0) {
+		/* All C0xx are ECDHE */
+		tls->flags |= NEED_EC_KEY;
+		if (cipherid1 & 1) {
+			/* Odd numbered C0xx use AES128 (even ones use AES256) */
+			tls->key_size = AES128_KEYSIZE;
+		}
+		if (ENABLE_FEATURE_TLS_SHA1 && cipherid1 <= 0x19) {
+			tls->MAC_size = SHA1_OUTSIZE;
+		} else
+		if (cipherid1 >= 0x2B && cipherid1 <= 0x30) {
+			/* C02B,2C,2F,30 are AES-GCM */
+			tls->flags |= ENCRYPTION_AESGCM;
+			tls->MAC_size = 0;
+			tls->IV_size = 4;
+		}
+	} else {
+		/* All 00xx are RSA */
+		if ((ENABLE_FEATURE_TLS_SHA1 && cipherid1 == 0x2F)
+		 || cipherid1 == 0x3C
+		 || cipherid1 == 0x9C
+		) {
+			tls->key_size = AES128_KEYSIZE;
+		}
+		if (ENABLE_FEATURE_TLS_SHA1 && cipherid1 <= 0x35) {
+			tls->MAC_size = SHA1_OUTSIZE;
+		} else
+		if (cipherid1 == 0x9C /*|| cipherid1 == 0x9D*/) {
+			/* 009C,9D are AES-GCM */
+			tls->flags |= ENCRYPTION_AESGCM;
+			tls->MAC_size = 0;
+			tls->IV_size = 4;
+		}
 	}
+	dbg("server chose cipher %04x\n", tls->cipher_id);
+	dbg("key_size:%u MAC_size:%u IV_size:%u\n", tls->key_size, tls->MAC_size, tls->IV_size);
+
 	/* Handshake hash eventually destined to FINISHED record
 	 * is sha256 regardless of cipher
 	 * (at least for all ciphers defined by RFC5246).
 	 * It's not sha1 for AES_128_CBC_SHA - only MAC is sha1, not this hash.
 	 */
+/* HANDSHAKE HASH:
 	sha256_begin(&tls->hsd->handshake_hash_ctx);
 	hash_handshake(tls, ">> client hello hash:%s",
 		tls->hsd->saved_client_hello, tls->hsd->saved_client_hello_size
@@ -1364,6 +1786,7 @@ static void get_server_hello(tls_state_t
 	hash_handshake(tls, "<< server hello hash:%s",
 		tls->inbuf + RECHDR_LEN, len
 	);
+ */
 }
 
 static void get_server_cert(tls_state_t *tls)
@@ -1396,6 +1819,68 @@ static void get_server_cert(tls_state_t
 		find_key_in_der_cert(tls, certbuf + 10, len);
 }
 
+/* On input, len is known to be >= 4.
+ * The record is known to be SERVER_KEY_EXCHANGE.
+ */
+static void process_server_key(tls_state_t *tls, int len)
+{
+	struct record_hdr *xhdr;
+	uint8_t *keybuf;
+	int len1;
+	uint32_t t32;
+
+	xhdr = (void*)tls->inbuf;
+	keybuf = (void*)(xhdr + 1);
+//seen from is.gd: it selects curve_x25519:
+//  0c 00006e //SERVER_KEY_EXCHANGE, len
+//    03 //curve_type: named curve
+//    001d //curve_x25519
+//server-chosen EC point, and then signed_params
+//      (RFC 8422: "A hash of the params, with the signature
+//      appropriate to that hash applied.  The private key corresponding
+//      to the certified public key in the server's Certificate message is
+//      used for signing.")
+//follow. Format unclear/guessed:
+//    20 //eccPubKeyLen
+//      25511923d73b70dd2f60e66ba2f3fda31a9c25170963c7a3a972e481dbb2835d //eccPubKey (32bytes)
+//    0203 //hashSigAlg: 2:SHA1 (4:SHA256 5:SHA384 6:SHA512), 3:ECDSA (1:RSA)
+//    0046 //len (16bit)
+//      30 44 //SEQ, len
+//        02 20 //INTEGER, len
+//          2e18e7c2a9badd0a70cd3059a6ab114539b9f5163568911147386cd77ed7c412 //32bytes
+//this item ^^^^^ is sometimes 33 bytes (with all container sizes also +1)
+//        02 20 //INTEGER, len
+//          64523d6216cb94c43c9b20e377d8c52c55be6703fd6730a155930c705eaf3af6 //32bytes
+//same about this item ^^^^^
+
+//seen from ftp.openbsd.org
+//(which only accepts ECDHE-RSA-AESnnn-GCM-SHAnnn and ECDHE-RSA-CHACHA20-POLY1305 ciphers):
+//  0c 000228 //SERVER_KEY_EXCHANGE, len
+//    03 //curve_type: named curve
+//    001d //curve_x25519
+//    20 //eccPubKeyLen
+//      eef7a15c43b71a4c7eaa48a39369399cc4332e569ec90a83274cc92596705c1a //eccPubKey
+//    0401 //hashSigAlg: 4:SHA256, 1:RSA
+//    0200 //len
+//      //0x200 bytes follow
+
+	/* Get and verify length */
+	len1 = get24be(keybuf + 1);
+	if (len1 > len - 4) tls_error_die(tls);
+	len = len1;
+	if (len < (1+2+1+32)) tls_error_die(tls);
+	keybuf += 4;
+
+	/* So far we only support curve_x25519 */
+	move_from_unaligned32(t32, keybuf);
+	if (t32 != htonl(0x03001d20))
+		bb_error_msg_and_die("elliptic curve is not x25519");
+
+	memcpy(tls->hsd->ecc_pub_key32, keybuf + 4, 32);
+	tls->flags |= GOT_EC_KEY;
+	dbg("got eccPubKey\n");
+}
+
 static void send_empty_client_cert(tls_state_t *tls)
 {
 	struct client_empty_cert {
@@ -1405,12 +1890,14 @@ static void send_empty_client_cert(tls_s
 	};
 	struct client_empty_cert *record;
 
-	record = tls_get_outbuf(tls, sizeof(*record));
-//FIXME: can just memcpy a ready-made one.
-	fill_handshake_record_hdr(record, HANDSHAKE_CERTIFICATE, sizeof(*record));
-	record->cert_chain_len24_hi = 0;
-	record->cert_chain_len24_mid = 0;
-	record->cert_chain_len24_lo = 0;
+	record = tls_get_zeroed_outbuf(tls, sizeof(*record));
+	//fill_handshake_record_hdr(record, HANDSHAKE_CERTIFICATE, sizeof(*record));
+	//record->cert_chain_len24_hi = 0;
+	//record->cert_chain_len24_mid = 0;
+	//record->cert_chain_len24_lo = 0;
+	// same as above:
+	record->type = HANDSHAKE_CERTIFICATE;
+	record->len24_lo = 3;
 
 	dbg(">> CERTIFICATE\n");
 	xwrite_and_update_handshake_hash(tls, sizeof(*record));
@@ -1421,36 +1908,72 @@ static void send_client_key_exchange(tls
 	struct client_key_exchange {
 		uint8_t type;
 		uint8_t len24_hi, len24_mid, len24_lo;
-		/* keylen16 exists for RSA (in TLS, not in SSL), but not for some other key types */
-		uint8_t keylen16_hi, keylen16_lo;
-		uint8_t key[4 * 1024]; // size??
+		uint8_t key[2 + 4 * 1024]; // size??
 	};
 //FIXME: better size estimate
-	struct client_key_exchange *record = tls_get_outbuf(tls, sizeof(*record));
+	struct client_key_exchange *record = tls_get_zeroed_outbuf(tls, sizeof(*record));
 	uint8_t rsa_premaster[RSA_PREMASTER_SIZE];
+	uint8_t x25519_premaster[CURVE25519_KEYSIZE];
+	uint8_t *premaster;
+	int premaster_size;
 	int len;
 
-	tls_get_random(rsa_premaster, sizeof(rsa_premaster));
-	if (TLS_DEBUG_FIXED_SECRETS)
-		memset(rsa_premaster, 0x44, sizeof(rsa_premaster));
-	// RFC 5246
-	// "Note: The version number in the PreMasterSecret is the version
-	// offered by the client in the ClientHello.client_version, not the
-	// version negotiated for the connection."
-	rsa_premaster[0] = TLS_MAJ;
-	rsa_premaster[1] = TLS_MIN;
-	dump_hex("premaster:%s\n", rsa_premaster, sizeof(rsa_premaster));
-	len = psRsaEncryptPub(/*pool:*/ NULL,
-		/* psRsaKey_t* */ &tls->hsd->server_rsa_pub_key,
-		rsa_premaster, /*inlen:*/ sizeof(rsa_premaster),
-		record->key, sizeof(record->key),
-		data_param_ignored
-	);
-	record->keylen16_hi = len >> 8;
-	record->keylen16_lo = len & 0xff;
-	len += 2;
+	if (!(tls->flags & NEED_EC_KEY)) {
+		/* RSA */
+		if (!(tls->flags & GOT_CERT_RSA_KEY_ALG))
+			bb_error_msg("server cert is not RSA");
+
+		tls_get_random(rsa_premaster, sizeof(rsa_premaster));
+		if (TLS_DEBUG_FIXED_SECRETS)
+			memset(rsa_premaster, 0x44, sizeof(rsa_premaster));
+		// RFC 5246
+		// "Note: The version number in the PreMasterSecret is the version
+		// offered by the client in the ClientHello.client_version, not the
+		// version negotiated for the connection."
+		rsa_premaster[0] = TLS_MAJ;
+		rsa_premaster[1] = TLS_MIN;
+		dump_hex("premaster:%s\n", rsa_premaster, sizeof(rsa_premaster));
+		len = psRsaEncryptPub(/*pool:*/ NULL,
+			/* psRsaKey_t* */ &tls->hsd->server_rsa_pub_key,
+			rsa_premaster, /*inlen:*/ sizeof(rsa_premaster),
+			record->key + 2, sizeof(record->key) - 2,
+			data_param_ignored
+		);
+		/* keylen16 exists for RSA (in TLS, not in SSL), but not for some other key types */
+		record->key[0] = len >> 8;
+		record->key[1] = len & 0xff;
+		len += 2;
+		premaster = rsa_premaster;
+		premaster_size = sizeof(rsa_premaster);
+	} else {
+		/* ECDHE */
+		static const uint8_t basepoint9[CURVE25519_KEYSIZE] = {9};
+		uint8_t privkey[CURVE25519_KEYSIZE]; //[32]
+
+		if (!(tls->flags & GOT_EC_KEY))
+			bb_error_msg("server did not provide EC key");
+
+		/* Generate random private key, see RFC 7748 */
+		tls_get_random(privkey, sizeof(privkey));
+		privkey[0] &= 0xf8;
+		privkey[CURVE25519_KEYSIZE-1] = ((privkey[CURVE25519_KEYSIZE-1] & 0x7f) | 0x40);
+
+		/* Compute public key */
+		curve25519(record->key + 1, privkey, basepoint9);
+
+		/* Compute premaster using peer's public key */
+		dbg("computing x25519_premaster\n");
+		curve25519(x25519_premaster, privkey, tls->hsd->ecc_pub_key32);
+
+		len = CURVE25519_KEYSIZE;
+		record->key[0] = len;
+		len++;
+		premaster = x25519_premaster;
+		premaster_size = sizeof(x25519_premaster);
+	}
+
 	record->type = HANDSHAKE_CLIENT_KEY_EXCHANGE;
-	record->len24_hi  = 0;
+	/* record->len24_hi = 0; - already is */
 	record->len24_mid = len >> 8;
 	record->len24_lo  = len & 0xff;
 	len += 4;
@@ -1470,7 +1993,7 @@ static void send_client_key_exchange(tls
 	// of the premaster secret will vary depending on key exchange method.
 	prf_hmac_sha256(/*tls,*/
 		tls->hsd->master_secret, sizeof(tls->hsd->master_secret),
-		rsa_premaster, sizeof(rsa_premaster),
+		premaster, premaster_size,
 		"master secret",
 		tls->hsd->client_and_server_rand32, sizeof(tls->hsd->client_and_server_rand32)
 	);
@@ -1517,23 +2040,38 @@ static void send_client_key_exchange(tls
 		memcpy(&tmp64[32], &tls->hsd->client_and_server_rand32[0] , 32);
 
 		prf_hmac_sha256(/*tls,*/
-			tls->client_write_MAC_key, 2 * (tls->MAC_size + tls->key_size),
+			tls->client_write_MAC_key, 2 * (tls->MAC_size + tls->key_size + tls->IV_size),
 			// also fills:
 			// server_write_MAC_key[]
 			// client_write_key[]
 			// server_write_key[]
+			// client_write_IV[]
+			// server_write_IV[]
 			tls->hsd->master_secret, sizeof(tls->hsd->master_secret),
 			"key expansion",
 			tmp64, 64
 		);
 		tls->client_write_key = tls->client_write_MAC_key + (2 * tls->MAC_size);
 		tls->server_write_key = tls->client_write_key + tls->key_size;
+		tls->client_write_IV = tls->server_write_key + tls->key_size;
+		tls->server_write_IV = tls->client_write_IV + tls->IV_size;
 		dump_hex("client_write_MAC_key:%s\n",
 			tls->client_write_MAC_key, tls->MAC_size
 		);
 		dump_hex("client_write_key:%s\n",
 			tls->client_write_key, tls->key_size
 		);
+		dump_hex("client_write_IV:%s\n",
+			tls->client_write_IV, tls->IV_size
+		);
+
+		aes_setkey(&tls->aes_decrypt, tls->server_write_key, tls->key_size);
+		aes_setkey(&tls->aes_encrypt, tls->client_write_key, tls->key_size);
+		{
+			uint8_t iv[AES_BLOCK_SIZE];
+			memset(iv, 0, AES_BLOCK_SIZE);
+			aes_encrypt_one_block(&tls->aes_encrypt, iv, tls->H);
+		}
 	}
 }
 
@@ -1598,7 +2136,8 @@ static void send_client_finished(tls_sta
 
 	fill_handshake_record_hdr(record, HANDSHAKE_FINISHED, sizeof(*record));
 
-	len = get_handshake_hash(tls, handshake_hash);
+	len = sha_end(&tls->hsd->handshake_hash_ctx, handshake_hash);
+
 	prf_hmac_sha256(/*tls,*/
 		record->prf_result, sizeof(record->prf_result),
 		tls->hsd->master_secret, sizeof(tls->hsd->master_secret),
@@ -1657,8 +2196,19 @@ void FAST_FUNC tls_handshake(tls_state_t
 		//SvKey len=455^
 		// with TLS_ECDHE_RSA_WITH_AES_128_CBC_SHA: 461 bytes:
 		// 0c   00|01|c9 03|00|17|41|04|cd|9b|b4|29|1f|f6|b0|c2|84|82|7f|29|6a|47|4e|ec|87|0b|c1|9c|69|e1|f8|c6|d0|53|e9|27|90|a5|c8|02|15|75...
+		//
+		// RFC 8422 5.4. Server Key Exchange
+		// This message is sent when using the ECDHE_ECDSA, ECDHE_RSA, and
+		// ECDH_anon key exchange algorithms.
+		// This message is used to convey the server's ephemeral ECDH public key
+		// (and the corresponding elliptic curve domain parameters) to the
+		// client.
 		dbg("<< SERVER_KEY_EXCHANGE len:%u\n", len);
-//probably need to save it
+		dump_raw_in("<< %s\n", tls->inbuf, RECHDR_LEN + len);
+		if (tls->flags & NEED_EC_KEY)
+			process_server_key(tls, len);
+
+		// read next handshake block
 		len = tls_xread_handshake_block(tls, 4);
 	}
 
@@ -1692,7 +2242,7 @@ void FAST_FUNC tls_handshake(tls_state_t
 	send_change_cipher_spec(tls);
 	/* from now on we should send encrypted */
 	/* tls->write_seq64_be = 0; - already is */
-	tls->encrypt_on_write = 1;
+	tls->flags |= ENCRYPT_ON_WRITE;
 
 	send_client_finished(tls);
 
@@ -1701,18 +2251,22 @@ void FAST_FUNC tls_handshake(tls_state_t
 	if (len != 1 || memcmp(tls->inbuf, rec_CHANGE_CIPHER_SPEC, 6) != 0)
 		bad_record_die(tls, "switch to encrypted traffic", len);
 	dbg("<< CHANGE_CIPHER_SPEC\n");
-	if (CIPHER_ID1 == TLS_RSA_WITH_NULL_SHA256
+
+	if (ALLOW_RSA_NULL_SHA256
 	 && tls->cipher_id == TLS_RSA_WITH_NULL_SHA256
 	) {
 		tls->min_encrypted_len_on_read = tls->MAC_size;
-	} else {
-		unsigned mac_blocks = (unsigned)(tls->MAC_size + AES_BLOCKSIZE-1) / AES_BLOCKSIZE;
+	} else
+	if (!(tls->flags & ENCRYPTION_AESGCM)) {
+		unsigned mac_blocks = (unsigned)(TLS_MAC_SIZE(tls) + AES_BLOCK_SIZE-1) / AES_BLOCK_SIZE;
 		/* all incoming packets now should be encrypted and have
 		 * at least IV + (MAC padded to blocksize):
 		 */
-		tls->min_encrypted_len_on_read = AES_BLOCKSIZE + (mac_blocks * AES_BLOCKSIZE);
-		dbg("min_encrypted_len_on_read: %u", tls->min_encrypted_len_on_read);
+		tls->min_encrypted_len_on_read = AES_BLOCK_SIZE + (mac_blocks * AES_BLOCK_SIZE);
+	} else {
+		tls->min_encrypted_len_on_read = 8 + AES_BLOCK_SIZE;
 	}
+	dbg("min_encrypted_len_on_read: %u\n", tls->min_encrypted_len_on_read);
 
 	/* Get (encrypted) FINISHED from the server */
 	len = tls_xread_record(tls, "'server finished'");
@@ -1722,6 +2276,7 @@ void FAST_FUNC tls_handshake(tls_state_t
 	/* application data can be sent/received */
 
 	/* free handshake data */
+	psRsaKey_clear(&tls->hsd->server_rsa_pub_key);
 //	if (PARANOIA)
 //		memset(tls->hsd, 0, tls->hsd->hsd_size);
 	free(tls->hsd);
@@ -1736,12 +2291,12 @@ static void tls_xwrite(tls_state_t *tls,
 
 // To run a test server using openssl:
 // openssl req -x509 -newkey rsa:$((4096/4*3)) -keyout key.pem -out server.pem -nodes -days 99999 -subj '/CN=localhost'
-// openssl s_server -key key.pem -cert server.pem -debug -tls1_2 -no_tls1 -no_tls1_1
+// openssl s_server -key key.pem -cert server.pem -debug -tls1_2
 //
 // Unencryped SHA256 example:
 // openssl req -x509 -newkey rsa:$((4096/4*3)) -keyout key.pem -out server.pem -nodes -days 99999 -subj '/CN=localhost'
-// openssl s_server -key key.pem -cert server.pem -debug -tls1_2 -no_tls1 -no_tls1_1 -cipher NULL
-// openssl s_client -connect 127.0.0.1:4433 -debug -tls1_2 -no_tls1 -no_tls1_1 -cipher NULL-SHA256
+// openssl s_server -key key.pem -cert server.pem -debug -tls1_2 -cipher NULL
+// openssl s_client -connect 127.0.0.1:4433 -debug -tls1_2 -cipher NULL-SHA256
 
 void FAST_FUNC tls_run_copy_loop(tls_state_t *tls, unsigned flags)
 {
diff -urpN busybox-1.29.3/networking/tls.h busybox-1.30.0/networking/tls.h
--- busybox-1.29.3/networking/tls.h	2018-07-02 13:23:06.000000000 +0200
+++ busybox-1.30.0/networking/tls.h	2018-12-05 15:44:34.000000000 +0100
@@ -78,7 +78,14 @@ typedef  int16_t  int16;
 #define PUBKEY_TYPE     0x01
 #define PRIVKEY_TYPE    0x02
 
-void tls_get_random(void *buf, unsigned len);
+#define AES_BLOCK_SIZE  16
+
+void tls_get_random(void *buf, unsigned len) FAST_FUNC;
+
+void xorbuf(void* buf, const void* mask, unsigned count) FAST_FUNC;
+
+#define ALIGNED_long ALIGNED(sizeof(long))
+void xorbuf_aligned_AES_BLOCK_SIZE(void* buf, const void* mask) FAST_FUNC;
 
 #define matrixCryptoGetPrngData(buf, len, userPtr) (tls_get_random(buf, len), PS_SUCCESS)
 
@@ -94,6 +101,8 @@ void tls_get_random(void *buf, unsigned
 
 
 #include "tls_pstm.h"
-#include "tls_rsa.h"
 #include "tls_symmetric.h"
 #include "tls_aes.h"
+#include "tls_aesgcm.h"
+#include "tls_rsa.h"
+#include "tls_fe.h"
diff -urpN busybox-1.29.3/networking/tls_aes.c busybox-1.30.0/networking/tls_aes.c
--- busybox-1.29.3/networking/tls_aes.c	2018-07-02 13:23:06.000000000 +0200
+++ busybox-1.30.0/networking/tls_aes.c	2018-12-05 15:44:34.000000000 +0100
@@ -326,8 +326,11 @@ static void InvMixColumns(unsigned astat
 	}
 }
 
-static void aes_encrypt_1(unsigned astate[16], unsigned rounds, const uint32_t *RoundKey)
+static void aes_encrypt_1(struct tls_aes *aes, unsigned astate[16])
 {
+	unsigned rounds = aes->rounds;
+	const uint32_t *RoundKey = aes->key;
+
 	for (;;) {
 		AddRoundKey(astate, RoundKey);
 		RoundKey += 4;
@@ -340,8 +343,12 @@ static void aes_encrypt_1(unsigned astat
 	AddRoundKey(astate, RoundKey);
 }
 
-#if 0 // UNUSED
-static void aes_encrypt_one_block(unsigned rounds, const uint32_t *RoundKey, const void *data, void *dst)
+void FAST_FUNC aes_setkey(struct tls_aes *aes, const void *key, unsigned key_len)
+{
+	aes->rounds = KeyExpansion(aes->key, key, key_len);
+}
+
+void FAST_FUNC aes_encrypt_one_block(struct tls_aes *aes, const void *data, void *dst)
 {
 	unsigned astate[16];
 	unsigned i;
@@ -351,23 +358,19 @@ static void aes_encrypt_one_block(unsign
 
 	for (i = 0; i < 16; i++)
 		astate[i] = pt[i];
-	aes_encrypt_1(astate, rounds, RoundKey);
+	aes_encrypt_1(aes, astate);
 	for (i = 0; i < 16; i++)
 		ct[i] = astate[i];
 }
-#endif
 
-void aes_cbc_encrypt(const void *key, int klen, void *iv, const void *data, size_t len, void *dst)
+void FAST_FUNC aes_cbc_encrypt(struct tls_aes *aes, void *iv, const void *data, size_t len, void *dst)
 {
-	uint32_t RoundKey[60];
 	uint8_t iv2[16];
-	unsigned rounds;
 
 	const uint8_t *pt = data;
 	uint8_t *ct = dst;
 
 	memcpy(iv2, iv, 16);
-	rounds = KeyExpansion(RoundKey, key, klen);
 	while (len > 0) {
 		{
 			/* almost aes_encrypt_one_block(rounds, RoundKey, pt, ct);
@@ -378,7 +381,7 @@ void aes_cbc_encrypt(const void *key, in
 			unsigned astate[16];
 			for (i = 0; i < 16; i++)
 				astate[i] = pt[i] ^ iv2[i];
-			aes_encrypt_1(astate, rounds, RoundKey);
+			aes_encrypt_1(aes, astate);
 			for (i = 0; i < 16; i++)
 				iv2[i] = ct[i] = astate[i];
 		}
@@ -388,8 +391,11 @@ void aes_cbc_encrypt(const void *key, in
 	}
 }
 
-static void aes_decrypt_1(unsigned astate[16], unsigned rounds, const uint32_t *RoundKey)
+static void aes_decrypt_1(struct tls_aes *aes, unsigned astate[16])
 {
+	unsigned rounds = aes->rounds;
+	const uint32_t *RoundKey = aes->key;
+
 	RoundKey += rounds * 4;
 	AddRoundKey(astate, RoundKey);
 	for (;;) {
@@ -404,8 +410,10 @@ static void aes_decrypt_1(unsigned astat
 }
 
 #if 0 //UNUSED
-static void aes_decrypt_one_block(unsigned rounds, const uint32_t *RoundKey, const void *data, void *dst)
+static void aes_decrypt_one_block(struct tls_aes *aes, const void *data, void *dst)
 {
+	unsigned rounds = aes->rounds;
+	const uint32_t *RoundKey = aes->key;
 	unsigned astate[16];
 	unsigned i;
 
@@ -414,25 +422,22 @@ static void aes_decrypt_one_block(unsign
 
 	for (i = 0; i < 16; i++)
 		astate[i] = ct[i];
-	aes_decrypt_1(astate, rounds, RoundKey);
+	aes_decrypt_1(aes, astate);
 	for (i = 0; i < 16; i++)
 		pt[i] = astate[i];
 }
 #endif
 
-void aes_cbc_decrypt(const void *key, int klen, void *iv, const void *data, size_t len, void *dst)
+void FAST_FUNC aes_cbc_decrypt(struct tls_aes *aes, void *iv, const void *data, size_t len, void *dst)
 {
-	uint32_t RoundKey[60];
 	uint8_t iv2[16];
 	uint8_t iv3[16];
-	unsigned rounds;
 	uint8_t *ivbuf;
 	uint8_t *ivnext;
 
 	const uint8_t *ct = data;
 	uint8_t *pt = dst;
 
-	rounds = KeyExpansion(RoundKey, key, klen);
 	ivbuf = memcpy(iv2, iv, 16);
 	while (len) {
 		ivnext = (ivbuf==iv2) ? iv3 : iv2;
@@ -444,7 +449,7 @@ void aes_cbc_decrypt(const void *key, in
 			unsigned astate[16];
 			for (i = 0; i < 16; i++)
 				ivnext[i] = astate[i] = ct[i];
-			aes_decrypt_1(astate, rounds, RoundKey);
+			aes_decrypt_1(aes, astate);
 			for (i = 0; i < 16; i++)
 				pt[i] = astate[i] ^ ivbuf[i];
 		}
diff -urpN busybox-1.29.3/networking/tls_aes.h busybox-1.30.0/networking/tls_aes.h
--- busybox-1.29.3/networking/tls_aes.h	2018-07-02 13:23:06.000000000 +0200
+++ busybox-1.30.0/networking/tls_aes.h	2018-12-05 15:44:34.000000000 +0100
@@ -6,5 +6,9 @@
  * Selected few declarations for AES.
  */
 
-void aes_cbc_encrypt(const void *key, int klen, void *iv, const void *data, size_t len, void *dst);
-void aes_cbc_decrypt(const void *key, int klen, void *iv, const void *data, size_t len, void *dst);
+void aes_setkey(struct tls_aes *aes, const void *key, unsigned key_len) FAST_FUNC;
+
+void aes_encrypt_one_block(struct tls_aes *aes, const void *data, void *dst) FAST_FUNC;
+
+void aes_cbc_encrypt(struct tls_aes *aes, void *iv, const void *data, size_t len, void *dst) FAST_FUNC;
+void aes_cbc_decrypt(struct tls_aes *aes, void *iv, const void *data, size_t len, void *dst) FAST_FUNC;
diff -urpN busybox-1.29.3/networking/tls_aesgcm.c busybox-1.30.0/networking/tls_aesgcm.c
--- busybox-1.29.3/networking/tls_aesgcm.c	1970-01-01 01:00:00.000000000 +0100
+++ busybox-1.30.0/networking/tls_aesgcm.c	2018-12-30 16:14:20.000000000 +0100
@@ -0,0 +1,200 @@
+/*
+ * Copyright (C) 2018 Denys Vlasenko
+ *
+ * Licensed under GPLv2, see file LICENSE in this source tree.
+ */
+
+#include "tls.h"
+
+typedef uint8_t byte;
+typedef uint32_t word32;
+#define XMEMSET memset
+#define XMEMCPY memcpy
+
+/* from wolfssl-3.15.3/wolfcrypt/src/aes.c */
+
+static ALWAYS_INLINE void FlattenSzInBits(byte* buf, word32 sz)
+{
+    /* Multiply the sz by 8 */
+//bbox: these sizes are never even close to 2^32/8
+//    word32 szHi = (sz >> (8*sizeof(sz) - 3));
+    sz <<= 3;
+
+    /* copy over the words of the sz into the destination buffer */
+//    buf[0] = (szHi >> 24) & 0xff;
+//    buf[1] = (szHi >> 16) & 0xff;
+//    buf[2] = (szHi >>  8) & 0xff;
+//    buf[3] = szHi & 0xff;
+    *(uint32_t*)(buf + 0) = 0;
+//    buf[4] = (sz >> 24) & 0xff;
+//    buf[5] = (sz >> 16) & 0xff;
+//    buf[6] = (sz >>  8) & 0xff;
+//    buf[7] = sz & 0xff;
+    *(uint32_t*)(buf + 4) = SWAP_BE32(sz);
+}
+
+static void RIGHTSHIFTX(byte* x)
+{
+#define l ((unsigned long*)x)
+#if 0
+
+    // Generic byte-at-a-time algorithm
+    int i;
+    byte carryIn = (x[15] & 0x01) ? 0xE1 : 0;
+    for (i = 0; i < AES_BLOCK_SIZE; i++) {
+        byte carryOut = (x[i] << 7); // zero, or 0x80
+        x[i] = (x[i] >> 1) ^ carryIn;
+        carryIn = carryOut;
+    }
+
+#elif BB_BIG_ENDIAN
+
+    // Big-endian can shift-right in larger than byte chunks
+    // (we use the fact that 'x' is long-aligned)
+    unsigned long carryIn = (x[15] & 0x01)
+        ? ((unsigned long)0xE1 << (LONG_BIT-8))
+        : 0;
+# if ULONG_MAX <= 0xffffffff
+    int i;
+    for (i = 0; i < AES_BLOCK_SIZE/sizeof(long); i++) {
+        unsigned long carryOut = l[i] << (LONG_BIT-1); // zero, or 0x800..00
+        l[i] = (l[i] >> 1) ^ carryIn;
+        carryIn = carryOut;
+    }
+# else
+    // 64-bit code: need to process only 2 words
+    unsigned long carryOut = l[0] << (LONG_BIT-1); // zero, or 0x800..00
+    l[0] = (l[0] >> 1) ^ carryIn;
+    l[1] = (l[1] >> 1) ^ carryOut;
+# endif
+
+#else /* LITTLE_ENDIAN */
+
+    // In order to use word-sized ops, little-endian needs to byteswap.
+    // On x86, code size increase is ~10 bytes compared to byte-by-byte.
+    unsigned long carryIn = (x[15] & 0x01)
+        ? ((unsigned long)0xE1 << (LONG_BIT-8))
+        : 0;
+# if ULONG_MAX <= 0xffffffff
+    int i;
+    for (i = 0; i < AES_BLOCK_SIZE/sizeof(long); i++) {
+        unsigned long ti = SWAP_BE32(l[i]);
+        unsigned long carryOut = ti << (LONG_BIT-1); // zero, or 0x800..00
+        ti = (ti >> 1) ^ carryIn;
+        l[i] = SWAP_BE32(ti);
+        carryIn = carryOut;
+    }
+# else
+    // 64-bit code: need to process only 2 words
+    unsigned long tt = SWAP_BE64(l[0]);
+    unsigned long carryOut = tt << (LONG_BIT-1); // zero, or 0x800..00
+    tt = (tt >> 1) ^ carryIn; l[0] = SWAP_BE64(tt);
+    tt = SWAP_BE64(l[1]);
+    tt = (tt >> 1) ^ carryOut; l[1] = SWAP_BE64(tt);
+# endif
+
+#endif /* LITTLE_ENDIAN */
+#undef l
+}
+
+// Caller guarantees X is aligned
+static void GMULT(byte* X, byte* Y)
+{
+    byte Z[AES_BLOCK_SIZE] ALIGNED_long;
+    //byte V[AES_BLOCK_SIZE] ALIGNED_long;
+    int i;
+
+    XMEMSET(Z, 0, AES_BLOCK_SIZE);
+    //XMEMCPY(V, X, AES_BLOCK_SIZE);
+    for (i = 0; i < AES_BLOCK_SIZE; i++) {
+        uint32_t y = 0x800000 | Y[i];
+        for (;;) { // for every bit in Y[i], from msb to lsb
+            if (y & 0x80) {
+                xorbuf_aligned_AES_BLOCK_SIZE(Z, X); // was V, not X
+            }
+            RIGHTSHIFTX(X); // was V, not X
+            y = y << 1;
+            if ((int32_t)y < 0) // if bit 0x80000000 set = if 8 iterations done
+                break;
+        }
+    }
+    XMEMCPY(X, Z, AES_BLOCK_SIZE);
+}
+
+//bbox:
+// for TLS AES-GCM, a (which is AAD) is always 13 bytes long, and bbox code provides
+// extra 3 zeroed bytes, making it a[16], or a[AES_BLOCK_SIZE].
+// Resulting auth tag in s[] is also always AES_BLOCK_SIZE bytes.
+//
+// This allows some simplifications.
+#define aSz 13
+#define sSz AES_BLOCK_SIZE
+void FAST_FUNC aesgcm_GHASH(byte* h,
+    const byte* a, //unsigned aSz,
+    const byte* c, unsigned cSz,
+    byte* s //, unsigned sSz
+)
+{
+    byte x[AES_BLOCK_SIZE] ALIGNED_long;
+//    byte scratch[AES_BLOCK_SIZE] ALIGNED_long;
+    unsigned blocks, partial;
+    //was: byte* h = aes->H;
+
+    //XMEMSET(x, 0, AES_BLOCK_SIZE);
+
+    /* Hash in A, the Additional Authentication Data */
+//    if (aSz != 0 && a != NULL) {
+//        blocks = aSz / AES_BLOCK_SIZE;
+//        partial = aSz % AES_BLOCK_SIZE;
+//        while (blocks--) {
+            //xorbuf(x, a, AES_BLOCK_SIZE);
+            XMEMCPY(x, a, AES_BLOCK_SIZE);// memcpy(x,a) = memset(x,0)+xorbuf(x,a)
+            GMULT(x, h);
+//            a += AES_BLOCK_SIZE;
+//        }
+//        if (partial != 0) {
+//            XMEMSET(scratch, 0, AES_BLOCK_SIZE);
+//            XMEMCPY(scratch, a, partial);
+//            xorbuf(x, scratch, AES_BLOCK_SIZE);
+//            GMULT(x, h);
+//        }
+//    }
+
+    /* Hash in C, the Ciphertext */
+    if (cSz != 0 /*&& c != NULL*/) {
+        blocks = cSz / AES_BLOCK_SIZE;
+        partial = cSz % AES_BLOCK_SIZE;
+        while (blocks--) {
+            if (BB_UNALIGNED_MEMACCESS_OK) // c is not guaranteed to be aligned
+                xorbuf_aligned_AES_BLOCK_SIZE(x, c);
+            else
+                xorbuf(x, c, AES_BLOCK_SIZE);
+            GMULT(x, h);
+            c += AES_BLOCK_SIZE;
+        }
+        if (partial != 0) {
+            //XMEMSET(scratch, 0, AES_BLOCK_SIZE);
+            //XMEMCPY(scratch, c, partial);
+            //xorbuf(x, scratch, AES_BLOCK_SIZE);
+            xorbuf(x, c, partial);//same result as above
+            GMULT(x, h);
+        }
+    }
+
+    /* Hash in the lengths of A and C in bits */
+    //FlattenSzInBits(&scratch[0], aSz);
+    //FlattenSzInBits(&scratch[8], cSz);
+    //xorbuf_aligned_AES_BLOCK_SIZE(x, scratch);
+    // simpler:
+#define P32(v) ((uint32_t*)v)
+  //P32(x)[0] ^= 0;
+    P32(x)[1] ^= SWAP_BE32(aSz * 8);
+  //P32(x)[2] ^= 0;
+    P32(x)[3] ^= SWAP_BE32(cSz * 8);
+#undef P32
+
+    GMULT(x, h);
+
+    /* Copy the result into s. */
+    XMEMCPY(s, x, sSz);
+}
diff -urpN busybox-1.29.3/networking/tls_aesgcm.h busybox-1.30.0/networking/tls_aesgcm.h
--- busybox-1.29.3/networking/tls_aesgcm.h	1970-01-01 01:00:00.000000000 +0100
+++ busybox-1.30.0/networking/tls_aesgcm.h	2018-12-05 15:44:34.000000000 +0100
@@ -0,0 +1,11 @@
+/*
+ * Copyright (C) 2018 Denys Vlasenko
+ *
+ * Licensed under GPLv2, see file LICENSE in this source tree.
+ */
+
+void aesgcm_GHASH(uint8_t* h,
+	const uint8_t* a, //unsigned aSz,
+	const uint8_t* c, unsigned cSz,
+	uint8_t* s //, unsigned sSz
+) FAST_FUNC;
diff -urpN busybox-1.29.3/networking/tls_fe.c busybox-1.30.0/networking/tls_fe.c
--- busybox-1.29.3/networking/tls_fe.c	1970-01-01 01:00:00.000000000 +0100
+++ busybox-1.30.0/networking/tls_fe.c	2018-12-05 15:44:34.000000000 +0100
@@ -0,0 +1,611 @@
+/*
+ * Copyright (C) 2018 Denys Vlasenko
+ *
+ * Licensed under GPLv2, see file LICENSE in this source tree.
+ */
+#include "tls.h"
+
+typedef uint8_t  byte;
+typedef uint16_t word16;
+typedef uint32_t word32;
+#define XMEMSET  memset
+
+#define F25519_SIZE CURVE25519_KEYSIZE
+
+/* The code below is taken from wolfssl-3.15.3/wolfcrypt/src/fe_low_mem.c
+ * Header comment is kept intact:
+ */
+
+/* fe_low_mem.c
+ *
+ * Copyright (C) 2006-2017 wolfSSL Inc.
+ *
+ * This file is part of wolfSSL.
+ *
+ * wolfSSL is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * wolfSSL is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1335, USA
+ */
+
+
+/* Based from Daniel Beer's public domain work. */
+
+#if 0 //UNUSED
+static void fprime_copy(byte *x, const byte *a)
+{
+    int i;
+    for (i = 0; i < F25519_SIZE; i++)
+        x[i] = a[i];
+}
+#endif
+
+static void lm_copy(byte* x, const byte* a)
+{
+    int i;
+    for (i = 0; i < F25519_SIZE; i++)
+        x[i] = a[i];
+}
+
+#if 0 //UNUSED
+static void fprime_select(byte *dst, const byte *zero, const byte *one, byte condition)
+{
+	const byte mask = -condition;
+	int i;
+
+	for (i = 0; i < F25519_SIZE; i++)
+		dst[i] = zero[i] ^ (mask & (one[i] ^ zero[i]));
+}
+#endif
+
+static void fe_select(byte *dst,
+		   const byte *zero, const byte *one,
+		   byte condition)
+{
+	const byte mask = -condition;
+	int i;
+
+	for (i = 0; i < F25519_SIZE; i++)
+		dst[i] = zero[i] ^ (mask & (one[i] ^ zero[i]));
+}
+
+#if 0 //UNUSED
+static void raw_add(byte *x, const byte *p)
+{
+	word16 c = 0;
+	int i;
+
+	for (i = 0; i < F25519_SIZE; i++) {
+		c += ((word16)x[i]) + ((word16)p[i]);
+		x[i] = (byte)c;
+		c >>= 8;
+	}
+}
+#endif
+
+#if 0 //UNUSED
+static void raw_try_sub(byte *x, const byte *p)
+{
+	byte minusp[F25519_SIZE];
+	word16 c = 0;
+	int i;
+
+	for (i = 0; i < F25519_SIZE; i++) {
+		c = ((word16)x[i]) - ((word16)p[i]) - c;
+		minusp[i] = (byte)c;
+		c = (c >> 8) & 1;
+	}
+
+	fprime_select(x, minusp, x, (byte)c);
+}
+#endif
+
+#if 0 //UNUSED
+static int prime_msb(const byte *p)
+{
+    int i;
+    byte x;
+    int shift = 1;
+    int z     = F25519_SIZE - 1;
+
+   /*
+       Test for any hot bits.
+       As soon as one instance is encountered set shift to 0.
+    */
+	for (i = F25519_SIZE - 1; i >= 0; i--) {
+        shift &= ((shift ^ ((-p[i] | p[i]) >> 7)) & 1);
+        z -= shift;
+    }
+	x = p[z];
+	z <<= 3;
+    shift = 1;
+    for (i = 0; i < 8; i++) {
+        shift &= ((-(x >> i) | (x >> i)) >> (7 - i) & 1);
+        z += shift;
+    }
+
+	return z - 1;
+}
+#endif
+
+#if 0 //UNUSED
+static void fprime_add(byte *r, const byte *a, const byte *modulus)
+{
+	raw_add(r, a);
+	raw_try_sub(r, modulus);
+}
+#endif
+
+#if 0 //UNUSED
+static void fprime_sub(byte *r, const byte *a, const byte *modulus)
+{
+	raw_add(r, modulus);
+	raw_try_sub(r, a);
+	raw_try_sub(r, modulus);
+}
+#endif
+
+#if 0 //UNUSED
+static void fprime_mul(byte *r, const byte *a, const byte *b,
+		const byte *modulus)
+{
+	word16 c = 0;
+	int i,j;
+
+	XMEMSET(r, 0, F25519_SIZE);
+
+	for (i = prime_msb(modulus); i >= 0; i--) {
+		const byte bit = (b[i >> 3] >> (i & 7)) & 1;
+		byte plusa[F25519_SIZE];
+
+	    for (j = 0; j < F25519_SIZE; j++) {
+		    c |= ((word16)r[j]) << 1;
+		    r[j] = (byte)c;
+		    c >>= 8;
+	    }
+		raw_try_sub(r, modulus);
+
+		fprime_copy(plusa, r);
+		fprime_add(plusa, a, modulus);
+
+		fprime_select(r, r, plusa, bit);
+	}
+}
+#endif
+
+#if 0 //UNUSED
+static void fe_load(byte *x, word32 c)
+{
+	word32 i;
+
+	for (i = 0; i < sizeof(c); i++) {
+		x[i] = c;
+		c >>= 8;
+	}
+
+	for (; i < F25519_SIZE; i++)
+		x[i] = 0;
+}
+#endif
+
+static void fe_normalize(byte *x)
+{
+	byte minusp[F25519_SIZE];
+	word16 c;
+	int i;
+
+	/* Reduce using 2^255 = 19 mod p */
+	c = (x[31] >> 7) * 19;
+	x[31] &= 127;
+
+	for (i = 0; i < F25519_SIZE; i++) {
+		c += x[i];
+		x[i] = (byte)c;
+		c >>= 8;
+	}
+
+	/* The number is now less than 2^255 + 18, and therefore less than
+	 * 2p. Try subtracting p, and conditionally load the subtracted
+	 * value if underflow did not occur.
+	 */
+	c = 19;
+
+	for (i = 0; i + 1 < F25519_SIZE; i++) {
+		c += x[i];
+		minusp[i] = (byte)c;
+		c >>= 8;
+	}
+
+	c += ((word16)x[i]) - 128;
+	minusp[31] = (byte)c;
+
+	/* Load x-p if no underflow */
+	fe_select(x, minusp, x, (c >> 15) & 1);
+}
+
+static void lm_add(byte* r, const byte* a, const byte* b)
+{
+	word16 c = 0;
+	int i;
+
+	/* Add */
+	for (i = 0; i < F25519_SIZE; i++) {
+		c >>= 8;
+		c += ((word16)a[i]) + ((word16)b[i]);
+		r[i] = (byte)c;
+	}
+
+	/* Reduce with 2^255 = 19 mod p */
+	r[31] &= 127;
+	c = (c >> 7) * 19;
+
+	for (i = 0; i < F25519_SIZE; i++) {
+		c += r[i];
+		r[i] = (byte)c;
+		c >>= 8;
+	}
+}
+
+static void lm_sub(byte* r, const byte* a, const byte* b)
+{
+	word32 c = 0;
+	int i;
+
+	/* Calculate a + 2p - b, to avoid underflow */
+	c = 218;
+	for (i = 0; i + 1 < F25519_SIZE; i++) {
+		c += 65280 + ((word32)a[i]) - ((word32)b[i]);
+		r[i] = c;
+		c >>= 8;
+	}
+
+	c += ((word32)a[31]) - ((word32)b[31]);
+	r[31] = c & 127;
+	c = (c >> 7) * 19;
+
+	for (i = 0; i < F25519_SIZE; i++) {
+		c += r[i];
+		r[i] = c;
+		c >>= 8;
+	}
+}
+
+#if 0 //UNUSED
+static void lm_neg(byte* r, const byte* a)
+{
+	word32 c = 0;
+	int i;
+
+	/* Calculate 2p - a, to avoid underflow */
+	c = 218;
+	for (i = 0; i + 1 < F25519_SIZE; i++) {
+		c += 65280 - ((word32)a[i]);
+		r[i] = c;
+		c >>= 8;
+	}
+
+	c -= ((word32)a[31]);
+	r[31] = c & 127;
+	c = (c >> 7) * 19;
+
+	for (i = 0; i < F25519_SIZE; i++) {
+		c += r[i];
+		r[i] = c;
+		c >>= 8;
+	}
+}
+#endif
+
+static void fe_mul__distinct(byte *r, const byte *a, const byte *b)
+{
+	word32 c = 0;
+	int i;
+
+	for (i = 0; i < F25519_SIZE; i++) {
+		int j;
+
+		c >>= 8;
+		for (j = 0; j <= i; j++)
+			c += ((word32)a[j]) * ((word32)b[i - j]);
+
+		for (; j < F25519_SIZE; j++)
+			c += ((word32)a[j]) *
+			     ((word32)b[i + F25519_SIZE - j]) * 38;
+
+		r[i] = c;
+	}
+
+	r[31] &= 127;
+	c = (c >> 7) * 19;
+
+	for (i = 0; i < F25519_SIZE; i++) {
+		c += r[i];
+		r[i] = c;
+		c >>= 8;
+	}
+}
+
+#if 0 //UNUSED
+static void lm_mul(byte *r, const byte* a, const byte *b)
+{
+	byte tmp[F25519_SIZE];
+
+	fe_mul__distinct(tmp, a, b);
+	lm_copy(r, tmp);
+}
+#endif
+
+static void fe_mul_c(byte *r, const byte *a, word32 b)
+{
+	word32 c = 0;
+	int i;
+
+	for (i = 0; i < F25519_SIZE; i++) {
+		c >>= 8;
+		c += b * ((word32)a[i]);
+		r[i] = c;
+	}
+
+	r[31] &= 127;
+	c >>= 7;
+	c *= 19;
+
+	for (i = 0; i < F25519_SIZE; i++) {
+		c += r[i];
+		r[i] = c;
+		c >>= 8;
+	}
+}
+
+static void fe_inv__distinct(byte *r, const byte *x)
+{
+	byte s[F25519_SIZE];
+	int i;
+
+	/* This is a prime field, so by Fermat's little theorem:
+	 *
+	 *     x^(p-1) = 1 mod p
+	 *
+	 * Therefore, raise to (p-2) = 2^255-21 to get a multiplicative
+	 * inverse.
+	 *
+	 * This is a 255-bit binary number with the digits:
+	 *
+	 *     11111111... 01011
+	 *
+	 * We compute the result by the usual binary chain, but
+	 * alternate between keeping the accumulator in r and s, so as
+	 * to avoid copying temporaries.
+	 */
+
+	/* 1 1 */
+	fe_mul__distinct(s, x, x);
+	fe_mul__distinct(r, s, x);
+
+	/* 1 x 248 */
+	for (i = 0; i < 248; i++) {
+		fe_mul__distinct(s, r, r);
+		fe_mul__distinct(r, s, x);
+	}
+
+	/* 0 */
+	fe_mul__distinct(s, r, r);
+
+	/* 1 */
+	fe_mul__distinct(r, s, s);
+	fe_mul__distinct(s, r, x);
+
+	/* 0 */
+	fe_mul__distinct(r, s, s);
+
+	/* 1 */
+	fe_mul__distinct(s, r, r);
+	fe_mul__distinct(r, s, x);
+
+	/* 1 */
+	fe_mul__distinct(s, r, r);
+	fe_mul__distinct(r, s, x);
+}
+
+#if 0 //UNUSED
+static void lm_invert(byte *r, const byte *x)
+{
+	byte tmp[F25519_SIZE];
+
+	fe_inv__distinct(tmp, x);
+	lm_copy(r, tmp);
+}
+#endif
+
+#if 0 //UNUSED
+/* Raise x to the power of (p-5)/8 = 2^252-3, using s for temporary
+ * storage.
+ */
+static void exp2523(byte *r, const byte *x, byte *s)
+{
+	int i;
+
+	/* This number is a 252-bit number with the binary expansion:
+	 *
+	 *     111111... 01
+	 */
+
+	/* 1 1 */
+	fe_mul__distinct(r, x, x);
+	fe_mul__distinct(s, r, x);
+
+	/* 1 x 248 */
+	for (i = 0; i < 248; i++) {
+		fe_mul__distinct(r, s, s);
+		fe_mul__distinct(s, r, x);
+	}
+
+	/* 0 */
+	fe_mul__distinct(r, s, s);
+
+	/* 1 */
+	fe_mul__distinct(s, r, r);
+	fe_mul__distinct(r, s, x);
+}
+#endif
+
+#if 0 //UNUSED
+static void fe_sqrt(byte *r, const byte *a)
+{
+	byte v[F25519_SIZE];
+	byte i[F25519_SIZE];
+	byte x[F25519_SIZE];
+	byte y[F25519_SIZE];
+
+	/* v = (2a)^((p-5)/8) [x = 2a] */
+	fe_mul_c(x, a, 2);
+	exp2523(v, x, y);
+
+	/* i = 2av^2 - 1 */
+	fe_mul__distinct(y, v, v);
+	fe_mul__distinct(i, x, y);
+	fe_load(y, 1);
+	lm_sub(i, i, y);
+
+	/* r = avi */
+	fe_mul__distinct(x, v, a);
+	fe_mul__distinct(r, x, i);
+}
+#endif
+
+/* Differential addition */
+static void xc_diffadd(byte *x5, byte *z5,
+		       const byte *x1, const byte *z1,
+		       const byte *x2, const byte *z2,
+		       const byte *x3, const byte *z3)
+{
+	/* Explicit formulas database: dbl-1987-m3
+	 *
+	 * source 1987 Montgomery "Speeding the Pollard and elliptic curve
+	 *   methods of factorization", page 261, fifth display, plus
+	 *   common-subexpression elimination
+	 * compute A = X2+Z2
+	 * compute B = X2-Z2
+	 * compute C = X3+Z3
+	 * compute D = X3-Z3
+	 * compute DA = D A
+	 * compute CB = C B
+	 * compute X5 = Z1(DA+CB)^2
+	 * compute Z5 = X1(DA-CB)^2
+	 */
+	byte da[F25519_SIZE];
+	byte cb[F25519_SIZE];
+	byte a[F25519_SIZE];
+	byte b[F25519_SIZE];
+
+	lm_add(a, x2, z2);
+	lm_sub(b, x3, z3); /* D */
+	fe_mul__distinct(da, a, b);
+
+	lm_sub(b, x2, z2);
+	lm_add(a, x3, z3); /* C */
+	fe_mul__distinct(cb, a, b);
+
+	lm_add(a, da, cb);
+	fe_mul__distinct(b, a, a);
+	fe_mul__distinct(x5, z1, b);
+
+	lm_sub(a, da, cb);
+	fe_mul__distinct(b, a, a);
+	fe_mul__distinct(z5, x1, b);
+}
+
+/* Double an X-coordinate */
+static void xc_double(byte *x3, byte *z3,
+		      const byte *x1, const byte *z1)
+{
+	/* Explicit formulas database: dbl-1987-m
+	 *
+	 * source 1987 Montgomery "Speeding the Pollard and elliptic
+	 *   curve methods of factorization", page 261, fourth display
+	 * compute X3 = (X1^2-Z1^2)^2
+	 * compute Z3 = 4 X1 Z1 (X1^2 + a X1 Z1 + Z1^2)
+	 */
+	byte x1sq[F25519_SIZE];
+	byte z1sq[F25519_SIZE];
+	byte x1z1[F25519_SIZE];
+	byte a[F25519_SIZE];
+
+	fe_mul__distinct(x1sq, x1, x1);
+	fe_mul__distinct(z1sq, z1, z1);
+	fe_mul__distinct(x1z1, x1, z1);
+
+	lm_sub(a, x1sq, z1sq);
+	fe_mul__distinct(x3, a, a);
+
+	fe_mul_c(a, x1z1, 486662);
+	lm_add(a, x1sq, a);
+	lm_add(a, z1sq, a);
+	fe_mul__distinct(x1sq, x1z1, a);
+	fe_mul_c(z3, x1sq, 4);
+}
+
+void FAST_FUNC curve25519(byte *result, const byte *e, const byte *q)
+{
+	int i;
+
+	struct {
+		/* from wolfssl-3.15.3/wolfssl/wolfcrypt/fe_operations.h */
+		/*static const*/ byte f25519_one[F25519_SIZE]; // = {1};
+
+		/* Current point: P_m */
+		byte xm[F25519_SIZE];
+		byte zm[F25519_SIZE]; // = {1};
+		/* Predecessor: P_(m-1) */
+		byte xm1[F25519_SIZE]; // = {1};
+		byte zm1[F25519_SIZE]; // = {0};
+	} z;
+#define f25519_one z.f25519_one
+#define xm         z.xm
+#define zm         z.zm
+#define xm1        z.xm1
+#define zm1        z.zm1
+	memset(&z, 0, sizeof(z));
+	f25519_one[0] = 1;
+	zm[0] = 1;
+	xm1[0] = 1;
+
+	/* Note: bit 254 is assumed to be 1 */
+	lm_copy(xm, q);
+
+	for (i = 253; i >= 0; i--) {
+		const int bit = (e[i >> 3] >> (i & 7)) & 1;
+		byte xms[F25519_SIZE];
+		byte zms[F25519_SIZE];
+
+		/* From P_m and P_(m-1), compute P_(2m) and P_(2m-1) */
+		xc_diffadd(xm1, zm1, q, f25519_one, xm, zm, xm1, zm1);
+		xc_double(xm, zm, xm, zm);
+
+		/* Compute P_(2m+1) */
+		xc_diffadd(xms, zms, xm1, zm1, xm, zm, q, f25519_one);
+
+		/* Select:
+		 *   bit = 1 --> (P_(2m+1), P_(2m))
+		 *   bit = 0 --> (P_(2m), P_(2m-1))
+		 */
+		fe_select(xm1, xm1, xm, bit);
+		fe_select(zm1, zm1, zm, bit);
+		fe_select(xm, xm, xms, bit);
+		fe_select(zm, zm, zms, bit);
+	}
+
+	/* Freeze out of projective coordinates */
+	fe_inv__distinct(zm1, zm);
+	fe_mul__distinct(result, zm1, xm);
+	fe_normalize(result);
+}
diff -urpN busybox-1.29.3/networking/tls_fe.h busybox-1.30.0/networking/tls_fe.h
--- busybox-1.29.3/networking/tls_fe.h	1970-01-01 01:00:00.000000000 +0100
+++ busybox-1.30.0/networking/tls_fe.h	2018-12-05 15:44:34.000000000 +0100
@@ -0,0 +1,7 @@
+/*
+ * Copyright (C) 2018 Denys Vlasenko
+ *
+ * Licensed under GPLv2, see file LICENSE in this source tree.
+ */
+#define CURVE25519_KEYSIZE 32
+void curve25519(uint8_t *result, const uint8_t *e, const uint8_t *q) FAST_FUNC;
diff -urpN busybox-1.29.3/networking/tls_rsa.c busybox-1.30.0/networking/tls_rsa.c
--- busybox-1.29.3/networking/tls_rsa.c	2018-07-02 13:23:06.000000000 +0200
+++ busybox-1.30.0/networking/tls_rsa.c	2018-12-05 15:44:34.000000000 +0100
@@ -179,7 +179,7 @@ done:
 	return res;
 }
 
-int32 psRsaEncryptPub(psPool_t *pool, psRsaKey_t *key,
+int32 FAST_FUNC psRsaEncryptPub(psPool_t *pool, psRsaKey_t *key,
 						unsigned char *in, uint32 inlen,
 						unsigned char *out, uint32 outlen, void *data)
 {
diff -urpN busybox-1.29.3/networking/tls_rsa.h busybox-1.30.0/networking/tls_rsa.h
--- busybox-1.29.3/networking/tls_rsa.h	2018-07-02 13:23:06.000000000 +0200
+++ busybox-1.30.0/networking/tls_rsa.h	2018-12-05 15:44:34.000000000 +0100
@@ -13,8 +13,20 @@ typedef struct {
 //bbox	psPool_t *pool;
 } psRsaKey_t;
 
+static ALWAYS_INLINE void psRsaKey_clear(psRsaKey_t *key)
+{
+	pstm_clear(&key->N);
+	pstm_clear(&key->e);
+	pstm_clear(&key->d);
+	pstm_clear(&key->p);
+	pstm_clear(&key->q);
+	pstm_clear(&key->dP);
+	pstm_clear(&key->dQ);
+	pstm_clear(&key->qP);
+}
+
 #define psRsaEncryptPub(pool, key, in, inlen, out, outlen, data) \
         psRsaEncryptPub(      key, in, inlen, out, outlen)
 int32 psRsaEncryptPub(psPool_t *pool, psRsaKey_t *key,
                                                 unsigned char *in, uint32 inlen,
-                                                unsigned char *out, uint32 outlen, void *data);
+                                                unsigned char *out, uint32 outlen, void *data) FAST_FUNC;
diff -urpN busybox-1.29.3/networking/traceroute.c busybox-1.30.0/networking/traceroute.c
--- busybox-1.29.3/networking/traceroute.c	2018-07-02 13:23:06.000000000 +0200
+++ busybox-1.30.0/networking/traceroute.c	2018-12-30 16:14:20.000000000 +0100
@@ -217,7 +217,7 @@
 //config:	Utility to trace the route of IP packets.
 //config:
 //config:config TRACEROUTE6
-//config:	bool "traceroute6 (12 kb)"
+//config:	bool "traceroute6 (13 kb)"
 //config:	default y
 //config:	depends on FEATURE_IPV6
 //config:	help
diff -urpN busybox-1.29.3/networking/tunctl.c busybox-1.30.0/networking/tunctl.c
--- busybox-1.29.3/networking/tunctl.c	2018-07-02 13:23:06.000000000 +0200
+++ busybox-1.30.0/networking/tunctl.c	2018-12-30 16:14:20.000000000 +0100
@@ -10,7 +10,7 @@
  * Licensed under GPLv2, see file LICENSE in this source tree.
  */
 //config:config TUNCTL
-//config:	bool "tunctl (6.4 kb)"
+//config:	bool "tunctl (6.2 kb)"
 //config:	default y
 //config:	select PLATFORM_LINUX
 //config:	help
diff -urpN busybox-1.29.3/networking/udhcp/Config.src busybox-1.30.0/networking/udhcp/Config.src
--- busybox-1.29.3/networking/udhcp/Config.src	2018-07-02 13:23:06.000000000 +0200
+++ busybox-1.30.0/networking/udhcp/Config.src	2018-12-30 16:14:20.000000000 +0100
@@ -4,7 +4,7 @@
 #
 
 config UDHCPD
-	bool "udhcpd"
+	bool "udhcpd (21 kb)"
 	default y
 	select PLATFORM_LINUX
 	help
@@ -44,7 +44,7 @@ config DHCPD_LEASES_FILE
 	of the file. Normally it is safe to leave it untouched.
 
 config DUMPLEASES
-	bool "dumpleases (6.4 kb)"
+	bool "dumpleases (5.1 kb)"
 	default y
 	help
 	dumpleases displays the leases written out by the udhcpd.
@@ -52,7 +52,7 @@ config DUMPLEASES
 	by the absolute time that it expires in seconds from epoch.
 
 config DHCPRELAY
-	bool "dhcprelay (5.8 kb)"
+	bool "dhcprelay (5.2 kb)"
 	default y
 	help
 	dhcprelay listens for DHCP requests on one or more interfaces
@@ -60,7 +60,7 @@ config DHCPRELAY
 	server.
 
 config UDHCPC
-	bool "udhcpc"
+	bool "udhcpc (24 kb)"
 	default y
 	select PLATFORM_LINUX
 	help
diff -urpN busybox-1.29.3/networking/udhcp/common.c busybox-1.30.0/networking/udhcp/common.c
--- busybox-1.29.3/networking/udhcp/common.c	2018-07-02 13:23:06.000000000 +0200
+++ busybox-1.30.0/networking/udhcp/common.c	2018-12-30 16:14:20.000000000 +0100
@@ -65,6 +65,7 @@ const struct dhcp_optflag dhcp_optflags[
 #endif
 	{ OPTION_STRING                           , 0xd1 }, /* DHCP_PXE_CONF_FILE */
 	{ OPTION_STRING                           , 0xd2 }, /* DHCP_PXE_PATH_PREFIX */
+	{ OPTION_U32                              , 0xd3 }, /* DHCP_REBOOT_TIME   */
 	{ OPTION_6RD                              , 0xd4 }, /* DHCP_6RD           */
 	{ OPTION_STATIC_ROUTES | OPTION_LIST      , 0xf9 }, /* DHCP_MS_STATIC_ROUTES */
 	{ OPTION_STRING                           , 0xfc }, /* DHCP_WPAD          */
@@ -92,50 +93,51 @@ const struct dhcp_optflag dhcp_optflags[
  */
 /* Must match dhcp_optflags[] order */
 const char dhcp_option_strings[] ALIGN1 =
-	"subnet" "\0"      /* DHCP_SUBNET         */
-	"timezone" "\0"    /* DHCP_TIME_OFFSET    */
-	"router" "\0"      /* DHCP_ROUTER         */
-//	"timesrv" "\0"     /* DHCP_TIME_SERVER    */
-//	"namesrv" "\0"     /* DHCP_NAME_SERVER    */
-	"dns" "\0"         /* DHCP_DNS_SERVER     */
-//	"logsrv" "\0"      /* DHCP_LOG_SERVER     */
-//	"cookiesrv" "\0"   /* DHCP_COOKIE_SERVER  */
-	"lprsrv" "\0"      /* DHCP_LPR_SERVER     */
-	"hostname" "\0"    /* DHCP_HOST_NAME      */
-	"bootsize" "\0"    /* DHCP_BOOT_SIZE      */
-	"domain" "\0"      /* DHCP_DOMAIN_NAME    */
-	"swapsrv" "\0"     /* DHCP_SWAP_SERVER    */
-	"rootpath" "\0"    /* DHCP_ROOT_PATH      */
-	"ipttl" "\0"       /* DHCP_IP_TTL         */
-	"mtu" "\0"         /* DHCP_MTU            */
-	"broadcast" "\0"   /* DHCP_BROADCAST      */
-	"routes" "\0"      /* DHCP_ROUTES         */
-	"nisdomain" "\0"   /* DHCP_NIS_DOMAIN     */
-	"nissrv" "\0"      /* DHCP_NIS_SERVER     */
-	"ntpsrv" "\0"      /* DHCP_NTP_SERVER     */
-	"wins" "\0"        /* DHCP_WINS_SERVER    */
-	"lease" "\0"       /* DHCP_LEASE_TIME     */
-	"serverid" "\0"    /* DHCP_SERVER_ID      */
-	"message" "\0"     /* DHCP_ERR_MESSAGE    */
-	"tftp" "\0"        /* DHCP_TFTP_SERVER_NAME */
-	"bootfile" "\0"    /* DHCP_BOOT_FILE      */
-//	"userclass" "\0"   /* DHCP_USER_CLASS     */
+	"subnet" "\0"           /* DHCP_SUBNET          */
+	"timezone" "\0"         /* DHCP_TIME_OFFSET     */
+	"router" "\0"           /* DHCP_ROUTER          */
+//	"timesrv" "\0"          /* DHCP_TIME_SERVER     */
+//	"namesrv" "\0"          /* DHCP_NAME_SERVER     */
+	"dns" "\0"              /* DHCP_DNS_SERVER      */
+//	"logsrv" "\0"           /* DHCP_LOG_SERVER      */
+//	"cookiesrv" "\0"        /* DHCP_COOKIE_SERVER   */
+	"lprsrv" "\0"           /* DHCP_LPR_SERVER      */
+	"hostname" "\0"         /* DHCP_HOST_NAME       */
+	"bootsize" "\0"         /* DHCP_BOOT_SIZE       */
+	"domain" "\0"           /* DHCP_DOMAIN_NAME     */
+	"swapsrv" "\0"          /* DHCP_SWAP_SERVER     */
+	"rootpath" "\0"         /* DHCP_ROOT_PATH       */
+	"ipttl" "\0"            /* DHCP_IP_TTL          */
+	"mtu" "\0"              /* DHCP_MTU             */
+	"broadcast" "\0"        /* DHCP_BROADCAST       */
+	"routes" "\0"           /* DHCP_ROUTES          */
+	"nisdomain" "\0"        /* DHCP_NIS_DOMAIN      */
+	"nissrv" "\0"           /* DHCP_NIS_SERVER      */
+	"ntpsrv" "\0"           /* DHCP_NTP_SERVER      */
+	"wins" "\0"             /* DHCP_WINS_SERVER     */
+	"lease" "\0"            /* DHCP_LEASE_TIME      */
+	"serverid" "\0"         /* DHCP_SERVER_ID       */
+	"message" "\0"          /* DHCP_ERR_MESSAGE     */
+	"tftp" "\0"             /* DHCP_TFTP_SERVER_NAME*/
+	"bootfile" "\0"         /* DHCP_BOOT_FILE       */
+//	"userclass" "\0"        /* DHCP_USER_CLASS      */
 #if ENABLE_FEATURE_UDHCP_RFC3397
-	"search" "\0"      /* DHCP_DOMAIN_SEARCH  */
+	"search" "\0"           /* DHCP_DOMAIN_SEARCH   */
 // doesn't work in udhcpd.conf since OPTION_SIP_SERVERS
 // is not handled yet by "string->option" conversion code:
-	"sipsrv" "\0"      /* DHCP_SIP_SERVERS    */
+	"sipsrv" "\0"           /* DHCP_SIP_SERVERS     */
 #endif
-	"staticroutes" "\0"/* DHCP_STATIC_ROUTES  */
+	"staticroutes" "\0"     /* DHCP_STATIC_ROUTES   */
 #if ENABLE_FEATURE_UDHCP_8021Q
-	"vlanid" "\0"      /* DHCP_VLAN_ID        */
-	"vlanpriority" "\0"/* DHCP_VLAN_PRIORITY  */
+	"vlanid" "\0"           /* DHCP_VLAN_ID         */
+	"vlanpriority" "\0"     /* DHCP_VLAN_PRIORITY   */
 #endif
-	"pxeconffile" "\0" /* DHCP_PXE_CONF_FILE  */
-	"pxepathprefix" "\0" /* DHCP_PXE_PATH_PREFIX  */
-	"ip6rd" "\0"       /* DHCP_6RD            */
-	"msstaticroutes""\0"/* DHCP_MS_STATIC_ROUTES */
-	"wpad" "\0"        /* DHCP_WPAD           */
+	"pxeconffile" "\0"      /* DHCP_PXE_CONF_FILE   */
+	"pxepathprefix" "\0"    /* DHCP_PXE_PATH_PREFIX */
+	"reboottime" "\0"       /* DHCP_REBOOT_TIME     */
+	"ip6rd" "\0"            /* DHCP_6RD             */
+	"msstaticroutes" "\0"   /* DHCP_MS_STATIC_ROUTES*/
+	"wpad" "\0"             /* DHCP_WPAD            */
 	;
 #endif
 
@@ -270,6 +272,15 @@ uint8_t* FAST_FUNC udhcp_get_option(stru
 			goto complain; /* complain and return NULL */
 
 		if (optionptr[OPT_CODE] == code) {
+			if (optionptr[OPT_LEN] == 0) {
+				/* So far no valid option with length 0 known.
+				 * Having this check means that searching
+				 * for DHCP_MESSAGE_TYPE need not worry
+				 * that returned pointer might be unsafe
+				 * to dereference.
+				 */
+				goto complain; /* complain and return NULL */
+			}
 			log_option("option found", optionptr);
 			return optionptr + OPT_DATA;
 		}
@@ -287,6 +298,16 @@ uint8_t* FAST_FUNC udhcp_get_option(stru
 	return NULL;
 }
 
+uint8_t* FAST_FUNC udhcp_get_option32(struct dhcp_packet *packet, int code)
+{
+	uint8_t *r = udhcp_get_option(packet, code);
+	if (r) {
+		if (r[-1] != 4)
+			r = NULL;
+	}
+	return r;
+}
+
 /* Return the position of the 'end' option (no bounds checking) */
 int FAST_FUNC udhcp_end_option(uint8_t *optionptr)
 {
diff -urpN busybox-1.29.3/networking/udhcp/common.h busybox-1.30.0/networking/udhcp/common.h
--- busybox-1.29.3/networking/udhcp/common.h	2018-07-02 13:23:06.000000000 +0200
+++ busybox-1.30.0/networking/udhcp/common.h	2018-12-30 16:14:20.000000000 +0100
@@ -122,9 +122,9 @@ enum {
 //#define DHCP_LOG_SERVER       0x07 /* port 704 UDP log (not syslog)
 //#define DHCP_COOKIE_SERVER    0x08 /* "quote of the day" server */
 //#define DHCP_LPR_SERVER       0x09
-#define DHCP_HOST_NAME          0x0c /* either client informs server or server gives name to client */
+#define DHCP_HOST_NAME          0x0c /* 12: either client informs server or server gives name to client */
 //#define DHCP_BOOT_SIZE        0x0d
-//#define DHCP_DOMAIN_NAME      0x0f /* server gives domain suffix */
+//#define DHCP_DOMAIN_NAME      0x0f /* 15: server gives domain suffix */
 //#define DHCP_SWAP_SERVER      0x10
 //#define DHCP_ROOT_PATH        0x11
 //#define DHCP_IP_TTL           0x17
@@ -135,39 +135,40 @@ enum {
 //#define DHCP_NIS_SERVER       0x29
 //#define DHCP_NTP_SERVER       0x2a
 //#define DHCP_WINS_SERVER      0x2c
-#define DHCP_REQUESTED_IP       0x32 /* sent by client if specific IP is wanted */
-#define DHCP_LEASE_TIME         0x33
-#define DHCP_OPTION_OVERLOAD    0x34
-#define DHCP_MESSAGE_TYPE       0x35
-#define DHCP_SERVER_ID          0x36 /* by default server's IP */
-#define DHCP_PARAM_REQ          0x37 /* list of options client wants */
-//#define DHCP_ERR_MESSAGE      0x38 /* error message when sending NAK etc */
-#define DHCP_MAX_SIZE           0x39
-#define DHCP_VENDOR             0x3c /* client's vendor (a string) */
-#define DHCP_CLIENT_ID          0x3d /* by default client's MAC addr, but may be arbitrarily long */
-//#define DHCP_TFTP_SERVER_NAME 0x42 /* same as 'sname' field */
-//#define DHCP_BOOT_FILE        0x43 /* same as 'file' field */
-//#define DHCP_USER_CLASS       0x4d /* RFC 3004. set of LASCII strings. "I am a printer" etc */
-#define DHCP_FQDN               0x51 /* client asks to update DNS to map its FQDN to its new IP */
-//#define DHCP_DOMAIN_SEARCH    0x77 /* RFC 3397. set of ASCIZ string, DNS-style compressed */
-//#define DHCP_SIP_SERVERS      0x78 /* RFC 3361. flag byte, then: 0: domain names, 1: IP addrs */
-//#define DHCP_STATIC_ROUTES    0x79 /* RFC 3442. (mask,ip,router) tuples */
-//#define DHCP_VLAN_ID          0x84 /* 802.1P VLAN ID */
-//#define DHCP_VLAN_PRIORITY    0x85 /* 802.1Q VLAN priority */
-//#define DHCP_PXE_CONF_FILE    0xd1 /* RFC 5071 Configuration File */
-//#define DHCP_PXE_PATH_PREFIX  0xd2 /* RFC 5071 Configuration File */
-//#define DHCP_MS_STATIC_ROUTES 0xf9 /* Microsoft's pre-RFC 3442 code for 0x79? */
-//#define DHCP_WPAD             0xfc /* MSIE's Web Proxy Autodiscovery Protocol */
-#define DHCP_END                0xff
+#define DHCP_REQUESTED_IP       0x32 /* 50: sent by client if specific IP is wanted */
+#define DHCP_LEASE_TIME         0x33 /* 51: */
+#define DHCP_OPTION_OVERLOAD    0x34 /* 52: */
+#define DHCP_MESSAGE_TYPE       0x35 /* 53: */
+#define DHCP_SERVER_ID          0x36 /* 54: server's IP */
+#define DHCP_PARAM_REQ          0x37 /* 55: list of options client wants */
+//#define DHCP_ERR_MESSAGE      0x38 /* 56: error message when sending NAK etc */
+#define DHCP_MAX_SIZE           0x39 /* 57: */
+#define DHCP_VENDOR             0x3c /* 60: client's vendor (a string) */
+#define DHCP_CLIENT_ID          0x3d /* 61: by default client's MAC addr, but may be arbitrarily long */
+//#define DHCP_TFTP_SERVER_NAME 0x42 /* 66: same as 'sname' field */
+//#define DHCP_BOOT_FILE        0x43 /* 67: same as 'file' field */
+//#define DHCP_USER_CLASS       0x4d /* 77: RFC 3004. set of LASCII strings. "I am a printer" etc */
+#define DHCP_FQDN               0x51 /* 81: client asks to update DNS to map its FQDN to its new IP */
+//#define DHCP_DOMAIN_SEARCH    0x77 /* 119: RFC 3397. set of ASCIZ string, DNS-style compressed */
+//#define DHCP_SIP_SERVERS      0x78 /* 120: RFC 3361. flag byte, then: 0: domain names, 1: IP addrs */
+//#define DHCP_STATIC_ROUTES    0x79 /* 121: RFC 3442. (mask,ip,router) tuples */
+//#define DHCP_VLAN_ID          0x84 /* 132: 802.1P VLAN ID */
+//#define DHCP_VLAN_PRIORITY    0x85 /* 133: 802.1Q VLAN priority */
+//#define DHCP_PXE_CONF_FILE    0xd1 /* 209: RFC 5071 Configuration File */
+//#define DHCP_PXE_PATH_PREFIX  0xd2 /* 210: RFC 5071 Configuration File */
+//#define DHCP_REBOOT_TIME      0xd3 /* 211: RFC 5071 Reboot time */
+//#define DHCP_MS_STATIC_ROUTES 0xf9 /* 249: Microsoft's pre-RFC 3442 code for 0x79? */
+//#define DHCP_WPAD             0xfc /* 252: MSIE's Web Proxy Autodiscovery Protocol */
+#define DHCP_END                0xff /* 255: */
 
 /* Offsets in option byte sequence */
 #define OPT_CODE                0
 #define OPT_LEN                 1
 #define OPT_DATA                2
 /* Offsets in option byte sequence for DHCPv6 */
-#define D6_OPT_CODE				0
-#define D6_OPT_LEN				2
-#define D6_OPT_DATA				4
+#define D6_OPT_CODE             0
+#define D6_OPT_LEN              2
+#define D6_OPT_DATA             4
 /* Bits in "overload" option */
 #define OPTION_FIELD            0
 #define FILE_FIELD              1
@@ -204,6 +205,10 @@ extern const uint8_t dhcp_option_lengths
 unsigned FAST_FUNC udhcp_option_idx(const char *name, const char *option_strings);
 
 uint8_t *udhcp_get_option(struct dhcp_packet *packet, int code) FAST_FUNC;
+/* Same as above + ensures that option length is 4 bytes
+ * (returns NULL if size is different)
+ */
+uint8_t *udhcp_get_option32(struct dhcp_packet *packet, int code) FAST_FUNC;
 int udhcp_end_option(uint8_t *optionptr) FAST_FUNC;
 void udhcp_add_binary_option(struct dhcp_packet *packet, uint8_t *addopt) FAST_FUNC;
 #if ENABLE_UDHCPC || ENABLE_UDHCPD
diff -urpN busybox-1.29.3/networking/udhcp/d6_dhcpc.c busybox-1.30.0/networking/udhcp/d6_dhcpc.c
--- busybox-1.29.3/networking/udhcp/d6_dhcpc.c	2018-07-02 13:23:06.000000000 +0200
+++ busybox-1.30.0/networking/udhcp/d6_dhcpc.c	2018-12-30 16:14:20.000000000 +0100
@@ -9,7 +9,7 @@
  * Licensed under GPLv2, see file LICENSE in this source tree.
  */
 //config:config UDHCPC6
-//config:	bool "udhcpc6"
+//config:	bool "udhcpc6 (21 kb)"
 //config:	default n  # not yet ready
 //config:	depends on FEATURE_IPV6
 //config:	help
@@ -814,7 +814,9 @@ static NOINLINE int send_d6_renew(uint32
 }
 
 /* Unicast a DHCP release message */
-static int send_d6_release(struct in6_addr *server_ipv6, struct in6_addr *our_cur_ipv6)
+static
+ALWAYS_INLINE /* one caller, help compiler to use this fact */
+int send_d6_release(struct in6_addr *server_ipv6, struct in6_addr *our_cur_ipv6)
 {
 	struct d6_packet packet;
 	uint8_t *opt_ptr;
@@ -1405,7 +1407,7 @@ int udhcpc6_main(int argc UNUSED_PARAM,
 			case RENEW_REQUESTED: /* manual (SIGUSR1) renew */
 			case_RENEW_REQUESTED:
 			case RENEWING:
-				if (timeout > 60) {
+				if (timeout >= 60) {
 					/* send an unicast renew request */
 			/* Sometimes observed to fail (EADDRNOTAVAIL) to bind
 			 * a new UDP socket for sending inside send_renew.
@@ -1465,11 +1467,9 @@ int udhcpc6_main(int argc UNUSED_PARAM,
 				 * For the second case, must make sure timeout
 				 * is not too big, or else we can send
 				 * futile renew requests for hours.
-				 * (Ab)use -A TIMEOUT value (usually 20 sec)
-				 * as a cap on the timeout.
 				 */
-				if (timeout > tryagain_timeout)
-					timeout = tryagain_timeout;
+				if (timeout > 60)
+					timeout = 60;
 				goto case_RENEW_REQUESTED;
 			}
 			/* Start things over */
@@ -1740,8 +1740,9 @@ int udhcpc6_main(int argc UNUSED_PARAM,
 				/* note: "int timeout" will not overflow even with 0xffffffff inputs here: */
 				timeout = (prefix_timeout < address_timeout ? prefix_timeout : address_timeout) / 2;
 				/* paranoia: must not be too small */
-				if (timeout < 0x10)
-					timeout = 0x10;
+				/* timeout > 60 - ensures at least one unicast renew attempt */
+				if (timeout < 61)
+					timeout = 61;
 				/* enter bound state */
 				d6_run_script(packet.d6_options, packet_end,
 					(state == REQUESTING ? "bound" : "renew"));
diff -urpN busybox-1.29.3/networking/udhcp/dhcpc.c busybox-1.30.0/networking/udhcp/dhcpc.c
--- busybox-1.29.3/networking/udhcp/dhcpc.c	2018-07-02 13:23:06.000000000 +0200
+++ busybox-1.30.0/networking/udhcp/dhcpc.c	2018-12-30 16:14:20.000000000 +0100
@@ -160,8 +160,8 @@ static int mton(uint32_t mask)
 
 #if ENABLE_FEATURE_UDHCPC_SANITIZEOPT
 /* Check if a given label represents a valid DNS label
- * Return pointer to the first character after the label upon success,
- * NULL otherwise.
+ * Return pointer to the first character after the label
+ * (NUL or dot) upon success, NULL otherwise.
  * See RFC1035, 2.3.1
  */
 /* We don't need to be particularly anal. For example, allowing _, hyphen
@@ -173,8 +173,10 @@ static int mton(uint32_t mask)
 static const char *valid_domain_label(const char *label)
 {
 	unsigned char ch;
-	unsigned pos = 0;
+	//unsigned pos = 0;
 
+	if (label[0] == '-')
+		return NULL;
 	for (;;) {
 		ch = *label;
 		if ((ch|0x20) < 'a' || (ch|0x20) > 'z') {
@@ -187,7 +189,7 @@ static const char *valid_domain_label(co
 			}
 		}
 		label++;
-		pos++;
+		//pos++;
 		//Do we want this?
 		//if (pos > 63) /* NS_MAXLABEL; labels must be 63 chars or less */
 		//	return NULL;
@@ -272,6 +274,12 @@ static NOINLINE char *xmalloc_optname_op
 		case OPTION_STRING_HOST:
 			memcpy(dest, option, len);
 			dest[len] = '\0';
+//TODO: it appears option 15 DHCP_DOMAIN_NAME is often abused
+//by DHCP admins to contain a space-separated list of domains,
+//not one domain name (presumably, to work as list of search domains,
+//instead of using proper option 119 DHCP_DOMAIN_SEARCH).
+//Currently, good_hostname() balks on strings containing spaces.
+//Do we need to allow it? Only for DHCP_DOMAIN_NAME option?
 			if (type == OPTION_STRING_HOST && !good_hostname(dest))
 				safe_strncpy(dest, "bad", len);
 			return ret;
@@ -842,7 +850,9 @@ static NOINLINE int send_decline(/*uint3
 #endif
 
 /* Unicast a DHCP release message */
-static int send_release(uint32_t server, uint32_t ciaddr)
+static
+ALWAYS_INLINE /* one caller, help compiler to use this fact */
+int send_release(uint32_t server, uint32_t ciaddr)
 {
 	struct dhcp_packet packet;
 
@@ -1511,7 +1521,7 @@ int udhcpc_main(int argc UNUSED_PARAM, c
 			case RENEW_REQUESTED: /* manual (SIGUSR1) renew */
 			case_RENEW_REQUESTED:
 			case RENEWING:
-				if (timeout > 60) {
+				if (timeout >= 60) {
 					/* send an unicast renew request */
 			/* Sometimes observed to fail (EADDRNOTAVAIL) to bind
 			 * a new UDP socket for sending inside send_renew.
@@ -1584,11 +1594,9 @@ int udhcpc_main(int argc UNUSED_PARAM, c
 				 * For the second case, must make sure timeout
 				 * is not too big, or else we can send
 				 * futile renew requests for hours.
-				 * (Ab)use -A TIMEOUT value (usually 20 sec)
-				 * as a cap on the timeout.
 				 */
-				if (timeout > tryagain_timeout)
-					timeout = tryagain_timeout;
+				if (timeout > 60)
+					timeout = 60;
 				goto case_RENEW_REQUESTED;
 			}
 			/* Start things over */
@@ -1683,7 +1691,7 @@ int udhcpc_main(int argc UNUSED_PARAM, c
  * They say ISC DHCP client supports this case.
  */
 				server_addr = 0;
-				temp = udhcp_get_option(&packet, DHCP_SERVER_ID);
+				temp = udhcp_get_option32(&packet, DHCP_SERVER_ID);
 				if (!temp) {
 					bb_error_msg("no server ID, using 0.0.0.0");
 				} else {
@@ -1710,7 +1718,7 @@ int udhcpc_main(int argc UNUSED_PARAM, c
 				struct in_addr temp_addr;
 				uint8_t *temp;
 
-				temp = udhcp_get_option(&packet, DHCP_LEASE_TIME);
+				temp = udhcp_get_option32(&packet, DHCP_LEASE_TIME);
 				if (!temp) {
 					bb_error_msg("no lease time with ACK, using 1 hour lease");
 					lease_seconds = 60 * 60;
@@ -1719,8 +1727,9 @@ int udhcpc_main(int argc UNUSED_PARAM, c
 					move_from_unaligned32(lease_seconds, temp);
 					lease_seconds = ntohl(lease_seconds);
 					/* paranoia: must not be too small and not prone to overflows */
-					if (lease_seconds < 0x10)
-						lease_seconds = 0x10;
+					/* timeout > 60 - ensures at least one unicast renew attempt */
+					if (lease_seconds < 2 * 61)
+						lease_seconds = 2 * 61;
 					//if (lease_seconds > 0x7fffffff)
 					//	lease_seconds = 0x7fffffff;
 					//^^^not necessary since "timeout = lease_seconds / 2"
@@ -1804,7 +1813,7 @@ int udhcpc_main(int argc UNUSED_PARAM, c
 					uint32_t svid;
 					uint8_t *temp;
 
-					temp = udhcp_get_option(&packet, DHCP_SERVER_ID);
+					temp = udhcp_get_option32(&packet, DHCP_SERVER_ID);
 					if (!temp) {
  non_matching_svid:
 						log1("received DHCP NAK with wrong"
diff -urpN busybox-1.29.3/networking/udhcp/dhcpd.c busybox-1.30.0/networking/udhcp/dhcpd.c
--- busybox-1.29.3/networking/udhcp/dhcpd.c	2018-07-02 13:23:06.000000000 +0200
+++ busybox-1.30.0/networking/udhcp/dhcpd.c	2018-12-30 16:14:20.000000000 +0100
@@ -378,7 +378,7 @@ struct config_keyword {
 #define OFS(field) offsetof(struct server_config_t, field)
 
 static const struct config_keyword keywords[] = {
-	/* keyword        handler           variable address               default */
+	/* keyword        handler           variable address    default */
 	{"start"        , udhcp_str2nip   , OFS(start_ip     ), "192.168.0.20"},
 	{"end"          , udhcp_str2nip   , OFS(end_ip       ), "192.168.0.254"},
 	{"interface"    , read_str        , OFS(interface    ), "eth0"},
@@ -640,7 +640,7 @@ static void add_server_options(struct dh
 static uint32_t select_lease_time(struct dhcp_packet *packet)
 {
 	uint32_t lease_time_sec = server_config.max_lease_sec;
-	uint8_t *lease_time_opt = udhcp_get_option(packet, DHCP_LEASE_TIME);
+	uint8_t *lease_time_opt = udhcp_get_option32(packet, DHCP_LEASE_TIME);
 	if (lease_time_opt) {
 		move_from_unaligned32(lease_time_sec, lease_time_opt);
 		lease_time_sec = ntohl(lease_time_sec);
@@ -987,7 +987,7 @@ int udhcpd_main(int argc UNUSED_PARAM, c
 		}
 
 		/* Get SERVER_ID if present */
-		server_id_opt = udhcp_get_option(&packet, DHCP_SERVER_ID);
+		server_id_opt = udhcp_get_option32(&packet, DHCP_SERVER_ID);
 		if (server_id_opt) {
 			uint32_t server_id_network_order;
 			move_from_unaligned32(server_id_network_order, server_id_opt);
@@ -1011,7 +1011,7 @@ int udhcpd_main(int argc UNUSED_PARAM, c
 		}
 
 		/* Get REQUESTED_IP if present */
-		requested_ip_opt = udhcp_get_option(&packet, DHCP_REQUESTED_IP);
+		requested_ip_opt = udhcp_get_option32(&packet, DHCP_REQUESTED_IP);
 		if (requested_ip_opt) {
 			move_from_unaligned32(requested_nip, requested_ip_opt);
 		}
diff -urpN busybox-1.29.3/networking/vconfig.c busybox-1.30.0/networking/vconfig.c
--- busybox-1.29.3/networking/vconfig.c	2018-07-02 13:23:06.000000000 +0200
+++ busybox-1.30.0/networking/vconfig.c	2018-12-30 16:14:20.000000000 +0100
@@ -7,7 +7,7 @@
  * Licensed under GPLv2 or later, see file LICENSE in this source tree.
  */
 //config:config VCONFIG
-//config:	bool "vconfig (2.5 kb)"
+//config:	bool "vconfig (2.3 kb)"
 //config:	default y
 //config:	select PLATFORM_LINUX
 //config:	help
diff -urpN busybox-1.29.3/networking/wget.c busybox-1.30.0/networking/wget.c
--- busybox-1.29.3/networking/wget.c	2018-07-15 14:52:21.000000000 +0200
+++ busybox-1.30.0/networking/wget.c	2018-12-30 16:14:20.000000000 +0100
@@ -9,7 +9,7 @@
  * Kuhn's copyrights are licensed GPLv2-or-later.  File as a whole remains GPLv2.
  */
 //config:config WGET
-//config:	bool "wget (35 kb)"
+//config:	bool "wget (38 kb)"
 //config:	default y
 //config:	help
 //config:	wget is a utility for non-interactive download of files from HTTP
@@ -233,20 +233,19 @@ struct globals {
 	char *fname_out;        /* where to direct output (-O) */
 	const char *proxy_flag; /* Use proxies if env vars are set */
 	const char *user_agent; /* "User-Agent" header field */
+	int output_fd;
+	int o_flags;
 #if ENABLE_FEATURE_WGET_TIMEOUT
 	unsigned timeout_seconds;
-	bool die_if_timed_out;
+	smallint die_if_timed_out;
 #endif
-	int output_fd;
-	int o_flags;
 	smallint chunked;         /* chunked transfer encoding */
 	smallint got_clen;        /* got content-length: from server  */
 	/* Local downloads do benefit from big buffer.
 	 * With 512 byte buffer, it was measured to be
 	 * an order of magnitude slower than with big one.
 	 */
-	uint64_t just_to_align_next_member;
-	char wget_buf[CONFIG_FEATURE_COPYBUF_KB*1024];
+	char wget_buf[CONFIG_FEATURE_COPYBUF_KB*1024] ALIGNED(sizeof(long));
 } FIX_ALIASING;
 #define G (*ptr_to_globals)
 #define INIT_G() do { \
@@ -283,13 +282,15 @@ enum {
 #if ENABLE_FEATURE_WGET_STATUSBAR
 static void progress_meter(int flag)
 {
+	int notty;
+
 	if (option_mask32 & WGET_OPT_QUIET)
 		return;
 
 	if (flag == PROGRESS_START)
 		bb_progress_init(&G.pmt, G.curfile);
 
-	bb_progress_update(&G.pmt,
+	notty = bb_progress_update(&G.pmt,
 			G.beg_range,
 			G.transferred,
 			(G.chunked || !G.got_clen) ? 0 : G.beg_range + G.transferred + G.content_len
@@ -297,7 +298,8 @@ static void progress_meter(int flag)
 
 	if (flag == PROGRESS_END) {
 		bb_progress_free(&G.pmt);
-		bb_putchar_stderr('\n');
+		if (notty == 0)
+			bb_putchar_stderr('\n'); /* it's tty */
 		G.transferred = 0;
 	}
 }
@@ -346,9 +348,8 @@ static void strip_ipv6_scope_id(char *ho
 /* Base64-encode character string. */
 static char *base64enc(const char *str)
 {
-	unsigned len = strlen(str);
-	if (len > sizeof(G.wget_buf)/4*3 - 10) /* paranoia */
-		len = sizeof(G.wget_buf)/4*3 - 10;
+	/* paranoia */
+	unsigned len = strnlen(str, sizeof(G.wget_buf)/4*3 - 10);
 	bb_uuencode(G.wget_buf, str, len, bb_uuenc_tbl_base64);
 	return G.wget_buf;
 }
@@ -716,8 +717,10 @@ static void spawn_ssl_client(const char
 	int pid;
 	char *servername, *p;
 
-	if (!(option_mask32 & WGET_OPT_NO_CHECK_CERT))
+	if (!(option_mask32 & WGET_OPT_NO_CHECK_CERT)) {
+		option_mask32 |= WGET_OPT_NO_CHECK_CERT;
 		bb_error_msg("note: TLS certificate validation not implemented");
+	}
 
 	servername = xstrdup(host);
 	p = strrchr(servername, ':');
diff -urpN busybox-1.29.3/networking/whois.c busybox-1.30.0/networking/whois.c
--- busybox-1.29.3/networking/whois.c	2018-07-02 13:23:06.000000000 +0200
+++ busybox-1.30.0/networking/whois.c	2018-12-30 16:14:20.000000000 +0100
@@ -10,7 +10,7 @@
  * Add proxy support
  */
 //config:config WHOIS
-//config:	bool "whois (6.6 kb)"
+//config:	bool "whois (6.3 kb)"
 //config:	default y
 //config:	help
 //config:	whois is a client for the whois directory service
@@ -39,20 +39,26 @@ static char *query(const char *host, int
 	bool success;
 	char *redir = NULL;
 	const char *pfx = "";
-	char linebuf[1024];
+	/* some .io domains reported to have very long strings in whois
+	 * responses, 1k was not enough:
+	 */
+	char linebuf[2 * 1024];
 	char *buf = NULL;
 	unsigned bufpos = 0;
 
  again:
 	printf("[Querying %s:%d '%s%s']\n", host, port, pfx, domain);
 	fd = create_and_connect_stream_or_die(host, port);
-	success = 0;
 	fdprintf(fd, "%s%s\r\n", pfx, domain);
 	fp = xfdopen_for_read(fd);
 
-	while (fgets(linebuf, sizeof(linebuf), fp)) {
-		unsigned len = strcspn(linebuf, "\r\n");
+	success = 0;
+	while (fgets(linebuf, sizeof(linebuf)-1, fp)) {
+		unsigned len;
+
+		len = strcspn(linebuf, "\r\n");
 		linebuf[len++] = '\n';
+		linebuf[len] = '\0';
 
 		buf = xrealloc(buf, bufpos + len + 1);
 		memcpy(buf + bufpos, linebuf, len);
diff -urpN busybox-1.29.3/networking/zcip.c busybox-1.30.0/networking/zcip.c
--- busybox-1.29.3/networking/zcip.c	2018-07-02 13:23:06.000000000 +0200
+++ busybox-1.30.0/networking/zcip.c	2018-12-30 16:14:20.000000000 +0100
@@ -14,7 +14,7 @@
  * certainly be used.  Its naming is built over multicast DNS.
  */
 //config:config ZCIP
-//config:	bool "zcip (7.8 kb)"
+//config:	bool "zcip (8.4 kb)"
 //config:	default y
 //config:	select PLATFORM_LINUX
 //config:	select FEATURE_SYSLOG
diff -urpN busybox-1.29.3/printutils/lpd.c busybox-1.30.0/printutils/lpd.c
--- busybox-1.29.3/printutils/lpd.c	2018-07-02 13:23:06.000000000 +0200
+++ busybox-1.30.0/printutils/lpd.c	2018-12-30 16:14:20.000000000 +0100
@@ -70,7 +70,7 @@
  * mv -f ./"$DATAFILE" save/
  */
 //config:config LPD
-//config:	bool "lpd (5.3 kb)"
+//config:	bool "lpd (5.5 kb)"
 //config:	default y
 //config:	help
 //config:	lpd is a print spooling daemon.
diff -urpN busybox-1.29.3/printutils/lpr.c busybox-1.30.0/printutils/lpr.c
--- busybox-1.29.3/printutils/lpr.c	2018-07-02 13:23:06.000000000 +0200
+++ busybox-1.30.0/printutils/lpr.c	2018-12-30 16:14:20.000000000 +0100
@@ -12,13 +12,13 @@
  * See RFC 1179 for protocol description.
  */
 //config:config LPR
-//config:	bool "lpr (10 kb)"
+//config:	bool "lpr (9.9 kb)"
 //config:	default y
 //config:	help
 //config:	lpr sends files (or standard input) to a print spooling daemon.
 //config:
 //config:config LPQ
-//config:	bool "lpq (10 kb)"
+//config:	bool "lpq (9.9 kb)"
 //config:	default y
 //config:	help
 //config:	lpq is a print spool queue examination and manipulation program.
diff -urpN busybox-1.29.3/procps/free.c busybox-1.30.0/procps/free.c
--- busybox-1.29.3/procps/free.c	2018-07-02 13:23:06.000000000 +0200
+++ busybox-1.30.0/procps/free.c	2018-12-30 16:14:20.000000000 +0100
@@ -7,7 +7,7 @@
  * Licensed under GPLv2, see file LICENSE in this source tree.
  */
 //config:config FREE
-//config:	bool "free (2.4 kb)"
+//config:	bool "free (3.1 kb)"
 //config:	default y
 //config:	select PLATFORM_LINUX #sysinfo()
 //config:	help
@@ -53,21 +53,27 @@ static unsigned long long scale(struct g
 }
 
 /* NOINLINE reduces main() stack usage, which makes code smaller (on x86 at least) */
-static NOINLINE unsigned long parse_cached_kb(void)
+static NOINLINE unsigned int parse_meminfo(unsigned long *cached_kb, unsigned long *available_kb)
 {
 	char buf[60]; /* actual lines we expect are ~30 chars or less */
 	FILE *fp;
-	unsigned long cached = 0;
+	int seen_cached_and_available;
 
 	fp = xfopen_for_read("/proc/meminfo");
-	while (fgets(buf, sizeof(buf), fp) != NULL) {
-		if (sscanf(buf, "Cached: %lu %*s\n", &cached) == 1)
-			break;
+	*cached_kb = *available_kb = 0;
+	seen_cached_and_available = 2;
+	while (fgets(buf, sizeof(buf), fp)) {
+		if (sscanf(buf, "Cached: %lu %*s\n", cached_kb) == 1)
+			if (--seen_cached_and_available == 0)
+				break;
+		if (sscanf(buf, "MemAvailable: %lu %*s\n", available_kb) == 1)
+			if (--seen_cached_and_available == 0)
+				break;
 	}
 	/* Have to close because of NOFORK */
 	fclose(fp);
 
-	return cached;
+	return seen_cached_and_available == 0;
 }
 
 int free_main(int argc, char **argv) MAIN_EXTERNALLY_VISIBLE;
@@ -75,7 +81,9 @@ int free_main(int argc UNUSED_PARAM, cha
 {
 	struct globals G;
 	struct sysinfo info;
-	unsigned long long cached;
+	unsigned long long cached, cached_plus_free, available;
+	unsigned long cached_kb, available_kb;
+	int seen_available;
 
 #if ENABLE_DESKTOP
 	G.unit_steps = 10;
@@ -98,41 +106,46 @@ int free_main(int argc UNUSED_PARAM, cha
 		}
 	}
 #endif
-	printf("       %11s%11s%11s%11s%11s%11s\n"
+	printf("       %12s%12s%12s%12s%12s%12s\n"
 	"Mem:   ",
 		"total",
 		"used",
 		"free",
-		"shared", "buffers", "cached" /* swap and total don't have these columns */
+		"shared", "buff/cache", "available" /* swap and total don't have these columns */
 	);
 
 	sysinfo(&info);
 	/* Kernels prior to 2.4.x will return info.mem_unit==0, so cope... */
 	G.mem_unit = (info.mem_unit ? info.mem_unit : 1);
-	/* Extract cached from /proc/meminfo and convert to mem_units */
-	cached = ((unsigned long long) parse_cached_kb() * 1024) / G.mem_unit;
+	/* Extract cached and memavailable from /proc/meminfo and convert to mem_units */
+	seen_available = parse_meminfo(&cached_kb, &available_kb);
+	available = ((unsigned long long) available_kb * 1024) / G.mem_unit;
+	cached = ((unsigned long long) cached_kb * 1024) / G.mem_unit;
+	cached += info.bufferram;
+	cached_plus_free = cached + info.freeram;
 
-#define FIELDS_6 "%11llu%11llu%11llu%11llu%11llu%11llu\n"
-#define FIELDS_3 (FIELDS_6 + 3*6)
-#define FIELDS_2 (FIELDS_6 + 4*6)
+#define FIELDS_6 "%12llu %11llu %11llu %11llu %11llu %11llu\n"
+#define FIELDS_3 (FIELDS_6 + 6 + 7 + 7)
+#define FIELDS_2 (FIELDS_6 + 6 + 7 + 7 + 7)
 
 	printf(FIELDS_6,
 		scale(&G, info.totalram),                //total
-		scale(&G, info.totalram - info.freeram), //used
+		scale(&G, info.totalram - cached_plus_free), //used
 		scale(&G, info.freeram),                 //free
 		scale(&G, info.sharedram),               //shared
-		scale(&G, info.bufferram),               //buffers
-		scale(&G, cached)                        //cached
+		scale(&G, cached),                       //buff/cache
+		scale(&G, available)                     //available
 	);
-	/* Show alternate, more meaningful busy/free numbers by counting
+	/* On kernels < 3.14, MemAvailable is not provided.
+	 * Show alternate, more meaningful busy/free numbers by counting
 	 * buffer cache as free memory. */
-	printf("-/+ buffers/cache:");
-	cached += info.freeram;
-	cached += info.bufferram;
-	printf(FIELDS_2,
-		scale(&G, info.totalram - cached), //used
-		scale(&G, cached)                  //free
-	);
+	if (!seen_available) {
+		printf("-/+ buffers/cache: ");
+		printf(FIELDS_2,
+			scale(&G, info.totalram - cached_plus_free), //used
+			scale(&G, cached_plus_free)                  //free
+		);
+	}
 #if BB_MMU
 	printf("Swap:  ");
 	printf(FIELDS_3,
diff -urpN busybox-1.29.3/procps/iostat.c busybox-1.30.0/procps/iostat.c
--- busybox-1.29.3/procps/iostat.c	2018-07-02 13:23:06.000000000 +0200
+++ busybox-1.30.0/procps/iostat.c	2018-12-30 16:14:20.000000000 +0100
@@ -7,7 +7,7 @@
  * Licensed under GPLv2, see file LICENSE in this source tree.
  */
 //config:config IOSTAT
-//config:	bool "iostat (7.4 kb)"
+//config:	bool "iostat (7.6 kb)"
 //config:	default y
 //config:	help
 //config:	Report CPU and I/O statistics
diff -urpN busybox-1.29.3/procps/kill.c busybox-1.30.0/procps/kill.c
--- busybox-1.29.3/procps/kill.c	2018-07-02 13:23:06.000000000 +0200
+++ busybox-1.30.0/procps/kill.c	2018-12-30 16:14:20.000000000 +0100
@@ -8,7 +8,7 @@
  * Licensed under GPLv2 or later, see file LICENSE in this source tree.
  */
 //config:config KILL
-//config:	bool "kill (2.6 kb)"
+//config:	bool "kill (3.1 kb)"
 //config:	default y
 //config:	help
 //config:	The command kill sends the specified signal to the specified
diff -urpN busybox-1.29.3/procps/lsof.c busybox-1.30.0/procps/lsof.c
--- busybox-1.29.3/procps/lsof.c	2018-07-02 13:23:06.000000000 +0200
+++ busybox-1.30.0/procps/lsof.c	2018-12-30 16:14:20.000000000 +0100
@@ -7,7 +7,7 @@
  * Licensed under GPLv2, see file LICENSE in this source tree.
  */
 //config:config LSOF
-//config:	bool "lsof (3.6 kb)"
+//config:	bool "lsof (3.4 kb)"
 //config:	default y
 //config:	help
 //config:	Show open files in the format of:
diff -urpN busybox-1.29.3/procps/mpstat.c busybox-1.30.0/procps/mpstat.c
--- busybox-1.29.3/procps/mpstat.c	2018-07-02 13:23:06.000000000 +0200
+++ busybox-1.30.0/procps/mpstat.c	2018-12-30 16:14:20.000000000 +0100
@@ -7,7 +7,7 @@
  * Licensed under GPLv2, see file LICENSE in this source tree.
  */
 //config:config MPSTAT
-//config:	bool "mpstat (10 kb)"
+//config:	bool "mpstat (9.8 kb)"
 //config:	default y
 //config:	help
 //config:	Per-processor statistics
diff -urpN busybox-1.29.3/procps/nmeter.c busybox-1.30.0/procps/nmeter.c
--- busybox-1.29.3/procps/nmeter.c	2018-07-02 13:23:06.000000000 +0200
+++ busybox-1.30.0/procps/nmeter.c	2018-12-30 16:14:20.000000000 +0100
@@ -6,7 +6,7 @@
  * Contact me: vda.linux@googlemail.com
  */
 //config:config NMETER
-//config:	bool "nmeter (10 kb)"
+//config:	bool "nmeter (11 kb)"
 //config:	default y
 //config:	help
 //config:	Prints selected system stats continuously, one line per update.
diff -urpN busybox-1.29.3/procps/pgrep.c busybox-1.30.0/procps/pgrep.c
--- busybox-1.29.3/procps/pgrep.c	2018-07-02 13:23:06.000000000 +0200
+++ busybox-1.30.0/procps/pgrep.c	2018-12-30 16:14:20.000000000 +0100
@@ -7,13 +7,13 @@
  * Licensed under GPLv2 or later, see file LICENSE in this source tree.
  */
 //config:config PGREP
-//config:	bool "pgrep (6.8 kb)"
+//config:	bool "pgrep (6.5 kb)"
 //config:	default y
 //config:	help
 //config:	Look for processes by name.
 //config:
 //config:config PKILL
-//config:	bool "pkill (7.6 kb)"
+//config:	bool "pkill (7.5 kb)"
 //config:	default y
 //config:	help
 //config:	Send signals to processes by name.
diff -urpN busybox-1.29.3/procps/pidof.c busybox-1.30.0/procps/pidof.c
--- busybox-1.29.3/procps/pidof.c	2018-07-02 13:23:06.000000000 +0200
+++ busybox-1.30.0/procps/pidof.c	2018-12-30 16:14:20.000000000 +0100
@@ -7,7 +7,7 @@
  * Licensed under GPLv2, see file LICENSE in this source tree.
  */
 //config:config PIDOF
-//config:	bool "pidof (6.6 kb)"
+//config:	bool "pidof (6.3 kb)"
 //config:	default y
 //config:	help
 //config:	Pidof finds the process id's (pids) of the named programs. It prints
diff -urpN busybox-1.29.3/procps/powertop.c busybox-1.30.0/procps/powertop.c
--- busybox-1.29.3/procps/powertop.c	2018-07-02 13:23:06.000000000 +0200
+++ busybox-1.30.0/procps/powertop.c	2018-12-30 16:14:20.000000000 +0100
@@ -9,7 +9,7 @@
  * Licensed under GPLv2, see file LICENSE in this source tree.
  */
 //config:config POWERTOP
-//config:	bool "powertop (9.1 kb)"
+//config:	bool "powertop (9.6 kb)"
 //config:	default y
 //config:	help
 //config:	Analyze power consumption on Intel-based laptops
diff -urpN busybox-1.29.3/procps/pstree.c busybox-1.30.0/procps/pstree.c
--- busybox-1.29.3/procps/pstree.c	2018-07-02 13:23:06.000000000 +0200
+++ busybox-1.30.0/procps/pstree.c	2018-12-30 16:14:20.000000000 +0100
@@ -10,7 +10,7 @@
  * Licensed under GPLv2, see file LICENSE in this source tree.
  */
 //config:config PSTREE
-//config:	bool "pstree (9.4 kb)"
+//config:	bool "pstree (9.3 kb)"
 //config:	default y
 //config:	help
 //config:	Display a tree of processes.
diff -urpN busybox-1.29.3/procps/pwdx.c busybox-1.30.0/procps/pwdx.c
--- busybox-1.29.3/procps/pwdx.c	2018-07-02 13:23:06.000000000 +0200
+++ busybox-1.30.0/procps/pwdx.c	2018-12-30 16:14:20.000000000 +0100
@@ -8,7 +8,7 @@
  * Licensed under GPLv2, see file LICENSE in this source tree.
  */
 //config:config PWDX
-//config:	bool "pwdx (3.5 kb)"
+//config:	bool "pwdx (3.7 kb)"
 //config:	default y
 //config:	help
 //config:	Report current working directory of a process
diff -urpN busybox-1.29.3/procps/smemcap.c busybox-1.30.0/procps/smemcap.c
--- busybox-1.29.3/procps/smemcap.c	2018-07-02 13:23:06.000000000 +0200
+++ busybox-1.30.0/procps/smemcap.c	2018-12-05 15:44:34.000000000 +0100
@@ -65,7 +65,11 @@ static void archivefile(const char *path
 	struct stat s;
 
 	/* buffer the file */
-	fd = xopen(path, O_RDONLY);
+	fd = open(path, O_RDONLY);
+	if (fd == -1) {
+		/* skip vanished processes between dir listing and traversal */
+		return;
+	}
 	do {
 		cur = xzalloc(sizeof(*cur));
 		*prev = cur;
diff -urpN busybox-1.29.3/procps/sysctl.c busybox-1.30.0/procps/sysctl.c
--- busybox-1.29.3/procps/sysctl.c	2018-07-02 13:23:06.000000000 +0200
+++ busybox-1.30.0/procps/sysctl.c	2018-12-30 16:14:20.000000000 +0100
@@ -11,7 +11,7 @@
  * v1.01.1 - busybox applet aware by <solar@gentoo.org>
  */
 //config:config BB_SYSCTL
-//config:	bool "sysctl (6.9 kb)"
+//config:	bool "sysctl (7.4 kb)"
 //config:	default y
 //config:	help
 //config:	Configure kernel parameters at runtime.
diff -urpN busybox-1.29.3/procps/top.c busybox-1.30.0/procps/top.c
--- busybox-1.29.3/procps/top.c	2018-07-02 13:23:06.000000000 +0200
+++ busybox-1.30.0/procps/top.c	2018-12-30 16:14:20.000000000 +0100
@@ -50,7 +50,7 @@
  * chroot . ./top -bn1 >top1.out
  */
 //config:config TOP
-//config:	bool "top (17 kb)"
+//config:	bool "top (18 kb)"
 //config:	default y
 //config:	help
 //config:	The top program provides a dynamic real-time view of a running
@@ -901,11 +901,11 @@ enum {
 };
 
 #if ENABLE_FEATURE_TOP_INTERACTIVE
-static unsigned handle_input(unsigned scan_mask, unsigned interval)
+static unsigned handle_input(unsigned scan_mask, duration_t interval)
 {
 	if (option_mask32 & OPT_EOF) {
 		/* EOF on stdin ("top </dev/null") */
-		sleep(interval);
+		sleep_for_duration(interval);
 		return scan_mask;
 	}
 
@@ -1092,9 +1092,9 @@ static unsigned handle_input(unsigned sc
 int top_main(int argc, char **argv) MAIN_EXTERNALLY_VISIBLE;
 int top_main(int argc UNUSED_PARAM, char **argv)
 {
+	duration_t interval;
 	int iterations;
 	unsigned col;
-	unsigned interval;
 	char *str_interval, *str_iterations;
 	unsigned scan_mask = TOP_MASK;
 
@@ -1120,8 +1120,10 @@ int top_main(int argc UNUSED_PARAM, char
 		/* work around for "-d 1" -> "-d -1" done by make_all_argv_opts() */
 		if (str_interval[0] == '-')
 			str_interval++;
+		interval = parse_duration_str(str_interval);
 		/* Need to limit it to not overflow poll timeout */
-		interval = xatou16(str_interval);
+		if (interval > INT_MAX / 1000)
+			interval = INT_MAX / 1000;
 	}
 	if (col & OPT_n) {
 		if (str_iterations[0] == '-')
@@ -1169,7 +1171,7 @@ int top_main(int argc UNUSED_PARAM, char
 			/* We output to stdout, we need size of stdout (not stdin)! */
 			get_terminal_width_height(STDOUT_FILENO, &col, &G.lines);
 			if (G.lines < 5 || col < 10) {
-				sleep(interval);
+				sleep_for_duration(interval);
 				continue;
 			}
 			if (col > LINE_BUF_SIZE - 2)
@@ -1254,7 +1256,7 @@ int top_main(int argc UNUSED_PARAM, char
 			break;
 #if !ENABLE_FEATURE_TOP_INTERACTIVE
 		clearmems();
-		sleep(interval);
+		sleep_for_duration(interval);
 #else
 		new_mask = handle_input(scan_mask, interval);
 		if (new_mask == NO_RESCAN_MASK)
diff -urpN busybox-1.29.3/procps/uptime.c busybox-1.30.0/procps/uptime.c
--- busybox-1.29.3/procps/uptime.c	2018-07-02 13:23:06.000000000 +0200
+++ busybox-1.30.0/procps/uptime.c	2018-12-30 16:14:20.000000000 +0100
@@ -12,7 +12,7 @@
  * Added FEATURE_UPTIME_UTMP_SUPPORT flag.
  */
 //config:config UPTIME
-//config:	bool "uptime (632 bytes)"
+//config:	bool "uptime (3.7 kb)"
 //config:	default y
 //config:	select PLATFORM_LINUX #sysinfo()
 //config:	help
@@ -45,7 +45,6 @@
 # include <sys/sysinfo.h>
 #endif
 
-
 #ifndef FSHIFT
 # define FSHIFT 16              /* nr of bits of precision */
 #endif
@@ -53,29 +52,48 @@
 #define LOAD_INT(x)  (unsigned)((x) >> FSHIFT)
 #define LOAD_FRAC(x) LOAD_INT(((x) & (FIXED_1 - 1)) * 100)
 
-
 int uptime_main(int argc, char **argv) MAIN_EXTERNALLY_VISIBLE;
 int uptime_main(int argc UNUSED_PARAM, char **argv UNUSED_PARAM)
 {
 	unsigned updays, uphours, upminutes;
+	unsigned opts;
 	struct sysinfo info;
 	struct tm *current_time;
 	time_t current_secs;
 
+	opts = getopt32(argv, "s");
+
 	time(&current_secs);
+	sysinfo(&info);
+
+	if (opts) // -s
+		current_secs -= info.uptime;
+
 	current_time = localtime(&current_secs);
 
-	sysinfo(&info);
+	if (opts) { // -s
+		printf("%04u-%02u-%02u %02u:%02u:%02u\n",
+			current_time->tm_year + 1900, current_time->tm_mon + 1, current_time->tm_mday,
+			current_time->tm_hour, current_time->tm_min, current_time->tm_sec
+		);
+		/* The above way of calculating boot time is wobbly,
+		 * info.uptime has only 1 second precision, which makes
+		 * "uptime -s" wander +- one second.
+		 * /proc/uptime may be better, it has 0.01s precision.
+		 */
+		return EXIT_SUCCESS;
+	}
 
 	printf(" %02u:%02u:%02u up ",
-			current_time->tm_hour, current_time->tm_min, current_time->tm_sec);
+			current_time->tm_hour, current_time->tm_min, current_time->tm_sec
+	);
 	updays = (unsigned) info.uptime / (unsigned)(60*60*24);
-	if (updays)
+	if (updays != 0)
 		printf("%u day%s, ", updays, (updays != 1) ? "s" : "");
 	upminutes = (unsigned) info.uptime / (unsigned)60;
 	uphours = (upminutes / (unsigned)60) % (unsigned)24;
 	upminutes %= 60;
-	if (uphours)
+	if (uphours != 0)
 		printf("%2u:%02u", uphours, upminutes);
 	else
 		printf("%u min", upminutes);
diff -urpN busybox-1.29.3/procps/watch.c busybox-1.30.0/procps/watch.c
--- busybox-1.29.3/procps/watch.c	2018-07-02 13:23:06.000000000 +0200
+++ busybox-1.30.0/procps/watch.c	2018-12-30 16:14:20.000000000 +0100
@@ -8,7 +8,7 @@
  * Licensed under GPLv2 or later, see file LICENSE in this source tree.
  */
 //config:config WATCH
-//config:	bool "watch (4.1 kb)"
+//config:	bool "watch (4.4 kb)"
 //config:	default y
 //config:	help
 //config:	watch is used to execute a program periodically, showing
diff -urpN busybox-1.29.3/runit/chpst.c busybox-1.30.0/runit/chpst.c
--- busybox-1.29.3/runit/chpst.c	2018-07-02 13:23:06.000000000 +0200
+++ busybox-1.30.0/runit/chpst.c	2018-12-30 16:14:20.000000000 +0100
@@ -28,20 +28,20 @@ ADVISED OF THE POSSIBILITY OF SUCH DAMAG
 /* Busyboxed by Denys Vlasenko <vda.linux@googlemail.com> */
 
 //config:config CHPST
-//config:	bool "chpst (8.7 kb)"
+//config:	bool "chpst (9 kb)"
 //config:	default y
 //config:	help
 //config:	chpst changes the process state according to the given options, and
 //config:	execs specified program.
 //config:
 //config:config SETUIDGID
-//config:	bool "setuidgid (4.2 kb)"
+//config:	bool "setuidgid (4 kb)"
 //config:	default y
 //config:	help
 //config:	Sets soft resource limits as specified by options
 //config:
 //config:config ENVUIDGID
-//config:	bool "envuidgid (3.6 kb)"
+//config:	bool "envuidgid (3.9 kb)"
 //config:	default y
 //config:	help
 //config:	Sets $UID to account's uid and $GID to account's gid
@@ -54,7 +54,7 @@ ADVISED OF THE POSSIBILITY OF SUCH DAMAG
 //config:	in the given directory
 //config:
 //config:config SOFTLIMIT
-//config:	bool "softlimit (4.3 kb)"
+//config:	bool "softlimit (4.5 kb)"
 //config:	default y
 //config:	help
 //config:	Sets soft resource limits as specified by options
diff -urpN busybox-1.29.3/runit/runsv.c busybox-1.30.0/runit/runsv.c
--- busybox-1.29.3/runit/runsv.c	2018-07-02 13:23:06.000000000 +0200
+++ busybox-1.30.0/runit/runsv.c	2018-12-30 16:14:20.000000000 +0100
@@ -28,7 +28,7 @@ ADVISED OF THE POSSIBILITY OF SUCH DAMAG
 /* Busyboxed by Denys Vlasenko <vda.linux@googlemail.com> */
 
 //config:config RUNSV
-//config:	bool "runsv (7.2 kb)"
+//config:	bool "runsv (7.8 kb)"
 //config:	default y
 //config:	help
 //config:	runsv starts and monitors a service and optionally an appendant log
diff -urpN busybox-1.29.3/runit/runsvdir.c busybox-1.30.0/runit/runsvdir.c
--- busybox-1.29.3/runit/runsvdir.c	2018-07-02 13:23:06.000000000 +0200
+++ busybox-1.30.0/runit/runsvdir.c	2018-12-30 16:14:20.000000000 +0100
@@ -28,7 +28,7 @@ ADVISED OF THE POSSIBILITY OF SUCH DAMAG
 /* Busyboxed by Denys Vlasenko <vda.linux@googlemail.com> */
 
 //config:config RUNSVDIR
-//config:	bool "runsvdir (6 kb)"
+//config:	bool "runsvdir (6.3 kb)"
 //config:	default y
 //config:	help
 //config:	runsvdir starts a runsv process for each subdirectory, or symlink to
diff -urpN busybox-1.29.3/runit/sv.c busybox-1.30.0/runit/sv.c
--- busybox-1.29.3/runit/sv.c	2018-07-02 13:23:06.000000000 +0200
+++ busybox-1.30.0/runit/sv.c	2018-12-30 16:14:20.000000000 +0100
@@ -154,7 +154,7 @@ Exit Codes
 /* Busyboxed by Denys Vlasenko <vda.linux@googlemail.com> */
 
 //config:config SV
-//config:	bool "sv (7.8 kb)"
+//config:	bool "sv (8.5 kb)"
 //config:	default y
 //config:	help
 //config:	sv reports the current status and controls the state of services
@@ -169,14 +169,14 @@ Exit Codes
 //config:	Defaults to "/var/service"
 //config:
 //config:config SVC
-//config:	bool "svc (7.8 kb)"
+//config:	bool "svc (8.4 kb)"
 //config:	default y
 //config:	help
 //config:	svc controls the state of services monitored by the runsv supervisor.
 //config:	It is compatible with daemontools command with the same name.
 //config:
 //config:config SVOK
-//config:	bool "svok"
+//config:	bool "svok (1.5 kb)"
 //config:	default y
 //config:	help
 //config:	svok checks whether runsv supervisor is running.
diff -urpN busybox-1.29.3/runit/svlogd.c busybox-1.30.0/runit/svlogd.c
--- busybox-1.29.3/runit/svlogd.c	2018-07-02 13:23:06.000000000 +0200
+++ busybox-1.30.0/runit/svlogd.c	2018-12-30 16:14:20.000000000 +0100
@@ -124,7 +124,7 @@ log message, you can use a pattern like
 -*: *: pid *
 */
 //config:config SVLOGD
-//config:	bool "svlogd (15 kb)"
+//config:	bool "svlogd (16 kb)"
 //config:	default y
 //config:	help
 //config:	svlogd continuously reads log data from its standard input, optionally
@@ -1010,7 +1010,7 @@ static void sig_hangup_handler(int sig_n
 	reopenasap = 1;
 }
 
-static void logmatch(struct logdir *ld)
+static void logmatch(struct logdir *ld, char* lineptr, int lineptr_len)
 {
 	char *s;
 
@@ -1021,12 +1021,12 @@ static void logmatch(struct logdir *ld)
 		switch (s[0]) {
 		case '+':
 		case '-':
-			if (pmatch(s+1, line, linelen))
+			if (pmatch(s+1, lineptr, lineptr_len))
 				ld->match = s[0];
 			break;
 		case 'e':
 		case 'E':
-			if (pmatch(s+1, line, linelen))
+			if (pmatch(s+1, lineptr, lineptr_len))
 				ld->matcherr = s[0];
 			break;
 		}
@@ -1182,7 +1182,7 @@ int svlogd_main(int argc, char **argv)
 			if (ld->fddir == -1)
 				continue;
 			if (ld->inst)
-				logmatch(ld);
+				logmatch(ld, lineptr, linelen);
 			if (ld->matcherr == 'e') {
 				/* runit-1.8.0 compat: if timestamping, do it on stderr too */
 				////full_write(STDERR_FILENO, printptr, printlen);
diff -urpN busybox-1.29.3/scripts/embedded_scripts busybox-1.30.0/scripts/embedded_scripts
--- busybox-1.29.3/scripts/embedded_scripts	1970-01-01 01:00:00.000000000 +0100
+++ busybox-1.30.0/scripts/embedded_scripts	2018-12-05 15:44:34.000000000 +0100
@@ -0,0 +1,125 @@
+#!/bin/sh
+
+. ./.config || exit 1
+
+target="$1"
+custom_loc="$2"
+applet_loc="$3"
+
+test "$target" || exit 1
+test "$SED" || SED=sed
+test "$DD" || DD=dd
+
+if [ x"$CONFIG_FEATURE_SH_EMBEDDED_SCRIPTS" != x"y" ]
+then
+	printf '#define NUM_SCRIPTS 0\n' >"$target"
+	exit 0
+fi
+
+# Some people were bitten by their system lacking a (proper) od
+od -v -b </dev/null >/dev/null
+if test $? != 0; then
+	echo 'od tool is not installed or cannot accept "-v -b" options'
+	exit 1
+fi
+
+custom_scripts=""
+if [ -d "$custom_loc" ]
+then
+	custom_scripts=$(cd $custom_loc; ls * 2>/dev/null)
+fi
+all_scripts=$($srctree/applets/busybox.mkscripts)
+
+# all_scripts includes applet scripts and custom scripts, sort them out
+applet_scripts=""
+for i in $all_scripts
+do
+    found=0
+	for j in $custom_scripts
+	do
+		if [ "$i" = "$j" ]
+		then
+			found=1
+			break;
+		fi
+	done
+	if [ $found -eq 0 ]
+	then
+		# anything that isn't a custom script is an applet script
+		applet_scripts="$applet_scripts $i"
+	fi
+done
+
+# we know the custom scripts are present but applet scripts might have
+# become detached from their configuration
+for i in $applet_scripts
+do
+	#if [ ! -f "$applet_loc/$i" -a ! -f "$custom_loc/$i" ]
+	if [ ! -f "$applet_loc/$i" ]
+	then
+		echo "missing applet script $i"
+		exit 1
+	fi
+done
+
+n=$(echo $custom_scripts $applet_scripts | wc -w)
+nall=$(echo $all_scripts | wc -w)
+
+if [ $n -ne $nall ]
+then
+	echo "script mismatch $n != $nall"
+	exit 1
+fi
+
+concatenate_scripts() {
+	for i in $custom_scripts
+	do
+		cat $custom_loc/$i
+		printf '\000'
+	done
+	for i in $applet_scripts
+	do
+		cat $applet_loc/$i
+		printf '\000'
+	done
+}
+
+exec >"$target.$$"
+
+if [ $n -ne 0 ]
+then
+	printf '#ifdef DEFINE_SCRIPT_DATA\n'
+	printf 'const uint16_t applet_numbers[] = {\n'
+	for i in $custom_scripts $applet_scripts
+	do
+		# TODO support applets with names including invalid characters
+		printf '\tAPPLET_NO_%s,\n' $i
+	done
+	printf '};\n'
+	printf '#else\n'
+	printf 'extern const uint16_t applet_numbers[];\n'
+	printf '#endif\n'
+fi
+
+printf "\n"
+printf '#define NUM_SCRIPTS %d\n' $n
+printf "\n"
+
+if [ $n -ne 0 ]
+then
+	printf '#define UNPACKED_SCRIPTS_LENGTH '
+	concatenate_scripts | wc -c
+
+	printf '#define PACKED_SCRIPTS \\\n'
+	concatenate_scripts | bzip2 -1 | $DD bs=2 skip=1 2>/dev/null | \
+	od -v -b \
+	| grep -v '^ ' \
+	| $SED -e 's/^[^ ]*//' \
+		-e 's/ //g' \
+		-e '/^$/d' \
+		-e 's/\(...\)/0\1,/g' \
+		-e 's/$/ \\/'
+	printf '\n'
+fi
+
+mv -- "$target.$$" "$target"
diff -urpN busybox-1.29.3/scripts/gen_build_files.sh busybox-1.30.0/scripts/gen_build_files.sh
--- busybox-1.29.3/scripts/gen_build_files.sh	2018-07-02 13:23:06.000000000 +0200
+++ busybox-1.30.0/scripts/gen_build_files.sh	2018-12-05 15:44:34.000000000 +0100
@@ -17,12 +17,26 @@ status() { printf '  %-8s%s\n' "$1" "$2"
 gen() { status "GEN" "$@"; }
 chk() { status "CHK" "$@"; }
 
+# scripts in the 'embed' directory are treated as fake applets
+custom_scripts()
+{
+	custom_loc="$1"
+	if [ -d "$custom_loc" ]
+	then
+		for i in $(cd "$custom_loc"; ls * 2>/dev/null)
+		do
+			printf "IF_FEATURE_SH_EMBEDDED_SCRIPTS(APPLET_SCRIPTED(%s, scripted, BB_DIR_USR_BIN, BB_SUID_DROP, scripted))\n" $i;
+		done
+	fi
+}
+
 generate()
 {
 	# NB: data to be inserted at INSERT line is coming on stdin
 	src="$1"
 	dst="$2"
 	header="$3"
+	loc="$4"
 	#chk "${dst}"
 	{
 		# Need to use printf: different shells have inconsistent
@@ -32,6 +46,10 @@ generate()
 		sed -n '/^INSERT$/ q; p' "${src}"
 		# copy stdin to stdout
 		cat
+		if [ -n "$loc" ]
+		then
+			custom_scripts "$loc"
+		fi
 		# print everything after INSERT line
 		sed -n '/^INSERT$/ {
 		:l
@@ -53,7 +71,8 @@ sed -n 's@^//applet:@@p' "$srctree"/*/*.
 | generate \
 	"$srctree/include/applets.src.h" \
 	"include/applets.h" \
-	"/* DO NOT EDIT. This file is generated from applets.src.h */"
+	"/* DO NOT EDIT. This file is generated from applets.src.h */" \
+	"$srctree/embed"
 
 # (Re)generate include/usage.h
 # We add line continuation backslash after each line,
diff -urpN busybox-1.29.3/scripts/trylink busybox-1.30.0/scripts/trylink
--- busybox-1.29.3/scripts/trylink	2018-07-02 13:23:06.000000000 +0200
+++ busybox-1.30.0/scripts/trylink	2018-12-05 15:44:34.000000000 +0100
@@ -149,8 +149,8 @@ try $CC $CFLAGS $LDFLAGS \
 # Stop when no lib can be removed.
 while test "$LDLIBS"; do
     $debug && echo "Trying libraries: $LDLIBS"
-    all_needed=true
-    last_needed=false
+    dropped_non_first_lib=false
+    first_lib=true
     for one in $LDLIBS; do
 	without_one=`echo " $LDLIBS " | sed "s/ $one / /g" | xargs`
 	# "lib1 lib2 lib3" -> "-llib1 -llib2 -llib3"
@@ -167,20 +167,17 @@ while test "$LDLIBS"; do
 	if test $? = 0; then
 	    echo " Library $one is not needed, excluding it"
 	    LDLIBS="$without_one"
-	    all_needed=false
-	    last_needed=false
+	    $first_lib || dropped_non_first_lib=true
 	else
 	    echo " Library $one is needed, can't exclude it (yet)"
-	    last_needed=true
+	    first_lib=false
 	fi
     done
-    # All libs were needed, can't remove any
-    $all_needed && break
-    # Optimization: was the last tried lib needed?
-    if $last_needed; then
-	# Was it the only one lib left? Don't test again then.
-	{ echo "$LDLIBS" | grep -q ' '; } || break
-    fi
+    # We can stop trying to drop libs if either all libs were needed,
+    # or we excluded only the _first_ few.
+    # (else: we dropped some intermediate lib(s), maybe now we can succeed
+    # in dropping some of the preceding ones)
+    $dropped_non_first_lib || break
 done
 
 # Make the binary with final, minimal list of libs
diff -urpN busybox-1.29.3/selinux/chcon.c busybox-1.30.0/selinux/chcon.c
--- busybox-1.29.3/selinux/chcon.c	2018-07-02 13:23:06.000000000 +0200
+++ busybox-1.30.0/selinux/chcon.c	2018-12-05 15:44:34.000000000 +0100
@@ -131,8 +131,10 @@ static int FAST_FUNC change_filedir_cont
 			bb_error_msg("can't change context of %s to %s",
 					fname, context_string);
 		}
-	} else if (option_mask32 & OPT_VERBOSE) {
-		printf("context of %s retained as %s\n", fname, context_string);
+	} else {
+		if (option_mask32 & OPT_VERBOSE) {
+			printf("context of %s retained as %s\n", fname, context_string);
+		}
 		rc = TRUE;
 	}
 skip:
@@ -202,7 +204,7 @@ int chcon_main(int argc UNUSED_PARAM, ch
 		fname[fname_len] = '\0';
 
 		if (recursive_action(fname,
-					1<<option_mask32 & OPT_RECURSIVE,
+					((option_mask32 & OPT_RECURSIVE) ? ACTION_RECURSIVE : 0),
 					change_filedir_context,
 					change_filedir_context,
 					NULL, 0) != TRUE)
diff -urpN busybox-1.29.3/shell/Config.src busybox-1.30.0/shell/Config.src
--- busybox-1.29.3/shell/Config.src	2018-07-02 13:23:06.000000000 +0200
+++ busybox-1.30.0/shell/Config.src	2018-12-05 15:44:34.000000000 +0100
@@ -161,6 +161,20 @@ config FEATURE_SH_HISTFILESIZE
 	to set shell history size. Note that its max value is capped
 	by "History size" setting in library tuning section.
 
+config FEATURE_SH_EMBEDDED_SCRIPTS
+	bool "Embed scripts in the binary"
+	default y
+	depends on ASH || HUSH || SH_IS_ASH || BASH_IS_ASH || SH_IS_HUSH || BASH_IS_HUSH
+	help
+	Allow scripts to be compressed and embedded in the busybox
+	binary. The scripts should be placed in the 'embed' directory
+	at build time. Like applets, scripts can be run as
+	'busybox SCRIPT ...' or by linking their name to the binary.
+
+	This also allows applets to be implemented as scripts: place
+	the script in 'applets_sh' and a stub C file containing
+	configuration in the appropriate subsystem directory.
+
 endif # Options common to all shells
 
 endmenu
diff -urpN busybox-1.29.3/shell/ash.c busybox-1.30.0/shell/ash.c
--- busybox-1.29.3/shell/ash.c	2018-07-02 13:23:06.000000000 +0200
+++ busybox-1.30.0/shell/ash.c	2018-12-30 16:14:20.000000000 +0100
@@ -16,7 +16,7 @@
  * Licensed under GPLv2 or later, see file LICENSE in this source tree.
  */
 //config:config ASH
-//config:	bool "ash (77 kb)"
+//config:	bool "ash (78 kb)"
 //config:	default y
 //config:	depends on !NOMMU
 //config:	help
@@ -181,6 +181,11 @@
 #include <sys/times.h>
 #include <sys/utsname.h> /* for setting $HOSTNAME */
 #include "busybox.h" /* for applet_names */
+#if ENABLE_FEATURE_SH_EMBEDDED_SCRIPTS
+# include "embedded_scripts.h"
+#else
+# define NUM_SCRIPTS 0
+#endif
 
 /* So far, all bash compat is controlled by one config option */
 /* Separate defines document which part of code implements what */
@@ -2405,13 +2410,12 @@ setvar(const char *name, const char *val
 	}
 
 	INT_OFF;
-	nameeq = ckmalloc(namelen + vallen + 2);
+	nameeq = ckzalloc(namelen + vallen + 2);
 	p = mempcpy(nameeq, name, namelen);
 	if (val) {
 		*p++ = '=';
-		p = mempcpy(p, val, vallen);
+		memcpy(p, val, vallen);
 	}
-	*p = '\0';
 	vp = setvareq(nameeq, flags | VNOSAVE);
 	INT_ON;
 
@@ -4213,7 +4217,7 @@ wait_block_or_sig(int *status)
 		/* Children exist, but none are ready. Sleep until interesting signal */
 #if 1
 		sigfillset(&mask);
-		sigprocmask(SIG_SETMASK, &mask, &mask);
+		sigprocmask2(SIG_SETMASK, &mask); /* mask is updated */
 		while (!got_sigchld && !pending_sig)
 			sigsuspend(&mask);
 		sigprocmask(SIG_SETMASK, &mask, NULL);
@@ -5902,7 +5906,7 @@ static int substr_atoi(const char *s)
 #define EXP_CASE        0x10    /* keeps quotes around for CASE pattern */
 #define EXP_VARTILDE2   0x20    /* expand tildes after colons only */
 #define EXP_WORD        0x40    /* expand word in parameter expansion */
-#define EXP_QUOTED      0x80    /* expand word in double quotes */
+#define EXP_QUOTED      0x100   /* expand word in double quotes */
 /*
  * rmescape() flags
  */
@@ -6236,9 +6240,7 @@ memtodest(const char *p, size_t len, int
 			if (quotes & QUOTES_ESC) {
 				int n = SIT(c, syntax);
 				if (n == CCTL
-				 || (((quotes & EXP_FULL) || syntax != BASESYNTAX)
-				     && n == CBACK
-				    )
+				 || (syntax != BASESYNTAX && n == CBACK)
 				) {
 					USTPUTC(CTLESC, q);
 				}
@@ -6854,8 +6856,15 @@ subevalvar(char *p, char *varname, int s
 	if (subtype == VSREPLACE || subtype == VSREPLACEALL) {
 		/* Find '/' and replace with NUL */
 		repl = p;
+		/* The pattern can't be empty.
+		 * IOW: if the first char after "${v//" is a slash,
+		 * it does not terminate the pattern - it's the first char of the pattern:
+		 *  v=/dev/ram; echo ${v////-}  prints -dev-ram (pattern is "/")
+		 *  v=/dev/ram; echo ${v///r/-} prints /dev-am  (pattern is "/r")
+		 */
+		if (*repl == '/')
+			repl++;
 		for (;;) {
-			/* Handle escaped slashes, e.g. "${v/\//_}" (they are CTLESC'ed by this point) */
 			if (*repl == '\0') {
 				repl = NULL;
 				break;
@@ -6864,6 +6873,7 @@ subevalvar(char *p, char *varname, int s
 				*repl = '\0';
 				break;
 			}
+			/* Handle escaped slashes, e.g. "${v/\//_}" (they are CTLESC'ed by this point) */
 			if ((unsigned char)*repl == CTLESC && repl[1])
 				repl++;
 			repl++;
@@ -7167,14 +7177,13 @@ subevalvar(char *p, char *varname, int s
  * ash -c 'echo ${#1#}'  name:'1=#'
  */
 static NOINLINE ssize_t
-varvalue(char *name, int varflags, int flags, int *quotedp)
+varvalue(char *name, int varflags, int flags, int quoted)
 {
 	const char *p;
 	int num;
 	int i;
 	ssize_t len = 0;
 	int sep;
-	int quoted = *quotedp;
 	int subtype = varflags & VSTYPE;
 	int discard = subtype == VSPLUS || subtype == VSLENGTH;
 	int quotes = (discard ? 0 : (flags & QUOTES_ESC)) | QUOTES_KEEPNUL;
@@ -7222,13 +7231,27 @@ varvalue(char *name, int varflags, int f
 	case '*': {
 		char **ap;
 		char sepc;
+		char c;
 
-		if (quoted)
-			sep = 0;
-		sep |= ifsset() ? ifsval()[0] : ' ';
+		/* We will set c to 0 or ~0 depending on whether
+		 * we're doing field splitting.  We won't do field
+		 * splitting if either we're quoted or sep is zero.
+		 *
+		 * Instead of testing (quoted || !sep) the following
+		 * trick optimises away any branches by using the
+		 * fact that EXP_QUOTED (which is the only bit that
+		 * can be set in quoted) is the same as EXP_FULL <<
+		 * CHAR_BIT (which is the only bit that can be set
+		 * in sep).
+		 */
+#if EXP_QUOTED >> CHAR_BIT != EXP_FULL
+#error The following two lines expect EXP_QUOTED == EXP_FULL << CHAR_BIT
+#endif
+		c = !((quoted | ~sep) & EXP_QUOTED) - 1;
+		sep &= ~quoted;
+		sep |= ifsset() ? (unsigned char)(c & ifsval()[0]) : ' ';
  param:
 		sepc = sep;
-		*quotedp = !sepc;
 		ap = shellparam.p;
 		if (!ap)
 			return -1;
@@ -7293,7 +7316,6 @@ evalvar(char *p, int flag)
 	char varflags;
 	char subtype;
 	int quoted;
-	char easy;
 	char *var;
 	int patloc;
 	int startloc;
@@ -7307,12 +7329,11 @@ evalvar(char *p, int flag)
 
 	quoted = flag & EXP_QUOTED;
 	var = p;
-	easy = (!quoted || (*var == '@' && shellparam.nparam));
 	startloc = expdest - (char *)stackblock();
 	p = strchr(p, '=') + 1; //TODO: use var_end(p)?
 
  again:
-	varlen = varvalue(var, varflags, flag, &quoted);
+	varlen = varvalue(var, varflags, flag, quoted);
 	if (varflags & VSNUL)
 		varlen--;
 
@@ -7358,8 +7379,11 @@ evalvar(char *p, int flag)
 
 	if (subtype == VSNORMAL) {
  record:
-		if (!easy)
-			goto end;
+		if (quoted) {
+			quoted = *var == '@' && shellparam.nparam;
+			if (!quoted)
+				goto end;
+		}
 		recordregion(startloc, expdest - (char *)stackblock(), quoted);
 		goto end;
 	}
@@ -7617,7 +7641,7 @@ expmeta(exp_t *exp, char *name, unsigned
 				}
 			}
 		} else {
-			if (*p == '\\')
+			if (*p == '\\' && p[1])
 				esc++;
 			if (p[esc] == '/') {
 				if (metaflag)
@@ -7631,7 +7655,7 @@ expmeta(exp_t *exp, char *name, unsigned
 			return;
 		p = name;
 		do {
-			if (*p == '\\')
+			if (*p == '\\' && p[1])
 				p++;
 			*enddir++ = *p;
 		} while (*p++);
@@ -7643,7 +7667,7 @@ expmeta(exp_t *exp, char *name, unsigned
 	if (name < start) {
 		p = name;
 		do {
-			if (*p == '\\')
+			if (*p == '\\' && p[1])
 				p++;
 			*enddir++ = *p++;
 		} while (p < start);
@@ -8004,6 +8028,7 @@ tryexec(IF_FEATURE_SH_STANDALONE(int app
 #else
 	execve(cmd, argv, envp);
 #endif
+
 	if (cmd != bb_busybox_exec_path && errno == ENOEXEC) {
 		/* Run "cmd" as a shell script:
 		 * http://pubs.opengroup.org/onlinepubs/9699919799/utilities/V3_chap02.html
@@ -8076,15 +8101,15 @@ static void shellexec(char *prog, char *
 
 	/* Map to POSIX errors */
 	switch (e) {
-	case EACCES:
+	default:
 		exerrno = 126;
 		break;
+	case ELOOP:
+	case ENAMETOOLONG:
 	case ENOENT:
+	case ENOTDIR:
 		exerrno = 127;
 		break;
-	default:
-		exerrno = 2;
-		break;
 	}
 	exitstatus = exerrno;
 	TRACE(("shellexec failed for %s, errno %d, suppress_int %d\n",
@@ -8512,7 +8537,8 @@ describe_command(char *command, const ch
 
 	case CMDFUNCTION:
 		if (describe_command_verbose) {
-			out1str(" is a shell function");
+			/*out1str(" is a shell function");*/
+			out1str(" is a function"); /* bash says this */
 		} else {
 			out1str(command);
 		}
@@ -9591,9 +9617,7 @@ evalfun(struct funcnode *func, int argc,
 	shellparam.optind = 1;
 	shellparam.optoff = -1;
 #endif
-	pushlocalvars();
 	evaltree(func->n.ndefun.body, flags & EV_TESTED);
-	poplocalvars(0);
  funcdone:
 	INT_OFF;
 	funcline = savefuncline;
@@ -9921,6 +9945,7 @@ find_builtin(const char *name)
 /*
  * Execute a simple command.
  */
+static void unwindfiles(struct parsefile *stop);
 static int
 isassignment(const char *p)
 {
@@ -9943,6 +9968,7 @@ evalcommand(union node *cmd, int flags)
 		"\0\0", bltincmd /* why three NULs? */
 	};
 	struct localvar_list *localvar_stop;
+	struct parsefile *file_stop;
 	struct redirtab *redir_stop;
 	struct stackmark smark;
 	union node *argp;
@@ -9968,6 +9994,7 @@ evalcommand(union node *cmd, int flags)
 	TRACE(("evalcommand(0x%lx, %d) called\n", (long)cmd, flags));
 	setstackmark(&smark);
 	localvar_stop = pushlocalvars();
+	file_stop = g_parsefile;
 	back_exitstatus = 0;
 
 	cmdentry.cmdtype = CMDBUILTIN;
@@ -10226,7 +10253,6 @@ evalcommand(union node *cmd, int flags)
 		goto readstatus;
 
 	case CMDFUNCTION:
-		poplocalvars(1);
 		/* See above for the rationale */
 		dowait(DOWAIT_NONBLOCK, NULL);
 		if (evalfun(cmdentry.u.func, argc, argv, flags))
@@ -10240,6 +10266,7 @@ evalcommand(union node *cmd, int flags)
 	if (cmd->ncmd.redirect)
 		popredir(/*drop:*/ cmd_is_exec);
 	unwindredir(redir_stop);
+	unwindfiles(file_stop);
 	unwindlocalvars(localvar_stop);
 	if (lastarg) {
 		/* dsl: I think this is intended to be used to support
@@ -10762,14 +10789,20 @@ popfile(void)
 	INT_ON;
 }
 
+static void
+unwindfiles(struct parsefile *stop)
+{
+	while (g_parsefile != stop)
+		popfile();
+}
+
 /*
  * Return to top level.
  */
 static void
 popallfiles(void)
 {
-	while (g_parsefile != &basepf)
-		popfile();
+	unwindfiles(&basepf);
 }
 
 /*
@@ -12411,7 +12444,7 @@ parsesub: {
 				STPUTC(c, out);
 				c = pgetc_eatbnl();
 			} while (isdigit(c));
-		} else {
+		} else if (c != '}') {
 			/* $[{[#]]<specialchar>[}] */
 			int cc = c;
 
@@ -12437,7 +12470,8 @@ parsesub: {
 			}
 
 			USTPUTC(cc, out);
-		}
+		} else
+			goto badsub;
 
 		if (c != '}' && subtype == VSLENGTH) {
 			/* ${#VAR didn't end with } */
@@ -12913,6 +12947,7 @@ parseheredoc(void)
 	heredoclist = NULL;
 
 	while (here) {
+		tokpushback = 0;
 		setprompt_if(needprompt, 2);
 		readtoken1(pgetc(), here->here->type == NHERE ? SQSYNTAX : DQSYNTAX,
 				here->eofmark, here->striptabs);
@@ -13742,38 +13777,35 @@ letcmd(int argc UNUSED_PARAM, char **arg
 static int FAST_FUNC
 readcmd(int argc UNUSED_PARAM, char **argv UNUSED_PARAM)
 {
-	char *opt_n = NULL;
-	char *opt_p = NULL;
-	char *opt_t = NULL;
-	char *opt_u = NULL;
-	char *opt_d = NULL; /* optimized out if !BASH */
-	int read_flags = 0;
+	struct builtin_read_params params;
 	const char *r;
 	int i;
 
+	memset(&params, 0, sizeof(params));
+
 	while ((i = nextopt("p:u:rt:n:sd:")) != '\0') {
 		switch (i) {
 		case 'p':
-			opt_p = optionarg;
+			params.opt_p = optionarg;
 			break;
 		case 'n':
-			opt_n = optionarg;
+			params.opt_n = optionarg;
 			break;
 		case 's':
-			read_flags |= BUILTIN_READ_SILENT;
+			params.read_flags |= BUILTIN_READ_SILENT;
 			break;
 		case 't':
-			opt_t = optionarg;
+			params.opt_t = optionarg;
 			break;
 		case 'r':
-			read_flags |= BUILTIN_READ_RAW;
+			params.read_flags |= BUILTIN_READ_RAW;
 			break;
 		case 'u':
-			opt_u = optionarg;
+			params.opt_u = optionarg;
 			break;
 #if BASH_READ_D
 		case 'd':
-			opt_d = optionarg;
+			params.opt_d = optionarg;
 			break;
 #endif
 		default:
@@ -13781,21 +13813,16 @@ readcmd(int argc UNUSED_PARAM, char **ar
 		}
 	}
 
+	params.argv = argptr;
+	params.setvar = setvar0;
+	params.ifs = bltinlookup("IFS"); /* can be NULL */
+
 	/* "read -s" needs to save/restore termios, can't allow ^C
 	 * to jump out of it.
 	 */
  again:
 	INT_OFF;
-	r = shell_builtin_read(setvar0,
-		argptr,
-		bltinlookup("IFS"), /* can be NULL */
-		read_flags,
-		opt_n,
-		opt_p,
-		opt_t,
-		opt_u,
-		opt_d
-	);
+	r = shell_builtin_read(&params);
 	INT_ON;
 
 	if ((uintptr_t)r == 1 && errno == EINTR) {
@@ -13954,6 +13981,7 @@ init(void)
 			}
 		}
 
+		setvareq((char*)defifsvar, VTEXTFIXED);
 		setvareq((char*)defoptindvar, VTEXTFIXED);
 
 		setvar0("PPID", utoa(getppid()));
@@ -14000,12 +14028,16 @@ procargs(char **argv)
 
 	xargv = argv;
 	login_sh = xargv[0] && xargv[0][0] == '-';
+#if NUM_SCRIPTS > 0
+	if (minusc)
+		goto setarg0;
+#endif
 	arg0 = xargv[0];
 	/* if (xargv[0]) - mmm, this is always true! */
 		xargv++;
+	argptr = xargv;
 	for (i = 0; i < NOPTS; i++)
 		optlist[i] = 2;
-	argptr = xargv;
 	if (options(/*cmdline:*/ 1, &login_sh)) {
 		/* it already printed err message */
 		raise_exception(EXERROR);
@@ -14107,7 +14139,12 @@ extern int etext();
  * is used to figure out how far we had gotten.
  */
 int ash_main(int argc, char **argv) MAIN_EXTERNALLY_VISIBLE;
+#if NUM_SCRIPTS > 0
+int ash_main(int argc, char **argv)
+#else
 int ash_main(int argc UNUSED_PARAM, char **argv)
+#endif
+/* note: 'argc' is used only if embedded scripts are enabled */
 {
 	volatile smallint state;
 	struct jmploc jmploc;
@@ -14161,6 +14198,12 @@ int ash_main(int argc UNUSED_PARAM, char
 
 	init();
 	setstackmark(&smark);
+
+#if NUM_SCRIPTS > 0
+	if (argc < 0)
+		/* Non-NULL minusc tells procargs that an embedded script is being run */
+		minusc = get_script_content(-argc - 1);
+#endif
 	login_sh = procargs(argv);
 #if DEBUG
 	TRACE(("Shell args: "));
diff -urpN busybox-1.29.3/shell/ash_test/ash-glob/glob_altvalue1.right busybox-1.30.0/shell/ash_test/ash-glob/glob_altvalue1.right
--- busybox-1.29.3/shell/ash_test/ash-glob/glob_altvalue1.right	1970-01-01 01:00:00.000000000 +0100
+++ busybox-1.30.0/shell/ash_test/ash-glob/glob_altvalue1.right	2018-12-05 15:44:34.000000000 +0100
@@ -0,0 +1,7 @@
+1u: glob_altvalue1.tests
+2u: glob_altvalue1.t*
+3u: glob_altvalue1.t*
+4u: glob_altvalue1.t*
+1q: glob_altvalue1.t*
+2q: 'glob_altvalue1.t*'
+3q: glob_altvalue1.t*
diff -urpN busybox-1.29.3/shell/ash_test/ash-glob/glob_altvalue1.tests busybox-1.30.0/shell/ash_test/ash-glob/glob_altvalue1.tests
--- busybox-1.29.3/shell/ash_test/ash-glob/glob_altvalue1.tests	1970-01-01 01:00:00.000000000 +0100
+++ busybox-1.30.0/shell/ash_test/ash-glob/glob_altvalue1.tests	2018-12-05 15:44:34.000000000 +0100
@@ -0,0 +1,13 @@
+x=x
+
+echo 1u: ${x:+glob_altvalue1.t*}
+echo 2u: ${x:+'glob_altvalue1.t*'}
+echo 3u: ${x:+"glob_altvalue1.t*"}
+echo 4u: ${x:+glob_altvalue1.t\*}
+##echo 5u: ${x:+"glob_altvalue1.t\*"}
+
+echo 1q: "${x:+glob_altvalue1.t*}"
+echo 2q: "${x:+'glob_altvalue1.t*'}"
+echo 3q: "${x:+"glob_altvalue1.t*"}"
+##echo 4q: "${x:+glob_altvalue1.t\*}"
+##echo 5q: "${x:+"glob_altvalue1.t\*"}"
diff -urpN busybox-1.29.3/shell/ash_test/ash-glob/glob_bkslash_in_var.right busybox-1.30.0/shell/ash_test/ash-glob/glob_bkslash_in_var.right
--- busybox-1.29.3/shell/ash_test/ash-glob/glob_bkslash_in_var.right	1970-01-01 01:00:00.000000000 +0100
+++ busybox-1.30.0/shell/ash_test/ash-glob/glob_bkslash_in_var.right	2018-12-05 15:44:34.000000000 +0100
@@ -0,0 +1,4 @@
+Unquoted non-matching glob in var:'test*.TMP/\name_doesnt_exist'
+Unquoted matching glob in var:    'testdir.TMP/name'
+Quoted non-matching glob in var:  'test*.TMP/\name_doesnt_exist'
+Quoted matching glob in var:      'test*.TMP/\name'
diff -urpN busybox-1.29.3/shell/ash_test/ash-glob/glob_bkslash_in_var.tests busybox-1.30.0/shell/ash_test/ash-glob/glob_bkslash_in_var.tests
--- busybox-1.29.3/shell/ash_test/ash-glob/glob_bkslash_in_var.tests	1970-01-01 01:00:00.000000000 +0100
+++ busybox-1.30.0/shell/ash_test/ash-glob/glob_bkslash_in_var.tests	2018-12-05 15:44:34.000000000 +0100
@@ -0,0 +1,10 @@
+mkdir testdir.TMP
+>testdir.TMP/name
+a="test*.TMP/\name_doesnt_exist"
+b="test*.TMP/\name"
+printf "Unquoted non-matching glob in var:'%s'\n" $a
+printf "Unquoted matching glob in var:    '%s'\n" $b
+printf "Quoted non-matching glob in var:  '%s'\n" "$a"
+printf "Quoted matching glob in var:      '%s'\n" "$b"
+rm -f testdir.TMP/name
+rmdir testdir.TMP
diff -urpN busybox-1.29.3/shell/ash_test/ash-heredoc/heredoc.right busybox-1.30.0/shell/ash_test/ash-heredoc/heredoc.right
--- busybox-1.29.3/shell/ash_test/ash-heredoc/heredoc.right	2018-07-02 13:23:06.000000000 +0200
+++ busybox-1.30.0/shell/ash_test/ash-heredoc/heredoc.right	2018-12-05 15:44:34.000000000 +0100
@@ -16,6 +16,6 @@ tab 3
 abc
 def ghi
 jkl mno
-fff is a shell function
+fff is a function
 hi
 there
diff -urpN busybox-1.29.3/shell/ash_test/ash-heredoc/heredocA.right busybox-1.30.0/shell/ash_test/ash-heredoc/heredocA.right
--- busybox-1.29.3/shell/ash_test/ash-heredoc/heredocA.right	1970-01-01 01:00:00.000000000 +0100
+++ busybox-1.30.0/shell/ash_test/ash-heredoc/heredocA.right	2018-12-05 15:44:34.000000000 +0100
@@ -0,0 +1 @@
+Ok
diff -urpN busybox-1.29.3/shell/ash_test/ash-heredoc/heredocA.tests busybox-1.30.0/shell/ash_test/ash-heredoc/heredocA.tests
--- busybox-1.29.3/shell/ash_test/ash-heredoc/heredocA.tests	1970-01-01 01:00:00.000000000 +0100
+++ busybox-1.30.0/shell/ash_test/ash-heredoc/heredocA.tests	2018-12-05 15:44:34.000000000 +0100
@@ -0,0 +1,4 @@
+{ cat <<EOF ;
+Ok
+EOF
+}
diff -urpN busybox-1.29.3/shell/ash_test/ash-heredoc/heredocB.right busybox-1.30.0/shell/ash_test/ash-heredoc/heredocB.right
--- busybox-1.29.3/shell/ash_test/ash-heredoc/heredocB.right	1970-01-01 01:00:00.000000000 +0100
+++ busybox-1.30.0/shell/ash_test/ash-heredoc/heredocB.right	2018-12-05 15:44:34.000000000 +0100
@@ -0,0 +1,3 @@
+one - alpha
+two - beta
+three - gamma
diff -urpN busybox-1.29.3/shell/ash_test/ash-heredoc/heredocB.tests busybox-1.30.0/shell/ash_test/ash-heredoc/heredocB.tests
--- busybox-1.29.3/shell/ash_test/ash-heredoc/heredocB.tests	1970-01-01 01:00:00.000000000 +0100
+++ busybox-1.30.0/shell/ash_test/ash-heredoc/heredocB.tests	2018-12-05 15:44:34.000000000 +0100
@@ -0,0 +1,12 @@
+while read line1; do
+	read line2 <&3
+	echo $line1 - $line2
+done <<EOF1 3<<EOF2
+one
+two
+three
+EOF1
+alpha
+beta
+gamma
+EOF2
diff -urpN busybox-1.29.3/shell/ash_test/ash-heredoc/heredoc_after_compound1.right busybox-1.30.0/shell/ash_test/ash-heredoc/heredoc_after_compound1.right
--- busybox-1.29.3/shell/ash_test/ash-heredoc/heredoc_after_compound1.right	1970-01-01 01:00:00.000000000 +0100
+++ busybox-1.30.0/shell/ash_test/ash-heredoc/heredoc_after_compound1.right	2018-12-05 15:44:34.000000000 +0100
@@ -0,0 +1,2 @@
+Ok1
+Ok2
diff -urpN busybox-1.29.3/shell/ash_test/ash-heredoc/heredoc_after_compound1.tests busybox-1.30.0/shell/ash_test/ash-heredoc/heredoc_after_compound1.tests
--- busybox-1.29.3/shell/ash_test/ash-heredoc/heredoc_after_compound1.tests	1970-01-01 01:00:00.000000000 +0100
+++ busybox-1.30.0/shell/ash_test/ash-heredoc/heredoc_after_compound1.tests	2018-12-05 15:44:34.000000000 +0100
@@ -0,0 +1,3 @@
+{ cat <<EOF; }; echo Ok2
+Ok1
+EOF
diff -urpN busybox-1.29.3/shell/ash_test/ash-heredoc/heredoc_bkslash_newline2.right busybox-1.30.0/shell/ash_test/ash-heredoc/heredoc_bkslash_newline2.right
--- busybox-1.29.3/shell/ash_test/ash-heredoc/heredoc_bkslash_newline2.right	1970-01-01 01:00:00.000000000 +0100
+++ busybox-1.30.0/shell/ash_test/ash-heredoc/heredoc_bkslash_newline2.right	2018-12-05 15:44:34.000000000 +0100
@@ -0,0 +1 @@
+Ok1
diff -urpN busybox-1.29.3/shell/ash_test/ash-heredoc/heredoc_bkslash_newline2.tests busybox-1.30.0/shell/ash_test/ash-heredoc/heredoc_bkslash_newline2.tests
--- busybox-1.29.3/shell/ash_test/ash-heredoc/heredoc_bkslash_newline2.tests	1970-01-01 01:00:00.000000000 +0100
+++ busybox-1.30.0/shell/ash_test/ash-heredoc/heredoc_bkslash_newline2.tests	2018-12-05 15:44:34.000000000 +0100
@@ -0,0 +1,4 @@
+cat <<EOF
+Ok1
+EO\
+F
diff -urpN busybox-1.29.3/shell/ash_test/ash-heredoc/heredoc_empty3.right busybox-1.30.0/shell/ash_test/ash-heredoc/heredoc_empty3.right
--- busybox-1.29.3/shell/ash_test/ash-heredoc/heredoc_empty3.right	1970-01-01 01:00:00.000000000 +0100
+++ busybox-1.30.0/shell/ash_test/ash-heredoc/heredoc_empty3.right	2018-12-05 15:44:34.000000000 +0100
@@ -0,0 +1,2 @@
+
+Ok
diff -urpN busybox-1.29.3/shell/ash_test/ash-heredoc/heredoc_empty3.tests busybox-1.30.0/shell/ash_test/ash-heredoc/heredoc_empty3.tests
--- busybox-1.29.3/shell/ash_test/ash-heredoc/heredoc_empty3.tests	1970-01-01 01:00:00.000000000 +0100
+++ busybox-1.30.0/shell/ash_test/ash-heredoc/heredoc_empty3.tests	2018-12-05 15:44:34.000000000 +0100
@@ -0,0 +1,4 @@
+cat <<EOF
+
+Ok
+EOF
diff -urpN busybox-1.29.3/shell/ash_test/ash-misc/empty_for1.right busybox-1.30.0/shell/ash_test/ash-misc/empty_for1.right
--- busybox-1.29.3/shell/ash_test/ash-misc/empty_for1.right	1970-01-01 01:00:00.000000000 +0100
+++ busybox-1.30.0/shell/ash_test/ash-misc/empty_for1.right	2018-12-05 15:44:34.000000000 +0100
@@ -0,0 +1 @@
+Zero:0
diff -urpN busybox-1.29.3/shell/ash_test/ash-misc/empty_for1.tests busybox-1.30.0/shell/ash_test/ash-misc/empty_for1.tests
--- busybox-1.29.3/shell/ash_test/ash-misc/empty_for1.tests	1970-01-01 01:00:00.000000000 +0100
+++ busybox-1.30.0/shell/ash_test/ash-misc/empty_for1.tests	2018-12-05 15:44:34.000000000 +0100
@@ -0,0 +1,5 @@
+false
+for v; do
+	exit 2
+done
+echo Zero:$?
diff -urpN busybox-1.29.3/shell/ash_test/ash-misc/env_and_func.right busybox-1.30.0/shell/ash_test/ash-misc/env_and_func.right
--- busybox-1.29.3/shell/ash_test/ash-misc/env_and_func.right	2018-07-02 13:23:06.000000000 +0200
+++ busybox-1.30.0/shell/ash_test/ash-misc/env_and_func.right	2018-12-05 15:44:34.000000000 +0100
@@ -1,2 +1,2 @@
 var=val
-var=val
+var=old
diff -urpN busybox-1.29.3/shell/ash_test/ash-misc/env_and_func.tests busybox-1.30.0/shell/ash_test/ash-misc/env_and_func.tests
--- busybox-1.29.3/shell/ash_test/ash-misc/env_and_func.tests	2018-07-02 13:23:06.000000000 +0200
+++ busybox-1.30.0/shell/ash_test/ash-misc/env_and_func.tests	2018-12-05 15:44:34.000000000 +0100
@@ -3,6 +3,6 @@ f() { echo "var=$var"; }
 # bash: POSIXLY_CORRECT behavior is to "leak" new variable values
 # out of function invocations (similar to "special builtins" behavior);
 # but in "bash mode", they don't leak.
-# hush does not "leak" values. ash does.
+# hush does not "leak" values. ash used to, but now does not.
 var=val f
 echo "var=$var"
diff -urpN busybox-1.29.3/shell/ash_test/ash-quoting/dollar_altvalue1.right busybox-1.30.0/shell/ash_test/ash-quoting/dollar_altvalue1.right
--- busybox-1.29.3/shell/ash_test/ash-quoting/dollar_altvalue1.right	1970-01-01 01:00:00.000000000 +0100
+++ busybox-1.30.0/shell/ash_test/ash-quoting/dollar_altvalue1.right	2018-12-05 15:44:34.000000000 +0100
@@ -0,0 +1,16 @@
+Unquoted b c d
+|b|
+|c|
+|d|
+Unquoted 'b c' d
+|b c|
+|d|
+Unquoted "b c" d
+|b c|
+|d|
+Quoted b c d
+|b c d|
+Quoted 'b c' d
+|'b c' d|
+Quoted "b c" d
+|b c d|
diff -urpN busybox-1.29.3/shell/ash_test/ash-quoting/dollar_altvalue1.tests busybox-1.30.0/shell/ash_test/ash-quoting/dollar_altvalue1.tests
--- busybox-1.29.3/shell/ash_test/ash-quoting/dollar_altvalue1.tests	1970-01-01 01:00:00.000000000 +0100
+++ busybox-1.30.0/shell/ash_test/ash-quoting/dollar_altvalue1.tests	2018-12-05 15:44:34.000000000 +0100
@@ -0,0 +1,16 @@
+f() { for i; do echo "|$i|"; done; }
+x=a
+
+echo Unquoted b c d
+f ${x:+b c d}
+echo Unquoted "'b c' d"
+f ${x:+'b c' d}
+echo Unquoted '"b c" d'
+f ${x:+"b c" d}
+
+echo Quoted b c d
+f "${x:+b c d}"
+echo Quoted "'b c' d"
+f "${x:+'b c' d}"
+echo Quoted '"b c" d'
+f "${x:+"b c" d}"
diff -urpN busybox-1.29.3/shell/ash_test/ash-quoting/dollar_altvalue2.right busybox-1.30.0/shell/ash_test/ash-quoting/dollar_altvalue2.right
--- busybox-1.29.3/shell/ash_test/ash-quoting/dollar_altvalue2.right	1970-01-01 01:00:00.000000000 +0100
+++ busybox-1.30.0/shell/ash_test/ash-quoting/dollar_altvalue2.right	2018-12-05 15:44:34.000000000 +0100
@@ -0,0 +1,69 @@
+Unquoted '':
+start:
+||
+end
+start:
+||
+end
+start:
+||
+end
+start:
+||
+end
+start:
+||
+||
+end
+
+Unquoted "":
+start:
+||
+end
+start:
+||
+end
+start:
+||
+end
+start:
+||
+end
+start:
+||
+||
+end
+
+Quoted '':
+start:
+|''|
+end
+start:
+|'' |
+end
+start:
+| ''|
+end
+start:
+| '' |
+end
+start:
+|'' ''|
+end
+
+Quoted "":
+start:
+||
+end
+start:
+| |
+end
+start:
+| |
+end
+start:
+|  |
+end
+start:
+| |
+end
diff -urpN busybox-1.29.3/shell/ash_test/ash-quoting/dollar_altvalue2.tests busybox-1.30.0/shell/ash_test/ash-quoting/dollar_altvalue2.tests
--- busybox-1.29.3/shell/ash_test/ash-quoting/dollar_altvalue2.tests	1970-01-01 01:00:00.000000000 +0100
+++ busybox-1.30.0/shell/ash_test/ash-quoting/dollar_altvalue2.tests	2018-12-05 15:44:34.000000000 +0100
@@ -0,0 +1,33 @@
+f() { echo start:; for i; do echo "|$i|"; done; echo end; }
+x=a
+
+echo "Unquoted '':"
+f ${x:+''}
+f ${x:+'' }
+f ${x:+ ''}
+f ${x:+ '' }
+f ${x:+'' ''}
+
+echo
+echo 'Unquoted "":'
+f ${x:+""}
+f ${x:+"" }
+f ${x:+ ""}
+f ${x:+ "" }
+f ${x:+"" ""}
+
+echo
+echo "Quoted '':"
+f "${x:+''}"
+f "${x:+'' }"
+f "${x:+ ''}"
+f "${x:+ '' }"
+f "${x:+'' ''}"
+
+echo
+echo 'Quoted "":'
+f "${x:+""}"
+f "${x:+"" }"
+f "${x:+ ""}"
+f "${x:+ "" }"
+f "${x:+"" ""}"
diff -urpN busybox-1.29.3/shell/ash_test/ash-quoting/dollar_altvalue9.right busybox-1.30.0/shell/ash_test/ash-quoting/dollar_altvalue9.right
--- busybox-1.29.3/shell/ash_test/ash-quoting/dollar_altvalue9.right	1970-01-01 01:00:00.000000000 +0100
+++ busybox-1.30.0/shell/ash_test/ash-quoting/dollar_altvalue9.right	2018-12-05 15:44:34.000000000 +0100
@@ -0,0 +1,26 @@
+Unquoted 1:
+|a|
+|x y|
+|1|
+|2|
+||
+|1 2|
+|A|
+|B|
+|C D|
+|zb|
+Quoted 1:
+|a 'x y' 1 2 ''  1 2 A B C D zb|
+Unquoted 2:
+|ax y|
+|1|
+|2|
+||
+|1 2|
+|A|
+|B|
+|C D|
+|z|
+|b|
+Quoted 2:
+|a 'x y' 1 2 ''  1 2 A B C D z b|
diff -urpN busybox-1.29.3/shell/ash_test/ash-quoting/dollar_altvalue9.tests busybox-1.30.0/shell/ash_test/ash-quoting/dollar_altvalue9.tests
--- busybox-1.29.3/shell/ash_test/ash-quoting/dollar_altvalue9.tests	1970-01-01 01:00:00.000000000 +0100
+++ busybox-1.30.0/shell/ash_test/ash-quoting/dollar_altvalue9.tests	2018-12-05 15:44:34.000000000 +0100
@@ -0,0 +1,17 @@
+f() { for i; do echo "|$i|"; done; }
+
+echo Unquoted 1:
+x='1 2'; f a${x:+ 'x y' $x ''  "$x" `echo A B` "`echo C D`" z}b
+echo Quoted 1:
+x='1 2'; f "a${x:+ 'x y' $x ''  "$x" `echo A B` "`echo C D`" z}b"
+
+echo Unquoted 2:
+x='1 2'; f a${x:+'x y' $x ''  "$x" `echo A B` "`echo C D`" z }b
+echo Quoted 2:
+x='1 2'; f "a${x:+ 'x y' $x ''  "$x" `echo A B` "`echo C D`" z }b"
+
+#echo Unquoted 3:
+#e=
+#x='1 2'; f a${x:+'x y' $x ''  "$x" $e $e "$e" $e `echo A B` "`echo C D`" z }b
+#echo Quoted 3:
+#x='1 2'; f "a${x:+ 'x y' $x ''  "$x" $e $e "$e" $e `echo A B` "`echo C D`" z }b"
diff -urpN busybox-1.29.3/shell/ash_test/ash-quoting/dollar_repl_bash1.right busybox-1.30.0/shell/ash_test/ash-quoting/dollar_repl_bash1.right
--- busybox-1.29.3/shell/ash_test/ash-quoting/dollar_repl_bash1.right	1970-01-01 01:00:00.000000000 +0100
+++ busybox-1.30.0/shell/ash_test/ash-quoting/dollar_repl_bash1.right	2018-12-05 15:44:34.000000000 +0100
@@ -0,0 +1,14 @@
+|y|
+|zx|
+|y|
+|zx|
+|y zx|
+|y zx|
+|y|
+|zy|
+|z|
+|y|
+|zy|
+|z|
+|y zy z|
+|y zy z|
diff -urpN busybox-1.29.3/shell/ash_test/ash-quoting/dollar_repl_bash1.tests busybox-1.30.0/shell/ash_test/ash-quoting/dollar_repl_bash1.tests
--- busybox-1.29.3/shell/ash_test/ash-quoting/dollar_repl_bash1.tests	1970-01-01 01:00:00.000000000 +0100
+++ busybox-1.30.0/shell/ash_test/ash-quoting/dollar_repl_bash1.tests	2018-12-05 15:44:34.000000000 +0100
@@ -0,0 +1,12 @@
+f() { for i; do echo "|$i|"; done; }
+v=xx
+
+f ${v/'x'/"y z"}
+f ${v/"x"/'y z'}
+f "${v/'x'/"y z"}"
+f "${v/"x"/'y z'}"
+
+f ${v//'x'/"y z"}
+f ${v//"x"/'y z'}
+f "${v//'x'/"y z"}"
+f "${v//"x"/'y z'}"
diff -urpN busybox-1.29.3/shell/ash_test/ash-quoting/squote_in_varexp.right busybox-1.30.0/shell/ash_test/ash-quoting/squote_in_varexp.right
--- busybox-1.29.3/shell/ash_test/ash-quoting/squote_in_varexp.right	2018-07-02 13:23:06.000000000 +0200
+++ busybox-1.30.0/shell/ash_test/ash-quoting/squote_in_varexp.right	2018-12-05 15:44:34.000000000 +0100
@@ -1,5 +1,9 @@
 z
 z
+z
+z
+y
+y
 y
 y
 Ok:0
diff -urpN busybox-1.29.3/shell/ash_test/ash-quoting/squote_in_varexp.tests busybox-1.30.0/shell/ash_test/ash-quoting/squote_in_varexp.tests
--- busybox-1.29.3/shell/ash_test/ash-quoting/squote_in_varexp.tests	2018-07-02 13:23:06.000000000 +0200
+++ busybox-1.30.0/shell/ash_test/ash-quoting/squote_in_varexp.tests	2018-12-05 15:44:34.000000000 +0100
@@ -1,6 +1,10 @@
 x=yz
 echo ${x#'y'}
 echo "${x#'y'}"
+echo ${x#"y"}
+echo "${x#"y"}"
 echo ${x%'z'}
 echo "${x%'z'}"
+echo ${x%"z"}
+echo "${x%"z"}"
 echo Ok:$?
diff -urpN busybox-1.29.3/shell/ash_test/ash-quoting/squote_in_varexp2.right busybox-1.30.0/shell/ash_test/ash-quoting/squote_in_varexp2.right
--- busybox-1.29.3/shell/ash_test/ash-quoting/squote_in_varexp2.right	2018-07-02 13:23:06.000000000 +0200
+++ busybox-1.30.0/shell/ash_test/ash-quoting/squote_in_varexp2.right	2018-12-05 15:44:34.000000000 +0100
@@ -1,3 +1,5 @@
 Nothing:
 Nothing:
+Nothing:
+Nothing:
 Ok:0
diff -urpN busybox-1.29.3/shell/ash_test/ash-quoting/squote_in_varexp2.tests busybox-1.30.0/shell/ash_test/ash-quoting/squote_in_varexp2.tests
--- busybox-1.29.3/shell/ash_test/ash-quoting/squote_in_varexp2.tests	2018-07-02 13:23:06.000000000 +0200
+++ busybox-1.30.0/shell/ash_test/ash-quoting/squote_in_varexp2.tests	2018-12-05 15:44:34.000000000 +0100
@@ -1,4 +1,6 @@
 x='\\\\'
 printf Nothing:'%s\n' ${x#'\\\\'}
 printf Nothing:'%s\n' "${x#'\\\\'}"
+printf Nothing:'%s\n' ${x#"\\\\\\\\"}
+printf Nothing:'%s\n' "${x#"\\\\\\\\"}"
 echo Ok:$?
diff -urpN busybox-1.29.3/shell/ash_test/ash-redir/redir_script.tests busybox-1.30.0/shell/ash_test/ash-redir/redir_script.tests
--- busybox-1.29.3/shell/ash_test/ash-redir/redir_script.tests	2018-07-02 13:23:06.000000000 +0200
+++ busybox-1.30.0/shell/ash_test/ash-redir/redir_script.tests	2018-12-05 15:44:34.000000000 +0100
@@ -27,6 +27,10 @@ test x"$fds1" = x"$fds" \
 test x"$fds1" = x" 10>&- 3>&-" && \
 test x"$fds"  = x" 11>&- 3>&-" \
 && { echo "Ok: script fd is not closed"; exit 0; }
+# or we see that fd 3 moved to fd 10:
+test x"$fds1" = x" 3>&- 4>&-" && \
+test x"$fds"  = x" 10>&- 3>&-" \
+&& { echo "Ok: script fd is not closed"; exit 0; }
 
 echo "Bug: script fd is closed"
 echo "fds1:$fds1"
diff -urpN busybox-1.29.3/shell/ash_test/ash-vars/var_bash_pattern_starting_with_slash.right busybox-1.30.0/shell/ash_test/ash-vars/var_bash_pattern_starting_with_slash.right
--- busybox-1.29.3/shell/ash_test/ash-vars/var_bash_pattern_starting_with_slash.right	1970-01-01 01:00:00.000000000 +0100
+++ busybox-1.30.0/shell/ash_test/ash-vars/var_bash_pattern_starting_with_slash.right	2018-12-05 15:44:34.000000000 +0100
@@ -0,0 +1,2 @@
+-dev-ram
+/dev-am
diff -urpN busybox-1.29.3/shell/ash_test/ash-vars/var_bash_pattern_starting_with_slash.tests busybox-1.30.0/shell/ash_test/ash-vars/var_bash_pattern_starting_with_slash.tests
--- busybox-1.29.3/shell/ash_test/ash-vars/var_bash_pattern_starting_with_slash.tests	1970-01-01 01:00:00.000000000 +0100
+++ busybox-1.30.0/shell/ash_test/ash-vars/var_bash_pattern_starting_with_slash.tests	2018-12-05 15:44:34.000000000 +0100
@@ -0,0 +1,3 @@
+v=/dev/ram
+echo ${v////-}
+echo ${v///r/-}
diff -urpN busybox-1.29.3/shell/ash_test/ash-vars/var_leak.right busybox-1.30.0/shell/ash_test/ash-vars/var_leak.right
--- busybox-1.29.3/shell/ash_test/ash-vars/var_leak.right	2018-07-02 13:23:06.000000000 +0200
+++ busybox-1.30.0/shell/ash_test/ash-vars/var_leak.right	2018-12-05 15:44:34.000000000 +0100
@@ -1,4 +1,4 @@
 should be empty: ''
 should be empty: ''
 should be not empty: 'val2'
-should be not empty: 'val3'
+should be empty: ''
diff -urpN busybox-1.29.3/shell/ash_test/ash-vars/var_leak.tests busybox-1.30.0/shell/ash_test/ash-vars/var_leak.tests
--- busybox-1.29.3/shell/ash_test/ash-vars/var_leak.tests	2018-07-02 13:23:06.000000000 +0200
+++ busybox-1.30.0/shell/ash_test/ash-vars/var_leak.tests	2018-12-05 15:44:34.000000000 +0100
@@ -15,9 +15,7 @@ VAR=''
 VAR=val2 exec 2>&1
 echo "should be not empty: '$VAR'"
 
-# ash follows the "function call is a special builtin" rule here
-# (bash does not do it)
 f() { true; }
 VAR=''
 VAR=val3 f
-echo "should be not empty: '$VAR'"
+echo "should be empty: '$VAR'"
diff -urpN busybox-1.29.3/shell/ash_test/ash-vars/var_wordsplit_ifs5.right busybox-1.30.0/shell/ash_test/ash-vars/var_wordsplit_ifs5.right
--- busybox-1.29.3/shell/ash_test/ash-vars/var_wordsplit_ifs5.right	1970-01-01 01:00:00.000000000 +0100
+++ busybox-1.30.0/shell/ash_test/ash-vars/var_wordsplit_ifs5.right	2018-12-05 15:44:34.000000000 +0100
@@ -0,0 +1 @@
+Zero:0
diff -urpN busybox-1.29.3/shell/ash_test/ash-vars/var_wordsplit_ifs5.tests busybox-1.30.0/shell/ash_test/ash-vars/var_wordsplit_ifs5.tests
--- busybox-1.29.3/shell/ash_test/ash-vars/var_wordsplit_ifs5.tests	1970-01-01 01:00:00.000000000 +0100
+++ busybox-1.30.0/shell/ash_test/ash-vars/var_wordsplit_ifs5.tests	2018-12-05 15:44:34.000000000 +0100
@@ -0,0 +1,4 @@
+IFS=
+set --
+set -- $@ $*
+echo Zero:$#
diff -urpN busybox-1.29.3/shell/ash_test/ash-z_slow/many_ifs.tests busybox-1.30.0/shell/ash_test/ash-z_slow/many_ifs.tests
--- busybox-1.29.3/shell/ash_test/ash-z_slow/many_ifs.tests	2018-07-02 13:23:06.000000000 +0200
+++ busybox-1.30.0/shell/ash_test/ash-z_slow/many_ifs.tests	2018-12-05 15:44:34.000000000 +0100
@@ -229,8 +229,8 @@ do
 						'')	split "$d0$f1$d1$f2$d2$f3$d3" "[2]($f1)($f2)" "($f1)($f2)" ;;
 						' ')	;;
 						*)	x=$f2$d2$f3$d3
-							x=${x# } #was x=${x#' '} hush needs fixing for this to work
-							x=${x% } #was x=${x%' '}
+							x=${x#' '}
+							x=${x%' '}
 							split "$d0$f1$d1$f2$d2$f3$d3" "[3]($f1)($f2)($f3)" "($f1)($x)"
 							;;
 						esac
diff -urpN busybox-1.29.3/shell/cttyhack.c busybox-1.30.0/shell/cttyhack.c
--- busybox-1.29.3/shell/cttyhack.c	2018-07-02 13:23:06.000000000 +0200
+++ busybox-1.30.0/shell/cttyhack.c	2018-12-30 16:14:20.000000000 +0100
@@ -5,7 +5,7 @@
  * Licensed under GPLv2, see file LICENSE in this source tree.
  */
 //config:config CTTYHACK
-//config:	bool "cttyhack (2.5 kb)"
+//config:	bool "cttyhack (2.4 kb)"
 //config:	default y
 //config:	help
 //config:	One common problem reported on the mailing list is the "can't
diff -urpN busybox-1.29.3/shell/hush.c busybox-1.30.0/shell/hush.c
--- busybox-1.29.3/shell/hush.c	2018-07-02 13:23:06.000000000 +0200
+++ busybox-1.30.0/shell/hush.c	2018-12-30 16:14:20.000000000 +0100
@@ -93,7 +93,7 @@
  * add =~ regex match operator: STR =~ REGEX
  */
 //config:config HUSH
-//config:	bool "hush (64 kb)"
+//config:	bool "hush (68 kb)"
 //config:	default y
 //config:	help
 //config:	hush is a small shell. It handles the normal flow control
@@ -157,7 +157,7 @@
 //config:	but no separate process group is formed.
 //config:
 //config:config HUSH_TICK
-//config:	bool "Support process substitution"
+//config:	bool "Support command substitution"
 //config:	default y
 //config:	depends on HUSH || SH_IS_HUSH || BASH_IS_HUSH
 //config:	help
@@ -357,6 +357,9 @@
 #else
 # define CLEAR_RANDOM_T(rnd) ((void)0)
 #endif
+#ifndef O_CLOEXEC
+# define O_CLOEXEC 0
+#endif
 #ifndef F_DUPFD_CLOEXEC
 # define F_DUPFD_CLOEXEC F_DUPFD
 #endif
@@ -364,6 +367,11 @@
 # define PIPE_BUF 4096  /* amount of buffering in a pipe */
 #endif
 
+#if ENABLE_FEATURE_SH_EMBEDDED_SCRIPTS && !(ENABLE_ASH || ENABLE_SH_IS_ASH || ENABLE_BASH_IS_ASH)
+# include "embedded_scripts.h"
+#else
+# define NUM_SCRIPTS 0
+#endif
 
 /* So far, all bash compat is controlled by one config option */
 /* Separate defines document which part of code implements what */
@@ -439,21 +447,22 @@
 
 /* If you comment out one of these below, it will be #defined later
  * to perform debug printfs to stderr: */
-#define debug_printf(...)        do {} while (0)
+#define debug_printf(...)         do {} while (0)
 /* Finer-grained debug switches */
-#define debug_printf_parse(...)  do {} while (0)
-#define debug_print_tree(a, b)   do {} while (0)
-#define debug_printf_exec(...)   do {} while (0)
-#define debug_printf_env(...)    do {} while (0)
-#define debug_printf_jobs(...)   do {} while (0)
-#define debug_printf_expand(...) do {} while (0)
-#define debug_printf_varexp(...) do {} while (0)
-#define debug_printf_glob(...)   do {} while (0)
-#define debug_printf_redir(...)  do {} while (0)
-#define debug_printf_list(...)   do {} while (0)
-#define debug_printf_subst(...)  do {} while (0)
-#define debug_printf_prompt(...) do {} while (0)
-#define debug_printf_clean(...)  do {} while (0)
+#define debug_printf_parse(...)   do {} while (0)
+#define debug_printf_heredoc(...) do {} while (0)
+#define debug_print_tree(a, b)    do {} while (0)
+#define debug_printf_exec(...)    do {} while (0)
+#define debug_printf_env(...)     do {} while (0)
+#define debug_printf_jobs(...)    do {} while (0)
+#define debug_printf_expand(...)  do {} while (0)
+#define debug_printf_varexp(...)  do {} while (0)
+#define debug_printf_glob(...)    do {} while (0)
+#define debug_printf_redir(...)   do {} while (0)
+#define debug_printf_list(...)    do {} while (0)
+#define debug_printf_subst(...)   do {} while (0)
+#define debug_printf_prompt(...)  do {} while (0)
+#define debug_printf_clean(...)   do {} while (0)
 
 #define ERR_PTR ((void*)(long)1)
 
@@ -534,6 +543,7 @@ typedef struct o_string {
 	 * possibly empty one: word"", wo''rd etc. */
 	smallint has_quoted_part;
 	smallint has_empty_slot;
+	smallint ended_in_ifs;
 } o_string;
 enum {
 	EXP_FLAG_SINGLEWORD     = 0x80, /* must be 0x80 */
@@ -554,11 +564,27 @@ static const char *const assignment_flag
 };
 #endif
 
+/* We almost can use standard FILE api, but we need an ability to move
+ * its fd when redirects coincide with it. No api exists for that
+ * (RFE for it at https://sourceware.org/bugzilla/show_bug.cgi?id=21902).
+ * HFILE is our internal alternative. Only supports reading.
+ * Since we now can, we incorporate linked list of all opened HFILEs
+ * into the struct (used to be a separate mini-list).
+ */
+typedef struct HFILE {
+	char *cur;
+	char *end;
+	struct HFILE *next_hfile;
+	int is_stdin;
+	int fd;
+	char buf[1024];
+} HFILE;
+
 typedef struct in_str {
 	const char *p;
 	int peek_buf[2];
 	int last_char;
-	FILE *file;
+	HFILE *file;
 } in_str;
 
 /* The descrip member of this structure is only used to make
@@ -812,14 +838,6 @@ enum {
 	NUM_OPT_O
 };
 
-
-struct FILE_list {
-	struct FILE_list *next;
-	FILE *fp;
-	int fd;
-};
-
-
 /* "Globals" within this file */
 /* Sorted roughly by size (smaller offsets == smaller code) */
 struct globals {
@@ -952,7 +970,7 @@ struct globals {
 	unsigned lineno;
 	char *lineno_var;
 #endif
-	struct FILE_list *FILE_list;
+	HFILE *HFILE_list;
 	/* Which signals have non-DFL handler (even with no traps set)?
 	 * Set at the start to:
 	 * (SIGQUIT + maybe SPECIAL_INTERACTIVE_SIGS + maybe SPECIAL_JOBSTOP_SIGS)
@@ -977,7 +995,16 @@ struct globals {
 #if ENABLE_HUSH_MEMLEAK
 	unsigned long memleak_value;
 #endif
-#if HUSH_DEBUG
+#if ENABLE_HUSH_MODE_X
+	unsigned x_mode_depth;
+	/* "set -x" output should not be redirectable with subsequent 2>FILE.
+	 * We dup fd#2 to x_mode_fd when "set -x" is executed, and use it
+	 * for all subsequent output.
+	 */
+	int x_mode_fd;
+	o_string x_mode_buf;
+#endif
+#if HUSH_DEBUG >= 2
 	int debug_indent;
 #endif
 	struct sigaction sa;
@@ -1199,7 +1226,7 @@ static const struct built_in_command blt
 
 /* Debug printouts.
  */
-#if HUSH_DEBUG
+#if HUSH_DEBUG >= 2
 /* prevent disasters with G.debug_indent < 0 */
 # define indent() fdprintf(2, "%*s", (G.debug_indent * 2) & 0xff, "")
 # define debug_enter() (G.debug_indent++)
@@ -1218,6 +1245,10 @@ static const struct built_in_command blt
 # define debug_printf_parse(...) (indent(), fdprintf(2, __VA_ARGS__))
 #endif
 
+#ifndef debug_printf_heredoc
+# define debug_printf_heredoc(...) (indent(), fdprintf(2, __VA_ARGS__))
+#endif
+
 #ifndef debug_printf_exec
 #define debug_printf_exec(...) (indent(), fdprintf(2, __VA_ARGS__))
 #endif
@@ -1557,83 +1588,127 @@ static int xdup_CLOEXEC_and_close(int fd
 }
 
 
-/* Manipulating the list of open FILEs */
-static FILE *remember_FILE(FILE *fp)
+/* Manipulating HFILEs */
+static HFILE *hfopen(const char *name)
 {
-	if (fp) {
-		struct FILE_list *n = xmalloc(sizeof(*n));
-		n->next = G.FILE_list;
-		G.FILE_list = n;
-		n->fp = fp;
-		n->fd = fileno(fp);
-		close_on_exec_on(n->fd);
+	HFILE *fp;
+	int fd;
+
+	fd = STDIN_FILENO;
+	if (name) {
+		fd = open(name, O_RDONLY | O_CLOEXEC);
+		if (fd < 0)
+			return NULL;
+		if (O_CLOEXEC == 0) /* ancient libc */
+			close_on_exec_on(fd);
 	}
+
+	fp = xmalloc(sizeof(*fp));
+	fp->is_stdin = (name == NULL);
+	fp->fd = fd;
+	fp->cur = fp->end = fp->buf;
+	fp->next_hfile = G.HFILE_list;
+	G.HFILE_list = fp;
 	return fp;
 }
-static void fclose_and_forget(FILE *fp)
+static void hfclose(HFILE *fp)
 {
-	struct FILE_list **pp = &G.FILE_list;
+	HFILE **pp = &G.HFILE_list;
 	while (*pp) {
-		struct FILE_list *cur = *pp;
-		if (cur->fp == fp) {
-			*pp = cur->next;
-			free(cur);
+		HFILE *cur = *pp;
+		if (cur == fp) {
+			*pp = cur->next_hfile;
 			break;
 		}
-		pp = &cur->next;
+		pp = &cur->next_hfile;
 	}
-	fclose(fp);
+	if (fp->fd >= 0)
+		close(fp->fd);
+	free(fp);
 }
-static int save_FILEs_on_redirect(int fd, int avoid_fd)
+static int refill_HFILE_and_getc(HFILE *fp)
 {
-	struct FILE_list *fl = G.FILE_list;
+	int n;
+
+	if (fp->fd < 0) {
+		/* Already saw EOF */
+		return EOF;
+	}
+	/* Try to buffer more input */
+	fp->cur = fp->buf;
+	n = safe_read(fp->fd, fp->buf, sizeof(fp->buf));
+	if (n < 0) {
+		bb_perror_msg("read error");
+		n = 0;
+	}
+	fp->end = fp->buf + n;
+	if (n == 0) {
+		/* EOF/error */
+		close(fp->fd);
+		fp->fd = -1;
+		return EOF;
+	}
+	return (unsigned char)(*fp->cur++);
+}
+/* Inlined for common case of non-empty buffer.
+ */
+static ALWAYS_INLINE int hfgetc(HFILE *fp)
+{
+	if (fp->cur < fp->end)
+		return (unsigned char)(*fp->cur++);
+	/* Buffer empty */
+	return refill_HFILE_and_getc(fp);
+}
+static int move_HFILEs_on_redirect(int fd, int avoid_fd)
+{
+	HFILE *fl = G.HFILE_list;
 	while (fl) {
 		if (fd == fl->fd) {
 			/* We use it only on script files, they are all CLOEXEC */
 			fl->fd = xdup_CLOEXEC_and_close(fd, avoid_fd);
 			debug_printf_redir("redirect_fd %d: matches a script fd, moving it to %d\n", fd, fl->fd);
-			return 1;
+			return 1; /* "found and moved" */
 		}
-		fl = fl->next;
+		fl = fl->next_hfile;
 	}
-	return 0;
-}
-static void restore_redirected_FILEs(void)
-{
-	struct FILE_list *fl = G.FILE_list;
-	while (fl) {
-		int should_be = fileno(fl->fp);
-		if (fl->fd != should_be) {
-			debug_printf_redir("restoring script fd from %d to %d\n", fl->fd, should_be);
-			xmove_fd(fl->fd, should_be);
-			fl->fd = should_be;
-		}
-		fl = fl->next;
+#if ENABLE_HUSH_MODE_X
+	if (G.x_mode_fd > 0 && fd == G.x_mode_fd) {
+		G.x_mode_fd = xdup_CLOEXEC_and_close(fd, avoid_fd);
+		return 1; /* "found and moved" */
 	}
+#endif
+	return 0; /* "not in the list" */
 }
 #if ENABLE_FEATURE_SH_STANDALONE && BB_MMU
-static void close_all_FILE_list(void)
+static void close_all_HFILE_list(void)
 {
-	struct FILE_list *fl = G.FILE_list;
+	HFILE *fl = G.HFILE_list;
 	while (fl) {
-		/* fclose would also free FILE object.
+		/* hfclose would also free HFILE object.
 		 * It is disastrous if we share memory with a vforked parent.
 		 * I'm not sure we never come here after vfork.
 		 * Therefore just close fd, nothing more.
+		 *
+		 * ">" instead of ">=": we don't close fd#0,
+		 * interactive shell uses hfopen(NULL) as stdin input
+		 * which has fl->fd == 0, but fd#0 gets redirected in pipes.
+		 * If we'd close it here, then e.g. interactive "set | sort"
+		 * with NOFORKed sort, would have sort's input fd closed.
 		 */
-		/*fclose(fl->fp); - unsafe */
-		close(fl->fd);
-		fl = fl->next;
+		if (fl->fd > 0)
+			/*hfclose(fl); - unsafe */
+			close(fl->fd);
+		fl = fl->next_hfile;
 	}
 }
 #endif
-static int fd_in_FILEs(int fd)
+static int fd_in_HFILEs(int fd)
 {
-	struct FILE_list *fl = G.FILE_list;
+	HFILE *fl = G.HFILE_list;
 	while (fl) {
 		if (fl->fd == fd)
 			return 1;
-		fl = fl->next;
+		fl = fl->next_hfile;
 	}
 	return 0;
 }
@@ -2327,6 +2402,12 @@ static int set_local_var(char *str, unsi
 	return 0;
 }
 
+static void FAST_FUNC set_local_var_from_halves(const char *name, const char *val)
+{
+	char *var = xasprintf("%s=%s", name, val);
+	set_local_var(var, /*flag:*/ 0);
+}
+
 /* Used at startup and after each cd */
 static void set_pwd_var(unsigned flag)
 {
@@ -2373,15 +2454,6 @@ static int unset_local_var(const char *n
 }
 #endif
 
-#if BASH_HOSTNAME_VAR || ENABLE_FEATURE_SH_MATH || ENABLE_HUSH_READ || ENABLE_HUSH_GETOPTS \
- || (ENABLE_HUSH_INTERACTIVE && ENABLE_FEATURE_EDITING_FANCY_PROMPT)
-static void FAST_FUNC set_local_var_from_halves(const char *name, const char *val)
-{
-	char *var = xasprintf("%s=%s", name, val);
-	set_local_var(var, /*flag:*/ 0);
-}
-#endif
-
 
 /*
  * Helpers for "var1=val1 var2=val2 cmd" feature
@@ -2423,35 +2495,33 @@ static void set_vars_and_save_old(char *
 		char *eq;
 
 		eq = strchr(*s, '=');
-		if (eq) {
-			var_pp = get_ptr_to_local_var(*s, eq - *s);
-			if (var_pp) {
-				var_p = *var_pp;
-				if (var_p->flg_read_only) {
-					char **p;
-					bb_error_msg("%s: readonly variable", *s);
-					/*
-					 * "VAR=V BLTIN" unsets VARs after BLTIN completes.
-					 * If VAR is readonly, leaving it in the list
-					 * after asssignment error (msg above)
-					 * causes doubled error message later, on unset.
-					 */
-					debug_printf_env("removing/freeing '%s' element\n", *s);
-					free(*s);
-					p = s;
-					do { *p = p[1]; p++; } while (*p);
-					goto next;
-				}
-				/* below, set_local_var() with nest level will
-				 * "shadow" (remove) this variable from
-				 * global linked list.
-				 */
-			}
-			debug_printf_env("%s: env override '%s'/%u\n", __func__, *s, G.var_nest_level);
-			set_local_var(*s, (G.var_nest_level << SETFLAG_VARLVL_SHIFT) | SETFLAG_EXPORT);
-		} else if (HUSH_DEBUG) {
+		if (HUSH_DEBUG && !eq)
 			bb_error_msg_and_die("BUG in varexp4");
+		var_pp = get_ptr_to_local_var(*s, eq - *s);
+		if (var_pp) {
+			var_p = *var_pp;
+			if (var_p->flg_read_only) {
+				char **p;
+				bb_error_msg("%s: readonly variable", *s);
+				/*
+				 * "VAR=V BLTIN" unsets VARs after BLTIN completes.
+				 * If VAR is readonly, leaving it in the list
+				 * after asssignment error (msg above)
+				 * causes doubled error message later, on unset.
+				 */
+				debug_printf_env("removing/freeing '%s' element\n", *s);
+				free(*s);
+				p = s;
+				do { *p = p[1]; p++; } while (*p);
+				goto next;
+			}
+			/* below, set_local_var() with nest level will
+			 * "shadow" (remove) this variable from
+			 * global linked list.
+			 */
 		}
+		debug_printf_env("%s: env override '%s'/%u\n", __func__, *s, G.var_nest_level);
+		set_local_var(*s, (G.var_nest_level << SETFLAG_VARLVL_SHIFT) | SETFLAG_EXPORT);
 		s++;
  next: ;
 	}
@@ -2470,7 +2540,7 @@ static void reinit_unicode_for_hush(void
 	 */
 	if (ENABLE_FEATURE_CHECK_UNICODE_IN_ENV
 	 || ENABLE_UNICODE_USING_LOCALE
-        ) {
+	) {
 		const char *s = get_local_var_value("LC_ALL");
 		if (!s) s = get_local_var_value("LC_CTYPE");
 		if (!s) s = get_local_var_value("LANG");
@@ -2576,7 +2646,7 @@ static int get_user_input(struct in_str
 		}
 		fflush_all();
 //FIXME: here ^C or SIGINT will have effect only after <Enter>
-		r = fgetc(i->file);
+		r = hfgetc(i->file);
 		/* In !ENABLE_FEATURE_EDITING we don't use read_line_input,
 		 * no ^C masking happens during fgetc, no special code for ^C:
 		 * it generates SIGINT as usual.
@@ -2596,22 +2666,22 @@ static int fgetc_interactive(struct in_s
 {
 	int ch;
 	/* If it's interactive stdin, get new line. */
-	if (G_interactive_fd && i->file == stdin) {
+	if (G_interactive_fd && i->file->is_stdin) {
 		/* Returns first char (or EOF), the rest is in i->p[] */
 		ch = get_user_input(i);
 		G.promptmode = 1; /* PS2 */
 		debug_printf_prompt("%s promptmode=%d\n", __func__, G.promptmode);
 	} else {
 		/* Not stdin: script file, sourced file, etc */
-		do ch = fgetc(i->file); while (ch == '\0');
+		do ch = hfgetc(i->file); while (ch == '\0');
 	}
 	return ch;
 }
 #else
-static inline int fgetc_interactive(struct in_str *i)
+static ALWAYS_INLINE int fgetc_interactive(struct in_str *i)
 {
 	int ch;
-	do ch = fgetc(i->file); while (ch == '\0');
+	do ch = hfgetc(i->file); while (ch == '\0');
 	return ch;
 }
 #endif  /* INTERACTIVE */
@@ -2726,7 +2796,7 @@ static int i_peek2(struct in_str *i)
 	ch = i->peek_buf[1];
 	if (ch == 0) {
 		/* We did not read it yet, get it now */
-		do ch = fgetc(i->file); while (ch == '\0');
+		do ch = hfgetc(i->file); while (ch == '\0');
 		i->peek_buf[1] = ch;
 	}
 
@@ -2770,10 +2840,10 @@ static int i_peek_and_eat_bkslash_nl(str
 	}
 }
 
-static void setup_file_in_str(struct in_str *i, FILE *f)
+static void setup_file_in_str(struct in_str *i, HFILE *fp)
 {
 	memset(i, 0, sizeof(*i));
-	i->file = f;
+	i->file = fp;
 	/* i->p = NULL; */
 }
 
@@ -2798,13 +2868,13 @@ static void o_reset_to_empty_unquoted(o_
 		o->data[0] = '\0';
 }
 
-static void o_free(o_string *o)
+static void o_free_and_set_NULL(o_string *o)
 {
 	free(o->data);
 	memset(o, 0, sizeof(*o));
 }
 
-static ALWAYS_INLINE void o_free_unsafe(o_string *o)
+static ALWAYS_INLINE void o_free(o_string *o)
 {
 	free(o->data);
 }
@@ -2853,6 +2923,11 @@ static void o_addstr(o_string *o, const
 	o_addblock(o, str, strlen(str));
 }
 
+static void o_addstr_with_NUL(o_string *o, const char *str)
+{
+	o_addblock(o, str, strlen(str) + 1);
+}
+
 #if !BB_MMU
 static void nommu_addchr(o_string *o, int ch)
 {
@@ -2863,10 +2938,36 @@ static void nommu_addchr(o_string *o, in
 # define nommu_addchr(o, str) ((void)0)
 #endif
 
-static void o_addstr_with_NUL(o_string *o, const char *str)
+#if ENABLE_HUSH_MODE_X
+static void x_mode_addchr(int ch)
 {
-	o_addblock(o, str, strlen(str) + 1);
+	o_addchr(&G.x_mode_buf, ch);
 }
+static void x_mode_addstr(const char *str)
+{
+	o_addstr(&G.x_mode_buf, str);
+}
+static void x_mode_addblock(const char *str, int len)
+{
+	o_addblock(&G.x_mode_buf, str, len);
+}
+static void x_mode_prefix(void)
+{
+	int n = G.x_mode_depth;
+	do x_mode_addchr('+'); while (--n >= 0);
+}
+static void x_mode_flush(void)
+{
+	int len = G.x_mode_buf.length;
+	if (len <= 0)
+		return;
+	if (G.x_mode_fd > 0) {
+		G.x_mode_buf.data[len] = '\n';
+		full_write(G.x_mode_fd, G.x_mode_buf.data, len + 1);
+	}
+	G.x_mode_buf.length = 0;
+}
+#endif
 
 /*
  * HUSH_BRACE_EXPANSION code needs corresponding quoting on variable expansion side.
@@ -3021,6 +3122,13 @@ static int o_save_ptr_helper(o_string *o
 			o->data = xrealloc(o->data, o->maxlen + 1);
 			list = (char**)o->data;
 			memmove(list + n + 0x10, list + n, string_len);
+			/*
+			 * expand_on_ifs() has a "previous argv[] ends in IFS?"
+			 * check. (grep for -prev-ifs-check-).
+			 * Ensure that argv[-1][last] is not garbage
+			 * but zero bytes, to save index check there.
+			 */
+			list[n + 0x10 - 1] = 0;
 			o->length += 0x10 * sizeof(list[0]);
 		} else {
 			debug_printf_list("list[%d]=%d string_start=%d\n",
@@ -3048,6 +3156,41 @@ static int o_get_last_ptr(o_string *o, i
 	return ((int)(uintptr_t)list[n-1]) + string_start;
 }
 
+/*
+ * Globbing routines.
+ *
+ * Most words in commands need to be globbed, even ones which are
+ * (single or double) quoted. This stems from the possiblity of
+ * constructs like "abc"* and 'abc'* - these should be globbed.
+ * Having a different code path for fully-quoted strings ("abc",
+ * 'abc') would only help performance-wise, but we still need
+ * code for partially-quoted strings.
+ *
+ * Unfortunately, if we want to match bash and ash behavior in all cases,
+ * the logic can't be "shell-syntax argument is first transformed
+ * to a string, then globbed, and if globbing does not match anything,
+ * it is used verbatim". Here are two examples where it fails:
+ *
+ * 	echo 'b\*'?
+ *
+ * The globbing can't be avoided (because of '?' at the end).
+ * The glob pattern is: b\\\*? - IOW, both \ and * are literals
+ * and are glob-escaped. If this does not match, bash/ash print b\*?
+ * - IOW: they "unbackslash" the glob pattern.
+ * Now, look at this:
+ *
+ * 	v='\\\*'; echo b$v?
+ *
+ * The glob pattern is the same here: b\\\*? - the unquoted $v expansion
+ * should be used as glob pattern with no changes. However, if glob
+ * does not match, bash/ash print b\\\*? - NOT THE SAME as first example!
+ *
+ * ash implements this by having an encoded representation of the word
+ * to glob, which IS NOT THE SAME as the glob pattern - it has more data.
+ * Glob pattern is derived from it. If glob fails, the decision what result
+ * should be is made using that encoded representation. Not glob pattern.
+ */
+
 #if ENABLE_HUSH_BRACE_EXPANSION
 /* There in a GNU extension, GLOB_BRACE, but it is not usable:
  * first, it processes even {a} (no commas), second,
@@ -3343,7 +3486,6 @@ static char **o_finalize_list(o_string *
 	char **list;
 	int string_start;
 
-	n = o_save_ptr(o, n); /* force growth for list[n] if necessary */
 	if (DEBUG_EXPAND)
 		debug_print_list("finalized", o, n);
 	debug_printf_expand("finalized n:%d\n", n);
@@ -3531,6 +3673,8 @@ static void debug_print_tree(struct pipe
 				fdprintf(2, " '%s'", *argv);
 				argv++;
 			}
+			if (command->redirects)
+				fdprintf(2, " {redir}");
 			fdprintf(2, "\n");
 			prn++;
 		}
@@ -3854,7 +3998,7 @@ static const struct reserved_combo* rese
 			int len = old->as_string.length;
 			/* Concatenate halves */
 			o_addstr(&old->as_string, ctx->as_string.data);
-			o_free_unsafe(&ctx->as_string);
+			o_free(&ctx->as_string);
 			/* Find where leading keyword starts in first half */
 			str = old->as_string.data + len;
 			if (str > old->as_string.data)
@@ -4228,6 +4372,14 @@ static char *fetch_till_str(o_string *as
 	int prev = 0; /* not \ */
 	int ch;
 
+	/* Starting with "" is necessary for this case:
+	 * cat <<EOF
+	 *
+	 * xxx
+	 * EOF
+	 */
+	heredoc.data = xzalloc(1); /* start as "", not as NULL */
+
 	goto jump_in;
 
 	while (1) {
@@ -4237,9 +4389,10 @@ static char *fetch_till_str(o_string *as
 		if (ch == '\n' || ch == EOF) {
  check_heredoc_end:
 			if ((heredoc_flags & HEREDOC_QUOTED) || prev != '\\') {
+				/* End-of-line, and not a line continuation */
 				if (strcmp(heredoc.data + past_EOL, word) == 0) {
 					heredoc.data[past_EOL] = '\0';
-					debug_printf_parse("parsed heredoc '%s'\n", heredoc.data);
+					debug_printf_heredoc("parsed '%s' heredoc '%s'\n", word, heredoc.data);
 					return heredoc.data;
 				}
 				if (ch == '\n') {
@@ -4262,17 +4415,32 @@ static char *fetch_till_str(o_string *as
 					if (ch == '\n')
 						goto check_heredoc_end;
 				}
+			} else {
+				/* Backslash-line continuation in an unquoted
+				 * heredoc. This does not need special handling
+				 * for heredoc body (unquoted heredocs are
+				 * expanded on "execution" and that would take
+				 * care of this case too), but not the case
+				 * of line continuation *in terminator*:
+				 *  cat <<EOF
+				 *  Ok1
+				 *  EO\
+				 *  F
+				 */
+				heredoc.data[--heredoc.length] = '\0';
+				prev = 0; /* not '\' */
+				continue;
 			}
 		}
 		if (ch == EOF) {
-			o_free_unsafe(&heredoc);
-			return NULL;
+			o_free(&heredoc);
+			return NULL; /* error */
 		}
 		o_addchr(&heredoc, ch);
 		nommu_addchr(as_string, ch);
 		if (prev == '\\' && ch == '\\')
 			/* Correctly handle foo\\<eol> (not a line cont.) */
-			prev = 0; /* not \ */
+			prev = 0; /* not '\' */
 		else
 			prev = ch;
 	}
@@ -4281,21 +4449,24 @@ static char *fetch_till_str(o_string *as
 /* Look at entire parse tree for not-yet-loaded REDIRECT_HEREDOCs
  * and load them all. There should be exactly heredoc_cnt of them.
  */
-static int fetch_heredocs(int heredoc_cnt, struct parse_context *ctx, struct in_str *input)
+#if BB_MMU
+#define fetch_heredocs(as_string, pi, heredoc_cnt, input) \
+	fetch_heredocs(pi, heredoc_cnt, input)
+#endif
+static int fetch_heredocs(o_string *as_string, struct pipe *pi, int heredoc_cnt, struct in_str *input)
 {
-	struct pipe *pi = ctx->list_head;
-
 	while (pi && heredoc_cnt) {
 		int i;
 		struct command *cmd = pi->cmds;
 
-		debug_printf_parse("fetch_heredocs: num_cmds:%d cmd argv0:'%s'\n",
+		debug_printf_heredoc("fetch_heredocs: num_cmds:%d cmd argv0:'%s'\n",
 				pi->num_cmds,
-				cmd->argv ? cmd->argv[0] : "NONE");
+				cmd->argv ? cmd->argv[0] : "NONE"
+		);
 		for (i = 0; i < pi->num_cmds; i++) {
 			struct redir_struct *redir = cmd->redirects;
 
-			debug_printf_parse("fetch_heredocs: %d cmd argv0:'%s'\n",
+			debug_printf_heredoc("fetch_heredocs: %d cmd argv0:'%s'\n",
 					i, cmd->argv ? cmd->argv[0] : "NONE");
 			while (redir) {
 				if (redir->rd_type == REDIRECT_HEREDOC) {
@@ -4303,11 +4474,11 @@ static int fetch_heredocs(int heredoc_cn
 
 					redir->rd_type = REDIRECT_HEREDOC2;
 					/* redir->rd_dup is (ab)used to indicate <<- */
-					p = fetch_till_str(&ctx->as_string, input,
+					p = fetch_till_str(as_string, input,
 							redir->rd_filename, redir->rd_dup);
 					if (!p) {
 						syntax_error("unexpected EOF in here document");
-						return 1;
+						return -1;
 					}
 					free(redir->rd_filename);
 					redir->rd_filename = p;
@@ -4315,31 +4486,36 @@ static int fetch_heredocs(int heredoc_cn
 				}
 				redir = redir->next;
 			}
+			if (cmd->group) {
+				//bb_error_msg("%s:%u heredoc_cnt:%d", __func__, __LINE__, heredoc_cnt);
+				heredoc_cnt = fetch_heredocs(as_string, cmd->group, heredoc_cnt, input);
+				//bb_error_msg("%s:%u heredoc_cnt:%d", __func__, __LINE__, heredoc_cnt);
+				if (heredoc_cnt < 0)
+					return heredoc_cnt; /* error */
+			}
 			cmd++;
 		}
 		pi = pi->next;
 	}
-#if 0
-	/* Should be 0. If it isn't, it's a parse error */
-	if (heredoc_cnt)
-		bb_error_msg_and_die("heredoc BUG 2");
-#endif
-	return 0;
+	return heredoc_cnt;
 }
 
 
 static int run_list(struct pipe *pi);
 #if BB_MMU
-#define parse_stream(pstring, input, end_trigger) \
-	parse_stream(input, end_trigger)
+#define parse_stream(pstring, heredoc_cnt_ptr, input, end_trigger) \
+	parse_stream(heredoc_cnt_ptr, input, end_trigger)
 #endif
 static struct pipe *parse_stream(char **pstring,
+		int *heredoc_cnt_ptr,
 		struct in_str *input,
 		int end_trigger);
 
-
+/* Returns number of heredocs not yet consumed,
+ * or -1 on error.
+ */
 static int parse_group(struct parse_context *ctx,
-	struct in_str *input, int ch)
+		struct in_str *input, int ch)
 {
 	/* ctx->word contains characters seen prior to ( or {.
 	 * Typically it's empty, but for function defs,
@@ -4350,6 +4526,7 @@ static int parse_group(struct parse_cont
 	char *as_string = NULL;
 #endif
 	struct pipe *pipe_list;
+	int heredoc_cnt = 0;
 	int endch;
 	struct command *command = ctx->command;
 
@@ -4358,12 +4535,12 @@ static int parse_group(struct parse_cont
 	if (ch == '(' && !ctx->word.has_quoted_part) {
 		if (ctx->word.length)
 			if (done_word(ctx))
-				return 1;
+				return -1;
 		if (!command->argv)
 			goto skip; /* (... */
 		if (command->argv[1]) { /* word word ... (... */
 			syntax_error_unexpected_ch('(');
-			return 1;
+			return -1;
 		}
 		/* it is "word(..." or "word (..." */
 		do
@@ -4371,7 +4548,7 @@ static int parse_group(struct parse_cont
 		while (ch == ' ' || ch == '\t');
 		if (ch != ')') {
 			syntax_error_unexpected_ch(ch);
-			return 1;
+			return -1;
 		}
 		nommu_addchr(&ctx->as_string, ch);
 		do
@@ -4379,7 +4556,7 @@ static int parse_group(struct parse_cont
 		while (ch == ' ' || ch == '\t' || ch == '\n');
 		if (ch != '{' && ch != '(') {
 			syntax_error_unexpected_ch(ch);
-			return 1;
+			return -1;
 		}
 		nommu_addchr(&ctx->as_string, ch);
 		command->cmd_type = CMD_FUNCDEF;
@@ -4393,9 +4570,9 @@ static int parse_group(struct parse_cont
 	 || ctx->word.has_quoted_part /* ""{... */
 	) {
 		syntax_error(NULL);
-		debug_printf_parse("parse_group return 1: "
+		debug_printf_parse("parse_group return -1: "
 			"syntax error, groups and arglists don't mix\n");
-		return 1;
+		return -1;
 	}
 #endif
 
@@ -4413,7 +4590,7 @@ static int parse_group(struct parse_cont
 		 && ch != '('	/* but "{(..." is allowed (without whitespace) */
 		) {
 			syntax_error_unexpected_ch(ch);
-			return 1;
+			return -1;
 		}
 		if (ch != '(') {
 			ch = i_getch(input);
@@ -4421,7 +4598,9 @@ static int parse_group(struct parse_cont
 		}
 	}
 
-	pipe_list = parse_stream(&as_string, input, endch);
+	debug_printf_heredoc("calling parse_stream, heredoc_cnt:%d\n", heredoc_cnt);
+	pipe_list = parse_stream(&as_string, &heredoc_cnt, input, endch);
+	debug_printf_heredoc("parse_stream returned: heredoc_cnt:%d\n", heredoc_cnt);
 #if !BB_MMU
 	if (as_string)
 		o_addstr(&ctx->as_string, as_string);
@@ -4432,9 +4611,9 @@ static int parse_group(struct parse_cont
 		/* parse_stream already emitted error msg */
 		if (!BB_MMU)
 			free(as_string);
-		debug_printf_parse("parse_group return 1: "
+		debug_printf_parse("parse_group return -1: "
 			"parse_stream returned %p\n", pipe_list);
-		return 1;
+		return -1;
 	}
 #if !BB_MMU
 	as_string[strlen(as_string) - 1] = '\0'; /* plink ')' or '}' */
@@ -4465,15 +4644,14 @@ static int parse_group(struct parse_cont
 
 	command->group = pipe_list;
 
-	debug_printf_parse("parse_group return 0\n");
-	return 0;
+	debug_printf_parse("parse_group return %d\n", heredoc_cnt);
+	return heredoc_cnt;
 	/* command remains "open", available for possible redirects */
 #undef as_string
 }
 
 #if ENABLE_HUSH_TICK || ENABLE_FEATURE_SH_MATH || ENABLE_HUSH_DOLLAR_OPS
 /* Subroutines for copying $(...) and `...` things */
-static int add_till_backquote(o_string *dest, struct in_str *input, int in_dquote);
 /* '...' */
 static int add_till_single_quote(o_string *dest, struct in_str *input)
 {
@@ -4488,7 +4666,21 @@ static int add_till_single_quote(o_strin
 		o_addchr(dest, ch);
 	}
 }
+static int add_till_single_quote_dquoted(o_string *dest, struct in_str *input)
+{
+	while (1) {
+		int ch = i_getch(input);
+		if (ch == EOF) {
+			syntax_error_unterm_ch('\'');
+			return 0;
+		}
+		if (ch == '\'')
+			return 1;
+		o_addqchr(dest, ch);
+	}
+}
 /* "...\"...`..`...." - do we need to handle "...$(..)..." too? */
+static int add_till_backquote(o_string *dest, struct in_str *input, int in_dquote);
 static int add_till_double_quote(o_string *dest, struct in_str *input)
 {
 	while (1) {
@@ -4781,6 +4973,15 @@ static int parse_dollar(o_string *as_str
 					end_ch = '}' * 0x100 + '/';
 				}
 				o_addchr(dest, ch);
+				/* The pattern can't be empty.
+				 * IOW: if the first char after "${v//" is a slash,
+				 * it does not terminate the pattern - it's the first char of the pattern:
+				 *  v=/dev/ram; echo ${v////-}  prints -dev-ram (pattern is "/")
+				 *  v=/dev/ram; echo ${v///r/-} prints /dev-am  (pattern is "/r")
+				 */
+				if (i_peek(input) == '/') {
+					o_addchr(dest, i_getch(input));
+				}
  again:
 				if (!BB_MMU)
 					pos = dest->length;
@@ -4888,34 +5089,15 @@ static int parse_dollar(o_string *as_str
 }
 
 #if BB_MMU
-# if BASH_PATTERN_SUBST
-#define encode_string(as_string, dest, input, dquote_end, process_bkslash) \
-	encode_string(dest, input, dquote_end, process_bkslash)
-# else
-/* only ${var/pattern/repl} (its pattern part) needs additional mode */
-#define encode_string(as_string, dest, input, dquote_end, process_bkslash) \
+#define encode_string(as_string, dest, input, dquote_end) \
 	encode_string(dest, input, dquote_end)
-# endif
 #define as_string NULL
-
-#else /* !MMU */
-
-# if BASH_PATTERN_SUBST
-/* all parameters are needed, no macro tricks */
-# else
-#define encode_string(as_string, dest, input, dquote_end, process_bkslash) \
-	encode_string(as_string, dest, input, dquote_end)
-# endif
 #endif
 static int encode_string(o_string *as_string,
 		o_string *dest,
 		struct in_str *input,
-		int dquote_end,
-		int process_bkslash)
+		int dquote_end)
 {
-#if !BASH_PATTERN_SUBST
-	const int process_bkslash = 1;
-#endif
 	int ch;
 	int next;
 
@@ -4938,7 +5120,7 @@ static int encode_string(o_string *as_st
 	}
 	debug_printf_parse("\" ch=%c (%d) escape=%d\n",
 			ch, ch, !!(dest->o_expflags & EXP_FLAG_ESC_GLOB_CHARS));
-	if (process_bkslash && ch == '\\') {
+	if (ch == '\\') {
 		if (next == EOF) {
 			/* Testcase: in interactive shell a file with
 			 *  echo "unterminated string\<eof>
@@ -4998,6 +5180,7 @@ static int encode_string(o_string *as_st
  * or return ERR_PTR.
  */
 static struct pipe *parse_stream(char **pstring,
+		int *heredoc_cnt_ptr,
 		struct in_str *input,
 		int end_trigger)
 {
@@ -5016,8 +5199,7 @@ static struct pipe *parse_stream(char **
 	/* If very first arg is "" or '', ctx.word.data may end up NULL.
 	 * Preventing this:
 	 */
-	o_addchr(&ctx.word, '\0');
-	ctx.word.length = 0;
+	ctx.word.data = xzalloc(1); /* start as "", not as NULL */
 
 	/* We used to separate words on $IFS here. This was wrong.
 	 * $IFS is used only for word splitting when $var is expanded,
@@ -5055,7 +5237,7 @@ static struct pipe *parse_stream(char **
 			if (done_word(&ctx)) {
 				goto parse_error;
 			}
-			o_free(&ctx.word);
+			o_free_and_set_NULL(&ctx.word);
 			done_pipe(&ctx, PIPE_SEQ);
 			pi = ctx.list_head;
 			/* If we got nothing... */
@@ -5072,9 +5254,13 @@ static struct pipe *parse_stream(char **
 			if (pstring)
 				*pstring = ctx.as_string.data;
 			else
-				o_free_unsafe(&ctx.as_string);
+				o_free(&ctx.as_string);
 #endif
+			// heredoc_cnt must be 0 here anyway
+			//if (heredoc_cnt_ptr)
+			//	*heredoc_cnt_ptr = heredoc_cnt;
 			debug_leave();
+			debug_printf_heredoc("parse_stream return heredoc_cnt:%d\n", heredoc_cnt);
 			debug_printf_parse("parse_stream return %p\n", pi);
 			return pi;
 		}
@@ -5201,7 +5387,9 @@ static struct pipe *parse_stream(char **
 				 * "case ... in <newline> word) ..."
 				 */
 				if (IS_NULL_CMD(ctx.command)
-				 && ctx.word.length == 0 && !ctx.word.has_quoted_part
+				 && ctx.word.length == 0
+				 && !ctx.word.has_quoted_part
+				 && heredoc_cnt == 0
 				) {
 					/* This newline can be ignored. But...
 					 * Without check #1, interactive shell
@@ -5229,12 +5417,11 @@ static struct pipe *parse_stream(char **
 				}
 				/* Treat newline as a command separator. */
 				done_pipe(&ctx, PIPE_SEQ);
-				debug_printf_parse("heredoc_cnt:%d\n", heredoc_cnt);
+				debug_printf_heredoc("heredoc_cnt:%d\n", heredoc_cnt);
 				if (heredoc_cnt) {
-					if (fetch_heredocs(heredoc_cnt, &ctx, input)) {
+					heredoc_cnt = fetch_heredocs(&ctx.as_string, ctx.list_head, heredoc_cnt, input);
+					if (heredoc_cnt != 0)
 						goto parse_error;
-					}
-					heredoc_cnt = 0;
 				}
 				ctx.is_assignment = MAYBE_ASSIGNMENT;
 				debug_printf_parse("ctx.is_assignment='%s'\n", assignment_flag[ctx.is_assignment]);
@@ -5283,19 +5470,6 @@ static struct pipe *parse_stream(char **
 		    )
 #endif
 		) {
-			if (heredoc_cnt) {
-				/* This is technically valid:
-				 * { cat <<HERE; }; echo Ok
-				 * heredoc
-				 * heredoc
-				 * HERE
-				 * but we don't support this.
-				 * We require heredoc to be in enclosing {}/(),
-				 * if any.
-				 */
-				syntax_error_unterm_str("here document");
-				goto parse_error;
-			}
 			if (done_word(&ctx)) {
 				goto parse_error;
 			}
@@ -5306,13 +5480,13 @@ static struct pipe *parse_stream(char **
 			if (!HAS_KEYWORDS
 			IF_HAS_KEYWORDS(|| (ctx.ctx_res_w == RES_NONE && ctx.old_flag == 0))
 			) {
-				o_free(&ctx.word);
+				o_free_and_set_NULL(&ctx.word);
 #if !BB_MMU
 				debug_printf_parse("as_string2 '%s'\n", ctx.as_string.data);
 				if (pstring)
 					*pstring = ctx.as_string.data;
 				else
-					o_free_unsafe(&ctx.as_string);
+					o_free(&ctx.as_string);
 #endif
 				if (ch != ';' && IS_NULL_PIPE(ctx.list_head)) {
 					/* Example: bare "{ }", "()" */
@@ -5320,6 +5494,9 @@ static struct pipe *parse_stream(char **
 					syntax_error_unexpected_ch(ch);
 					goto parse_error2;
 				}
+				if (heredoc_cnt_ptr)
+					*heredoc_cnt_ptr = heredoc_cnt;
+				debug_printf_heredoc("parse_stream return heredoc_cnt:%d\n", heredoc_cnt);
 				debug_printf_parse("parse_stream return %p: "
 						"end_trigger char found\n",
 						ctx.list_head);
@@ -5363,7 +5540,7 @@ static struct pipe *parse_stream(char **
 			if (next == '<') {
 				redir_style = REDIRECT_HEREDOC;
 				heredoc_cnt++;
-				debug_printf_parse("++heredoc_cnt=%d\n", heredoc_cnt);
+				debug_printf_heredoc("++heredoc_cnt=%d\n", heredoc_cnt);
 				ch = i_getch(input);
 				nommu_addchr(&ctx.as_string, ch);
 			} else if (next == '>') {
@@ -5447,7 +5624,7 @@ static struct pipe *parse_stream(char **
 			}
 			if (ctx.is_assignment == NOT_ASSIGNMENT)
 				ctx.word.o_expflags |= EXP_FLAG_ESC_GLOB_CHARS;
-			if (!encode_string(&ctx.as_string, &ctx.word, input, '"', /*process_bkslash:*/ 1))
+			if (!encode_string(&ctx.as_string, &ctx.word, input, '"'))
 				goto parse_error;
 			ctx.word.o_expflags &= ~EXP_FLAG_ESC_GLOB_CHARS;
 			continue; /* get next char */
@@ -5541,16 +5718,22 @@ static struct pipe *parse_stream(char **
 				continue; /* get next char */
 			}
 #endif
-		case '{':
-			if (parse_group(&ctx, input, ch) != 0) {
+			/* fall through */
+		case '{': {
+			int n = parse_group(&ctx, input, ch);
+			if (n < 0) {
 				goto parse_error;
 			}
+			debug_printf_heredoc("parse_group done, needs heredocs:%d\n", n);
+			heredoc_cnt += n;
 			goto new_cmd;
+		}
 		case ')':
 #if ENABLE_HUSH_CASE
 			if (ctx.ctx_res_w == RES_MATCH)
 				goto case_semi;
 #endif
+
 		case '}':
 			/* proper use of this character is caught by end_trigger:
 			 * if we see {, we call parse_group(..., end_trigger='}')
@@ -5590,7 +5773,7 @@ static struct pipe *parse_stream(char **
 			free_pipe_list(pctx->list_head);
 			debug_printf_clean("freed list %p\n", pctx->list_head);
 #if !BB_MMU
-			o_free_unsafe(&pctx->as_string);
+			o_free(&pctx->as_string);
 #endif
 			IF_HAS_KEYWORDS(p2 = pctx->stack;)
 			if (pctx != &ctx) {
@@ -5621,6 +5804,7 @@ static char *expand_string_to_string(con
 #if ENABLE_HUSH_TICK
 static int process_command_subs(o_string *dest, const char *s);
 #endif
+static int expand_vars_to_list(o_string *output, int n, char *arg);
 
 /* expand_strvec_to_strvec() takes a list of strings, expands
  * all variable references within and returns a pointer to
@@ -5665,10 +5849,10 @@ static void o_addblock_duplicate_backsla
 /* Store given string, finalizing the word and starting new one whenever
  * we encounter IFS char(s). This is used for expanding variable values.
  * End-of-string does NOT finalize word: think about 'echo -$VAR-'.
- * Return in *ended_with_ifs:
+ * Return in output->ended_in_ifs:
  * 1 - ended with IFS char, else 0 (this includes case of empty str).
  */
-static int expand_on_ifs(int *ended_with_ifs, o_string *output, int n, const char *str)
+static int expand_on_ifs(o_string *output, int n, const char *str)
 {
 	int last_is_ifs = 0;
 
@@ -5717,12 +5901,16 @@ static int expand_on_ifs(int *ended_with
 		/* Start new word... but not always! */
 		/* Case "v=' a'; echo ''$v": we do need to finalize empty word: */
 		if (output->has_quoted_part
-		/* Case "v=' a'; echo $v":
+		/*
+		 * Case "v=' a'; echo $v":
 		 * here nothing precedes the space in $v expansion,
 		 * therefore we should not finish the word
 		 * (IOW: if there *is* word to finalize, only then do it):
+		 * It's okay if this accesses the byte before first argv[]:
+		 * past call to o_save_ptr() cleared it to zero byte
+		 * (grep for -prev-ifs-check-).
 		 */
-		 || (n > 0 && output->data[output->length - 1])
+		 || output->data[output->length - 1]
 		) {
  new_word:
 			o_addchr(output, '\0');
@@ -5731,8 +5919,7 @@ static int expand_on_ifs(int *ended_with
 		}
 	}
 
-	if (ended_with_ifs)
-		*ended_with_ifs = last_is_ifs;
+	output->ended_in_ifs = last_is_ifs;
 	debug_print_list("expand_on_ifs[1]", output, n);
 	return n;
 }
@@ -5744,45 +5931,292 @@ static int expand_on_ifs(int *ended_with
  * Returns malloced string.
  * As an optimization, we return NULL if expansion is not needed.
  */
-#if !BASH_PATTERN_SUBST
-/* only ${var/pattern/repl} (its pattern part) needs additional mode */
-#define encode_then_expand_string(str, process_bkslash, do_unbackslash) \
-	encode_then_expand_string(str)
-#endif
-static char *encode_then_expand_string(const char *str, int process_bkslash, int do_unbackslash)
+static char *encode_then_expand_string(const char *str)
 {
-#if !BASH_PATTERN_SUBST
-	enum { do_unbackslash = 1 };
-#endif
 	char *exp_str;
 	struct in_str input;
 	o_string dest = NULL_O_STRING;
+	const char *cp;
 
-	if (!strchr(str, '$')
-	 && !strchr(str, '\\')
+	cp = str;
+	for (;;) {
+		if (!*cp) return NULL; /* string has no special chars */
+		if (*cp == '$') break;
+		if (*cp == '\\') break;
 #if ENABLE_HUSH_TICK
-	 && !strchr(str, '`')
+		if (*cp == '`') break;
 #endif
-	) {
-		return NULL;
+		cp++;
 	}
 
 	/* We need to expand. Example:
 	 * echo $(($a + `echo 1`)) $((1 + $((2)) ))
 	 */
 	setup_string_in_str(&input, str);
-	encode_string(NULL, &dest, &input, EOF, process_bkslash);
+	encode_string(NULL, &dest, &input, EOF);
 //TODO: error check (encode_string returns 0 on error)?
 	//bb_error_msg("'%s' -> '%s'", str, dest.data);
 	exp_str = expand_string_to_string(dest.data,
+			EXP_FLAG_ESC_GLOB_CHARS,
+			/*unbackslash:*/ 1
+	);
+	//bb_error_msg("'%s' -> '%s'", dest.data, exp_str);
+	o_free(&dest);
+	return exp_str;
+}
+
+static const char *first_special_char_in_vararg(const char *cp)
+{
+	for (;;) {
+		if (!*cp) return NULL; /* string has no special chars */
+		if (*cp == '$') return cp;
+		if (*cp == '\\') return cp;
+		if (*cp == '\'') return cp;
+		if (*cp == '"') return cp;
+#if ENABLE_HUSH_TICK
+		if (*cp == '`') return cp;
+#endif
+		/* dquoted "${x:+ARG}" should not glob, therefore
+		 * '*' et al require some non-literal processing: */
+		if (*cp == '*') return cp;
+		if (*cp == '?') return cp;
+		if (*cp == '[') return cp;
+		cp++;
+	}
+}
+
+/* Expanding ARG in ${var#ARG}, ${var%ARG}, or ${var/ARG/ARG}.
+ * These can contain single- and double-quoted strings,
+ * and treated as if the ARG string is initially unquoted. IOW:
+ * ${var#ARG} and "${var#ARG}" treat ARG the same (ARG can even be
+ * a dquoted string: "${var#"zz"}"), the difference only comes later
+ * (word splitting and globbing of the ${var...} result).
+ */
+#if !BASH_PATTERN_SUBST
+#define encode_then_expand_vararg(str, handle_squotes, do_unbackslash) \
+	encode_then_expand_vararg(str, handle_squotes)
+#endif
+static char *encode_then_expand_vararg(const char *str, int handle_squotes, int do_unbackslash)
+{
+#if !BASH_PATTERN_SUBST && ENABLE_HUSH_CASE
+	const int do_unbackslash = 0;
+#endif
+	char *exp_str;
+	struct in_str input;
+	o_string dest = NULL_O_STRING;
+
+	if (!first_special_char_in_vararg(str)) {
+		/* string has no special chars */
+		return NULL;
+	}
+
+	setup_string_in_str(&input, str);
+	dest.data = xzalloc(1); /* start as "", not as NULL */
+	exp_str = NULL;
+
+	for (;;) {
+		int ch;
+
+		ch = i_getch(&input);
+		debug_printf_parse("%s: ch=%c (%d) escape=%d\n",
+				__func__, ch, ch, !!dest.o_expflags);
+
+		if (!dest.o_expflags) {
+			if (ch == EOF)
+				break;
+			if (handle_squotes && ch == '\'') {
+				if (!add_till_single_quote_dquoted(&dest, &input))
+					goto ret; /* error */
+				continue;
+			}
+		}
+		if (ch == EOF) {
+			syntax_error_unterm_ch('"');
+			goto ret; /* error */
+		}
+		if (ch == '"') {
+			dest.o_expflags ^= EXP_FLAG_ESC_GLOB_CHARS;
+			continue;
+		}
+		if (ch == '\\') {
+			ch = i_getch(&input);
+			if (ch == EOF) {
+//example? error message?	syntax_error_unterm_ch('"');
+				debug_printf_parse("%s: error: \\<eof>\n", __func__);
+				goto ret;
+			}
+			o_addqchr(&dest, ch);
+			continue;
+		}
+		if (ch == '$') {
+			if (!parse_dollar(NULL, &dest, &input, /*quote_mask:*/ 0x80)) {
+				debug_printf_parse("%s: error: parse_dollar returned 0 (error)\n", __func__);
+				goto ret;
+			}
+			continue;
+		}
+#if ENABLE_HUSH_TICK
+		if (ch == '`') {
+			//unsigned pos = dest->length;
+			o_addchr(&dest, SPECIAL_VAR_SYMBOL);
+			o_addchr(&dest, 0x80 | '`');
+			if (!add_till_backquote(&dest, &input,
+					/*in_dquote:*/ dest.o_expflags /* nonzero if EXP_FLAG_ESC_GLOB_CHARS set */
+				)
+			) {
+				goto ret; /* error */
+			}
+			o_addchr(&dest, SPECIAL_VAR_SYMBOL);
+			//debug_printf_subst("SUBST RES3 '%s'\n", dest->data + pos);
+			continue;
+		}
+#endif
+		o_addQchr(&dest, ch);
+	} /* for (;;) */
+
+	debug_printf_parse("encode: '%s' -> '%s'\n", str, dest.data);
+	exp_str = expand_string_to_string(dest.data,
 			do_unbackslash ? EXP_FLAG_ESC_GLOB_CHARS : 0,
 			do_unbackslash
 	);
-	//bb_error_msg("'%s' -> '%s'", dest.data, exp_str);
-	o_free_unsafe(&dest);
+ ret:
+	debug_printf_parse("expand: '%s' -> '%s'\n", dest.data, exp_str);
+	o_free(&dest);
 	return exp_str;
 }
 
+/* Expanding ARG in ${var+ARG}, ${var-ARG}
+ */
+static int encode_then_append_var_plusminus(o_string *output, int n,
+		char *str, int dquoted)
+{
+	struct in_str input;
+	o_string dest = NULL_O_STRING;
+
+	if (!first_special_char_in_vararg(str)
+	 && '\0' == str[strcspn(str, G.ifs)]
+	) {
+		/* string has no special chars
+		 * && string has no $IFS chars
+		 */
+		return expand_vars_to_list(output, n, str);
+	}
+
+	setup_string_in_str(&input, str);
+
+	for (;;) {
+		int ch;
+
+		ch = i_getch(&input);
+		debug_printf_parse("%s: ch=%c (%d) escape=%x\n",
+				__func__, ch, ch, dest.o_expflags);
+
+		if (!dest.o_expflags) {
+			if (ch == EOF)
+				break;
+			if (!dquoted && strchr(G.ifs, ch)) {
+				/* PREFIX${x:d${e}f ...} and we met space: expand "d${e}f" and start new word.
+				 * do not assume we are at the start of the word (PREFIX above).
+				 */
+				if (dest.data) {
+					n = expand_vars_to_list(output, n, dest.data);
+					o_free_and_set_NULL(&dest);
+					o_addchr(output, '\0');
+					n = o_save_ptr(output, n); /* create next word */
+				} else
+				if (output->length != o_get_last_ptr(output, n)
+				 || output->has_quoted_part
+				) {
+					/* For these cases:
+					 * f() { for i; do echo "|$i|"; done; }; x=x
+					 * f a${x:+ }b  # 1st condition
+					 * |a|
+					 * |b|
+					 * f ""${x:+ }b  # 2nd condition
+					 * ||
+					 * |b|
+					 */
+					o_addchr(output, '\0');
+					n = o_save_ptr(output, n); /* create next word */
+				}
+				continue;
+			}
+			if (!dquoted && ch == '\'') {
+				if (!add_till_single_quote_dquoted(&dest, &input))
+					goto ret; /* error */
+				o_addchr(&dest, SPECIAL_VAR_SYMBOL);
+				o_addchr(&dest, SPECIAL_VAR_SYMBOL);
+				continue;
+			}
+		}
+		if (ch == EOF) {
+			syntax_error_unterm_ch('"');
+			goto ret; /* error */
+		}
+		if (ch == '"') {
+			dest.o_expflags ^= EXP_FLAG_ESC_GLOB_CHARS;
+			if (dest.o_expflags) {
+				o_addchr(&dest, SPECIAL_VAR_SYMBOL);
+				o_addchr(&dest, SPECIAL_VAR_SYMBOL);
+			}
+			continue;
+		}
+		if (ch == '\\') {
+			ch = i_getch(&input);
+			if (ch == EOF) {
+//example? error message?	syntax_error_unterm_ch('"');
+				debug_printf_parse("%s: error: \\<eof>\n", __func__);
+				goto ret;
+			}
+			o_addqchr(&dest, ch);
+			continue;
+		}
+		if (ch == '$') {
+			if (!parse_dollar(NULL, &dest, &input, /*quote_mask:*/ (dest.o_expflags || dquoted) ? 0x80 : 0)) {
+				debug_printf_parse("%s: error: parse_dollar returned 0 (error)\n", __func__);
+				goto ret;
+			}
+			continue;
+		}
+#if ENABLE_HUSH_TICK
+		if (ch == '`') {
+			//unsigned pos = dest->length;
+			o_addchr(&dest, SPECIAL_VAR_SYMBOL);
+			o_addchr(&dest, (dest.o_expflags || dquoted) ? 0x80 | '`' : '`');
+			if (!add_till_backquote(&dest, &input,
+					/*in_dquote:*/ dest.o_expflags /* nonzero if EXP_FLAG_ESC_GLOB_CHARS set */
+				)
+			) {
+				goto ret; /* error */
+			}
+			o_addchr(&dest, SPECIAL_VAR_SYMBOL);
+			//debug_printf_subst("SUBST RES3 '%s'\n", dest->data + pos);
+			continue;
+		}
+#endif
+		if (dquoted) {
+			/* Always glob-protect if in dquotes:
+			 * x=x; echo "${x:+/bin/c*}" - prints: /bin/c*
+			 * x=x; echo "${x:+"/bin/c*"}" - prints: /bin/c*
+			 */
+			o_addqchr(&dest, ch);
+		} else {
+			/* Glob-protect only if char is quoted:
+			 * x=x; echo ${x:+/bin/c*} - prints many filenames
+			 * x=x; echo ${x:+"/bin/c*"} - prints: /bin/c*
+			 */
+			o_addQchr(&dest, ch);
+		}
+	} /* for (;;) */
+
+	if (dest.data) {
+		n = expand_vars_to_list(output, n, dest.data);
+	}
+ ret:
+	o_free(&dest);
+	return n;
+}
+
 #if ENABLE_FEATURE_SH_MATH
 static arith_t expand_and_evaluate_arith(const char *arg, const char **errmsg_p)
 {
@@ -5793,7 +6227,7 @@ static arith_t expand_and_evaluate_arith
 	math_state.lookupvar = get_local_var_value;
 	math_state.setvar = set_local_var_from_halves;
 	//math_state.endofname = endofname;
-	exp_str = encode_then_expand_string(arg, /*process_bkslash:*/ 1, /*unbackslash:*/ 1);
+	exp_str = encode_then_expand_string(arg);
 	res = arith(&math_state, exp_str ? exp_str : arg);
 	free(exp_str);
 	if (errmsg_p)
@@ -5860,16 +6294,33 @@ static char *replace_pattern(char *val,
 }
 #endif /* BASH_PATTERN_SUBST */
 
-/* Helper:
- * Handles <SPECIAL_VAR_SYMBOL>varname...<SPECIAL_VAR_SYMBOL> construct.
+static int append_str_maybe_ifs_split(o_string *output, int n,
+		int first_ch, const char *val)
+{
+	if (!(first_ch & 0x80)) { /* unquoted $VAR */
+		debug_printf_expand("unquoted '%s', output->o_escape:%d\n", val,
+				!!(output->o_expflags & EXP_FLAG_ESC_GLOB_CHARS));
+		if (val && val[0])
+			n = expand_on_ifs(output, n, val);
+	} else { /* quoted "$VAR" */
+		output->has_quoted_part = 1;
+		debug_printf_expand("quoted '%s', output->o_escape:%d\n", val,
+				!!(output->o_expflags & EXP_FLAG_ESC_GLOB_CHARS));
+		if (val && val[0])
+			o_addQstr(output, val);
+	}
+	return n;
+}
+
+/* Handle <SPECIAL_VAR_SYMBOL>varname...<SPECIAL_VAR_SYMBOL> construct.
  */
-static NOINLINE const char *expand_one_var(char **to_be_freed_pp, char *arg, char **pp)
+static NOINLINE int expand_one_var(o_string *output, int n,
+		int first_ch, char *arg, char **pp)
 {
 	const char *val;
 	char *to_be_freed;
 	char *p;
 	char *var;
-	char first_char;
 	char exp_op;
 	char exp_save = exp_save; /* for compiler */
 	char *exp_saveptr; /* points to expansion operator */
@@ -5883,10 +6334,10 @@ static NOINLINE const char *expand_one_v
 	var = arg;
 	exp_saveptr = arg[1] ? strchr(VAR_ENCODED_SUBST_OPS, arg[1]) : NULL;
 	arg0 = arg[0];
-	first_char = arg[0] = arg0 & 0x7f;
+	arg[0] = (arg0 & 0x7f);
 	exp_op = 0;
 
-	if (first_char == '#' && arg[1] /* ${#...} but not ${#} */
+	if (arg[0] == '#' && arg[1] /* ${#...} but not ${#} */
 	 && (!exp_saveptr               /* and ( not(${#<op_char>...}) */
 	    || (arg[2] == '\0' && strchr(SPECIAL_VARS_STR, arg[1])) /* or ${#C} "len of $C" ) */
 	    )		/* NB: skipping ^^^specvar check mishandles ${#::2} */
@@ -5897,7 +6348,7 @@ static NOINLINE const char *expand_one_v
 	} else {
 		/* Maybe handle parameter expansion */
 		if (exp_saveptr /* if 2nd char is one of expansion operators */
-		 && strchr(NUMERIC_SPECVARS_STR, first_char) /* 1st char is special variable */
+		 && strchr(NUMERIC_SPECVARS_STR, arg[0]) /* 1st char is special variable */
 		) {
 			/* ${?:0}, ${#[:]%0} etc */
 			exp_saveptr = var + 1;
@@ -5926,9 +6377,9 @@ static NOINLINE const char *expand_one_v
 	/* Look up the variable in question */
 	if (isdigit(var[0])) {
 		/* parse_dollar should have vetted var for us */
-		int n = xatoi_positive(var);
-		if (n < G.global_argc)
-			val = G.global_argv[n];
+		int nn = xatoi_positive(var);
+		if (nn < G.global_argc)
+			val = G.global_argv[nn];
 		/* else val remains NULL: $N with too big N */
 	} else {
 		switch (var[0]) {
@@ -5966,6 +6417,9 @@ static NOINLINE const char *expand_one_v
 			 * Word is expanded to produce a glob pattern.
 			 * Then var's value is matched to it and matching part removed.
 			 */
+//FIXME: ${x#...${...}...}
+//should evaluate inner ${...} even if x is "" and no shrinking of it is possible -
+//inner ${...} may have side effects!
 			if (val && val[0]) {
 				char *t;
 				char *exp_exp_word;
@@ -5974,20 +6428,16 @@ static NOINLINE const char *expand_one_v
 				if (exp_op == *exp_word)  /* ## or %% */
 					exp_word++;
 				debug_printf_expand("expand: exp_word:'%s'\n", exp_word);
-				/*
-				 * process_bkslash:1 unbackslash:1 breaks this:
-				 * a='a\\'; echo ${a%\\\\} # correct output is: a
-				 * process_bkslash:1 unbackslash:0 breaks this:
-				 * a='a}'; echo ${a%\}}    # correct output is: a
-				 */
-				exp_exp_word = encode_then_expand_string(exp_word, /*process_bkslash:*/ 0, /*unbackslash:*/ 0);
+				exp_exp_word = encode_then_expand_vararg(exp_word, /*handle_squotes:*/ 1, /*unbackslash:*/ 0);
 				if (exp_exp_word)
 					exp_word = exp_exp_word;
-				debug_printf_expand("expand: exp_exp_word:'%s'\n", exp_word);
-				/* HACK ALERT. We depend here on the fact that
+				debug_printf_expand("expand: exp_word:'%s'\n", exp_word);
+				/*
+				 * HACK ALERT. We depend here on the fact that
 				 * G.global_argv and results of utoa and get_local_var_value
 				 * are actually in writable memory:
-				 * scan_and_match momentarily stores NULs there. */
+				 * scan_and_match momentarily stores NULs there.
+				 */
 				t = (char*)val;
 				loc = scan_and_match(t, exp_word, scan_flags);
 				debug_printf_expand("op:%c str:'%s' pat:'%s' res:'%s'\n", exp_op, t, exp_word, loc);
@@ -6020,7 +6470,7 @@ static NOINLINE const char *expand_one_v
 				 * (note that a*z _pattern_ is never globbed!)
 				 */
 				char *pattern, *repl, *t;
-				pattern = encode_then_expand_string(exp_word, /*process_bkslash:*/ 0, /*unbackslash:*/ 0);
+				pattern = encode_then_expand_vararg(exp_word, /*handle_squotes:*/ 1, /*unbackslash:*/ 0);
 				if (!pattern)
 					pattern = xstrdup(exp_word);
 				debug_printf_varexp("pattern:'%s'->'%s'\n", exp_word, pattern);
@@ -6028,7 +6478,7 @@ static NOINLINE const char *expand_one_v
 				exp_word = p;
 				p = strchr(p, SPECIAL_VAR_SYMBOL);
 				*p = '\0';
-				repl = encode_then_expand_string(exp_word, /*process_bkslash:*/ 0, /*unbackslash:*/ 1);
+				repl = encode_then_expand_vararg(exp_word, /*handle_squotes:*/ 1, /*unbackslash:*/ 1);
 				debug_printf_varexp("repl:'%s'->'%s'\n", exp_word, repl);
 				/* HACK ALERT. We depend here on the fact that
 				 * G.global_argv and results of utoa and get_local_var_value
@@ -6124,6 +6574,34 @@ static NOINLINE const char *expand_one_v
 			 *
 			 * Colon forms (${var:-word}, ${var:=word} etc) do the same,
 			 * but also treat null var as if it is unset.
+			 *
+			 * Word-splitting and single quote behavior:
+			 *
+			 * $ f() { for i; do echo "|$i|"; done; };
+			 *
+			 * $ x=; f ${x:?'x y' z}
+			 * bash: x: x y z              #BUG: does not abort, ${} results in empty expansion
+			 * $ x=; f "${x:?'x y' z}"
+			 * bash: x: x y z       # dash prints: dash: x: 'x y' z   #BUG: does not abort, ${} results in ""
+			 *
+			 * $ x=; f ${x:='x y' z}
+			 * |x|
+			 * |y|
+			 * |z|
+			 * $ x=; f "${x:='x y' z}"
+			 * |'x y' z|
+			 *
+			 * $ x=x; f ${x:+'x y' z}
+			 * |x y|
+			 * |z|
+			 * $ x=x; f "${x:+'x y' z}"
+			 * |'x y' z|
+			 *
+			 * $ x=; f ${x:-'x y' z}
+			 * |x y|
+			 * |z|
+			 * $ x=; f "${x:-'x y' z}"
+			 * |'x y' z|
 			 */
 			int use_word = (!val || ((exp_save == ':') && !val[0]));
 			if (exp_op == '+')
@@ -6131,33 +6609,51 @@ static NOINLINE const char *expand_one_v
 			debug_printf_expand("expand: op:%c (null:%s) test:%i\n", exp_op,
 					(exp_save == ':') ? "true" : "false", use_word);
 			if (use_word) {
-				to_be_freed = encode_then_expand_string(exp_word, /*process_bkslash:*/ 1, /*unbackslash:*/ 1);
-				if (to_be_freed)
-					exp_word = to_be_freed;
-				if (exp_op == '?') {
-					/* mimic bash message */
-					msg_and_die_if_script("%s: %s",
-						var,
-						exp_word[0]
-						? exp_word
-						: "parameter null or not set"
-						/* ash has more specific messages, a-la: */
-						/*: (exp_save == ':' ? "parameter null or not set" : "parameter not set")*/
+				if (exp_op == '+' || exp_op == '-') {
+					/* ${var+word} - use alternative value */
+					/* ${var-word} - use default value */
+					n = encode_then_append_var_plusminus(output, n, exp_word,
+							/*dquoted:*/ (arg0 & 0x80)
 					);
-//TODO: how interactive bash aborts expansion mid-command?
+					val = NULL;
 				} else {
-					val = exp_word;
-				}
-
-				if (exp_op == '=') {
-					/* ${var=[word]} or ${var:=[word]} */
-					if (isdigit(var[0]) || var[0] == '#') {
+					/* ${var?word} - indicate error if unset */
+					/* ${var=word} - assign and use default value */
+					to_be_freed = encode_then_expand_vararg(exp_word,
+							/*handle_squotes:*/ !(arg0 & 0x80),
+							/*unbackslash:*/ 0
+					);
+					if (to_be_freed)
+						exp_word = to_be_freed;
+					if (exp_op == '?') {
 						/* mimic bash message */
-						msg_and_die_if_script("$%s: cannot assign in this way", var);
-						val = NULL;
+						msg_and_die_if_script("%s: %s",
+							var,
+							exp_word[0]
+							? exp_word
+							: "parameter null or not set"
+							/* ash has more specific messages, a-la: */
+							/*: (exp_save == ':' ? "parameter null or not set" : "parameter not set")*/
+						);
+//TODO: how interactive bash aborts expansion mid-command?
+//It aborts the entire line, returns to prompt:
+// $ f() { for i; do echo "|$i|"; done; }; x=; f "${x:?'x y' z}"; echo YO
+// bash: x: x y z
+// $
+// ("echo YO" is not executed, neither the f function call)
 					} else {
-						char *new_var = xasprintf("%s=%s", var, val);
-						set_local_var(new_var, /*flag:*/ 0);
+						val = exp_word;
+					}
+					if (exp_op == '=') {
+						/* ${var=[word]} or ${var:=[word]} */
+						if (isdigit(var[0]) || var[0] == '#') {
+							/* mimic bash message */
+							msg_and_die_if_script("$%s: cannot assign in this way", var);
+							val = NULL;
+						} else {
+							char *new_var = xasprintf("%s=%s", var, val);
+							set_local_var(new_var, /*flag:*/ 0);
+						}
 					}
 				}
 			}
@@ -6167,10 +6663,12 @@ static NOINLINE const char *expand_one_v
 	} /* if (exp_op) */
 
 	arg[0] = arg0;
-
 	*pp = p;
-	*to_be_freed_pp = to_be_freed;
-	return val;
+
+	n = append_str_maybe_ifs_split(output, n, first_ch, val);
+
+	free(to_be_freed);
+	return n;
 }
 
 /* Expand all variable references in given string, adding words to list[]
@@ -6184,30 +6682,22 @@ static NOINLINE int expand_vars_to_list(
 	 * expansion of right-hand side of assignment == 1-element expand.
 	 */
 	char cant_be_null = 0; /* only bit 0x80 matters */
-	int ended_in_ifs = 0;  /* did last unquoted expansion end with IFS chars? */
 	char *p;
 
 	debug_printf_expand("expand_vars_to_list: arg:'%s' singleword:%x\n", arg,
 			!!(output->o_expflags & EXP_FLAG_SINGLEWORD));
-	debug_print_list("expand_vars_to_list", output, n);
-	n = o_save_ptr(output, n);
 	debug_print_list("expand_vars_to_list[0]", output, n);
 
 	while ((p = strchr(arg, SPECIAL_VAR_SYMBOL)) != NULL) {
 		char first_ch;
-		char *to_be_freed = NULL;
-		const char *val = NULL;
-#if ENABLE_HUSH_TICK
-		o_string subst_result = NULL_O_STRING;
-#endif
 #if ENABLE_FEATURE_SH_MATH
 		char arith_buf[sizeof(arith_t)*3 + 2];
 #endif
 
-		if (ended_in_ifs) {
+		if (output->ended_in_ifs) {
 			o_addchr(output, '\0');
 			n = o_save_ptr(output, n);
-			ended_in_ifs = 0;
+			output->ended_in_ifs = 0;
 		}
 
 		o_addblock(output, arg, p - arg);
@@ -6238,7 +6728,7 @@ static NOINLINE int expand_vars_to_list(
 			cant_be_null |= first_ch; /* do it for "$@" _now_, when we know it's not empty */
 			if (!(first_ch & 0x80)) { /* unquoted $* or $@ */
 				while (G.global_argv[i]) {
-					n = expand_on_ifs(NULL, output, n, G.global_argv[i]);
+					n = expand_on_ifs(output, n, G.global_argv[i]);
 					debug_printf_expand("expand_vars_to_list: argv %d (last %d)\n", i, G.global_argc - 1);
 					if (G.global_argv[i++][0] && G.global_argv[i]) {
 						/* this argv[] is not empty and not last:
@@ -6275,19 +6765,25 @@ static NOINLINE int expand_vars_to_list(
 			}
 			break;
 		}
-		case SPECIAL_VAR_SYMBOL: /* <SPECIAL_VAR_SYMBOL><SPECIAL_VAR_SYMBOL> */
+		case SPECIAL_VAR_SYMBOL: {
+			/* <SPECIAL_VAR_SYMBOL><SPECIAL_VAR_SYMBOL> */
 			/* "Empty variable", used to make "" etc to not disappear */
 			output->has_quoted_part = 1;
-			arg++;
 			cant_be_null = 0x80;
+			arg++;
 			break;
+		}
 		case SPECIAL_VAR_QUOTED_SVS:
 			/* <SPECIAL_VAR_SYMBOL><SPECIAL_VAR_QUOTED_SVS><SPECIAL_VAR_SYMBOL> */
+			/* "^C variable", represents literal ^C char (possible in scripts) */
+			o_addchr(output, SPECIAL_VAR_SYMBOL);
 			arg++;
-			val = SPECIAL_VAR_SYMBOL_STR;
 			break;
 #if ENABLE_HUSH_TICK
-		case '`': /* <SPECIAL_VAR_SYMBOL>`cmd<SPECIAL_VAR_SYMBOL> */
+		case '`': {
+			/* <SPECIAL_VAR_SYMBOL>`cmd<SPECIAL_VAR_SYMBOL> */
+			o_string subst_result = NULL_O_STRING;
+
 			*p = '\0'; /* replace trailing <SPECIAL_VAR_SYMBOL> */
 			arg++;
 			/* Can't just stuff it into output o_string,
@@ -6297,11 +6793,14 @@ static NOINLINE int expand_vars_to_list(
 			G.last_exitcode = process_command_subs(&subst_result, arg);
 			G.expand_exitcode = G.last_exitcode;
 			debug_printf_subst("SUBST RES:%d '%s'\n", G.last_exitcode, subst_result.data);
-			val = subst_result.data;
-			goto store_val;
+			n = append_str_maybe_ifs_split(output, n, first_ch, subst_result.data);
+			o_free(&subst_result);
+			break;
+		}
 #endif
 #if ENABLE_FEATURE_SH_MATH
-		case '+': { /* <SPECIAL_VAR_SYMBOL>+cmd<SPECIAL_VAR_SYMBOL> */
+		case '+': {
+			/* <SPECIAL_VAR_SYMBOL>+arith<SPECIAL_VAR_SYMBOL> */
 			arith_t res;
 
 			arg++; /* skip '+' */
@@ -6310,62 +6809,43 @@ static NOINLINE int expand_vars_to_list(
 			res = expand_and_evaluate_arith(arg, NULL);
 			debug_printf_subst("ARITH RES '"ARITH_FMT"'\n", res);
 			sprintf(arith_buf, ARITH_FMT, res);
-			val = arith_buf;
+			o_addstr(output, arith_buf);
 			break;
 		}
 #endif
 		default:
-			val = expand_one_var(&to_be_freed, arg, &p);
- IF_HUSH_TICK(store_val:)
-			if (!(first_ch & 0x80)) { /* unquoted $VAR */
-				debug_printf_expand("unquoted '%s', output->o_escape:%d\n", val,
-						!!(output->o_expflags & EXP_FLAG_ESC_GLOB_CHARS));
-				if (val && val[0]) {
-					n = expand_on_ifs(&ended_in_ifs, output, n, val);
-					val = NULL;
-				}
-			} else { /* quoted $VAR, val will be appended below */
-				output->has_quoted_part = 1;
-				debug_printf_expand("quoted '%s', output->o_escape:%d\n", val,
-						!!(output->o_expflags & EXP_FLAG_ESC_GLOB_CHARS));
-			}
+			/* <SPECIAL_VAR_SYMBOL>varname[ops]<SPECIAL_VAR_SYMBOL> */
+			n = expand_one_var(output, n, first_ch, arg, &p);
 			break;
 		} /* switch (char after <SPECIAL_VAR_SYMBOL>) */
 
-		if (val && val[0]) {
-			o_addQstr(output, val);
-		}
-		free(to_be_freed);
-
 		/* Restore NULL'ed SPECIAL_VAR_SYMBOL.
 		 * Do the check to avoid writing to a const string. */
 		if (*p != SPECIAL_VAR_SYMBOL)
 			*p = SPECIAL_VAR_SYMBOL;
-
-#if ENABLE_HUSH_TICK
-		o_free(&subst_result);
-#endif
 		arg = ++p;
 	} /* end of "while (SPECIAL_VAR_SYMBOL is found) ..." */
 
-	if (arg[0]) {
-		if (ended_in_ifs) {
+	if (*arg) {
+		/* handle trailing string */
+		if (output->ended_in_ifs) {
 			o_addchr(output, '\0');
 			n = o_save_ptr(output, n);
 		}
 		debug_print_list("expand_vars_to_list[a]", output, n);
 		/* this part is literal, and it was already pre-quoted
-		 * if needed (much earlier), do not use o_addQstr here! */
-		o_addstr_with_NUL(output, arg);
+		 * if needed (much earlier), do not use o_addQstr here!
+		 */
+		o_addstr(output, arg);
 		debug_print_list("expand_vars_to_list[b]", output, n);
-	} else if (output->length == o_get_last_ptr(output, n) /* expansion is empty */
-	 && !(cant_be_null & 0x80) /* and all vars were not quoted. */
+	} else
+	if (output->length == o_get_last_ptr(output, n) /* expansion is empty */
+	 && !(cant_be_null & 0x80)   /* and all vars were not quoted */
+	 && !output->has_quoted_part
 	) {
 		n--;
 		/* allow to reuse list[n] later without re-growth */
 		output->has_empty_slot = 1;
-	} else {
-		o_addchr(output, '\0');
 	}
 
 	return n;
@@ -6380,9 +6860,18 @@ static char **expand_variables(char **ar
 	output.o_expflags = expflags;
 
 	n = 0;
-	while (*argv) {
-		n = expand_vars_to_list(&output, n, *argv);
-		argv++;
+	for (;;) {
+		/* go to next list[n] */
+		output.ended_in_ifs = 0;
+		n = o_save_ptr(&output, n);
+
+		if (!*argv)
+			break;
+
+		/* expand argv[i] */
+		n = expand_vars_to_list(&output, n, *argv++);
+		/* if (!output->has_empty_slot) -- need this?? */
+			o_addchr(&output, '\0');
 	}
 	debug_print_list("expand_variables", &output, n);
 
@@ -6432,13 +6921,20 @@ static char *expand_string_to_string(con
 	argv[0] = (char*)str;
 	argv[1] = NULL;
 	list = expand_variables(argv, EXP_flags | EXP_FLAG_SINGLEWORD);
-	if (HUSH_DEBUG)
-		if (!list[0] || list[1])
-			bb_error_msg_and_die("BUG in varexp2");
-	/* actually, just move string 2*sizeof(char*) bytes back */
-	overlapping_strcpy((char*)list, list[0]);
-	if (do_unbackslash)
-		unbackslash((char*)list);
+	if (!list[0]) {
+		/* Example where it happens:
+		 * x=; echo ${x:-"$@"}
+		 */
+		((char*)list)[0] = '\0';
+	} else {
+		if (HUSH_DEBUG)
+			if (list[1])
+				bb_error_msg_and_die("BUG in varexp2");
+		/* actually, just move string 2*sizeof(char*) bytes back */
+		overlapping_strcpy((char*)list, list[0]);
+		if (do_unbackslash)
+			unbackslash((char*)list);
+	}
 	debug_printf_expand("string_to_string=>'%s'\n", (char*)list);
 	return (char*)list;
 }
@@ -6725,7 +7221,7 @@ static void parse_and_run_stream(struct
 			debug_printf_prompt("%s promptmode=%d\n", __func__, G.promptmode);
 		}
 #endif
-		pipe_list = parse_stream(NULL, inp, end_trigger);
+		pipe_list = parse_stream(NULL, NULL, inp, end_trigger);
 		if (!pipe_list || pipe_list == ERR_PTR) { /* EOF/error */
 			/* If we are in "big" script
 			 * (not in `cmd` or something similar)...
@@ -6766,19 +7262,19 @@ static void parse_and_run_string(const c
 	//IF_HUSH_LINENO_VAR(G.lineno = sv;)
 }
 
-static void parse_and_run_file(FILE *f)
+static void parse_and_run_file(HFILE *fp)
 {
 	struct in_str input;
 	IF_HUSH_LINENO_VAR(unsigned sv = G.lineno;)
 
 	IF_HUSH_LINENO_VAR(G.lineno = 1;)
-	setup_file_in_str(&input, f);
+	setup_file_in_str(&input, fp);
 	parse_and_run_stream(&input, ';');
 	IF_HUSH_LINENO_VAR(G.lineno = sv;)
 }
 
 #if ENABLE_HUSH_TICK
-static FILE *generate_stream_from_string(const char *s, pid_t *pid_p)
+static int generate_stream_from_string(const char *s, pid_t *pid_p)
 {
 	pid_t pid;
 	int channel[2];
@@ -6799,11 +7295,8 @@ static FILE *generate_stream_from_string
 			+ (1 << SIGTTIN)
 			+ (1 << SIGTTOU)
 			, SIG_IGN);
-		CLEAR_RANDOM_T(&G.random_gen); /* or else $RANDOM repeats in child */
 		close(channel[0]); /* NB: close _first_, then move fd! */
 		xmove_fd(channel[1], 1);
-		/* Prevent it from trying to handle ctrl-z etc */
-		IF_HUSH_JOB(G.run_list_level = 1;)
 # if ENABLE_HUSH_TRAP
 		/* Awful hack for `trap` or $(trap).
 		 *
@@ -6850,7 +7343,12 @@ static FILE *generate_stream_from_string
 		}
 # endif
 # if BB_MMU
+		/* Prevent it from trying to handle ctrl-z etc */
+		IF_HUSH_JOB(G.run_list_level = 1;)
+		CLEAR_RANDOM_T(&G.random_gen); /* or else $RANDOM repeats in child */
 		reset_traps_to_defaults();
+		IF_HUSH_MODE_X(G.x_mode_depth++;)
+		//bb_error_msg("%s: ++x_mode_depth=%d", __func__, G.x_mode_depth);
 		parse_and_run_string(s);
 		_exit(G.last_exitcode);
 # else
@@ -6880,7 +7378,7 @@ static FILE *generate_stream_from_string
 	free(to_free);
 # endif
 	close(channel[1]);
-	return remember_FILE(xfdopen_for_read(channel[0]));
+	return channel[0];
 }
 
 /* Return code is exit status of the process that is run. */
@@ -6890,7 +7388,7 @@ static int process_command_subs(o_string
 	pid_t pid;
 	int status, ch, eol_cnt;
 
-	fp = generate_stream_from_string(s, &pid);
+	fp = xfdopen_for_read(generate_stream_from_string(s, &pid));
 
 	/* Now send results of command back into original context */
 	eol_cnt = 0;
@@ -6909,7 +7407,7 @@ static int process_command_subs(o_string
 	}
 
 	debug_printf("done reading from `cmd` pipe, closing it\n");
-	fclose_and_forget(fp);
+	fclose(fp);
 	/* We need to extract exitcode. Test case
 	 * "true; echo `sleep 1; false` $?"
 	 * should print 1 */
@@ -6934,7 +7432,7 @@ static void setup_heredoc(struct redir_s
 
 	expanded = NULL;
 	if (!(redir->rd_dup & HEREDOC_QUOTED)) {
-		expanded = encode_then_expand_string(heredoc, /*process_bkslash:*/ 1, /*unbackslash:*/ 1);
+		expanded = encode_then_expand_string(heredoc);
 		if (expanded)
 			heredoc = expanded;
 	}
@@ -7087,19 +7585,54 @@ static int save_fd_on_redirect(int fd, i
 		return 1; /* "we closed fd" */
 	}
 #endif
-	/* Are we called from setup_redirects(squirrel==NULL)? Two cases:
-	 * (1) Redirect in a forked child. No need to save FILEs' fds,
-	 * we aren't going to use them anymore, ok to trash.
-	 * (2) "exec 3>FILE". Bummer. We can save script FILEs' fds,
-	 * but how are we doing to restore them?
-	 * "fileno(fd) = new_fd" can't be done.
+	/* Are we called from setup_redirects(squirrel==NULL)
+	 * in redirect in a [v]forked child?
 	 */
-	if (!sqp)
+	if (sqp == NULL) {
+		/* No need to move script fds.
+		 * For NOMMU case, it's actively wrong: we'd change ->fd
+		 * fields in memory for the parent, but parent's fds
+		 * aren't be moved, it would use wrong fd!
+		 * Reproducer: "cmd 3>FILE" in script.
+		 * If we would call move_HFILEs_on_redirect(), child would:
+		 *  fcntl64(3, F_DUPFD_CLOEXEC, 10)   = 10
+		 *  close(3)                          = 0
+		 * and change ->fd to 10 if fd#3 is a script fd. WRONG.
+		 */
+		//bb_error_msg("sqp == NULL: [v]forked child");
 		return 0;
+	}
 
 	/* If this one of script's fds? */
-	if (save_FILEs_on_redirect(fd, avoid_fd))
-		return 1; /* yes. "we closed fd" */
+	if (move_HFILEs_on_redirect(fd, avoid_fd))
+		return 1; /* yes. "we closed fd" (actually moved it) */
+
+	/* Are we called for "exec 3>FILE"? Came through
+	 * redirect_and_varexp_helper(squirrel=ERR_PTR) -> setup_redirects(ERR_PTR)
+	 * This case used to fail for this script:
+	 *  exec 3>FILE
+	 *  echo Ok
+	 *  ...100000 more lines...
+	 *  echo Ok
+	 * as follows:
+	 *  read(3, "exec 3>FILE\necho Ok\necho Ok"..., 1024) = 1024
+	 *  open("FILE", O_WRONLY|O_CREAT|O_TRUNC|O_LARGEFILE, 0666) = 4
+	 *  dup2(4, 3)                        = 3
+	 *  ^^^^^^^^ oops, we lost fd#3 opened to our script!
+	 *  close(4)                          = 0
+	 *  write(1, "Ok\n", 3)               = 3
+	 *  ...                               = 3
+	 *  write(1, "Ok\n", 3)               = 3
+	 *  read(3, 0x94fbc08, 1024)          = -1 EBADF (Bad file descriptor)
+	 *  ^^^^^^^^ oops, wrong fd!!!
+	 * With this case separate from sqp == NULL and *after* move_HFILEs,
+	 * it now works:
+	 */
+	if (sqp == ERR_PTR) {
+		/* Don't preserve redirected fds: exec is _meant_ to change these */
+		//bb_error_msg("sqp == ERR_PTR: exec >FILE");
+		return 0;
+	}
 
 	/* Check whether it collides with any open fds (e.g. stdio), save fds as needed */
 	*sqp = add_squirrel(*sqp, fd, avoid_fd);
@@ -7125,8 +7658,6 @@ static void restore_redirects(struct squ
 	}
 
 	/* If moved, G.interactive_fd stays on new fd, not restoring it */
-
-	restore_redirected_FILEs();
 }
 
 #if ENABLE_FEATURE_SH_STANDALONE && BB_MMU
@@ -7134,7 +7665,7 @@ static void close_saved_fds_and_FILE_fds
 {
 	if (G_interactive_fd)
 		close(G_interactive_fd);
-	close_all_FILE_list();
+	close_all_HFILE_list();
 }
 #endif
 
@@ -7147,7 +7678,7 @@ static int internally_opened_fd(int fd,
 		return 1;
 #endif
 	/* If this one of script's fds? */
-	if (fd_in_FILEs(fd))
+	if (fd_in_HFILEs(fd))
 		return 1;
 
 	if (sq) for (i = 0; sq[i].orig_fd >= 0; i++) {
@@ -7172,7 +7703,7 @@ static int setup_redirects(struct comman
 			save_fd_on_redirect(redir->rd_fd, /*avoid:*/ 0, sqp);
 			/* for REDIRECT_HEREDOC2, rd_filename holds _contents_
 			 * of the heredoc */
-			debug_printf_parse("set heredoc '%s'\n",
+			debug_printf_redir("set heredoc '%s'\n",
 					redir->rd_filename);
 			setup_heredoc(redir);
 			continue;
@@ -7184,8 +7715,7 @@ static int setup_redirects(struct comman
 			int mode;
 
 			if (redir->rd_filename == NULL) {
-				/*
-				 * Examples:
+				/* Examples:
 				 * "cmd >" (no filename)
 				 * "cmd > <file" (2nd redirect starts too early)
 				 */
@@ -7241,7 +7771,7 @@ static int setup_redirects(struct comman
 			 */
 		} else {
 			/* if newfd is a script fd or saved fd, simulate EBADF */
-			if (internally_opened_fd(newfd, sqp ? *sqp : NULL)) {
+			if (internally_opened_fd(newfd, sqp && sqp != ERR_PTR ? *sqp : NULL)) {
 				//errno = EBADF;
 				//bb_perror_msg_and_die("can't duplicate file descriptor");
 				newfd = -1; /* same effect as code above */
@@ -7599,28 +8129,65 @@ static void execvp_or_die(char **argv)
 }
 
 #if ENABLE_HUSH_MODE_X
+static void x_mode_print_optionally_squoted(const char *str)
+{
+	unsigned len;
+	const char *cp;
+
+	cp = str;
+
+	/* the set of chars which-cause-string-to-be-squoted mimics bash */
+	/* test a char with: bash -c 'set -x; echo "CH"' */
+	if (str[strcspn(str, "\\\"'`$(){}[]<>;#&|~*?!^"
+			" " "\001\002\003\004\005\006\007"
+			"\010\011\012\013\014\015\016\017"
+			"\020\021\022\023\024\025\026\027"
+			"\030\031\032\033\034\035\036\037"
+			)
+		] == '\0'
+	) {
+		/* string has no special chars */
+		x_mode_addstr(str);
+		return;
+	}
+
+	cp = str;
+	for (;;) {
+		/* print '....' up to EOL or first squote */
+		len = (int)(strchrnul(cp, '\'') - cp);
+		if (len != 0) {
+			x_mode_addchr('\'');
+			x_mode_addblock(cp, len);
+			x_mode_addchr('\'');
+			cp += len;
+		}
+		if (*cp == '\0')
+			break;
+		/* string contains squote(s), print them as \' */
+		x_mode_addchr('\\');
+		x_mode_addchr('\'');
+		cp++;
+	}
+}
 static void dump_cmd_in_x_mode(char **argv)
 {
 	if (G_x_mode && argv) {
-		/* We want to output the line in one write op */
-		char *buf, *p;
-		int len;
-		int n;
+		unsigned n;
 
-		len = 3;
-		n = 0;
-		while (argv[n])
-			len += strlen(argv[n++]) + 1;
-		buf = xmalloc(len);
-		buf[0] = '+';
-		p = buf + 1;
+		/* "+[+++...][ cmd...]\n\0" */
+		x_mode_prefix();
 		n = 0;
-		while (argv[n])
-			p += sprintf(p, " %s", argv[n++]);
-		*p++ = '\n';
-		*p = '\0';
-		fputs(buf, stderr);
-		free(buf);
+		while (argv[n]) {
+			x_mode_addchr(' ');
+			if (argv[n][0] == '\0') {
+				x_mode_addchr('\'');
+				x_mode_addchr('\'');
+			} else {
+				x_mode_print_optionally_squoted(argv[n]);
+			}
+			n++;
+		}
+		x_mode_flush();
 	}
 }
 #else
@@ -8256,8 +8823,8 @@ static int checkjobs_and_fg_shell(struct
  * subshell:     ( list ) [&]
  */
 #if !ENABLE_HUSH_MODE_X
-#define redirect_and_varexp_helper(command, squirrel, argv_expanded) \
-	redirect_and_varexp_helper(command, squirrel)
+#define redirect_and_varexp_helper(command, sqp, argv_expanded) \
+	redirect_and_varexp_helper(command, sqp)
 #endif
 static int redirect_and_varexp_helper(
 		struct command *command,
@@ -8274,10 +8841,6 @@ static int redirect_and_varexp_helper(
 	/* this takes ownership of new_env[i] elements, and frees new_env: */
 	set_vars_and_save_old(new_env);
 
-	/* setup_redirects acts on file descriptors, not FILEs.
-	 * This is perfect for work that comes after exec().
-	 * Is it really safe for inline use?  Experimentally,
-	 * things seem to work. */
 	return setup_redirects(command, sqp);
 }
 static NOINLINE int run_pipe(struct pipe *pi)
@@ -8366,7 +8929,7 @@ static NOINLINE int run_pipe(struct pipe
 		}
 #endif
 		/* { list } */
-		debug_printf("non-subshell group\n");
+		debug_printf_exec("non-subshell group\n");
 		rcode = 1; /* exitcode if redir failed */
 		if (setup_redirects(command, &squirrel) == 0) {
 			debug_printf_exec(": run_list\n");
@@ -8410,16 +8973,25 @@ static NOINLINE int run_pipe(struct pipe
 			restore_redirects(squirrel);
 
 			/* Set shell variables */
-			if (G_x_mode)
-				bb_putchar_stderr('+');
 			i = 0;
 			while (i < command->assignment_cnt) {
 				char *p = expand_string_to_string(argv[i],
 						EXP_FLAG_ESC_GLOB_CHARS,
 						/*unbackslash:*/ 1
 				);
-				if (G_x_mode)
-					fprintf(stderr, " %s", p);
+#if ENABLE_HUSH_MODE_X
+				if (G_x_mode) {
+					char *eq;
+					if (i == 0)
+						x_mode_prefix();
+					x_mode_addchr(' ');
+					eq = strchrnul(p, '=');
+					if (*eq) eq++;
+					x_mode_addblock(p, (eq - p));
+					x_mode_print_optionally_squoted(eq);
+					x_mode_flush();
+				}
+#endif
 				debug_printf_env("set shell var:'%s'->'%s'\n", *argv, p);
 				if (set_local_var(p, /*flag:*/ 0)) {
 					/* assignment to readonly var / putenv error? */
@@ -8427,8 +8999,6 @@ static NOINLINE int run_pipe(struct pipe
 				}
 				i++;
 			}
-			if (G_x_mode)
-				bb_putchar_stderr('\n');
 			/* Redirect error sets $? to 1. Otherwise,
 			 * if evaluating assignment value set $?, retain it.
 			 * Else, clear $?:
@@ -8478,7 +9048,10 @@ static NOINLINE int run_pipe(struct pipe
 				 */
 				enter_var_nest_level();
 				G.shadowed_vars_pp = &old_vars;
-				rcode = redirect_and_varexp_helper(command, /*squirrel:*/ NULL, argv_expanded);
+				rcode = redirect_and_varexp_helper(command,
+					/*squirrel:*/ ERR_PTR,
+					argv_expanded
+				);
 				G.shadowed_vars_pp = sv_shadowed;
 				/* rcode=1 can be if redir file can't be opened */
 
@@ -8874,11 +9447,11 @@ static int run_list(struct pipe *pi)
 				}; /* argv list with one element: "$@" */
 				char **vals;
 
+				G.last_exitcode = rcode = EXIT_SUCCESS;
 				vals = (char**)encoded_dollar_at_argv;
 				if (pi->next->res_word == RES_IN) {
 					/* if no variable values after "in" we skip "for" */
 					if (!pi->next->cmds[0].argv) {
-						G.last_exitcode = rcode = EXIT_SUCCESS;
 						debug_printf_exec(": null FOR: exitcode EXIT_SUCCESS\n");
 						break;
 					}
@@ -9212,6 +9785,7 @@ static int set_mode(int state, char mode
 		break;
 	case 'x':
 		IF_HUSH_MODE_X(G_x_mode = state;)
+		IF_HUSH_MODE_X(if (G.x_mode_fd <= 0) G.x_mode_fd = dup_CLOEXEC(2, 10);)
 		break;
 	case 'o':
 		if (!o_opt) {
@@ -9317,6 +9891,10 @@ int hush_main(int argc, char **argv)
 		uname(&uts);
 		set_local_var_from_halves("HOSTNAME", uts.nodename);
 	}
+#endif
+	/* IFS is not inherited from the parent environment */
+	set_local_var_from_halves("IFS", defifs);
+
 	/* bash also exports SHLVL and _,
 	 * and sets (but doesn't export) the following variables:
 	 * BASH=/bin/bash
@@ -9347,10 +9925,8 @@ int hush_main(int argc, char **argv)
 	 * TERM=dumb
 	 * OPTERR=1
 	 * OPTIND=1
-	 * IFS=$' \t\n'
 	 * PS4='+ '
 	 */
-#endif
 
 #if ENABLE_HUSH_LINENO_VAR
 	if (ENABLE_HUSH_LINENO_VAR) {
@@ -9380,6 +9956,14 @@ int hush_main(int argc, char **argv)
 	/* http://www.opengroup.org/onlinepubs/9699919799/utilities/sh.html */
 	flags = (argv[0] && argv[0][0] == '-') ? OPT_login : 0;
 	builtin_argc = 0;
+#if NUM_SCRIPTS > 0
+	if (argc < 0) {
+		optarg = get_script_content(-argc - 1);
+		optind = 0;
+		argc = string_array_len(argv);
+		goto run_script;
+	}
+#endif
 	while (1) {
 		int opt = getopt(argc, argv, "+c:exinsl"
 #if !BB_MMU
@@ -9403,6 +9987,9 @@ int hush_main(int argc, char **argv)
 			 * Note: the form without ARG0 never happens:
 			 * sh ... -c 'builtin' BARGV... ""
 			 */
+#if NUM_SCRIPTS > 0
+ run_script:
+#endif
 			if (!G.root_pid) {
 				G.root_pid = getpid();
 				G.root_ppid = getppid();
@@ -9531,14 +10118,13 @@ int hush_main(int argc, char **argv)
 
 	/* If we are login shell... */
 	if (flags & OPT_login) {
-		FILE *input;
+		HFILE *input;
 		debug_printf("sourcing /etc/profile\n");
-		input = fopen_for_read("/etc/profile");
+		input = hfopen("/etc/profile");
 		if (input != NULL) {
-			remember_FILE(input);
 			install_special_sighandlers();
 			parse_and_run_file(input);
-			fclose_and_forget(input);
+			hfclose(input);
 		}
 		/* bash: after sourcing /etc/profile,
 		 * tries to source (in the given order):
@@ -9551,7 +10137,7 @@ int hush_main(int argc, char **argv)
 
 	/* -s is: hush -s ARGV1 ARGV2 (no SCRIPT) */
 	if (!(flags & OPT_s) && G.global_argv[1]) {
-		FILE *input;
+		HFILE *input;
 		/*
 		 * "bash <script>" (which is never interactive (unless -i?))
 		 * sources $BASH_ENV here (without scanning $PATH).
@@ -9562,13 +10148,15 @@ int hush_main(int argc, char **argv)
 		G.global_argv++;
 		debug_printf("running script '%s'\n", G.global_argv[0]);
 		xfunc_error_retval = 127; /* for "hush /does/not/exist" case */
-		input = xfopen_for_read(G.global_argv[0]);
+		input = hfopen(G.global_argv[0]);
+		if (!input) {
+			bb_simple_perror_msg_and_die(G.global_argv[0]);
+		}
 		xfunc_error_retval = 1;
-		remember_FILE(input);
 		install_special_sighandlers();
 		parse_and_run_file(input);
 #if ENABLE_FEATURE_CLEAN_UP
-		fclose_and_forget(input);
+		hfclose(input);
 #endif
 		goto final_return;
 	}
@@ -9698,7 +10286,7 @@ int hush_main(int argc, char **argv)
 		);
 	}
 
-	parse_and_run_file(stdin);
+	parse_and_run_file(hfopen(NULL)); /* stdin */
 
  final_return:
 	hush_exit(G.last_exitcode);
@@ -9806,41 +10394,45 @@ static int FAST_FUNC builtin_pwd(char **
 
 static int FAST_FUNC builtin_eval(char **argv)
 {
-	int rcode = EXIT_SUCCESS;
-
 	argv = skip_dash_dash(argv);
-	if (argv[0]) {
-		char *str = NULL;
 
-		if (argv[1]) {
-			/* "The eval utility shall construct a command by
-			 * concatenating arguments together, separating
-			 * each with a <space> character."
-			 */
-			char *p;
-			unsigned len = 0;
-			char **pp = argv;
-			do
-				len += strlen(*pp) + 1;
-			while (*++pp);
-			str = p = xmalloc(len);
-			pp = argv;
-			do {
-				p = stpcpy(p, *pp);
-				*p++ = ' ';
-			} while (*++pp);
-			p[-1] = '\0';
-		}
+	if (!argv[0])
+		return EXIT_SUCCESS;
 
+	IF_HUSH_MODE_X(G.x_mode_depth++;)
+	//bb_error_msg("%s: ++x_mode_depth=%d", __func__, G.x_mode_depth);
+	if (!argv[1]) {
 		/* bash:
 		 * eval "echo Hi; done" ("done" is syntax error):
 		 * "echo Hi" will not execute too.
 		 */
-		parse_and_run_string(str ? str : argv[0]);
+		parse_and_run_string(argv[0]);
+	} else {
+		/* "The eval utility shall construct a command by
+		 * concatenating arguments together, separating
+		 * each with a <space> character."
+		 */
+		char *str, *p;
+		unsigned len = 0;
+		char **pp = argv;
+		do
+			len += strlen(*pp) + 1;
+		while (*++pp);
+		str = p = xmalloc(len);
+		pp = argv;
+		for (;;) {
+			p = stpcpy(p, *pp);
+			pp++;
+			if (!*pp)
+				break;
+			*p++ = ' ';
+		}
+		parse_and_run_string(str);
 		free(str);
-		rcode = G.last_exitcode;
 	}
-	return rcode;
+	IF_HUSH_MODE_X(G.x_mode_depth--;)
+	//bb_error_msg("%s: --x_mode_depth=%d", __func__, G.x_mode_depth);
+	return G.last_exitcode;
 }
 
 static int FAST_FUNC builtin_exec(char **argv)
@@ -9959,40 +10551,29 @@ static int FAST_FUNC builtin_type(char *
 static int FAST_FUNC builtin_read(char **argv)
 {
 	const char *r;
-	char *opt_n = NULL;
-	char *opt_p = NULL;
-	char *opt_t = NULL;
-	char *opt_u = NULL;
-	char *opt_d = NULL; /* optimized out if !BASH */
-	const char *ifs;
-	int read_flags;
+	struct builtin_read_params params;
+
+	memset(&params, 0, sizeof(params));
 
 	/* "!": do not abort on errors.
 	 * Option string must start with "sr" to match BUILTIN_READ_xxx
 	 */
-	read_flags = getopt32(argv,
+	params.read_flags = getopt32(argv,
 #if BASH_READ_D
-		"!srn:p:t:u:d:", &opt_n, &opt_p, &opt_t, &opt_u, &opt_d
+		"!srn:p:t:u:d:", &params.opt_n, &params.opt_p, &params.opt_t, &params.opt_u, &params.opt_d
 #else
-		"!srn:p:t:u:", &opt_n, &opt_p, &opt_t, &opt_u
+		"!srn:p:t:u:", &params.opt_n, &params.opt_p, &params.opt_t, &params.opt_u
 #endif
 	);
-	if (read_flags == (uint32_t)-1)
+	if ((uint32_t)params.read_flags == (uint32_t)-1)
 		return EXIT_FAILURE;
 	argv += optind;
-	ifs = get_local_var_value("IFS"); /* can be NULL */
+	params.argv = argv;
+	params.setvar = set_local_var_from_halves;
+	params.ifs = get_local_var_value("IFS"); /* can be NULL */
 
  again:
-	r = shell_builtin_read(set_local_var_from_halves,
-		argv,
-		ifs,
-		read_flags,
-		opt_n,
-		opt_p,
-		opt_t,
-		opt_u,
-		opt_d
-	);
+	r = shell_builtin_read(&params);
 
 	if ((uintptr_t)r == 1 && errno == EINTR) {
 		unsigned sig = check_and_run_traps();
@@ -10509,7 +11090,7 @@ Test that VAR is a valid variable name?
 static int FAST_FUNC builtin_source(char **argv)
 {
 	char *arg_path, *filename;
-	FILE *input;
+	HFILE *input;
 	save_arg_t sv;
 	char *args_need_save;
 #if ENABLE_HUSH_FUNCTIONS
@@ -10533,10 +11114,10 @@ static int FAST_FUNC builtin_source(char
 			return EXIT_FAILURE;
 		}
 	}
-	input = remember_FILE(fopen_or_warn(filename, "r"));
+	input = hfopen(filename);
 	free(arg_path);
 	if (!input) {
-		/* bb_perror_msg("%s", *argv); - done by fopen_or_warn */
+		bb_perror_msg("%s", filename);
 		/* POSIX: non-interactive shell should abort here,
 		 * not merely fail. So far no one complained :)
 		 */
@@ -10555,7 +11136,7 @@ static int FAST_FUNC builtin_source(char
 	/* "false; . ./empty_line; echo Zero:$?" should print 0 */
 	G.last_exitcode = 0;
 	parse_and_run_file(input);
-	fclose_and_forget(input);
+	hfclose(input);
 
 	if (args_need_save) /* can't use argv[1] instead: "shift" can mangle it */
 		restore_G_args(&sv, argv);
@@ -10861,7 +11442,7 @@ static int wait_for_child_or_signal(stru
 		 * and get stuck in sigsuspend...
 		 */
 		sigfillset(&oldset); /* block all signals, remember old set */
-		sigprocmask(SIG_SETMASK, &oldset, &oldset);
+		sigprocmask2(SIG_SETMASK, &oldset);
 
 		if (!sigisemptyset(&G.pending_set)) {
 			/* Crap! we raced with some signal! */
diff -urpN busybox-1.29.3/shell/hush_test/hush-glob/glob_altvalue1.right busybox-1.30.0/shell/hush_test/hush-glob/glob_altvalue1.right
--- busybox-1.29.3/shell/hush_test/hush-glob/glob_altvalue1.right	1970-01-01 01:00:00.000000000 +0100
+++ busybox-1.30.0/shell/hush_test/hush-glob/glob_altvalue1.right	2018-12-05 15:44:34.000000000 +0100
@@ -0,0 +1,7 @@
+1u: glob_altvalue1.tests
+2u: glob_altvalue1.t*
+3u: glob_altvalue1.t*
+4u: glob_altvalue1.t*
+1q: glob_altvalue1.t*
+2q: 'glob_altvalue1.t*'
+3q: glob_altvalue1.t*
diff -urpN busybox-1.29.3/shell/hush_test/hush-glob/glob_altvalue1.tests busybox-1.30.0/shell/hush_test/hush-glob/glob_altvalue1.tests
--- busybox-1.29.3/shell/hush_test/hush-glob/glob_altvalue1.tests	1970-01-01 01:00:00.000000000 +0100
+++ busybox-1.30.0/shell/hush_test/hush-glob/glob_altvalue1.tests	2018-12-05 15:44:34.000000000 +0100
@@ -0,0 +1,13 @@
+x=x
+
+echo 1u: ${x:+glob_altvalue1.t*}
+echo 2u: ${x:+'glob_altvalue1.t*'}
+echo 3u: ${x:+"glob_altvalue1.t*"}
+echo 4u: ${x:+glob_altvalue1.t\*}
+##echo 5u: ${x:+"glob_altvalue1.t\*"}
+
+echo 1q: "${x:+glob_altvalue1.t*}"
+echo 2q: "${x:+'glob_altvalue1.t*'}"
+echo 3q: "${x:+"glob_altvalue1.t*"}"
+##echo 4q: "${x:+glob_altvalue1.t\*}"
+##echo 5q: "${x:+"glob_altvalue1.t\*"}"
diff -urpN busybox-1.29.3/shell/hush_test/hush-glob/glob_bkslash_in_var.right busybox-1.30.0/shell/hush_test/hush-glob/glob_bkslash_in_var.right
--- busybox-1.29.3/shell/hush_test/hush-glob/glob_bkslash_in_var.right	1970-01-01 01:00:00.000000000 +0100
+++ busybox-1.30.0/shell/hush_test/hush-glob/glob_bkslash_in_var.right	2018-12-05 15:44:34.000000000 +0100
@@ -0,0 +1,4 @@
+Unquoted non-matching glob in var:'test*.TMP/\name_doesnt_exist'
+Unquoted matching glob in var:    'testdir.TMP/name'
+Quoted non-matching glob in var:  'test*.TMP/\name_doesnt_exist'
+Quoted matching glob in var:      'test*.TMP/\name'
diff -urpN busybox-1.29.3/shell/hush_test/hush-glob/glob_bkslash_in_var.tests busybox-1.30.0/shell/hush_test/hush-glob/glob_bkslash_in_var.tests
--- busybox-1.29.3/shell/hush_test/hush-glob/glob_bkslash_in_var.tests	1970-01-01 01:00:00.000000000 +0100
+++ busybox-1.30.0/shell/hush_test/hush-glob/glob_bkslash_in_var.tests	2018-12-05 15:44:34.000000000 +0100
@@ -0,0 +1,10 @@
+mkdir testdir.TMP
+>testdir.TMP/name
+a="test*.TMP/\name_doesnt_exist"
+b="test*.TMP/\name"
+printf "Unquoted non-matching glob in var:'%s'\n" $a
+printf "Unquoted matching glob in var:    '%s'\n" $b
+printf "Quoted non-matching glob in var:  '%s'\n" "$a"
+printf "Quoted matching glob in var:      '%s'\n" "$b"
+rm -f testdir.TMP/name
+rmdir testdir.TMP
diff -urpN busybox-1.29.3/shell/hush_test/hush-heredoc/heredoc.right busybox-1.30.0/shell/hush_test/hush-heredoc/heredoc.right
--- busybox-1.29.3/shell/hush_test/hush-heredoc/heredoc.right	1970-01-01 01:00:00.000000000 +0100
+++ busybox-1.30.0/shell/hush_test/hush-heredoc/heredoc.right	2018-12-05 15:44:34.000000000 +0100
@@ -0,0 +1,20 @@
+there
+one - alpha
+two - beta
+three - gamma
+hi\
+there$a
+stuff
+hi\
+there
+EO\
+F
+hi
+hi
+tab 1
+tab 2
+tab 3
+abc
+def ghi
+jkl mno
+fff is a function
diff -urpN busybox-1.29.3/shell/hush_test/hush-heredoc/heredoc.tests busybox-1.30.0/shell/hush_test/hush-heredoc/heredoc.tests
--- busybox-1.29.3/shell/hush_test/hush-heredoc/heredoc.tests	1970-01-01 01:00:00.000000000 +0100
+++ busybox-1.30.0/shell/hush_test/hush-heredoc/heredoc.tests	2018-12-05 15:44:34.000000000 +0100
@@ -0,0 +1,97 @@
+# check order and content of multiple here docs
+
+cat << EOF1 << EOF2
+hi
+EOF1
+there
+EOF2
+
+while read line1; do
+	read line2 <&3
+	echo $line1 - $line2
+done <<EOF1 3<<EOF2
+one
+two
+three
+EOF1
+alpha
+beta
+gamma
+EOF2
+
+
+# check quoted here-doc is protected
+
+a=foo
+cat << 'EOF'
+hi\
+there$a
+stuff
+EOF
+
+# check that quoted here-documents don't have \newline processing done
+
+cat << 'EOF'
+hi\
+there
+EO\
+F
+EOF
+true
+
+# check that \newline is removed at start of here-doc
+cat << EO\
+F
+hi
+EOF
+
+# check that \newline removal works for here-doc delimiter
+cat << EOF
+hi
+EO\
+F
+
+# check operation of tab removal in here documents
+cat <<- EOF
+	tab 1
+	tab 2
+	tab 3
+	EOF
+
+# check appending of text to file from here document
+rm -f /tmp/bash-zzz
+cat > /tmp/bash-zzz << EOF
+abc
+EOF
+cat >> /tmp/bash-zzz << EOF
+def ghi
+jkl mno
+EOF
+cat /tmp/bash-zzz
+rm -f /tmp/bash-zzz
+
+# make sure command printing puts the here-document as the last redirection
+# on the line, and the function export code preserves syntactic correctness
+fff()
+{
+  ed /tmp/foo <<ENDOFINPUT >/dev/null
+/^name/d
+w
+q
+ENDOFINPUT
+aa=1
+}
+
+type fff
+#ash# export -f fff
+#ash# ${THIS_SH} -c 'type fff'
+
+#hush# bash warns: "here-document at line N delimited by end-of-file",
+#hush# ash allows it,
+#hush# hush errors out for now:
+#hush# # check that end of file delimits a here-document
+#hush# # THIS MUST BE LAST!
+#hush#
+#hush# cat << EOF
+#hush# hi
+#hush# there
diff -urpN busybox-1.29.3/shell/hush_test/hush-heredoc/heredoc9.right busybox-1.30.0/shell/hush_test/hush-heredoc/heredoc9.right
--- busybox-1.29.3/shell/hush_test/hush-heredoc/heredoc9.right	1970-01-01 01:00:00.000000000 +0100
+++ busybox-1.30.0/shell/hush_test/hush-heredoc/heredoc9.right	2018-12-05 15:44:34.000000000 +0100
@@ -0,0 +1 @@
+hello
diff -urpN busybox-1.29.3/shell/hush_test/hush-heredoc/heredoc9.tests busybox-1.30.0/shell/hush_test/hush-heredoc/heredoc9.tests
--- busybox-1.29.3/shell/hush_test/hush-heredoc/heredoc9.tests	1970-01-01 01:00:00.000000000 +0100
+++ busybox-1.30.0/shell/hush_test/hush-heredoc/heredoc9.tests	2018-12-05 15:44:34.000000000 +0100
@@ -0,0 +1,9 @@
+echo hello >greeting
+cat <<EOF &&
+$(cat greeting)
+EOF
+{
+	echo $?
+	cat greeting
+} >/dev/null
+rm greeting
diff -urpN busybox-1.29.3/shell/hush_test/hush-heredoc/heredocA.right busybox-1.30.0/shell/hush_test/hush-heredoc/heredocA.right
--- busybox-1.29.3/shell/hush_test/hush-heredoc/heredocA.right	1970-01-01 01:00:00.000000000 +0100
+++ busybox-1.30.0/shell/hush_test/hush-heredoc/heredocA.right	2018-12-05 15:44:34.000000000 +0100
@@ -0,0 +1 @@
+Ok
diff -urpN busybox-1.29.3/shell/hush_test/hush-heredoc/heredocA.tests busybox-1.30.0/shell/hush_test/hush-heredoc/heredocA.tests
--- busybox-1.29.3/shell/hush_test/hush-heredoc/heredocA.tests	1970-01-01 01:00:00.000000000 +0100
+++ busybox-1.30.0/shell/hush_test/hush-heredoc/heredocA.tests	2018-12-05 15:44:34.000000000 +0100
@@ -0,0 +1,4 @@
+{ cat <<EOF ;
+Ok
+EOF
+}
diff -urpN busybox-1.29.3/shell/hush_test/hush-heredoc/heredocB.right busybox-1.30.0/shell/hush_test/hush-heredoc/heredocB.right
--- busybox-1.29.3/shell/hush_test/hush-heredoc/heredocB.right	1970-01-01 01:00:00.000000000 +0100
+++ busybox-1.30.0/shell/hush_test/hush-heredoc/heredocB.right	2018-12-05 15:44:34.000000000 +0100
@@ -0,0 +1,3 @@
+one - alpha
+two - beta
+three - gamma
diff -urpN busybox-1.29.3/shell/hush_test/hush-heredoc/heredocB.tests busybox-1.30.0/shell/hush_test/hush-heredoc/heredocB.tests
--- busybox-1.29.3/shell/hush_test/hush-heredoc/heredocB.tests	1970-01-01 01:00:00.000000000 +0100
+++ busybox-1.30.0/shell/hush_test/hush-heredoc/heredocB.tests	2018-12-05 15:44:34.000000000 +0100
@@ -0,0 +1,12 @@
+while read line1; do
+	read line2 <&3
+	echo $line1 - $line2
+done <<EOF1 3<<EOF2
+one
+two
+three
+EOF1
+alpha
+beta
+gamma
+EOF2
diff -urpN busybox-1.29.3/shell/hush_test/hush-heredoc/heredoc_after_compound1.right busybox-1.30.0/shell/hush_test/hush-heredoc/heredoc_after_compound1.right
--- busybox-1.29.3/shell/hush_test/hush-heredoc/heredoc_after_compound1.right	1970-01-01 01:00:00.000000000 +0100
+++ busybox-1.30.0/shell/hush_test/hush-heredoc/heredoc_after_compound1.right	2018-12-05 15:44:34.000000000 +0100
@@ -0,0 +1,2 @@
+Ok1
+Ok2
diff -urpN busybox-1.29.3/shell/hush_test/hush-heredoc/heredoc_after_compound1.tests busybox-1.30.0/shell/hush_test/hush-heredoc/heredoc_after_compound1.tests
--- busybox-1.29.3/shell/hush_test/hush-heredoc/heredoc_after_compound1.tests	1970-01-01 01:00:00.000000000 +0100
+++ busybox-1.30.0/shell/hush_test/hush-heredoc/heredoc_after_compound1.tests	2018-12-05 15:44:34.000000000 +0100
@@ -0,0 +1,3 @@
+{ cat <<EOF; }; echo Ok2
+Ok1
+EOF
diff -urpN busybox-1.29.3/shell/hush_test/hush-heredoc/heredoc_bkslash_newline2.right busybox-1.30.0/shell/hush_test/hush-heredoc/heredoc_bkslash_newline2.right
--- busybox-1.29.3/shell/hush_test/hush-heredoc/heredoc_bkslash_newline2.right	1970-01-01 01:00:00.000000000 +0100
+++ busybox-1.30.0/shell/hush_test/hush-heredoc/heredoc_bkslash_newline2.right	2018-12-05 15:44:34.000000000 +0100
@@ -0,0 +1 @@
+Ok1
diff -urpN busybox-1.29.3/shell/hush_test/hush-heredoc/heredoc_bkslash_newline2.tests busybox-1.30.0/shell/hush_test/hush-heredoc/heredoc_bkslash_newline2.tests
--- busybox-1.29.3/shell/hush_test/hush-heredoc/heredoc_bkslash_newline2.tests	1970-01-01 01:00:00.000000000 +0100
+++ busybox-1.30.0/shell/hush_test/hush-heredoc/heredoc_bkslash_newline2.tests	2018-12-05 15:44:34.000000000 +0100
@@ -0,0 +1,4 @@
+cat <<EOF
+Ok1
+EO\
+F
diff -urpN busybox-1.29.3/shell/hush_test/hush-heredoc/heredoc_empty3.right busybox-1.30.0/shell/hush_test/hush-heredoc/heredoc_empty3.right
--- busybox-1.29.3/shell/hush_test/hush-heredoc/heredoc_empty3.right	1970-01-01 01:00:00.000000000 +0100
+++ busybox-1.30.0/shell/hush_test/hush-heredoc/heredoc_empty3.right	2018-12-05 15:44:34.000000000 +0100
@@ -0,0 +1,2 @@
+
+Ok
diff -urpN busybox-1.29.3/shell/hush_test/hush-heredoc/heredoc_empty3.tests busybox-1.30.0/shell/hush_test/hush-heredoc/heredoc_empty3.tests
--- busybox-1.29.3/shell/hush_test/hush-heredoc/heredoc_empty3.tests	1970-01-01 01:00:00.000000000 +0100
+++ busybox-1.30.0/shell/hush_test/hush-heredoc/heredoc_empty3.tests	2018-12-05 15:44:34.000000000 +0100
@@ -0,0 +1,4 @@
+cat <<EOF
+
+Ok
+EOF
diff -urpN busybox-1.29.3/shell/hush_test/hush-heredoc/heredoc_var_expand1.right busybox-1.30.0/shell/hush_test/hush-heredoc/heredoc_var_expand1.right
--- busybox-1.29.3/shell/hush_test/hush-heredoc/heredoc_var_expand1.right	1970-01-01 01:00:00.000000000 +0100
+++ busybox-1.30.0/shell/hush_test/hush-heredoc/heredoc_var_expand1.right	2018-12-05 15:44:34.000000000 +0100
@@ -0,0 +1,4 @@
+
+Ok1:0
+
+Ok2:0
diff -urpN busybox-1.29.3/shell/hush_test/hush-heredoc/heredoc_var_expand1.tests busybox-1.30.0/shell/hush_test/hush-heredoc/heredoc_var_expand1.tests
--- busybox-1.29.3/shell/hush_test/hush-heredoc/heredoc_var_expand1.tests	1970-01-01 01:00:00.000000000 +0100
+++ busybox-1.30.0/shell/hush_test/hush-heredoc/heredoc_var_expand1.tests	2018-12-05 15:44:34.000000000 +0100
@@ -0,0 +1,11 @@
+x='*'
+
+cat <<- EOF
+	${x#'*'}
+EOF
+echo Ok1:$?
+
+cat <<EOF
+${x#'*'}
+EOF
+echo Ok2:$?
diff -urpN busybox-1.29.3/shell/hush_test/hush-misc/empty_for1.right busybox-1.30.0/shell/hush_test/hush-misc/empty_for1.right
--- busybox-1.29.3/shell/hush_test/hush-misc/empty_for1.right	1970-01-01 01:00:00.000000000 +0100
+++ busybox-1.30.0/shell/hush_test/hush-misc/empty_for1.right	2018-12-05 15:44:34.000000000 +0100
@@ -0,0 +1 @@
+Zero:0
diff -urpN busybox-1.29.3/shell/hush_test/hush-misc/empty_for1.tests busybox-1.30.0/shell/hush_test/hush-misc/empty_for1.tests
--- busybox-1.29.3/shell/hush_test/hush-misc/empty_for1.tests	1970-01-01 01:00:00.000000000 +0100
+++ busybox-1.30.0/shell/hush_test/hush-misc/empty_for1.tests	2018-12-05 15:44:34.000000000 +0100
@@ -0,0 +1,5 @@
+false
+for v; do
+	exit 2
+done
+echo Zero:$?
diff -urpN busybox-1.29.3/shell/hush_test/hush-misc/env_and_func.tests busybox-1.30.0/shell/hush_test/hush-misc/env_and_func.tests
--- busybox-1.29.3/shell/hush_test/hush-misc/env_and_func.tests	2018-07-02 13:23:06.000000000 +0200
+++ busybox-1.30.0/shell/hush_test/hush-misc/env_and_func.tests	2018-12-05 15:44:34.000000000 +0100
@@ -3,6 +3,6 @@ f() { echo "var=$var"; }
 # bash: POSIXLY_CORRECT behavior is to "leak" new variable values
 # out of function invocations (similar to "special builtins" behavior);
 # but in "bash mode", they don't leak.
-# hush does not "leak" values. ash does.
+# hush does not "leak" values. ash used to, but now does not.
 var=val f
 echo "var=$var"
diff -urpN busybox-1.29.3/shell/hush_test/hush-quoting/dollar_altvalue1.right busybox-1.30.0/shell/hush_test/hush-quoting/dollar_altvalue1.right
--- busybox-1.29.3/shell/hush_test/hush-quoting/dollar_altvalue1.right	1970-01-01 01:00:00.000000000 +0100
+++ busybox-1.30.0/shell/hush_test/hush-quoting/dollar_altvalue1.right	2018-12-05 15:44:34.000000000 +0100
@@ -0,0 +1,16 @@
+Unquoted b c d
+|b|
+|c|
+|d|
+Unquoted 'b c' d
+|b c|
+|d|
+Unquoted "b c" d
+|b c|
+|d|
+Quoted b c d
+|b c d|
+Quoted 'b c' d
+|'b c' d|
+Quoted "b c" d
+|b c d|
diff -urpN busybox-1.29.3/shell/hush_test/hush-quoting/dollar_altvalue1.tests busybox-1.30.0/shell/hush_test/hush-quoting/dollar_altvalue1.tests
--- busybox-1.29.3/shell/hush_test/hush-quoting/dollar_altvalue1.tests	1970-01-01 01:00:00.000000000 +0100
+++ busybox-1.30.0/shell/hush_test/hush-quoting/dollar_altvalue1.tests	2018-12-05 15:44:34.000000000 +0100
@@ -0,0 +1,16 @@
+f() { for i; do echo "|$i|"; done; }
+x=a
+
+echo Unquoted b c d
+f ${x:+b c d}
+echo Unquoted "'b c' d"
+f ${x:+'b c' d}
+echo Unquoted '"b c" d'
+f ${x:+"b c" d}
+
+echo Quoted b c d
+f "${x:+b c d}"
+echo Quoted "'b c' d"
+f "${x:+'b c' d}"
+echo Quoted '"b c" d'
+f "${x:+"b c" d}"
diff -urpN busybox-1.29.3/shell/hush_test/hush-quoting/dollar_altvalue2.right busybox-1.30.0/shell/hush_test/hush-quoting/dollar_altvalue2.right
--- busybox-1.29.3/shell/hush_test/hush-quoting/dollar_altvalue2.right	1970-01-01 01:00:00.000000000 +0100
+++ busybox-1.30.0/shell/hush_test/hush-quoting/dollar_altvalue2.right	2018-12-05 15:44:34.000000000 +0100
@@ -0,0 +1,69 @@
+Unquoted '':
+start:
+||
+end
+start:
+||
+end
+start:
+||
+end
+start:
+||
+end
+start:
+||
+||
+end
+
+Unquoted "":
+start:
+||
+end
+start:
+||
+end
+start:
+||
+end
+start:
+||
+end
+start:
+||
+||
+end
+
+Quoted '':
+start:
+|''|
+end
+start:
+|'' |
+end
+start:
+| ''|
+end
+start:
+| '' |
+end
+start:
+|'' ''|
+end
+
+Quoted "":
+start:
+||
+end
+start:
+| |
+end
+start:
+| |
+end
+start:
+|  |
+end
+start:
+| |
+end
diff -urpN busybox-1.29.3/shell/hush_test/hush-quoting/dollar_altvalue2.tests busybox-1.30.0/shell/hush_test/hush-quoting/dollar_altvalue2.tests
--- busybox-1.29.3/shell/hush_test/hush-quoting/dollar_altvalue2.tests	1970-01-01 01:00:00.000000000 +0100
+++ busybox-1.30.0/shell/hush_test/hush-quoting/dollar_altvalue2.tests	2018-12-05 15:44:34.000000000 +0100
@@ -0,0 +1,33 @@
+f() { echo start:; for i; do echo "|$i|"; done; echo end; }
+x=a
+
+echo "Unquoted '':"
+f ${x:+''}
+f ${x:+'' }
+f ${x:+ ''}
+f ${x:+ '' }
+f ${x:+'' ''}
+
+echo
+echo 'Unquoted "":'
+f ${x:+""}
+f ${x:+"" }
+f ${x:+ ""}
+f ${x:+ "" }
+f ${x:+"" ""}
+
+echo
+echo "Quoted '':"
+f "${x:+''}"
+f "${x:+'' }"
+f "${x:+ ''}"
+f "${x:+ '' }"
+f "${x:+'' ''}"
+
+echo
+echo 'Quoted "":'
+f "${x:+""}"
+f "${x:+"" }"
+f "${x:+ ""}"
+f "${x:+ "" }"
+f "${x:+"" ""}"
diff -urpN busybox-1.29.3/shell/hush_test/hush-quoting/dollar_altvalue9.right busybox-1.30.0/shell/hush_test/hush-quoting/dollar_altvalue9.right
--- busybox-1.29.3/shell/hush_test/hush-quoting/dollar_altvalue9.right	1970-01-01 01:00:00.000000000 +0100
+++ busybox-1.30.0/shell/hush_test/hush-quoting/dollar_altvalue9.right	2018-12-05 15:44:34.000000000 +0100
@@ -0,0 +1,26 @@
+Unquoted 1:
+|a|
+|x y|
+|1|
+|2|
+||
+|1 2|
+|A|
+|B|
+|C D|
+|zb|
+Quoted 1:
+|a 'x y' 1 2 ''  1 2 A B C D zb|
+Unquoted 2:
+|ax y|
+|1|
+|2|
+||
+|1 2|
+|A|
+|B|
+|C D|
+|z|
+|b|
+Quoted 2:
+|a 'x y' 1 2 ''  1 2 A B C D z b|
diff -urpN busybox-1.29.3/shell/hush_test/hush-quoting/dollar_altvalue9.tests busybox-1.30.0/shell/hush_test/hush-quoting/dollar_altvalue9.tests
--- busybox-1.29.3/shell/hush_test/hush-quoting/dollar_altvalue9.tests	1970-01-01 01:00:00.000000000 +0100
+++ busybox-1.30.0/shell/hush_test/hush-quoting/dollar_altvalue9.tests	2018-12-05 15:44:34.000000000 +0100
@@ -0,0 +1,17 @@
+f() { for i; do echo "|$i|"; done; }
+
+echo Unquoted 1:
+x='1 2'; f a${x:+ 'x y' $x ''  "$x" `echo A B` "`echo C D`" z}b
+echo Quoted 1:
+x='1 2'; f "a${x:+ 'x y' $x ''  "$x" `echo A B` "`echo C D`" z}b"
+
+echo Unquoted 2:
+x='1 2'; f a${x:+'x y' $x ''  "$x" `echo A B` "`echo C D`" z }b
+echo Quoted 2:
+x='1 2'; f "a${x:+ 'x y' $x ''  "$x" `echo A B` "`echo C D`" z }b"
+
+#echo Unquoted 3:
+#e=
+#x='1 2'; f a${x:+'x y' $x ''  "$x" $e $e "$e" $e `echo A B` "`echo C D`" z }b
+#echo Quoted 3:
+#x='1 2'; f "a${x:+ 'x y' $x ''  "$x" $e $e "$e" $e `echo A B` "`echo C D`" z }b"
diff -urpN busybox-1.29.3/shell/hush_test/hush-quoting/dollar_repl_bash1.right busybox-1.30.0/shell/hush_test/hush-quoting/dollar_repl_bash1.right
--- busybox-1.29.3/shell/hush_test/hush-quoting/dollar_repl_bash1.right	1970-01-01 01:00:00.000000000 +0100
+++ busybox-1.30.0/shell/hush_test/hush-quoting/dollar_repl_bash1.right	2018-12-05 15:44:34.000000000 +0100
@@ -0,0 +1,14 @@
+|y|
+|zx|
+|y|
+|zx|
+|y zx|
+|y zx|
+|y|
+|zy|
+|z|
+|y|
+|zy|
+|z|
+|y zy z|
+|y zy z|
diff -urpN busybox-1.29.3/shell/hush_test/hush-quoting/dollar_repl_bash1.tests busybox-1.30.0/shell/hush_test/hush-quoting/dollar_repl_bash1.tests
--- busybox-1.29.3/shell/hush_test/hush-quoting/dollar_repl_bash1.tests	1970-01-01 01:00:00.000000000 +0100
+++ busybox-1.30.0/shell/hush_test/hush-quoting/dollar_repl_bash1.tests	2018-12-05 15:44:34.000000000 +0100
@@ -0,0 +1,12 @@
+f() { for i; do echo "|$i|"; done; }
+v=xx
+
+f ${v/'x'/"y z"}
+f ${v/"x"/'y z'}
+f "${v/'x'/"y z"}"
+f "${v/"x"/'y z'}"
+
+f ${v//'x'/"y z"}
+f ${v//"x"/'y z'}
+f "${v//'x'/"y z"}"
+f "${v//"x"/'y z'}"
diff -urpN busybox-1.29.3/shell/hush_test/hush-quoting/quote_in_varexp1.right busybox-1.30.0/shell/hush_test/hush-quoting/quote_in_varexp1.right
--- busybox-1.29.3/shell/hush_test/hush-quoting/quote_in_varexp1.right	1970-01-01 01:00:00.000000000 +0100
+++ busybox-1.30.0/shell/hush_test/hush-quoting/quote_in_varexp1.right	2018-12-05 15:44:34.000000000 +0100
@@ -0,0 +1,2 @@
+''
+Ok:0
diff -urpN busybox-1.29.3/shell/hush_test/hush-quoting/quote_in_varexp1.tests busybox-1.30.0/shell/hush_test/hush-quoting/quote_in_varexp1.tests
--- busybox-1.29.3/shell/hush_test/hush-quoting/quote_in_varexp1.tests	1970-01-01 01:00:00.000000000 +0100
+++ busybox-1.30.0/shell/hush_test/hush-quoting/quote_in_varexp1.tests	2018-12-05 15:44:34.000000000 +0100
@@ -0,0 +1,2 @@
+x="''''"; echo "${x#"${x+''}"''}"
+echo Ok:$?
diff -urpN busybox-1.29.3/shell/hush_test/hush-quoting/squote_in_varexp.right busybox-1.30.0/shell/hush_test/hush-quoting/squote_in_varexp.right
--- busybox-1.29.3/shell/hush_test/hush-quoting/squote_in_varexp.right	2018-07-02 13:23:06.000000000 +0200
+++ busybox-1.30.0/shell/hush_test/hush-quoting/squote_in_varexp.right	2018-12-05 15:44:34.000000000 +0100
@@ -1,5 +1,9 @@
 z
 z
+z
+z
+y
+y
 y
 y
 Ok:0
diff -urpN busybox-1.29.3/shell/hush_test/hush-quoting/squote_in_varexp.tests busybox-1.30.0/shell/hush_test/hush-quoting/squote_in_varexp.tests
--- busybox-1.29.3/shell/hush_test/hush-quoting/squote_in_varexp.tests	2018-07-02 13:23:06.000000000 +0200
+++ busybox-1.30.0/shell/hush_test/hush-quoting/squote_in_varexp.tests	2018-12-05 15:44:34.000000000 +0100
@@ -1,6 +1,10 @@
 x=yz
 echo ${x#'y'}
 echo "${x#'y'}"
+echo ${x#"y"}
+echo "${x#"y"}"
 echo ${x%'z'}
 echo "${x%'z'}"
+echo ${x%"z"}
+echo "${x%"z"}"
 echo Ok:$?
diff -urpN busybox-1.29.3/shell/hush_test/hush-quoting/squote_in_varexp2.right busybox-1.30.0/shell/hush_test/hush-quoting/squote_in_varexp2.right
--- busybox-1.29.3/shell/hush_test/hush-quoting/squote_in_varexp2.right	2018-07-02 13:23:06.000000000 +0200
+++ busybox-1.30.0/shell/hush_test/hush-quoting/squote_in_varexp2.right	2018-12-05 15:44:34.000000000 +0100
@@ -1,3 +1,5 @@
 Nothing:
 Nothing:
+Nothing:
+Nothing:
 Ok:0
diff -urpN busybox-1.29.3/shell/hush_test/hush-quoting/squote_in_varexp2.tests busybox-1.30.0/shell/hush_test/hush-quoting/squote_in_varexp2.tests
--- busybox-1.29.3/shell/hush_test/hush-quoting/squote_in_varexp2.tests	2018-07-02 13:23:06.000000000 +0200
+++ busybox-1.30.0/shell/hush_test/hush-quoting/squote_in_varexp2.tests	2018-12-05 15:44:34.000000000 +0100
@@ -1,4 +1,6 @@
 x='\\\\'
 printf Nothing:'%s\n' ${x#'\\\\'}
 printf Nothing:'%s\n' "${x#'\\\\'}"
+printf Nothing:'%s\n' ${x#"\\\\\\\\"}
+printf Nothing:'%s\n' "${x#"\\\\\\\\"}"
 echo Ok:$?
diff -urpN busybox-1.29.3/shell/hush_test/hush-redir/redir_script.tests busybox-1.30.0/shell/hush_test/hush-redir/redir_script.tests
--- busybox-1.29.3/shell/hush_test/hush-redir/redir_script.tests	2018-07-02 13:23:06.000000000 +0200
+++ busybox-1.30.0/shell/hush_test/hush-redir/redir_script.tests	2018-12-05 15:44:34.000000000 +0100
@@ -27,6 +27,10 @@ test x"$fds1" = x"$fds" \
 test x"$fds1" = x" 10>&- 3>&-" && \
 test x"$fds"  = x" 11>&- 3>&-" \
 && { echo "Ok: script fd is not closed"; exit 0; }
+# or we see that fd 3 moved to fd 10:
+test x"$fds1" = x" 3>&- 4>&-" && \
+test x"$fds"  = x" 10>&- 3>&-" \
+&& { echo "Ok: script fd is not closed"; exit 0; }
 
 echo "Bug: script fd is closed"
 echo "fds1:$fds1"
diff -urpN busybox-1.29.3/shell/hush_test/hush-vars/var_bash_pattern_starting_with_slash.right busybox-1.30.0/shell/hush_test/hush-vars/var_bash_pattern_starting_with_slash.right
--- busybox-1.29.3/shell/hush_test/hush-vars/var_bash_pattern_starting_with_slash.right	1970-01-01 01:00:00.000000000 +0100
+++ busybox-1.30.0/shell/hush_test/hush-vars/var_bash_pattern_starting_with_slash.right	2018-12-05 15:44:34.000000000 +0100
@@ -0,0 +1,2 @@
+-dev-ram
+/dev-am
diff -urpN busybox-1.29.3/shell/hush_test/hush-vars/var_bash_pattern_starting_with_slash.tests busybox-1.30.0/shell/hush_test/hush-vars/var_bash_pattern_starting_with_slash.tests
--- busybox-1.29.3/shell/hush_test/hush-vars/var_bash_pattern_starting_with_slash.tests	1970-01-01 01:00:00.000000000 +0100
+++ busybox-1.30.0/shell/hush_test/hush-vars/var_bash_pattern_starting_with_slash.tests	2018-12-05 15:44:34.000000000 +0100
@@ -0,0 +1,3 @@
+v=/dev/ram
+echo ${v////-}
+echo ${v///r/-}
diff -urpN busybox-1.29.3/shell/hush_test/hush-vars/var_wordsplit_ifs5.right busybox-1.30.0/shell/hush_test/hush-vars/var_wordsplit_ifs5.right
--- busybox-1.29.3/shell/hush_test/hush-vars/var_wordsplit_ifs5.right	1970-01-01 01:00:00.000000000 +0100
+++ busybox-1.30.0/shell/hush_test/hush-vars/var_wordsplit_ifs5.right	2018-12-05 15:44:34.000000000 +0100
@@ -0,0 +1 @@
+Zero:0
diff -urpN busybox-1.29.3/shell/hush_test/hush-vars/var_wordsplit_ifs5.tests busybox-1.30.0/shell/hush_test/hush-vars/var_wordsplit_ifs5.tests
--- busybox-1.29.3/shell/hush_test/hush-vars/var_wordsplit_ifs5.tests	1970-01-01 01:00:00.000000000 +0100
+++ busybox-1.30.0/shell/hush_test/hush-vars/var_wordsplit_ifs5.tests	2018-12-05 15:44:34.000000000 +0100
@@ -0,0 +1,4 @@
+IFS=
+set --
+set -- $@ $*
+echo Zero:$#
diff -urpN busybox-1.29.3/shell/hush_test/hush-z_slow/many_ifs.tests busybox-1.30.0/shell/hush_test/hush-z_slow/many_ifs.tests
--- busybox-1.29.3/shell/hush_test/hush-z_slow/many_ifs.tests	2018-07-02 13:23:06.000000000 +0200
+++ busybox-1.30.0/shell/hush_test/hush-z_slow/many_ifs.tests	2018-12-05 15:44:34.000000000 +0100
@@ -229,8 +229,8 @@ do
 						'')	split "$d0$f1$d1$f2$d2$f3$d3" "[2]($f1)($f2)" "($f1)($f2)" ;;
 						' ')	;;
 						*)	x=$f2$d2$f3$d3
-							x=${x# } #was x=${x#' '} hush needs fixing for this to work
-							x=${x% } #was x=${x%' '}
+							x=${x#' '}
+							x=${x%' '}
 							split "$d0$f1$d1$f2$d2$f3$d3" "[3]($f1)($f2)($f3)" "($f1)($x)"
 							;;
 						esac
diff -urpN busybox-1.29.3/shell/random.c busybox-1.30.0/shell/random.c
--- busybox-1.29.3/shell/random.c	2018-07-02 13:23:06.000000000 +0200
+++ busybox-1.30.0/shell/random.c	2018-12-05 15:44:34.000000000 +0100
@@ -46,11 +46,11 @@ next_random(random_t *rnd)
 	 * Choices for a,b,c: 10,13,10; 8,9,22; 2,7,3; 23,3,24
 	 * (given by algorithm author)
 	 */
-        enum {
-                a = 2,
-                b = 7,
-                c = 3,
-        };
+	enum {
+		a = 2,
+		b = 7,
+		c = 3,
+	};
 
 	uint32_t t;
 
@@ -154,7 +154,7 @@ int main(int argc, char **argv)
 		write(1, buf, sizeof(buf));
 	}
 
-        return 0;
+	return 0;
 }
 
 #endif
diff -urpN busybox-1.29.3/shell/shell_common.c busybox-1.30.0/shell/shell_common.c
--- busybox-1.29.3/shell/shell_common.c	2018-07-02 13:23:06.000000000 +0200
+++ busybox-1.30.0/shell/shell_common.c	2018-12-05 15:44:34.000000000 +0100
@@ -46,16 +46,7 @@ int FAST_FUNC is_well_formed_var_name(co
 //Here we can simply store "VAR=" at buffer start and store read data directly
 //after "=", then pass buffer to setvar() to consume.
 const char* FAST_FUNC
-shell_builtin_read(void FAST_FUNC (*setvar)(const char *name, const char *val),
-	char       **argv,
-	const char *ifs,
-	int        read_flags,
-	const char *opt_n,
-	const char *opt_p,
-	const char *opt_t,
-	const char *opt_u,
-	const char *opt_d
-)
+shell_builtin_read(struct builtin_read_params *params)
 {
 	struct pollfd pfd[1];
 #define fd (pfd[0].fd) /* -u FD */
@@ -70,9 +61,13 @@ shell_builtin_read(void FAST_FUNC (*setv
 	int bufpos; /* need to be able to hold -1 */
 	int startword;
 	smallint backslash;
+	char **argv;
+	const char *ifs;
+	int read_flags;
 
 	errno = err = 0;
 
+	argv = params->argv;
 	pp = argv;
 	while (*pp) {
 		if (!is_well_formed_var_name(*pp, '\0')) {
@@ -84,29 +79,29 @@ shell_builtin_read(void FAST_FUNC (*setv
 	}
 
 	nchars = 0; /* if != 0, -n is in effect */
-	if (opt_n) {
-		nchars = bb_strtou(opt_n, NULL, 10);
+	if (params->opt_n) {
+		nchars = bb_strtou(params->opt_n, NULL, 10);
 		if (nchars < 0 || errno)
 			return "invalid count";
 		/* note: "-n 0": off (bash 3.2 does this too) */
 	}
 
 	end_ms = 0;
-	if (opt_t && !ENABLE_FEATURE_SH_READ_FRAC) {
-		end_ms = bb_strtou(opt_t, NULL, 10);
+	if (params->opt_t && !ENABLE_FEATURE_SH_READ_FRAC) {
+		end_ms = bb_strtou(params->opt_t, NULL, 10);
 		if (errno)
 			return "invalid timeout";
 		if (end_ms > UINT_MAX / 2048) /* be safely away from overflow */
 			end_ms = UINT_MAX / 2048;
 		end_ms *= 1000;
 	}
-	if (opt_t && ENABLE_FEATURE_SH_READ_FRAC) {
+	if (params->opt_t && ENABLE_FEATURE_SH_READ_FRAC) {
 		/* bash 4.3 (maybe earlier) supports -t N.NNNNNN */
 		char *p;
 		/* Eat up to three fractional digits */
 		int frac_digits = 3 + 1;
 
-		end_ms = bb_strtou(opt_t, &p, 10);
+		end_ms = bb_strtou(params->opt_t, &p, 10);
 		if (end_ms > UINT_MAX / 2048) /* be safely away from overflow */
 			end_ms = UINT_MAX / 2048;
 
@@ -128,13 +123,13 @@ shell_builtin_read(void FAST_FUNC (*setv
 	}
 
 	fd = STDIN_FILENO;
-	if (opt_u) {
-		fd = bb_strtou(opt_u, NULL, 10);
+	if (params->opt_u) {
+		fd = bb_strtou(params->opt_u, NULL, 10);
 		if (fd < 0 || errno)
 			return "invalid file descriptor";
 	}
 
-	if (opt_t && end_ms == 0) {
+	if (params->opt_t && end_ms == 0) {
 		/* "If timeout is 0, read returns immediately, without trying
 		 * to read any data. The exit status is 0 if input is available
 		 * on the specified file descriptor, non-zero otherwise."
@@ -147,14 +142,16 @@ shell_builtin_read(void FAST_FUNC (*setv
 		return (const char *)(uintptr_t)(r <= 0);
 	}
 
-	if (opt_p && isatty(fd)) {
-		fputs(opt_p, stderr);
+	if (params->opt_p && isatty(fd)) {
+		fputs(params->opt_p, stderr);
 		fflush_all();
 	}
 
+	ifs = params->ifs;
 	if (ifs == NULL)
 		ifs = defifs;
 
+	read_flags = params->read_flags;
 	if (nchars || (read_flags & BUILTIN_READ_SILENT)) {
 		tcgetattr(fd, &tty);
 		old_tty = tty;
@@ -181,11 +178,11 @@ shell_builtin_read(void FAST_FUNC (*setv
 	retval = (const char *)(uintptr_t)0;
 	startword = 1;
 	backslash = 0;
-	if (opt_t)
+	if (params->opt_t)
 		end_ms += (unsigned)monotonic_ms();
 	buffer = NULL;
 	bufpos = 0;
-	delim = opt_d ? *opt_d : '\n';
+	delim = params->opt_d ? params->opt_d[0] : '\n';
 	do {
 		char c;
 		int timeout;
@@ -194,7 +191,7 @@ shell_builtin_read(void FAST_FUNC (*setv
 			buffer = xrealloc(buffer, bufpos + 0x101);
 
 		timeout = -1;
-		if (opt_t) {
+		if (params->opt_t) {
 			timeout = end_ms - (unsigned)monotonic_ms();
 			/* ^^^^^^^^^^^^^ all values are unsigned,
 			 * wrapping math is used here, good even if
@@ -246,7 +243,7 @@ shell_builtin_read(void FAST_FUNC (*setv
 		 * without variable names (bash compat).
 		 * Thus, "read" and "read REPLY" are not the same.
 		 */
-		if (!opt_d && argv[0]) {
+		if (!params->opt_d && argv[0]) {
 /* http://www.opengroup.org/onlinepubs/9699919799/utilities/V3_chap02.html#tag_18_06_05 */
 			const char *is_ifs = strchr(ifs, c);
 			if (startword && is_ifs) {
@@ -261,7 +258,7 @@ shell_builtin_read(void FAST_FUNC (*setv
 			if (argv[1] != NULL && is_ifs) {
 				buffer[bufpos] = '\0';
 				bufpos = 0;
-				setvar(*argv, buffer);
+				params->setvar(*argv, buffer);
 				argv++;
 				/* can we skip one non-space ifs char? (2: yes) */
 				startword = isspace(c) ? 2 : 1;
@@ -313,14 +310,14 @@ shell_builtin_read(void FAST_FUNC (*setv
 		}
 
 		/* Use the remainder as a value for the next variable */
-		setvar(*argv, buffer);
+		params->setvar(*argv, buffer);
 		/* Set the rest to "" */
 		while (*++argv)
-			setvar(*argv, "");
+			params->setvar(*argv, "");
 	} else {
 		/* Note: no $IFS removal */
 		buffer[bufpos] = '\0';
-		setvar("REPLY", buffer);
+		params->setvar("REPLY", buffer);
 	}
 
  ret:
diff -urpN busybox-1.29.3/shell/shell_common.h busybox-1.30.0/shell/shell_common.h
--- busybox-1.29.3/shell/shell_common.h	2018-07-02 13:23:06.000000000 +0200
+++ busybox-1.30.0/shell/shell_common.h	2018-12-05 15:44:34.000000000 +0100
@@ -30,6 +30,17 @@ int FAST_FUNC is_well_formed_var_name(co
 
 /* Builtins */
 
+struct builtin_read_params {
+	int        read_flags;
+	void FAST_FUNC (*setvar)(const char *name, const char *val);
+	char       **argv;
+	const char *ifs;
+	const char *opt_n;
+	const char *opt_p;
+	const char *opt_t;
+	const char *opt_u;
+	const char *opt_d;
+};
 enum {
 	BUILTIN_READ_SILENT = 1 << 0,
 	BUILTIN_READ_RAW    = 1 << 1,
@@ -40,16 +51,7 @@ enum {
 //	shell_builtin_read(setvar,argv,ifs,read_flags)
 //#endif
 const char* FAST_FUNC
-shell_builtin_read(void FAST_FUNC (*setvar)(const char *name, const char *val),
-	char       **argv,
-	const char *ifs,
-	int        read_flags,
-	const char *opt_n,
-	const char *opt_p,
-	const char *opt_t,
-	const char *opt_u,
-	const char *opt_d
-);
+shell_builtin_read(struct builtin_read_params *params);
 
 int FAST_FUNC
 shell_builtin_ulimit(char **argv);
diff -urpN busybox-1.29.3/size_single_applets.sh busybox-1.30.0/size_single_applets.sh
--- busybox-1.29.3/size_single_applets.sh	2018-07-02 13:23:06.000000000 +0200
+++ busybox-1.30.0/size_single_applets.sh	2018-12-30 16:14:20.000000000 +0100
@@ -1,4 +1,12 @@
 #!/bin/bash
+# Which config to use when updating the sizes in "official"
+# source tree? I am using x86 glibc toolchain of some typical distro,
+# not-static build, 32-bit defconfig build:
+# # CONFIG_STATIC is not set
+# CONFIG_CROSS_COMPILER_PREFIX=""
+# CONFIG_EXTRA_CFLAGS="-m32"
+# CONFIG_EXTRA_LDFLAGS="-m32"
+
 # The list of all applet config symbols
 test -f include/applets.h || { echo "No include/applets.h file"; exit 1; }
 apps="`
@@ -48,9 +56,9 @@ grep ^IF_ include/applets.h \
 	b="busybox_${app}"
 	test -f "$b" || continue
 
-	file=`grep -lF "bool \"$name" $(find -name '*.c') | xargs`
-	# so far all such items are in .c files; if need to check Config.* files:
-	#test "$file" || file=`grep -lF "bool \"$name" $(find -name 'Config.*') |  xargs`
+	file=`grep -l "bool \"$name[\" ]" $(find -name '*.c') | xargs`
+	# A few applets have their CONFIG items in Config.* files, not .c files:
+	test "$file" || file=`grep -l "bool \"$name[\" ]" $(find -name 'Config.*') | xargs`
 	test "$file" || continue
 	#echo "FILE:'$file'"
 
diff -urpN busybox-1.29.3/sysklogd/klogd.c busybox-1.30.0/sysklogd/klogd.c
--- busybox-1.29.3/sysklogd/klogd.c	2018-07-02 13:23:06.000000000 +0200
+++ busybox-1.30.0/sysklogd/klogd.c	2018-12-30 16:14:20.000000000 +0100
@@ -17,7 +17,7 @@
  * Licensed under GPLv2 or later, see file LICENSE in this source tree.
  */
 //config:config KLOGD
-//config:	bool "klogd (5.5 kb)"
+//config:	bool "klogd (5.7 kb)"
 //config:	default y
 //config:	help
 //config:	klogd is a utility which intercepts and logs all
@@ -53,7 +53,7 @@
 //usage:#define klogd_trivial_usage
 //usage:       "[-c N] [-n]"
 //usage:#define klogd_full_usage "\n\n"
-//usage:       "Kernel logger\n"
+//usage:       "Log kernel messages to syslog\n"
 //usage:     "\n	-c N	Print to console messages more urgent than prio N (1-8)"
 //usage:     "\n	-n	Run in foreground"
 
@@ -85,6 +85,7 @@ static void klogd_setloglevel(int lvl)
 
 static int klogd_read(char *bufp, int len)
 {
+	/* "2 -- Read from the log." */
 	return klogctl(2, bufp, len);
 }
 # define READ_ERROR "klogctl(2) error"
@@ -238,7 +239,6 @@ int klogd_main(int argc UNUSED_PARAM, ch
 		int priority;
 		char *start;
 
-		/* "2 -- Read from the log." */
 		start = log_buffer + used;
 		n = klogd_read(start, KLOGD_LOGBUF_SIZE-1 - used);
 		if (n < 0) {
@@ -275,10 +275,13 @@ int klogd_main(int argc UNUSED_PARAM, ch
 			priority = LOG_INFO;
 			if (*start == '<') {
 				start++;
-				if (*start)
-					priority = strtoul(start, &start, 10);
-				if (*start == '>')
-					start++;
+				if (*start) {
+					char *end;
+					priority = strtoul(start, &end, 10);
+					if (*end == '>')
+						end++;
+					start = end;
+				}
 			}
 			/* Log (only non-empty lines) */
 			if (*start)
diff -urpN busybox-1.29.3/sysklogd/logger.c busybox-1.30.0/sysklogd/logger.c
--- busybox-1.29.3/sysklogd/logger.c	2018-07-02 13:23:06.000000000 +0200
+++ busybox-1.30.0/sysklogd/logger.c	2018-12-30 16:14:20.000000000 +0100
@@ -7,7 +7,7 @@
  * Licensed under GPLv2 or later, see file LICENSE in this source tree.
  */
 //config:config LOGGER
-//config:	bool "logger (6.4 kb)"
+//config:	bool "logger (6.3 kb)"
 //config:	default y
 //config:	select FEATURE_SYSLOG
 //config:	help
diff -urpN busybox-1.29.3/sysklogd/logread.c busybox-1.30.0/sysklogd/logread.c
--- busybox-1.29.3/sysklogd/logread.c	2018-07-02 13:23:06.000000000 +0200
+++ busybox-1.30.0/sysklogd/logread.c	2018-12-30 16:14:20.000000000 +0100
@@ -9,7 +9,7 @@
  * Licensed under GPLv2 or later, see file LICENSE in this source tree.
  */
 //config:config LOGREAD
-//config:	bool "logread (6 kb)"
+//config:	bool "logread (4.8 kb)"
 //config:	default y
 //WRONG: it should be compilable without SYSLOG=y:
 //WRONG:	depends on FEATURE_IPC_SYSLOG
diff -urpN busybox-1.29.3/sysklogd/syslogd.c busybox-1.30.0/sysklogd/syslogd.c
--- busybox-1.29.3/sysklogd/syslogd.c	2018-07-02 13:23:06.000000000 +0200
+++ busybox-1.30.0/sysklogd/syslogd.c	2018-12-30 16:14:20.000000000 +0100
@@ -13,7 +13,7 @@
  * Licensed under GPLv2 or later, see file LICENSE in this source tree.
  */
 //config:config SYSLOGD
-//config:	bool "syslogd (12 kb)"
+//config:	bool "syslogd (13 kb)"
 //config:	default y
 //config:	help
 //config:	The syslogd utility is used to record logs of all the
@@ -140,6 +140,7 @@
 //usage:	)
 //usage:     "\n	-l N		Log only messages more urgent than prio N (1-8)"
 //usage:     "\n	-S		Smaller output"
+//usage:     "\n	-t		Strip client-generated timestamps"
 //usage:	IF_FEATURE_SYSLOGD_DUP(
 //usage:     "\n	-D		Drop duplicates"
 //usage:	)
@@ -316,6 +317,7 @@ enum {
 	OPTBIT_outfile, // -O
 	OPTBIT_loglevel, // -l
 	OPTBIT_small, // -S
+	OPTBIT_timestamp, // -t
 	IF_FEATURE_ROTATE_LOGFILE(OPTBIT_filesize   ,)	// -s
 	IF_FEATURE_ROTATE_LOGFILE(OPTBIT_rotatecnt  ,)	// -b
 	IF_FEATURE_REMOTE_LOG(    OPTBIT_remotelog  ,)	// -R
@@ -330,6 +332,7 @@ enum {
 	OPT_outfile     = 1 << OPTBIT_outfile ,
 	OPT_loglevel    = 1 << OPTBIT_loglevel,
 	OPT_small       = 1 << OPTBIT_small   ,
+	OPT_timestamp   = 1 << OPTBIT_timestamp,
 	OPT_filesize    = IF_FEATURE_ROTATE_LOGFILE((1 << OPTBIT_filesize   )) + 0,
 	OPT_rotatecnt   = IF_FEATURE_ROTATE_LOGFILE((1 << OPTBIT_rotatecnt  )) + 0,
 	OPT_remotelog   = IF_FEATURE_REMOTE_LOG(    (1 << OPTBIT_remotelog  )) + 0,
@@ -339,7 +342,7 @@ enum {
 	OPT_cfg         = IF_FEATURE_SYSLOGD_CFG(   (1 << OPTBIT_cfg        )) + 0,
 	OPT_kmsg        = IF_FEATURE_KMSG_SYSLOG(   (1 << OPTBIT_kmsg       )) + 0,
 };
-#define OPTION_STR "m:nO:l:S" \
+#define OPTION_STR "m:nO:l:St" \
 	IF_FEATURE_ROTATE_LOGFILE("s:" ) \
 	IF_FEATURE_ROTATE_LOGFILE("b:" ) \
 	IF_FEATURE_REMOTE_LOG(    "R:*") \
@@ -813,21 +816,27 @@ static void parse_fac_prio_20(int pri, c
  * that there is no timestamp, short-circuiting the test. */
 static void timestamp_and_log(int pri, char *msg, int len)
 {
-	char *timestamp;
+	char *timestamp = NULL;
 	time_t now;
 
 	/* Jan 18 00:11:22 msg... */
 	/* 01234567890123456 */
-	if (len < 16 || msg[3] != ' ' || msg[6] != ' '
-	 || msg[9] != ':' || msg[12] != ':' || msg[15] != ' '
+	if (len >= 16 && msg[3] == ' ' && msg[6] == ' '
+	 && msg[9] == ':' && msg[12] == ':' && msg[15] == ' '
 	) {
+		if (!(option_mask32 & OPT_timestamp)) {
+			/* use message timestamp */
+			timestamp = msg;
+			now = 0;
+		}
+		msg += 16;
+	}
+
+	if (!timestamp) {
 		time(&now);
 		timestamp = ctime(&now) + 4; /* skip day of week */
-	} else {
-		now = 0;
-		timestamp = msg;
-		msg += 16;
 	}
+
 	timestamp[15] = '\0';
 
 	if (option_mask32 & OPT_kmsg) {
diff -urpN busybox-1.29.3/testsuite/bc.tests busybox-1.30.0/testsuite/bc.tests
--- busybox-1.29.3/testsuite/bc.tests	1970-01-01 01:00:00.000000000 +0100
+++ busybox-1.30.0/testsuite/bc.tests	2018-12-30 16:14:20.000000000 +0100
@@ -0,0 +1,233 @@
+#!/bin/sh
+# Copyright 2018 by Denys Vlasenko
+# Licensed under GPLv2 or later, see file LICENSE in this source tree.
+
+. ./testing.sh
+
+# testing "test name" "command" "expected result" "file input" "stdin"
+
+testing "bc comment" \
+	"bc" \
+	"3\n" \
+	"" "1 /* comment */ + 2"
+
+testing "bc /*/ is not a closed comment" \
+	"bc" \
+	"4\n" \
+	"" "1 /*/ + 2 */ + 3"
+
+# this needs interactive testing
+testing "bc comment with \"" \
+	"bc" \
+	"3\n" \
+	"" "1 /* \" */ + 2"
+
+# this needs interactive testing
+testing "bc \"string/*\" is not a comment" \
+	"bc" \
+	"string/*9\n" \
+	"" "\"string/*\";9"
+
+testing "bc comment 3: unterminated #comment" \
+	"bc" \
+	"" \
+	"" "#foo"  # no trailing newline
+
+testing "bc backslash 1" \
+	"bc" \
+	"3\n" \
+	"" "1 \\\\\n + 2"
+
+testing "bc string 1" \
+	"bc" \
+	"STR\n" \
+	"" "\"STR\n\""
+
+testing "bc read() 4<EOF>" \
+	"bc input" \
+	"4\n" \
+	"read();halt" "4"
+
+testing "bc read()^2" \
+	"bc input" \
+	"16\n" \
+	"read()^2;halt" "4\n"
+
+testing "bc read()*read()" \
+	"bc input" \
+	"20\n" \
+	"read()*read();halt" "4\n5"
+
+testing "bc if 0 else" \
+	"bc" \
+	"2\n9\n" \
+	"" "if (0) 1 else 2; 9"
+
+testing "bc if 1 else" \
+	"bc" \
+	"1\n9\n" \
+	"" "if (1) 1 else 2; 9"
+
+testing "bc if 1 if 1 else else" \
+	"bc" \
+	"1\n9\n" \
+	"" "if (1) if (1) 1 else 2 else 3; 9"
+
+testing "bc if 0 else if 1" \
+	"bc" \
+	"2\n9\n" \
+	"" "if (0) 1 else if (1) 2; 9"
+
+testing "bc for (;;)" \
+	"bc" \
+	"2\n3\n2\n9\n" \
+	"" "i=2; for (;;) { 2; if(--i==0) break; 3; }; 9"
+
+testing "bc for (;cond;)" \
+	"bc" \
+	"1\n2\n3\n9\n" \
+	"" "i=0; for(;i<3;)++i; 9"
+
+testing "bc for (;cond;upd)" \
+	"bc" \
+	"1\n2\n3\n9\n" \
+	"" "i=1; for(;i<4;i++)i; 9"
+
+testing "bc for (init;cond;upd)" \
+	"bc" \
+	"1\n2\n3\n9\n" \
+	"" "for(i=1;i<4;i++)i; 9"
+
+testing "bc for (;;) {break}" \
+	"bc" \
+	"2\n9\n" \
+	"" "for (;;) {2;break}; 9"
+
+testing "bc define auto" \
+	"bc" \
+	"8\n9\n" \
+	"" "define w() { auto z; return 8; }; w(); 9"
+
+testing "bc define with body on next line" \
+	"bc" \
+	"8\n9\n" \
+	"" "define w()\n{ auto z; return 8; }\nw()\n9"
+
+testing "bc if(cond)<NL>" \
+	"bc" \
+	"9\n" \
+	"" "if(0)\n3\n9"
+
+testing "bc if(cond) stmt else<NL>" \
+	"bc" \
+	"4\n9\n" \
+	"" "if(0)3 else\n4\n9"
+
+testing "bc while(cond)<NL>" \
+	"bc" \
+	"8\n7\n6\n5\n4\n3\n2\n1\n9\n" \
+	"" "i=9;while(--i)\ni\n9"
+
+testing "bc ifz does not match if keyword" \
+	"bc" \
+	"1\n2\n2\n3\n" \
+	"" "ifz=1;ifz\n++ifz;ifz++\nifz"
+
+testing "bc print 1,2,3" \
+	"bc" \
+	"123" \
+	"" "print 1,2,3"
+
+testing "bc { print 1 }" \
+	"bc" \
+	"1" \
+	"" "{ print 1 }"
+
+testing "bc nested loops and breaks" \
+	"bc" \
+	"\
+11
+21
+31
+22
+12
+99
+" \
+	"" "\
+if(1) {
+	11
+	while(1) {
+		21
+		while(1) {
+			31
+			break
+			32
+		}
+		22
+		break
+		23
+	}
+	12
+} else {
+	88
+}
+99
+"
+
+testing "bc continue in if" \
+	"bc" \
+	"\
+11
+21
+11
+31
+99
+" \
+	"" "\
+i=2
+while(i--) {
+        11
+        if(i) {
+                21
+                continue
+                22
+        } else {
+                31
+                continue
+                32
+	}
+        12
+}
+99
+"
+
+testing "bc continue in for" \
+	"bc" \
+	"\
+1
+77
+2
+99
+" \
+	"" "\
+for(i=1; i<3; i++) {
+    i
+    if(i==2) continue
+    77
+}
+99
+"
+
+tar xJf bc_large.tar.xz
+
+for f in bc*.bc; do
+	r="`basename "$f" .bc`_results.txt"
+	test -f "$r" || continue
+	# testing "test name" "command" "expected result" "file input" "stdin"
+	testing "bc -lq $f" \
+		"{ { bc -lq $f 2>&1; echo E:\$? >&2; } | diff -u - $r; echo E:\$?; } 2>&1" \
+		"E:0\nE:0\n" \
+		"" ""
+done
+
+exit $FAILCOUNT
diff -urpN busybox-1.29.3/testsuite/bc_add.bc busybox-1.30.0/testsuite/bc_add.bc
--- busybox-1.29.3/testsuite/bc_add.bc	1970-01-01 01:00:00.000000000 +0100
+++ busybox-1.30.0/testsuite/bc_add.bc	2018-12-30 16:14:20.000000000 +0100
@@ -0,0 +1,26 @@
+0 + 0
+0 + 1
+1 + 1
+1 + 0
+2 + 5
+237 + 483
+999 + 999
+2374623 + 324869356734856
+2378639084586723980562 + 23468729367839
+37298367203972395108367910823465293084561329084561390845613409516734503870691837451 + 785621394067928346918023476190834672198467134908618723249671349062187346898241093486139046139084613490817356023871869102746182749061872609129847
+1.1 + 0
+0 + 1.1
+457283.731284923576 + 37842934672834.3874629385672354
+1.0 + 0.1
+3746289134067138046 + 0.138375863945672398456712389456273486293
+-1 + -1
+-4 + -15
+-1346782 + -1287904651762468913476
+99999999999999999999999999999999999999999999999999999999999.999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999 + 0.000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000001
+99999999999999999999999999999999999999999999999999999999999.999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999995 + 0.000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000005
+99999999999999999999999999999999999999999999999999999999999.999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999 + 0.00000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000001
+99999999999999999999999999999999999999999999999999999999999.999999999999999999999999999999999999999999999999999999999899999999999999999999999999999999999999999999999999999999999999 + 0.00000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000001
+99999999999999999999999999999999999989999999999999999999999.999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999 + 0.00000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000001
+-1889985797 + 2012747315
+0 + -14338.391079082
+-2422297 + 1.3134942556
diff -urpN busybox-1.29.3/testsuite/bc_add_results.txt busybox-1.30.0/testsuite/bc_add_results.txt
--- busybox-1.29.3/testsuite/bc_add_results.txt	1970-01-01 01:00:00.000000000 +0100
+++ busybox-1.30.0/testsuite/bc_add_results.txt	2018-12-30 16:14:20.000000000 +0100
@@ -0,0 +1,38 @@
+0
+1
+2
+1
+7
+720
+1998
+324869359109479
+2378639108055453348401
+78562139406792834691802347619083467219846713490861872324967138636055\
+45508706362018540498696043776980521464405852627147161556994835657433\
+00967298
+1.1
+1.1
+37842935130118.1187478621432354
+1.1
+3746289134067138046.138375863945672398456712389456273486293
+-2
+-19
+-1287904651762470260258
+100000000000000000000000000000000000000000000000000000000000.0000000\
+00000000000000000000000000000000000000000000000000000000000000000000\
+000000000000000000000000000000000000000000000
+100000000000000000000000000000000000000000000000000000000000.0000000\
+00000000000000000000000000000000000000000000000000000000000000000000\
+000000000000000000000000000000000000000000000
+100000000000000000000000000000000000000000000000000000000000.0000000\
+00000000000000000000000000000000000000000000000000000000000000000000\
+000000000000000000000000000000000000000009999
+99999999999999999999999999999999999999999999999999999999999.99999999\
+99999999999999999999999999999999999999999999999999000000000000000000\
+00000000000000000000000000000000000000009999
+99999999999999999999999999999999999990000000000000000000000.00000000\
+00000000000000000000000000000000000000000000000000000000000000000000\
+00000000000000000000000000000000000000009999
+122761518
+-14338.391079082
+-2422295.6865057444
diff -urpN busybox-1.29.3/testsuite/bc_arctangent.bc busybox-1.30.0/testsuite/bc_arctangent.bc
--- busybox-1.29.3/testsuite/bc_arctangent.bc	1970-01-01 01:00:00.000000000 +0100
+++ busybox-1.30.0/testsuite/bc_arctangent.bc	2018-12-30 16:14:20.000000000 +0100
@@ -0,0 +1,26 @@
+a(.267)
+a(1)
+scale = 64
+a(.267)
+a(1)
+scale = 100
+a(.267)
+a(1)
+scale = 20
+a(0)
+a(.5)
+a(0.577350269189625764509148780501)
+a(1.5)
+a(1.7320508075688772935274463415)
+a(2)
+a(3)
+a(1000)
+a(-.5)
+a(-0.577350269189625764509148780501)
+a(-1.5)
+a(-1.7320508075688772935274463415)
+a(-2)
+a(-3)
+a(-1000)
+a(-3249917614.2821897119)
+a(-694706362.1974670468)
diff -urpN busybox-1.29.3/testsuite/bc_arctangent_results.txt busybox-1.30.0/testsuite/bc_arctangent_results.txt
--- busybox-1.29.3/testsuite/bc_arctangent_results.txt	1970-01-01 01:00:00.000000000 +0100
+++ busybox-1.30.0/testsuite/bc_arctangent_results.txt	2018-12-30 16:14:20.000000000 +0100
@@ -0,0 +1,25 @@
+.26091356923294057959
+.78539816339744830961
+.2609135692329405795967852677779865639774740239882445822329882917
+.7853981633974483096156608458198757210492923498437764552437361480
+.2609135692329405795967852677779865639774740239882445822329882917230\
+650591934644905491823044536954978
+.7853981633974483096156608458198757210492923498437764552437361480769\
+541015715522496570087063355292669
+0
+.46364760900080611621
+.52359877559829887307
+.98279372324732906798
+1.04719755119659774615
+1.10714871779409050301
+1.24904577239825442582
+1.56979632712822975256
+-.46364760900080611621
+-.52359877559829887307
+-.98279372324732906798
+-1.04719755119659774615
+-1.10714871779409050301
+-1.24904577239825442582
+-1.56979632712822975256
+-1.57079632648719651151
+-1.57079632535543952711
diff -urpN busybox-1.29.3/testsuite/bc_array.bc busybox-1.30.0/testsuite/bc_array.bc
--- busybox-1.29.3/testsuite/bc_array.bc	1970-01-01 01:00:00.000000000 +0100
+++ busybox-1.30.0/testsuite/bc_array.bc	2018-12-30 16:14:20.000000000 +0100
@@ -0,0 +1,35 @@
+#! /usr/bin/bc -q
+
+define z(a[]) {
+	for (i = 0; i < l; ++i) {
+		a[i]
+	}
+}
+
+define x(a[]) {
+
+	for (i = 0; i < l; ++i) {
+		a[i] = -i
+	}
+
+	z(a[])
+}
+
+for (i = 0; i < 101; ++i) {
+	a[i] = i
+}
+
+a[104] = 204
+
+l = length(a[])
+
+for (i = 0; i <= l; ++i) {
+	a[i]
+}
+
+z(a[])
+x(a[])
+z(a[])
+l
+
+halt
diff -urpN busybox-1.29.3/testsuite/bc_array_results.txt busybox-1.30.0/testsuite/bc_array_results.txt
--- busybox-1.29.3/testsuite/bc_array_results.txt	1970-01-01 01:00:00.000000000 +0100
+++ busybox-1.30.0/testsuite/bc_array_results.txt	2018-12-30 16:14:20.000000000 +0100
@@ -0,0 +1,426 @@
+0
+1
+2
+3
+4
+5
+6
+7
+8
+9
+10
+11
+12
+13
+14
+15
+16
+17
+18
+19
+20
+21
+22
+23
+24
+25
+26
+27
+28
+29
+30
+31
+32
+33
+34
+35
+36
+37
+38
+39
+40
+41
+42
+43
+44
+45
+46
+47
+48
+49
+50
+51
+52
+53
+54
+55
+56
+57
+58
+59
+60
+61
+62
+63
+64
+65
+66
+67
+68
+69
+70
+71
+72
+73
+74
+75
+76
+77
+78
+79
+80
+81
+82
+83
+84
+85
+86
+87
+88
+89
+90
+91
+92
+93
+94
+95
+96
+97
+98
+99
+100
+0
+0
+0
+204
+0
+0
+1
+2
+3
+4
+5
+6
+7
+8
+9
+10
+11
+12
+13
+14
+15
+16
+17
+18
+19
+20
+21
+22
+23
+24
+25
+26
+27
+28
+29
+30
+31
+32
+33
+34
+35
+36
+37
+38
+39
+40
+41
+42
+43
+44
+45
+46
+47
+48
+49
+50
+51
+52
+53
+54
+55
+56
+57
+58
+59
+60
+61
+62
+63
+64
+65
+66
+67
+68
+69
+70
+71
+72
+73
+74
+75
+76
+77
+78
+79
+80
+81
+82
+83
+84
+85
+86
+87
+88
+89
+90
+91
+92
+93
+94
+95
+96
+97
+98
+99
+100
+0
+0
+0
+204
+0
+0
+-1
+-2
+-3
+-4
+-5
+-6
+-7
+-8
+-9
+-10
+-11
+-12
+-13
+-14
+-15
+-16
+-17
+-18
+-19
+-20
+-21
+-22
+-23
+-24
+-25
+-26
+-27
+-28
+-29
+-30
+-31
+-32
+-33
+-34
+-35
+-36
+-37
+-38
+-39
+-40
+-41
+-42
+-43
+-44
+-45
+-46
+-47
+-48
+-49
+-50
+-51
+-52
+-53
+-54
+-55
+-56
+-57
+-58
+-59
+-60
+-61
+-62
+-63
+-64
+-65
+-66
+-67
+-68
+-69
+-70
+-71
+-72
+-73
+-74
+-75
+-76
+-77
+-78
+-79
+-80
+-81
+-82
+-83
+-84
+-85
+-86
+-87
+-88
+-89
+-90
+-91
+-92
+-93
+-94
+-95
+-96
+-97
+-98
+-99
+-100
+-101
+-102
+-103
+-104
+0
+0
+0
+1
+2
+3
+4
+5
+6
+7
+8
+9
+10
+11
+12
+13
+14
+15
+16
+17
+18
+19
+20
+21
+22
+23
+24
+25
+26
+27
+28
+29
+30
+31
+32
+33
+34
+35
+36
+37
+38
+39
+40
+41
+42
+43
+44
+45
+46
+47
+48
+49
+50
+51
+52
+53
+54
+55
+56
+57
+58
+59
+60
+61
+62
+63
+64
+65
+66
+67
+68
+69
+70
+71
+72
+73
+74
+75
+76
+77
+78
+79
+80
+81
+82
+83
+84
+85
+86
+87
+88
+89
+90
+91
+92
+93
+94
+95
+96
+97
+98
+99
+100
+0
+0
+0
+204
+0
+105
diff -urpN busybox-1.29.3/testsuite/bc_arrays.bc busybox-1.30.0/testsuite/bc_arrays.bc
--- busybox-1.29.3/testsuite/bc_arrays.bc	1970-01-01 01:00:00.000000000 +0100
+++ busybox-1.30.0/testsuite/bc_arrays.bc	2018-12-30 16:14:20.000000000 +0100
@@ -0,0 +1,10 @@
+a[0] = 1
+a[2-1] = 2
+
+a[0]+a[0]
+
+a[2-1]+a[2-1]
+
+a[5] = 2
+a[5.789]
+
diff -urpN busybox-1.29.3/testsuite/bc_arrays_results.txt busybox-1.30.0/testsuite/bc_arrays_results.txt
--- busybox-1.29.3/testsuite/bc_arrays_results.txt	1970-01-01 01:00:00.000000000 +0100
+++ busybox-1.30.0/testsuite/bc_arrays_results.txt	2018-12-30 16:14:20.000000000 +0100
@@ -0,0 +1,3 @@
+2
+4
+2
diff -urpN busybox-1.29.3/testsuite/bc_bessel.bc busybox-1.30.0/testsuite/bc_bessel.bc
--- busybox-1.29.3/testsuite/bc_bessel.bc	1970-01-01 01:00:00.000000000 +0100
+++ busybox-1.30.0/testsuite/bc_bessel.bc	2018-12-30 16:14:20.000000000 +0100
@@ -0,0 +1,844 @@
+j(0, 0)
+j(0, .5)
+j(0, -.5)
+j(0, 1)
+j(0, -1)
+j(0, 1.5)
+j(0, -1.5)
+j(0, 1.74)
+j(0, -1.74)
+j(0, 2)
+j(0, -2)
+j(0, 3.2345)
+j(0, -3.2345)
+j(0, 100)
+j(0, -100)
+j(0, -.5)
+j(0, .5)
+j(0, -1)
+j(0, 1)
+j(0, -1.5)
+j(0, 1.5)
+j(0, -1.74)
+j(0, 1.74)
+j(0, -2)
+j(0, 2)
+j(0, -3.2345)
+j(0, 3.2345)
+j(0, -100)
+j(0, 100)
+j(.5, 0)
+j(.5, .5)
+j(.5, -.5)
+j(.5, 1)
+j(.5, -1)
+j(.5, 1.5)
+j(.5, -1.5)
+j(.5, 1.74)
+j(.5, -1.74)
+j(.5, 2)
+j(.5, -2)
+j(.5, 3.2345)
+j(.5, -3.2345)
+j(.5, 100)
+j(.5, -100)
+j(.5, -.5)
+j(.5, .5)
+j(.5, -1)
+j(.5, 1)
+j(.5, -1.5)
+j(.5, 1.5)
+j(.5, -1.74)
+j(.5, 1.74)
+j(.5, -2)
+j(.5, 2)
+j(.5, -3.2345)
+j(.5, 3.2345)
+j(.5, -100)
+j(.5, 100)
+j(-.5, 0)
+j(-.5, .5)
+j(-.5, -.5)
+j(-.5, 1)
+j(-.5, -1)
+j(-.5, 1.5)
+j(-.5, -1.5)
+j(-.5, 1.74)
+j(-.5, -1.74)
+j(-.5, 2)
+j(-.5, -2)
+j(-.5, 3.2345)
+j(-.5, -3.2345)
+j(-.5, 100)
+j(-.5, -100)
+j(-.5, -.5)
+j(-.5, .5)
+j(-.5, -1)
+j(-.5, 1)
+j(-.5, -1.5)
+j(-.5, 1.5)
+j(-.5, -1.74)
+j(-.5, 1.74)
+j(-.5, -2)
+j(-.5, 2)
+j(-.5, -3.2345)
+j(-.5, 3.2345)
+j(-.5, -100)
+j(-.5, 100)
+j(1, 0)
+j(1, .5)
+j(1, -.5)
+j(1, 1)
+j(1, -1)
+j(1, 1.5)
+j(1, -1.5)
+j(1, 1.74)
+j(1, -1.74)
+j(1, 2)
+j(1, -2)
+j(1, 3.2345)
+j(1, -3.2345)
+j(1, 100)
+j(1, -100)
+j(1, -.5)
+j(1, .5)
+j(1, -1)
+j(1, 1)
+j(1, -1.5)
+j(1, 1.5)
+j(1, -1.74)
+j(1, 1.74)
+j(1, -2)
+j(1, 2)
+j(1, -3.2345)
+j(1, 3.2345)
+j(1, -100)
+j(1, 100)
+j(-1, 0)
+j(-1, .5)
+j(-1, -.5)
+j(-1, 1)
+j(-1, -1)
+j(-1, 1.5)
+j(-1, -1.5)
+j(-1, 1.74)
+j(-1, -1.74)
+j(-1, 2)
+j(-1, -2)
+j(-1, 3.2345)
+j(-1, -3.2345)
+j(-1, 100)
+j(-1, -100)
+j(-1, -.5)
+j(-1, .5)
+j(-1, -1)
+j(-1, 1)
+j(-1, -1.5)
+j(-1, 1.5)
+j(-1, -1.74)
+j(-1, 1.74)
+j(-1, -2)
+j(-1, 2)
+j(-1, -3.2345)
+j(-1, 3.2345)
+j(-1, -100)
+j(-1, 100)
+j(1.5, 0)
+j(1.5, .5)
+j(1.5, -.5)
+j(1.5, 1)
+j(1.5, -1)
+j(1.5, 1.5)
+j(1.5, -1.5)
+j(1.5, 1.74)
+j(1.5, -1.74)
+j(1.5, 2)
+j(1.5, -2)
+j(1.5, 3.2345)
+j(1.5, -3.2345)
+j(1.5, 100)
+j(1.5, -100)
+j(1.5, -.5)
+j(1.5, .5)
+j(1.5, -1)
+j(1.5, 1)
+j(1.5, -1.5)
+j(1.5, 1.5)
+j(1.5, -1.74)
+j(1.5, 1.74)
+j(1.5, -2)
+j(1.5, 2)
+j(1.5, -3.2345)
+j(1.5, 3.2345)
+j(1.5, -100)
+j(1.5, 100)
+j(-1.5, 0)
+j(-1.5, .5)
+j(-1.5, -.5)
+j(-1.5, 1)
+j(-1.5, -1)
+j(-1.5, 1.5)
+j(-1.5, -1.5)
+j(-1.5, 1.74)
+j(-1.5, -1.74)
+j(-1.5, 2)
+j(-1.5, -2)
+j(-1.5, 3.2345)
+j(-1.5, -3.2345)
+j(-1.5, 100)
+j(-1.5, -100)
+j(-1.5, -.5)
+j(-1.5, .5)
+j(-1.5, -1)
+j(-1.5, 1)
+j(-1.5, -1.5)
+j(-1.5, 1.5)
+j(-1.5, -1.74)
+j(-1.5, 1.74)
+j(-1.5, -2)
+j(-1.5, 2)
+j(-1.5, -3.2345)
+j(-1.5, 3.2345)
+j(-1.5, -100)
+j(-1.5, 100)
+j(1.74, 0)
+j(1.74, .5)
+j(1.74, -.5)
+j(1.74, 1)
+j(1.74, -1)
+j(1.74, 1.5)
+j(1.74, -1.5)
+j(1.74, 1.74)
+j(1.74, -1.74)
+j(1.74, 2)
+j(1.74, -2)
+j(1.74, 3.2345)
+j(1.74, -3.2345)
+j(1.74, 100)
+j(1.74, -100)
+j(1.74, -.5)
+j(1.74, .5)
+j(1.74, -1)
+j(1.74, 1)
+j(1.74, -1.5)
+j(1.74, 1.5)
+j(1.74, -1.74)
+j(1.74, 1.74)
+j(1.74, -2)
+j(1.74, 2)
+j(1.74, -3.2345)
+j(1.74, 3.2345)
+j(1.74, -100)
+j(1.74, 100)
+j(-1.74, 0)
+j(-1.74, .5)
+j(-1.74, -.5)
+j(-1.74, 1)
+j(-1.74, -1)
+j(-1.74, 1.5)
+j(-1.74, -1.5)
+j(-1.74, 1.74)
+j(-1.74, -1.74)
+j(-1.74, 2)
+j(-1.74, -2)
+j(-1.74, 3.2345)
+j(-1.74, -3.2345)
+j(-1.74, 100)
+j(-1.74, -100)
+j(-1.74, -.5)
+j(-1.74, .5)
+j(-1.74, -1)
+j(-1.74, 1)
+j(-1.74, -1.5)
+j(-1.74, 1.5)
+j(-1.74, -1.74)
+j(-1.74, 1.74)
+j(-1.74, -2)
+j(-1.74, 2)
+j(-1.74, -3.2345)
+j(-1.74, 3.2345)
+j(-1.74, -100)
+j(-1.74, 100)
+j(2, 0)
+j(2, .5)
+j(2, -.5)
+j(2, 1)
+j(2, -1)
+j(2, 1.5)
+j(2, -1.5)
+j(2, 1.74)
+j(2, -1.74)
+j(2, 2)
+j(2, -2)
+j(2, 3.2345)
+j(2, -3.2345)
+j(2, 100)
+j(2, -100)
+j(2, -.5)
+j(2, .5)
+j(2, -1)
+j(2, 1)
+j(2, -1.5)
+j(2, 1.5)
+j(2, -1.74)
+j(2, 1.74)
+j(2, -2)
+j(2, 2)
+j(2, -3.2345)
+j(2, 3.2345)
+j(2, -100)
+j(2, 100)
+j(-2, 0)
+j(-2, .5)
+j(-2, -.5)
+j(-2, 1)
+j(-2, -1)
+j(-2, 1.5)
+j(-2, -1.5)
+j(-2, 1.74)
+j(-2, -1.74)
+j(-2, 2)
+j(-2, -2)
+j(-2, 3.2345)
+j(-2, -3.2345)
+j(-2, 100)
+j(-2, -100)
+j(-2, -.5)
+j(-2, .5)
+j(-2, -1)
+j(-2, 1)
+j(-2, -1.5)
+j(-2, 1.5)
+j(-2, -1.74)
+j(-2, 1.74)
+j(-2, -2)
+j(-2, 2)
+j(-2, -3.2345)
+j(-2, 3.2345)
+j(-2, -100)
+j(-2, 100)
+j(3.2345, 0)
+j(3.2345, .5)
+j(3.2345, -.5)
+j(3.2345, 1)
+j(3.2345, -1)
+j(3.2345, 1.5)
+j(3.2345, -1.5)
+j(3.2345, 1.74)
+j(3.2345, -1.74)
+j(3.2345, 2)
+j(3.2345, -2)
+j(3.2345, 3.2345)
+j(3.2345, -3.2345)
+j(3.2345, 100)
+j(3.2345, -100)
+j(3.2345, -.5)
+j(3.2345, .5)
+j(3.2345, -1)
+j(3.2345, 1)
+j(3.2345, -1.5)
+j(3.2345, 1.5)
+j(3.2345, -1.74)
+j(3.2345, 1.74)
+j(3.2345, -2)
+j(3.2345, 2)
+j(3.2345, -3.2345)
+j(3.2345, 3.2345)
+j(3.2345, -100)
+j(3.2345, 100)
+j(-3.2345, 0)
+j(-3.2345, .5)
+j(-3.2345, -.5)
+j(-3.2345, 1)
+j(-3.2345, -1)
+j(-3.2345, 1.5)
+j(-3.2345, -1.5)
+j(-3.2345, 1.74)
+j(-3.2345, -1.74)
+j(-3.2345, 2)
+j(-3.2345, -2)
+j(-3.2345, 3.2345)
+j(-3.2345, -3.2345)
+j(-3.2345, 100)
+j(-3.2345, -100)
+j(-3.2345, -.5)
+j(-3.2345, .5)
+j(-3.2345, -1)
+j(-3.2345, 1)
+j(-3.2345, -1.5)
+j(-3.2345, 1.5)
+j(-3.2345, -1.74)
+j(-3.2345, 1.74)
+j(-3.2345, -2)
+j(-3.2345, 2)
+j(-3.2345, -3.2345)
+j(-3.2345, 3.2345)
+j(-3.2345, -100)
+j(-3.2345, 100)
+j(100, 0)
+j(100, .5)
+j(100, -.5)
+j(100, 1)
+j(100, -1)
+j(100, 1.5)
+j(100, -1.5)
+j(100, 1.74)
+j(100, -1.74)
+j(100, 2)
+j(100, -2)
+j(100, 3.2345)
+j(100, -3.2345)
+j(100, 100)
+j(100, -100)
+j(100, -.5)
+j(100, .5)
+j(100, -1)
+j(100, 1)
+j(100, -1.5)
+j(100, 1.5)
+j(100, -1.74)
+j(100, 1.74)
+j(100, -2)
+j(100, 2)
+j(100, -3.2345)
+j(100, 3.2345)
+j(100, -100)
+j(100, 100)
+j(-100, 0)
+j(-100, .5)
+j(-100, -.5)
+j(-100, 1)
+j(-100, -1)
+j(-100, 1.5)
+j(-100, -1.5)
+j(-100, 1.74)
+j(-100, -1.74)
+j(-100, 2)
+j(-100, -2)
+j(-100, 3.2345)
+j(-100, -3.2345)
+j(-100, 100)
+j(-100, -100)
+j(-100, -.5)
+j(-100, .5)
+j(-100, -1)
+j(-100, 1)
+j(-100, -1.5)
+j(-100, 1.5)
+j(-100, -1.74)
+j(-100, 1.74)
+j(-100, -2)
+j(-100, 2)
+j(-100, -3.2345)
+j(-100, 3.2345)
+j(-100, -100)
+j(-100, 100)
+j(-.5, 0)
+j(-.5, .5)
+j(-.5, -.5)
+j(-.5, 1)
+j(-.5, -1)
+j(-.5, 1.5)
+j(-.5, -1.5)
+j(-.5, 1.74)
+j(-.5, -1.74)
+j(-.5, 2)
+j(-.5, -2)
+j(-.5, 3.2345)
+j(-.5, -3.2345)
+j(-.5, 100)
+j(-.5, -100)
+j(-.5, -.5)
+j(-.5, .5)
+j(-.5, -1)
+j(-.5, 1)
+j(-.5, -1.5)
+j(-.5, 1.5)
+j(-.5, -1.74)
+j(-.5, 1.74)
+j(-.5, -2)
+j(-.5, 2)
+j(-.5, -3.2345)
+j(-.5, 3.2345)
+j(-.5, -100)
+j(-.5, 100)
+j(.5, 0)
+j(.5, .5)
+j(.5, -.5)
+j(.5, 1)
+j(.5, -1)
+j(.5, 1.5)
+j(.5, -1.5)
+j(.5, 1.74)
+j(.5, -1.74)
+j(.5, 2)
+j(.5, -2)
+j(.5, 3.2345)
+j(.5, -3.2345)
+j(.5, 100)
+j(.5, -100)
+j(.5, -.5)
+j(.5, .5)
+j(.5, -1)
+j(.5, 1)
+j(.5, -1.5)
+j(.5, 1.5)
+j(.5, -1.74)
+j(.5, 1.74)
+j(.5, -2)
+j(.5, 2)
+j(.5, -3.2345)
+j(.5, 3.2345)
+j(.5, -100)
+j(.5, 100)
+j(-1, 0)
+j(-1, .5)
+j(-1, -.5)
+j(-1, 1)
+j(-1, -1)
+j(-1, 1.5)
+j(-1, -1.5)
+j(-1, 1.74)
+j(-1, -1.74)
+j(-1, 2)
+j(-1, -2)
+j(-1, 3.2345)
+j(-1, -3.2345)
+j(-1, 100)
+j(-1, -100)
+j(-1, -.5)
+j(-1, .5)
+j(-1, -1)
+j(-1, 1)
+j(-1, -1.5)
+j(-1, 1.5)
+j(-1, -1.74)
+j(-1, 1.74)
+j(-1, -2)
+j(-1, 2)
+j(-1, -3.2345)
+j(-1, 3.2345)
+j(-1, -100)
+j(-1, 100)
+j(1, 0)
+j(1, .5)
+j(1, -.5)
+j(1, 1)
+j(1, -1)
+j(1, 1.5)
+j(1, -1.5)
+j(1, 1.74)
+j(1, -1.74)
+j(1, 2)
+j(1, -2)
+j(1, 3.2345)
+j(1, -3.2345)
+j(1, 100)
+j(1, -100)
+j(1, -.5)
+j(1, .5)
+j(1, -1)
+j(1, 1)
+j(1, -1.5)
+j(1, 1.5)
+j(1, -1.74)
+j(1, 1.74)
+j(1, -2)
+j(1, 2)
+j(1, -3.2345)
+j(1, 3.2345)
+j(1, -100)
+j(1, 100)
+j(-1.5, 0)
+j(-1.5, .5)
+j(-1.5, -.5)
+j(-1.5, 1)
+j(-1.5, -1)
+j(-1.5, 1.5)
+j(-1.5, -1.5)
+j(-1.5, 1.74)
+j(-1.5, -1.74)
+j(-1.5, 2)
+j(-1.5, -2)
+j(-1.5, 3.2345)
+j(-1.5, -3.2345)
+j(-1.5, 100)
+j(-1.5, -100)
+j(-1.5, -.5)
+j(-1.5, .5)
+j(-1.5, -1)
+j(-1.5, 1)
+j(-1.5, -1.5)
+j(-1.5, 1.5)
+j(-1.5, -1.74)
+j(-1.5, 1.74)
+j(-1.5, -2)
+j(-1.5, 2)
+j(-1.5, -3.2345)
+j(-1.5, 3.2345)
+j(-1.5, -100)
+j(-1.5, 100)
+j(1.5, 0)
+j(1.5, .5)
+j(1.5, -.5)
+j(1.5, 1)
+j(1.5, -1)
+j(1.5, 1.5)
+j(1.5, -1.5)
+j(1.5, 1.74)
+j(1.5, -1.74)
+j(1.5, 2)
+j(1.5, -2)
+j(1.5, 3.2345)
+j(1.5, -3.2345)
+j(1.5, 100)
+j(1.5, -100)
+j(1.5, -.5)
+j(1.5, .5)
+j(1.5, -1)
+j(1.5, 1)
+j(1.5, -1.5)
+j(1.5, 1.5)
+j(1.5, -1.74)
+j(1.5, 1.74)
+j(1.5, -2)
+j(1.5, 2)
+j(1.5, -3.2345)
+j(1.5, 3.2345)
+j(1.5, -100)
+j(1.5, 100)
+j(-1.74, 0)
+j(-1.74, .5)
+j(-1.74, -.5)
+j(-1.74, 1)
+j(-1.74, -1)
+j(-1.74, 1.5)
+j(-1.74, -1.5)
+j(-1.74, 1.74)
+j(-1.74, -1.74)
+j(-1.74, 2)
+j(-1.74, -2)
+j(-1.74, 3.2345)
+j(-1.74, -3.2345)
+j(-1.74, 100)
+j(-1.74, -100)
+j(-1.74, -.5)
+j(-1.74, .5)
+j(-1.74, -1)
+j(-1.74, 1)
+j(-1.74, -1.5)
+j(-1.74, 1.5)
+j(-1.74, -1.74)
+j(-1.74, 1.74)
+j(-1.74, -2)
+j(-1.74, 2)
+j(-1.74, -3.2345)
+j(-1.74, 3.2345)
+j(-1.74, -100)
+j(-1.74, 100)
+j(1.74, 0)
+j(1.74, .5)
+j(1.74, -.5)
+j(1.74, 1)
+j(1.74, -1)
+j(1.74, 1.5)
+j(1.74, -1.5)
+j(1.74, 1.74)
+j(1.74, -1.74)
+j(1.74, 2)
+j(1.74, -2)
+j(1.74, 3.2345)
+j(1.74, -3.2345)
+j(1.74, 100)
+j(1.74, -100)
+j(1.74, -.5)
+j(1.74, .5)
+j(1.74, -1)
+j(1.74, 1)
+j(1.74, -1.5)
+j(1.74, 1.5)
+j(1.74, -1.74)
+j(1.74, 1.74)
+j(1.74, -2)
+j(1.74, 2)
+j(1.74, -3.2345)
+j(1.74, 3.2345)
+j(1.74, -100)
+j(1.74, 100)
+j(-2, 0)
+j(-2, .5)
+j(-2, -.5)
+j(-2, 1)
+j(-2, -1)
+j(-2, 1.5)
+j(-2, -1.5)
+j(-2, 1.74)
+j(-2, -1.74)
+j(-2, 2)
+j(-2, -2)
+j(-2, 3.2345)
+j(-2, -3.2345)
+j(-2, 100)
+j(-2, -100)
+j(-2, -.5)
+j(-2, .5)
+j(-2, -1)
+j(-2, 1)
+j(-2, -1.5)
+j(-2, 1.5)
+j(-2, -1.74)
+j(-2, 1.74)
+j(-2, -2)
+j(-2, 2)
+j(-2, -3.2345)
+j(-2, 3.2345)
+j(-2, -100)
+j(-2, 100)
+j(2, 0)
+j(2, .5)
+j(2, -.5)
+j(2, 1)
+j(2, -1)
+j(2, 1.5)
+j(2, -1.5)
+j(2, 1.74)
+j(2, -1.74)
+j(2, 2)
+j(2, -2)
+j(2, 3.2345)
+j(2, -3.2345)
+j(2, 100)
+j(2, -100)
+j(2, -.5)
+j(2, .5)
+j(2, -1)
+j(2, 1)
+j(2, -1.5)
+j(2, 1.5)
+j(2, -1.74)
+j(2, 1.74)
+j(2, -2)
+j(2, 2)
+j(2, -3.2345)
+j(2, 3.2345)
+j(2, -100)
+j(2, 100)
+j(-3.2345, 0)
+j(-3.2345, .5)
+j(-3.2345, -.5)
+j(-3.2345, 1)
+j(-3.2345, -1)
+j(-3.2345, 1.5)
+j(-3.2345, -1.5)
+j(-3.2345, 1.74)
+j(-3.2345, -1.74)
+j(-3.2345, 2)
+j(-3.2345, -2)
+j(-3.2345, 3.2345)
+j(-3.2345, -3.2345)
+j(-3.2345, 100)
+j(-3.2345, -100)
+j(-3.2345, -.5)
+j(-3.2345, .5)
+j(-3.2345, -1)
+j(-3.2345, 1)
+j(-3.2345, -1.5)
+j(-3.2345, 1.5)
+j(-3.2345, -1.74)
+j(-3.2345, 1.74)
+j(-3.2345, -2)
+j(-3.2345, 2)
+j(-3.2345, -3.2345)
+j(-3.2345, 3.2345)
+j(-3.2345, -100)
+j(-3.2345, 100)
+j(3.2345, 0)
+j(3.2345, .5)
+j(3.2345, -.5)
+j(3.2345, 1)
+j(3.2345, -1)
+j(3.2345, 1.5)
+j(3.2345, -1.5)
+j(3.2345, 1.74)
+j(3.2345, -1.74)
+j(3.2345, 2)
+j(3.2345, -2)
+j(3.2345, 3.2345)
+j(3.2345, -3.2345)
+j(3.2345, 100)
+j(3.2345, -100)
+j(3.2345, -.5)
+j(3.2345, .5)
+j(3.2345, -1)
+j(3.2345, 1)
+j(3.2345, -1.5)
+j(3.2345, 1.5)
+j(3.2345, -1.74)
+j(3.2345, 1.74)
+j(3.2345, -2)
+j(3.2345, 2)
+j(3.2345, -3.2345)
+j(3.2345, 3.2345)
+j(3.2345, -100)
+j(3.2345, 100)
+j(-100, 0)
+j(-100, .5)
+j(-100, -.5)
+j(-100, 1)
+j(-100, -1)
+j(-100, 1.5)
+j(-100, -1.5)
+j(-100, 1.74)
+j(-100, -1.74)
+j(-100, 2)
+j(-100, -2)
+j(-100, 3.2345)
+j(-100, -3.2345)
+j(-100, 100)
+j(-100, -100)
+j(-100, -.5)
+j(-100, .5)
+j(-100, -1)
+j(-100, 1)
+j(-100, -1.5)
+j(-100, 1.5)
+j(-100, -1.74)
+j(-100, 1.74)
+j(-100, -2)
+j(-100, 2)
+j(-100, -3.2345)
+j(-100, 3.2345)
+j(-100, -100)
+j(-100, 100)
+j(100, 0)
+j(100, .5)
+j(100, -.5)
+j(100, 1)
+j(100, -1)
+j(100, 1.5)
+j(100, -1.5)
+j(100, 1.74)
+j(100, -1.74)
+j(100, 2)
+j(100, -2)
+j(100, 3.2345)
+j(100, -3.2345)
+j(100, 100)
+j(100, -100)
+j(100, -.5)
+j(100, .5)
+j(100, -1)
+j(100, 1)
+j(100, -1.5)
+j(100, 1.5)
+j(100, -1.74)
+j(100, 1.74)
+j(100, -2)
+j(100, 2)
+j(100, -3.2345)
+j(100, 3.2345)
+j(100, -100)
+j(100, 100)
+j(3, 0.75)
+scale = 0; j(40, 0.75)
+halt
\ No newline at end of file
diff -urpN busybox-1.29.3/testsuite/bc_bessel_results.txt busybox-1.30.0/testsuite/bc_bessel_results.txt
--- busybox-1.29.3/testsuite/bc_bessel_results.txt	1970-01-01 01:00:00.000000000 +0100
+++ busybox-1.30.0/testsuite/bc_bessel_results.txt	2018-12-30 16:14:20.000000000 +0100
@@ -0,0 +1,843 @@
+1.00000000000000000000
+.93846980724081290422
+.93846980724081290422
+.76519768655796655144
+.76519768655796655144
+.51182767173591812874
+.51182767173591812874
+.37483214773176892693
+.37483214773176892693
+.22389077914123566805
+.22389077914123566805
+-.32896462175888702221
+-.32896462175888702221
+.01998585030422312242
+.01998585030422312242
+.93846980724081290422
+.93846980724081290422
+.76519768655796655144
+.76519768655796655144
+.51182767173591812874
+.51182767173591812874
+.37483214773176892693
+.37483214773176892693
+.22389077914123566805
+.22389077914123566805
+-.32896462175888702221
+-.32896462175888702221
+.01998585030422312242
+.01998585030422312242
+1.00000000000000000000
+.93846980724081290422
+.93846980724081290422
+.76519768655796655144
+.76519768655796655144
+.51182767173591812874
+.51182767173591812874
+.37483214773176892693
+.37483214773176892693
+.22389077914123566805
+.22389077914123566805
+-.32896462175888702221
+-.32896462175888702221
+.01998585030422312242
+.01998585030422312242
+.93846980724081290422
+.93846980724081290422
+.76519768655796655144
+.76519768655796655144
+.51182767173591812874
+.51182767173591812874
+.37483214773176892693
+.37483214773176892693
+.22389077914123566805
+.22389077914123566805
+-.32896462175888702221
+-.32896462175888702221
+.01998585030422312242
+.01998585030422312242
+1.00000000000000000000
+.93846980724081290422
+.93846980724081290422
+.76519768655796655144
+.76519768655796655144
+.51182767173591812874
+.51182767173591812874
+.37483214773176892693
+.37483214773176892693
+.22389077914123566805
+.22389077914123566805
+-.32896462175888702221
+-.32896462175888702221
+.01998585030422312242
+.01998585030422312242
+.93846980724081290422
+.93846980724081290422
+.76519768655796655144
+.76519768655796655144
+.51182767173591812874
+.51182767173591812874
+.37483214773176892693
+.37483214773176892693
+.22389077914123566805
+.22389077914123566805
+-.32896462175888702221
+-.32896462175888702221
+.01998585030422312242
+.01998585030422312242
+0
+.24226845767487388638
+-.24226845767487388638
+.44005058574493351595
+-.44005058574493351595
+.55793650791009964199
+-.55793650791009964199
+.57976044202797131452
+-.57976044202797131452
+.57672480775687338720
+-.57672480775687338720
+.24741588607612652213
+-.24741588607612652213
+-.07714535201411215803
+.07714535201411215803
+-.24226845767487388638
+.24226845767487388638
+-.44005058574493351595
+.44005058574493351595
+-.55793650791009964199
+.55793650791009964199
+-.57976044202797131452
+.57976044202797131452
+-.57672480775687338720
+.57672480775687338720
+-.24741588607612652213
+.24741588607612652213
+.07714535201411215803
+-.07714535201411215803
+0
+-.24226845767487388638
+.24226845767487388638
+-.44005058574493351595
+.44005058574493351595
+-.55793650791009964199
+.55793650791009964199
+-.57976044202797131452
+.57976044202797131452
+-.57672480775687338720
+.57672480775687338720
+-.24741588607612652213
+.24741588607612652213
+.07714535201411215803
+-.07714535201411215803
+.24226845767487388638
+-.24226845767487388638
+.44005058574493351595
+-.44005058574493351595
+.55793650791009964199
+-.55793650791009964199
+.57976044202797131452
+-.57976044202797131452
+.57672480775687338720
+-.57672480775687338720
+.24741588607612652213
+-.24741588607612652213
+-.07714535201411215803
+.07714535201411215803
+0
+.24226845767487388638
+-.24226845767487388638
+.44005058574493351595
+-.44005058574493351595
+.55793650791009964199
+-.55793650791009964199
+.57976044202797131452
+-.57976044202797131452
+.57672480775687338720
+-.57672480775687338720
+.24741588607612652213
+-.24741588607612652213
+-.07714535201411215803
+.07714535201411215803
+-.24226845767487388638
+.24226845767487388638
+-.44005058574493351595
+.44005058574493351595
+-.55793650791009964199
+.55793650791009964199
+-.57976044202797131452
+.57976044202797131452
+-.57672480775687338720
+.57672480775687338720
+-.24741588607612652213
+.24741588607612652213
+.07714535201411215803
+-.07714535201411215803
+0
+-.24226845767487388638
+.24226845767487388638
+-.44005058574493351595
+.44005058574493351595
+-.55793650791009964199
+.55793650791009964199
+-.57976044202797131452
+.57976044202797131452
+-.57672480775687338720
+.57672480775687338720
+-.24741588607612652213
+.24741588607612652213
+.07714535201411215803
+-.07714535201411215803
+.24226845767487388638
+-.24226845767487388638
+.44005058574493351595
+-.44005058574493351595
+.55793650791009964199
+-.55793650791009964199
+.57976044202797131452
+-.57976044202797131452
+.57672480775687338720
+-.57672480775687338720
+.24741588607612652213
+-.24741588607612652213
+-.07714535201411215803
+.07714535201411215803
+0
+.24226845767487388638
+-.24226845767487388638
+.44005058574493351595
+-.44005058574493351595
+.55793650791009964199
+-.55793650791009964199
+.57976044202797131452
+-.57976044202797131452
+.57672480775687338720
+-.57672480775687338720
+.24741588607612652213
+-.24741588607612652213
+-.07714535201411215803
+.07714535201411215803
+-.24226845767487388638
+.24226845767487388638
+-.44005058574493351595
+.44005058574493351595
+-.55793650791009964199
+.55793650791009964199
+-.57976044202797131452
+.57976044202797131452
+-.57672480775687338720
+.57672480775687338720
+-.24741588607612652213
+.24741588607612652213
+.07714535201411215803
+-.07714535201411215803
+0
+-.24226845767487388638
+.24226845767487388638
+-.44005058574493351595
+.44005058574493351595
+-.55793650791009964199
+.55793650791009964199
+-.57976044202797131452
+.57976044202797131452
+-.57672480775687338720
+.57672480775687338720
+-.24741588607612652213
+.24741588607612652213
+.07714535201411215803
+-.07714535201411215803
+.24226845767487388638
+-.24226845767487388638
+.44005058574493351595
+-.44005058574493351595
+.55793650791009964199
+-.55793650791009964199
+.57976044202797131452
+-.57976044202797131452
+.57672480775687338720
+-.57672480775687338720
+.24741588607612652213
+-.24741588607612652213
+-.07714535201411215803
+.07714535201411215803
+0
+.03060402345868264130
+.03060402345868264130
+.11490348493190048046
+.11490348493190048046
+.23208767214421472723
+.23208767214421472723
+.29155916494406017021
+.29155916494406017021
+.35283402861563771915
+.35283402861563771915
+.48195017505993913050
+.48195017505993913050
+-.02152875734450536558
+-.02152875734450536558
+.03060402345868264130
+.03060402345868264130
+.11490348493190048046
+.11490348493190048046
+.23208767214421472723
+.23208767214421472723
+.29155916494406017021
+.29155916494406017021
+.35283402861563771915
+.35283402861563771915
+.48195017505993913050
+.48195017505993913050
+-.02152875734450536558
+-.02152875734450536558
+0
+.03060402345868264130
+.03060402345868264130
+.11490348493190048046
+.11490348493190048046
+.23208767214421472723
+.23208767214421472723
+.29155916494406017021
+.29155916494406017021
+.35283402861563771915
+.35283402861563771915
+.48195017505993913050
+.48195017505993913050
+-.02152875734450536558
+-.02152875734450536558
+.03060402345868264130
+.03060402345868264130
+.11490348493190048046
+.11490348493190048046
+.23208767214421472723
+.23208767214421472723
+.29155916494406017021
+.29155916494406017021
+.35283402861563771915
+.35283402861563771915
+.48195017505993913050
+.48195017505993913050
+-.02152875734450536558
+-.02152875734450536558
+0
+.00256372999458724407
+-.00256372999458724407
+.01956335398266840591
+-.01956335398266840591
+.06096395114113963064
+-.06096395114113963064
+.09049051186641988137
+-.09049051186641988137
+.12894324947440205109
+-.12894324947440205109
+.34859607875298354805
+-.34859607875298354805
+.07628420172033194340
+-.07628420172033194340
+-.00256372999458724407
+.00256372999458724407
+-.01956335398266840591
+.01956335398266840591
+-.06096395114113963064
+.06096395114113963064
+-.09049051186641988137
+.09049051186641988137
+-.12894324947440205109
+.12894324947440205109
+-.34859607875298354805
+.34859607875298354805
+-.07628420172033194340
+.07628420172033194340
+0
+-.00256372999458724407
+.00256372999458724407
+-.01956335398266840591
+.01956335398266840591
+-.06096395114113963064
+.06096395114113963064
+-.09049051186641988137
+.09049051186641988137
+-.12894324947440205109
+.12894324947440205109
+-.34859607875298354805
+.34859607875298354805
+-.07628420172033194340
+.07628420172033194340
+.00256372999458724407
+-.00256372999458724407
+.01956335398266840591
+-.01956335398266840591
+.06096395114113963064
+-.06096395114113963064
+.09049051186641988137
+-.09049051186641988137
+.12894324947440205109
+-.12894324947440205109
+.34859607875298354805
+-.34859607875298354805
+.07628420172033194340
+-.07628420172033194340
+0
+0
+0
+0
+0
+0
+0
+0
+0
+0
+0
+0
+0
+.09636667329586155967
+.09636667329586155967
+0
+0
+0
+0
+0
+0
+0
+0
+0
+0
+0
+0
+.09636667329586155967
+.09636667329586155967
+0
+0
+0
+0
+0
+0
+0
+0
+0
+0
+0
+0
+0
+.09636667329586155967
+.09636667329586155967
+0
+0
+0
+0
+0
+0
+0
+0
+0
+0
+0
+0
+.09636667329586155967
+.09636667329586155967
+1.00000000000000000000
+.93846980724081290422
+.93846980724081290422
+.76519768655796655144
+.76519768655796655144
+.51182767173591812874
+.51182767173591812874
+.37483214773176892693
+.37483214773176892693
+.22389077914123566805
+.22389077914123566805
+-.32896462175888702221
+-.32896462175888702221
+.01998585030422312242
+.01998585030422312242
+.93846980724081290422
+.93846980724081290422
+.76519768655796655144
+.76519768655796655144
+.51182767173591812874
+.51182767173591812874
+.37483214773176892693
+.37483214773176892693
+.22389077914123566805
+.22389077914123566805
+-.32896462175888702221
+-.32896462175888702221
+.01998585030422312242
+.01998585030422312242
+1.00000000000000000000
+.93846980724081290422
+.93846980724081290422
+.76519768655796655144
+.76519768655796655144
+.51182767173591812874
+.51182767173591812874
+.37483214773176892693
+.37483214773176892693
+.22389077914123566805
+.22389077914123566805
+-.32896462175888702221
+-.32896462175888702221
+.01998585030422312242
+.01998585030422312242
+.93846980724081290422
+.93846980724081290422
+.76519768655796655144
+.76519768655796655144
+.51182767173591812874
+.51182767173591812874
+.37483214773176892693
+.37483214773176892693
+.22389077914123566805
+.22389077914123566805
+-.32896462175888702221
+-.32896462175888702221
+.01998585030422312242
+.01998585030422312242
+0
+-.24226845767487388638
+.24226845767487388638
+-.44005058574493351595
+.44005058574493351595
+-.55793650791009964199
+.55793650791009964199
+-.57976044202797131452
+.57976044202797131452
+-.57672480775687338720
+.57672480775687338720
+-.24741588607612652213
+.24741588607612652213
+.07714535201411215803
+-.07714535201411215803
+.24226845767487388638
+-.24226845767487388638
+.44005058574493351595
+-.44005058574493351595
+.55793650791009964199
+-.55793650791009964199
+.57976044202797131452
+-.57976044202797131452
+.57672480775687338720
+-.57672480775687338720
+.24741588607612652213
+-.24741588607612652213
+-.07714535201411215803
+.07714535201411215803
+0
+.24226845767487388638
+-.24226845767487388638
+.44005058574493351595
+-.44005058574493351595
+.55793650791009964199
+-.55793650791009964199
+.57976044202797131452
+-.57976044202797131452
+.57672480775687338720
+-.57672480775687338720
+.24741588607612652213
+-.24741588607612652213
+-.07714535201411215803
+.07714535201411215803
+-.24226845767487388638
+.24226845767487388638
+-.44005058574493351595
+.44005058574493351595
+-.55793650791009964199
+.55793650791009964199
+-.57976044202797131452
+.57976044202797131452
+-.57672480775687338720
+.57672480775687338720
+-.24741588607612652213
+.24741588607612652213
+.07714535201411215803
+-.07714535201411215803
+0
+-.24226845767487388638
+.24226845767487388638
+-.44005058574493351595
+.44005058574493351595
+-.55793650791009964199
+.55793650791009964199
+-.57976044202797131452
+.57976044202797131452
+-.57672480775687338720
+.57672480775687338720
+-.24741588607612652213
+.24741588607612652213
+.07714535201411215803
+-.07714535201411215803
+.24226845767487388638
+-.24226845767487388638
+.44005058574493351595
+-.44005058574493351595
+.55793650791009964199
+-.55793650791009964199
+.57976044202797131452
+-.57976044202797131452
+.57672480775687338720
+-.57672480775687338720
+.24741588607612652213
+-.24741588607612652213
+-.07714535201411215803
+.07714535201411215803
+0
+.24226845767487388638
+-.24226845767487388638
+.44005058574493351595
+-.44005058574493351595
+.55793650791009964199
+-.55793650791009964199
+.57976044202797131452
+-.57976044202797131452
+.57672480775687338720
+-.57672480775687338720
+.24741588607612652213
+-.24741588607612652213
+-.07714535201411215803
+.07714535201411215803
+-.24226845767487388638
+.24226845767487388638
+-.44005058574493351595
+.44005058574493351595
+-.55793650791009964199
+.55793650791009964199
+-.57976044202797131452
+.57976044202797131452
+-.57672480775687338720
+.57672480775687338720
+-.24741588607612652213
+.24741588607612652213
+.07714535201411215803
+-.07714535201411215803
+0
+-.24226845767487388638
+.24226845767487388638
+-.44005058574493351595
+.44005058574493351595
+-.55793650791009964199
+.55793650791009964199
+-.57976044202797131452
+.57976044202797131452
+-.57672480775687338720
+.57672480775687338720
+-.24741588607612652213
+.24741588607612652213
+.07714535201411215803
+-.07714535201411215803
+.24226845767487388638
+-.24226845767487388638
+.44005058574493351595
+-.44005058574493351595
+.55793650791009964199
+-.55793650791009964199
+.57976044202797131452
+-.57976044202797131452
+.57672480775687338720
+-.57672480775687338720
+.24741588607612652213
+-.24741588607612652213
+-.07714535201411215803
+.07714535201411215803
+0
+.24226845767487388638
+-.24226845767487388638
+.44005058574493351595
+-.44005058574493351595
+.55793650791009964199
+-.55793650791009964199
+.57976044202797131452
+-.57976044202797131452
+.57672480775687338720
+-.57672480775687338720
+.24741588607612652213
+-.24741588607612652213
+-.07714535201411215803
+.07714535201411215803
+-.24226845767487388638
+.24226845767487388638
+-.44005058574493351595
+.44005058574493351595
+-.55793650791009964199
+.55793650791009964199
+-.57976044202797131452
+.57976044202797131452
+-.57672480775687338720
+.57672480775687338720
+-.24741588607612652213
+.24741588607612652213
+.07714535201411215803
+-.07714535201411215803
+0
+.03060402345868264130
+.03060402345868264130
+.11490348493190048046
+.11490348493190048046
+.23208767214421472723
+.23208767214421472723
+.29155916494406017021
+.29155916494406017021
+.35283402861563771915
+.35283402861563771915
+.48195017505993913050
+.48195017505993913050
+-.02152875734450536558
+-.02152875734450536558
+.03060402345868264130
+.03060402345868264130
+.11490348493190048046
+.11490348493190048046
+.23208767214421472723
+.23208767214421472723
+.29155916494406017021
+.29155916494406017021
+.35283402861563771915
+.35283402861563771915
+.48195017505993913050
+.48195017505993913050
+-.02152875734450536558
+-.02152875734450536558
+0
+.03060402345868264130
+.03060402345868264130
+.11490348493190048046
+.11490348493190048046
+.23208767214421472723
+.23208767214421472723
+.29155916494406017021
+.29155916494406017021
+.35283402861563771915
+.35283402861563771915
+.48195017505993913050
+.48195017505993913050
+-.02152875734450536558
+-.02152875734450536558
+.03060402345868264130
+.03060402345868264130
+.11490348493190048046
+.11490348493190048046
+.23208767214421472723
+.23208767214421472723
+.29155916494406017021
+.29155916494406017021
+.35283402861563771915
+.35283402861563771915
+.48195017505993913050
+.48195017505993913050
+-.02152875734450536558
+-.02152875734450536558
+0
+-.00256372999458724407
+.00256372999458724407
+-.01956335398266840591
+.01956335398266840591
+-.06096395114113963064
+.06096395114113963064
+-.09049051186641988137
+.09049051186641988137
+-.12894324947440205109
+.12894324947440205109
+-.34859607875298354805
+.34859607875298354805
+-.07628420172033194340
+.07628420172033194340
+.00256372999458724407
+-.00256372999458724407
+.01956335398266840591
+-.01956335398266840591
+.06096395114113963064
+-.06096395114113963064
+.09049051186641988137
+-.09049051186641988137
+.12894324947440205109
+-.12894324947440205109
+.34859607875298354805
+-.34859607875298354805
+.07628420172033194340
+-.07628420172033194340
+0
+.00256372999458724407
+-.00256372999458724407
+.01956335398266840591
+-.01956335398266840591
+.06096395114113963064
+-.06096395114113963064
+.09049051186641988137
+-.09049051186641988137
+.12894324947440205109
+-.12894324947440205109
+.34859607875298354805
+-.34859607875298354805
+.07628420172033194340
+-.07628420172033194340
+-.00256372999458724407
+.00256372999458724407
+-.01956335398266840591
+.01956335398266840591
+-.06096395114113963064
+.06096395114113963064
+-.09049051186641988137
+.09049051186641988137
+-.12894324947440205109
+.12894324947440205109
+-.34859607875298354805
+.34859607875298354805
+-.07628420172033194340
+.07628420172033194340
+0
+0
+0
+0
+0
+0
+0
+0
+0
+0
+0
+0
+0
+.09636667329586155967
+.09636667329586155967
+0
+0
+0
+0
+0
+0
+0
+0
+0
+0
+0
+0
+.09636667329586155967
+.09636667329586155967
+0
+0
+0
+0
+0
+0
+0
+0
+0
+0
+0
+0
+0
+.09636667329586155967
+.09636667329586155967
+0
+0
+0
+0
+0
+0
+0
+0
+0
+0
+0
+0
+.09636667329586155967
+.09636667329586155967
+.00848438342327410884
+0
diff -urpN busybox-1.29.3/testsuite/bc_boolean.bc busybox-1.30.0/testsuite/bc_boolean.bc
--- busybox-1.29.3/testsuite/bc_boolean.bc	1970-01-01 01:00:00.000000000 +0100
+++ busybox-1.30.0/testsuite/bc_boolean.bc	2018-12-30 16:14:20.000000000 +0100
@@ -0,0 +1,181 @@
+!0
+!1
+!(-129)
+4 && 5
+4 && 0
+0 && 5
+4 && 5 && 7
+4 && 0 && 7
+0 && 5 && 7
+4 && 5 && 0
+0 && 0 && 7
+4 && 0 && 0
+0 && 5 && 0
+!4 && 5
+!4 && 0
+!0 && 5
+4 && !5
+4 && !0
+0 && !5
+!4 && 5 && 7
+!4 && 0 && 7
+!0 && 5 && 7
+!4 && 5 && 0
+!0 && 0 && 7
+!4 && 0 && 0
+!0 && 5 && 0
+4 && !5 && 7
+4 && !0 && 7
+0 && !5 && 7
+4 && !5 && 0
+0 && !0 && 7
+4 && !0 && 0
+0 && !5 && 0
+4 && 5 && !7
+4 && 0 && !7
+0 && 5 && !7
+4 && 5 && !0
+0 && 0 && !7
+4 && 0 && !0
+0 && 5 && !0
+!4 && !5 && 7
+!4 && !0 && 7
+!0 && !5 && 7
+!4 && !5 && 0
+!0 && !0 && 7
+!4 && !0 && 0
+!0 && !5 && 0
+!4 && 5 && !7
+!4 && 0 && !7
+!0 && 5 && !7
+!4 && 5 && !0
+!0 && 0 && !7
+!4 && 0 && !0
+!0 && 5 && !0
+4 && !5 && !7
+4 && !0 && !7
+0 && !5 && !7
+4 && !5 && !0
+0 && !0 && !7
+4 && !0 && !0
+0 && !5 && !0
+!4 && !5 && !7
+!4 && !0 && !7
+!0 && !5 && !7
+!4 && !5 && !0
+!0 && !0 && !7
+!4 && !0 && !0
+!0 && !5 && !0
+3 < 4 && 7
+3 && 4 >= 4
+3 > 4 && 7
+3 && 4 >= 5
+3 < 4 && 0
+0 && 4 >= 4
+3 > 4 && 0
+0 && 4 >= 5
+3 > 4 && 0
+0 && 4 < 4
+3 >= 4 && 0
+0 && 4 >= 5
+3 < 4 && 7
+3 && 4 >= 4
+3 > 4 && 7 > 4
+3 >= 2 && 4 >= 5
+3 < 4 && 0 > -1
+4 < 3 && 4 >= 4
+3 > 4 && 3 == 3
+3 != 3 && 4 >= 5
+3 > 4 && 0 > 1
+0 >= 0 && 4 < 4
+3 >= 4 && 0 >= 1
+0 <= -1 && 4 >= 5
+4 || 5
+4 || 0
+0 || 5
+4 || 5 || 7
+4 || 0 || 7
+0 || 5 || 7
+4 || 5 || 0
+0 || 0 || 7
+4 || 0 || 0
+0 || 5 || 0
+!4 || 5
+!4 || 0
+!0 || 5
+4 || !5
+4 || !0
+0 || !5
+!4 || 5 || 7
+!4 || 0 || 7
+!0 || 5 || 7
+!4 || 5 || 0
+!0 || 0 || 7
+!4 || 0 || 0
+!0 || 5 || 0
+4 || !5 || 7
+4 || !0 || 7
+0 || !5 || 7
+4 || !5 || 0
+0 || !0 || 7
+4 || !0 || 0
+0 || !5 || 0
+4 || 5 || !7
+4 || 0 || !7
+0 || 5 || !7
+4 || 5 || !0
+0 || 0 || !7
+4 || 0 || !0
+0 || 5 || !0
+!4 || !5 || 7
+!4 || !0 || 7
+!0 || !5 || 7
+!4 || !5 || 0
+!0 || !0 || 7
+!4 || !0 || 0
+!0 || !5 || 0
+!4 || 5 || !7
+!4 || 0 || !7
+!0 || 5 || !7
+!4 || 5 || !0
+!0 || 0 || !7
+!4 || 0 || !0
+!0 || 5 || !0
+4 || !5 || !7
+4 || !0 || !7
+0 || !5 || !7
+4 || !5 || !0
+0 || !0 || !7
+4 || !0 || !0
+0 || !5 || !0
+!4 || !5 || !7
+!4 || !0 || !7
+!0 || !5 || !7
+!4 || !5 || !0
+!0 || !0 || !7
+!4 || !0 || !0
+!0 || !5 || !0
+3 < 4 || 7
+3 || 4 >= 4
+3 > 4 || 7
+3 || 4 >= 5
+3 < 4 || 0
+0 || 4 >= 4
+3 > 4 || 0
+0 || 4 >= 5
+3 > 4 || 0
+0 || 4 < 4
+3 >= 4 || 0
+0 || 4 >= 5
+3 < 4 || 7
+3 || 4 >= 4
+3 > 4 || 7 > 4
+3 >= 2 || 4 >= 5
+3 < 4 || 0 > -1
+4 < 3 || 4 >= 4
+3 > 4 || 3 == 3
+3 != 3 || 4 >= 5
+3 > 4 || 0 > 1
+0 >= 0 || 4 < 4
+3 >= 4 || 0 >= 1
+0 <= -1 || 4 >= 5
diff -urpN busybox-1.29.3/testsuite/bc_boolean_results.txt busybox-1.30.0/testsuite/bc_boolean_results.txt
--- busybox-1.29.3/testsuite/bc_boolean_results.txt	1970-01-01 01:00:00.000000000 +0100
+++ busybox-1.30.0/testsuite/bc_boolean_results.txt	2018-12-30 16:14:20.000000000 +0100
@@ -0,0 +1,181 @@
+1
+0
+0
+1
+0
+0
+1
+0
+0
+0
+0
+0
+0
+0
+0
+1
+0
+1
+0
+0
+0
+1
+0
+0
+0
+0
+0
+1
+0
+0
+0
+0
+0
+0
+0
+0
+1
+0
+0
+0
+0
+0
+0
+0
+1
+0
+0
+0
+0
+0
+0
+0
+0
+1
+0
+0
+0
+0
+0
+1
+0
+0
+0
+0
+0
+0
+0
+0
+1
+1
+0
+0
+0
+0
+0
+0
+0
+0
+0
+0
+1
+1
+0
+0
+1
+0
+0
+0
+0
+0
+0
+0
+1
+1
+1
+1
+1
+1
+1
+1
+1
+1
+1
+0
+1
+1
+1
+0
+1
+1
+1
+1
+1
+0
+1
+1
+1
+1
+1
+1
+1
+0
+1
+1
+1
+1
+0
+1
+1
+1
+1
+1
+0
+1
+1
+1
+1
+0
+1
+1
+1
+1
+1
+1
+1
+0
+1
+1
+1
+1
+0
+1
+1
+1
+1
+1
+1
+1
+1
+1
+1
+1
+1
+0
+0
+0
+0
+0
+0
+1
+1
+1
+1
+1
+1
+1
+0
+0
+1
+0
+0
diff -urpN busybox-1.29.3/testsuite/bc_cosine.bc busybox-1.30.0/testsuite/bc_cosine.bc
--- busybox-1.29.3/testsuite/bc_cosine.bc	1970-01-01 01:00:00.000000000 +0100
+++ busybox-1.30.0/testsuite/bc_cosine.bc	2018-12-30 16:14:20.000000000 +0100
@@ -0,0 +1,44 @@
+scale = 25
+p = 4 * a(1)
+scale = 20
+c(0)
+c(0.5)
+c(1)
+c(2)
+c(3)
+c(-0.5)
+c(-1)
+c(-2)
+c(-3)
+c(p / 7)
+c(-p / 7)
+c(p / 4)
+c(-p / 4)
+c(p / 3)
+c(-p / 3)
+c(p / 2)
+c(-p / 2)
+c(3 * p / 4)
+c(3 * -p / 4)
+c(p)
+c(-p)
+c(3 * p / 2)
+c(3 * -p / 2)
+c(7 * p / 4)
+c(7 * -p / 4)
+c(13 * p / 4)
+c(13 * -p / 4)
+c(2 * p)
+c(2 * -p)
+c(131231)
+c(-131231)
+c(859799894.3562378245)
+c(859799894.3562378245)
+c(4307371)
+c(3522556.3323810191)
+c(44961070)
+c(6918619.1574479809)
+c(190836996.2180244164)
+c(34934)
+c(2483599)
+c(13720376)
diff -urpN busybox-1.29.3/testsuite/bc_cosine_results.txt busybox-1.30.0/testsuite/bc_cosine_results.txt
--- busybox-1.29.3/testsuite/bc_cosine_results.txt	1970-01-01 01:00:00.000000000 +0100
+++ busybox-1.30.0/testsuite/bc_cosine_results.txt	2018-12-30 16:14:20.000000000 +0100
@@ -0,0 +1,41 @@
+1.00000000000000000000
+.87758256189037271611
+.54030230586813971740
+-.41614683654714238699
+-.98999249660044545727
+.87758256189037271611
+.54030230586813971740
+-.41614683654714238699
+-.98999249660044545727
+.90096886790241912623
+.90096886790241912623
+.70710678118654752440
+.70710678118654752440
+.50000000000000000000
+.50000000000000000000
+0
+0
+-.70710678118654752439
+-.70710678118654752439
+-1.00000000000000000000
+-1.00000000000000000000
+0
+0
+.70710678118654752439
+.70710678118654752439
+-.70710678118654752440
+-.70710678118654752440
+1.00000000000000000000
+1.00000000000000000000
+.92427123447397657316
+.92427123447397657316
+-.04198856352825241211
+-.04198856352825241211
+-.75581969921220636368
+-.01644924448939844182
+-.97280717522127222547
+-.92573947460230585966
+-.14343824233852988038
+.87259414746802343203
+.93542606623067050616
+-.52795540572178251550
diff -urpN busybox-1.29.3/testsuite/bc_decimal.bc busybox-1.30.0/testsuite/bc_decimal.bc
--- busybox-1.29.3/testsuite/bc_decimal.bc	1970-01-01 01:00:00.000000000 +0100
+++ busybox-1.30.0/testsuite/bc_decimal.bc	2018-12-30 16:14:20.000000000 +0100
@@ -0,0 +1,36 @@
+0
+0.0
+.00000
+000000000000000000000000.00000000000000000000000
+000000000000000000000000000135482346782356
+000000000000000000000000002
+1
+11
+123
+7505
+1023468723275435238491972521917846
+4343472432431705867392073517038270398027352709027389273920739037937960379637893607893607893670530278200795207952702873892786172916728961783907893607418973587857386079679267926737520730925372983782793652793
+-1
+-203
+-57
+-18586
+-31378682943772818461924738352952347258
+-823945628745673589495067238723986520375698237620834674509627345273096287563846592384526349872634895763257893467523987578690283762897568459072348758071071087813501875908127359018715023841710239872301387278
+.123521346523546
+0.1245923756273856
+-.1024678456387
+-0.8735863475634587
+4.0
+-6.0
+234237468293576.000000000000000000000000000000
+23987623568943567.00000000000000000005677834650000000000000
+23856934568940675.000000000000000435676782300000000000000456784
+77567648698496.000000000000000000587674750000000000458563800000000000000
+2348672354968723.2374823546000000000003256987394502346892435623870000000034578
+-2354768.000000000000000000000000000000000000
+-96739874567.000000000347683456
+-3764568345.000000000004573845000000347683460
+-356784356.934568495770004586495678300000000
+74325437345273852773827101738273127312738521733017537073520735207307570358738257390761276072160719802671980267018728630178.7082681027680521760217867841276127681270867827821768173178207830710978017738178678012767377058785378278207385237085237803278203782037237582795870
+-756752732785273851273728537852738257837283678965738527385272983678372867327835672967385278372637862738627836279863782673862783670.71738178361738718367186378610738617836781603760178367018603760178107735278372832783728367826738627836278378260736270367362073867097307925
+9812734012837410982345719208345712908357412903587192048571920458712.23957182459817249058172945781
diff -urpN busybox-1.29.3/testsuite/bc_decimal_results.txt busybox-1.30.0/testsuite/bc_decimal_results.txt
--- busybox-1.29.3/testsuite/bc_decimal_results.txt	1970-01-01 01:00:00.000000000 +0100
+++ busybox-1.30.0/testsuite/bc_decimal_results.txt	2018-12-30 16:14:20.000000000 +0100
@@ -0,0 +1,51 @@
+0
+0
+0
+0
+135482346782356
+2
+1
+11
+123
+7505
+1023468723275435238491972521917846
+43434724324317058673920735170382703980273527090273892739207390379379\
+60379637893607893607893670530278200795207952702873892786172916728961\
+78390789360741897358785738607967926792673752073092537298378279365279\
+3
+-1
+-203
+-57
+-18586
+-31378682943772818461924738352952347258
+-8239456287456735894950672387239865203756982376208346745096273452730\
+96287563846592384526349872634895763257893467523987578690283762897568\
+45907234875807107108781350187590812735901871502384171023987230138727\
+8
+.123521346523546
+.1245923756273856
+-.1024678456387
+-.8735863475634587
+4.0
+-6.0
+234237468293576.000000000000000000000000000000
+23987623568943567.00000000000000000005677834650000000000000
+23856934568940675.000000000000000435676782300000000000000456784
+77567648698496.00000000000000000058767475000000000045856380000000000\
+0000
+2348672354968723.237482354600000000000325698739450234689243562387000\
+0000034578
+-2354768.000000000000000000000000000000000000
+-96739874567.000000000347683456
+-3764568345.000000000004573845000000347683460
+-356784356.934568495770004586495678300000000
+74325437345273852773827101738273127312738521733017537073520735207307\
+570358738257390761276072160719802671980267018728630178.7082681027680\
+52176021786784127612768127086782782176817317820783071097801773817867\
+8012767377058785378278207385237085237803278203782037237582795870
+-7567527327852738512737285378527382578372836789657385273852729836783\
+72867327835672967385278372637862738627836279863782673862783670.71738\
+17836173871836718637861073861783678160376017836701860376017810773527\
+8372832783728367826738627836278378260736270367362073867097307925
+9812734012837410982345719208345712908357412903587192048571920458712.\
+23957182459817249058172945781
diff -urpN busybox-1.29.3/testsuite/bc_divide.bc busybox-1.30.0/testsuite/bc_divide.bc
--- busybox-1.29.3/testsuite/bc_divide.bc	1970-01-01 01:00:00.000000000 +0100
+++ busybox-1.30.0/testsuite/bc_divide.bc	2018-12-30 16:14:20.000000000 +0100
@@ -0,0 +1,31 @@
+0 / 1
+0 / 321566
+0 / 0.3984567238456
+1 / 1
+1 / 1287469297356
+1 / 0.2395672438567234
+1 / 237586239856.0293596728392360
+1249687284356 / 3027949207835207
+378617298617396719 / 35748521
+9348576237845624358 / 0.9857829375461
+35768293846193284 / 2374568947.045762839567823
+-78987234567812345 / 876542837618936
+-356789237555535468 / 0.3375273860984786903
+-5203475364850390 / 435742903748307.70869378534043296404530458
+-0.37861723347576903 / 7385770896
+-0.399454682043962 / 0.34824389304
+-0.6920414523873204 / 356489645223.76076045304879030
+-35872917389671.7573280963748 / 73924708
+-78375896314.4836709876983 / 0.78356798637817
+-2374123896417.143789621437581 / 347821469423789.1473856783960
+-896729350238549726 / -34976289345762
+-2374568293458762348596 / -0.8792370647234987679
+-237584692306721845726038 / -21783910782374529637.978102738746189024761
+-0.23457980123576298375682 / -1375486293874612
+-0.173897061862478951264 / -0.8179327486017634987516298745
+-0.9186739823576829347586 / -0.235678293458756239846
+-0.9375896183746982374568 / -13784962873546.0928729395476283745
+-2930754618923467.12323745862937465 / -734869238465
+-23745861923467.874675129834675 / -0.23542357869124756
+-3878923750692883.7238596702834756902 / -7384192674957215364986723.9738461923487621983
+1 / 0.00000000000000000000000000000000000000000002346728372937352457354204563027
diff -urpN busybox-1.29.3/testsuite/bc_divide_results.txt busybox-1.30.0/testsuite/bc_divide_results.txt
--- busybox-1.29.3/testsuite/bc_divide_results.txt	1970-01-01 01:00:00.000000000 +0100
+++ busybox-1.30.0/testsuite/bc_divide_results.txt	2018-12-30 16:14:20.000000000 +0100
@@ -0,0 +1,31 @@
+0
+0
+0
+1.00000000000000000000
+.00000000000077671755
+4.17419336592637110778
+.00000000000420899796
+.00041271738677857404
+10591131829.40901859967857131767
+9483402361494453751.52388015648196297248
+15063068.13735316451497043884
+-90.11223545260531110575
+-1057067521778623447.45138528213564485251
+-11.94161814246320631346
+-.00000000005126306228
+-1.14705437777218917343
+-.00000000000194126663
+-485262.88923145638029569727
+-100024372711.74763635544535424582
+-.00682569681609989277
+25638.20711150436682153521
+2700714504347599627864.24626421085374010264
+10906.42973524078145692731
+.00000000000000017054
+.21260557443109085166
+3.89799997647407910677
+.00000000000006801538
+3988.13076601933678578945
+100864416620775.31076855630746548983
+.00000000052530099381
+42612515855353136519261264261472677699404182.78776061098893912189
diff -urpN busybox-1.29.3/testsuite/bc_exponent.bc busybox-1.30.0/testsuite/bc_exponent.bc
--- busybox-1.29.3/testsuite/bc_exponent.bc	1970-01-01 01:00:00.000000000 +0100
+++ busybox-1.30.0/testsuite/bc_exponent.bc	2018-12-30 16:14:20.000000000 +0100
@@ -0,0 +1,22 @@
+e(0)
+e(0.5)
+e(1)
+e(1.5)
+e(1.74)
+e(2)
+e(3.2345)
+e(5.283957)
+e(13.23857)
+e(100)
+e(283.238957)
+e(-0.5)
+e(-1)
+e(-1.5)
+e(-1.74)
+e(-2)
+e(-3.2345)
+e(-5.283957)
+e(-13.23857)
+e(-100)
+e(-283.238957)
+e(142.749502399)
diff -urpN busybox-1.29.3/testsuite/bc_exponent_results.txt busybox-1.30.0/testsuite/bc_exponent_results.txt
--- busybox-1.29.3/testsuite/bc_exponent_results.txt	1970-01-01 01:00:00.000000000 +0100
+++ busybox-1.30.0/testsuite/bc_exponent_results.txt	2018-12-30 16:14:20.000000000 +0100
@@ -0,0 +1,25 @@
+1.00000000000000000000
+1.64872127070012814684
+2.71828182845904523536
+4.48168907033806482260
+5.69734342267199101193
+7.38905609893065022723
+25.39367176822616278859
+197.14845034328553587817
+561613.96621445383501864766
+26881171418161354484126255515800135873611118.77374192241519160861
+10212124131159922810249757193864245307850725332411569566443792548720\
+75182918653384240389953781407569563117008113027037939783.70141667971\
+570827872
+.60653065971263342360
+.36787944117144232159
+.22313016014842982893
+.17552040061699687169
+.13533528323661269189
+.03937988996342191888
+.00507231985977442865
+.00000178058250000525
+0
+0
+98928445824097165243611240348236907682258759298273030827411201.25833\
+645622510213538
Binary files busybox-1.29.3/testsuite/bc_large.tar.xz and busybox-1.30.0/testsuite/bc_large.tar.xz differ
diff -urpN busybox-1.29.3/testsuite/bc_log.bc busybox-1.30.0/testsuite/bc_log.bc
--- busybox-1.29.3/testsuite/bc_log.bc	1970-01-01 01:00:00.000000000 +0100
+++ busybox-1.30.0/testsuite/bc_log.bc	2018-12-30 16:14:20.000000000 +0100
@@ -0,0 +1,22 @@
+l(0)
+l(0.5)
+l(1)
+l(1.5)
+l(1.74)
+l(2)
+l(3.2345)
+l(5.283957)
+l(13.23857)
+l(100)
+l(283.238957)
+l(-0.5)
+l(-1)
+l(-1.5)
+l(-1.74)
+l(-2)
+l(-3.2345)
+l(-5.283957)
+l(-13.23857)
+l(-100)
+l(-283.238957)
+l(10430710.3325472917)
diff -urpN busybox-1.29.3/testsuite/bc_log_results.txt busybox-1.30.0/testsuite/bc_log_results.txt
--- busybox-1.29.3/testsuite/bc_log_results.txt	1970-01-01 01:00:00.000000000 +0100
+++ busybox-1.30.0/testsuite/bc_log_results.txt	2018-12-30 16:14:20.000000000 +0100
@@ -0,0 +1,22 @@
+-99999999999999999999.00000000000000000000
+-.69314718055994530941
+0
+.40546510810816438197
+.55388511322643765995
+.69314718055994530941
+1.17387435650190306676
+1.66467524885255369652
+2.58313453863349348434
+4.60517018598809136803
+5.64629091238730017971
+-99999999999999999999.00000000000000000000
+-99999999999999999999.00000000000000000000
+-99999999999999999999.00000000000000000000
+-99999999999999999999.00000000000000000000
+-99999999999999999999.00000000000000000000
+-99999999999999999999.00000000000000000000
+-99999999999999999999.00000000000000000000
+-99999999999999999999.00000000000000000000
+-99999999999999999999.00000000000000000000
+-99999999999999999999.00000000000000000000
+16.16026492940839137014
diff -urpN busybox-1.29.3/testsuite/bc_misc.bc busybox-1.30.0/testsuite/bc_misc.bc
--- busybox-1.29.3/testsuite/bc_misc.bc	1970-01-01 01:00:00.000000000 +0100
+++ busybox-1.30.0/testsuite/bc_misc.bc	2018-12-30 16:14:20.000000000 +0100
@@ -0,0 +1,13 @@
+4.1*1.-13^ - 74 - 1284597623841*1.-13^ - 757
+4.1*1.\
+-1\
+3^ - 74 - 1284597623841*1.\
+-1\
+3^ - 757
+obase = 9
+4.1*1.-13^ - 74 - 1284597623841*1.-13^ - 757
+4.1*1.\
+-1\
+3^ - 74 - 1284597623841*1.\
+-1\
+3^ - 757
diff -urpN busybox-1.29.3/testsuite/bc_misc1.bc busybox-1.30.0/testsuite/bc_misc1.bc
--- busybox-1.29.3/testsuite/bc_misc1.bc	1970-01-01 01:00:00.000000000 +0100
+++ busybox-1.30.0/testsuite/bc_misc1.bc	2018-12-30 16:14:20.000000000 +0100
@@ -0,0 +1,76 @@
+define x(x) {
+	return(x)
+}
+define y() {
+	return;
+}
+define z() {
+	return ();
+}
+scale = 0
+x=2
+x[0]=3
+x
+x[0]
+scale
+ibase
+obase
+x ( 7 )
+x + x( 8 )
+x - x[0]
+321 * x
+2 ^ x[0]
+x++
+--x
+x += 9
+x
+length(2381)
+sqrt(9)
+scale(238.1)
+x=2
+x[0]=3
+(x)
+(x[0])
+(scale)
+(ibase)
+(obase)
+(x ( 7 ))
+(x + x( 8 ))
+(x - x[0])
+(321 * x)
+(2 ^ x[0])
+(x++)
+(--x)
+(x += 9)
+(length(2381))
+(sqrt(9))
+(scale(238.1))
+(scale = 0)
+(x = 10)
+(x += 100)
+(x -= 10)
+(x *= 10)
+(x /= 100)
+(x ^= 10)
+(x = sqrt(x))
+(x[1 - 1])
+x[(1 - 1)]
+2 + \
+3
+++ibase
+--ibase
+++obase
+--obase
+++last
+--last
+last
+last = 100
+last
+. = 150
+.
+++scale
+--scale
+y()
+z()
+2 + /*
+*/3
diff -urpN busybox-1.29.3/testsuite/bc_misc1_results.txt busybox-1.30.0/testsuite/bc_misc1_results.txt
--- busybox-1.29.3/testsuite/bc_misc1_results.txt	1970-01-01 01:00:00.000000000 +0100
+++ busybox-1.30.0/testsuite/bc_misc1_results.txt	2018-12-30 16:14:20.000000000 +0100
@@ -0,0 +1,57 @@
+2
+3
+0
+10
+10
+7
+10
+-1
+642
+8
+2
+2
+11
+4
+3
+1
+2
+3
+0
+10
+10
+7
+10
+-1
+642
+8
+2
+2
+11
+4
+3
+1
+0
+10
+110
+100
+1000
+10
+10000000000
+100000
+3
+3
+5
+11
+10
+10
+10
+11
+10
+10
+100
+150
+1
+0
+0
+0
+5
diff -urpN busybox-1.29.3/testsuite/bc_misc2.bc busybox-1.30.0/testsuite/bc_misc2.bc
--- busybox-1.29.3/testsuite/bc_misc2.bc	1970-01-01 01:00:00.000000000 +0100
+++ busybox-1.30.0/testsuite/bc_misc2.bc	2018-12-30 16:14:20.000000000 +0100
@@ -0,0 +1,44 @@
+define x() {
+"x"
+return ( 1 )
+}
+define y() {
+"y"
+return (2)
+}
+define z() {
+"z"
+return (3)
+}
+
+if ( x() == y() ) {1}
+1
+if ( x() <= y() ) {2}
+if ( y() >= x() ) {3}
+if ( x() != y() ) {4}
+if ( x() < y() ) {5}
+if ( y() > x() ) {6}
+
+if ( x() == z() ) {11}
+11
+if ( x() <= z() ) {12}
+if ( z() >= x() ) {13}
+if ( x() != z() ) {14}
+if ( x() < z() ) {15}
+if ( z() > x() ) {16}
+
+x = -10
+while (x <= 0) {
+	x
+	if (x == -5) break;
+	x += 1
+}
+
+define u() {
+	auto a[];
+	return a[0]
+}
+
+u()
+
+if (x == -4) x else x - 4
diff -urpN busybox-1.29.3/testsuite/bc_misc2_results.txt busybox-1.30.0/testsuite/bc_misc2_results.txt
--- busybox-1.29.3/testsuite/bc_misc2_results.txt	1970-01-01 01:00:00.000000000 +0100
+++ busybox-1.30.0/testsuite/bc_misc2_results.txt	2018-12-30 16:14:20.000000000 +0100
@@ -0,0 +1,20 @@
+xy1
+xy2
+yx3
+xy4
+xy5
+yx6
+xz11
+xz12
+zx13
+xz14
+xz15
+zx16
+-10
+-9
+-8
+-7
+-6
+-5
+0
+-9
diff -urpN busybox-1.29.3/testsuite/bc_misc_results.txt busybox-1.30.0/testsuite/bc_misc_results.txt
--- busybox-1.29.3/testsuite/bc_misc_results.txt	1970-01-01 01:00:00.000000000 +0100
+++ busybox-1.30.0/testsuite/bc_misc_results.txt	2018-12-30 16:14:20.000000000 +0100
@@ -0,0 +1,4 @@
+-1284597623836.9
+-1284597623836.9
+-4483684050181.80
+-4483684050181.80
diff -urpN busybox-1.29.3/testsuite/bc_modulus.bc busybox-1.30.0/testsuite/bc_modulus.bc
--- busybox-1.29.3/testsuite/bc_modulus.bc	1970-01-01 01:00:00.000000000 +0100
+++ busybox-1.30.0/testsuite/bc_modulus.bc	2018-12-30 16:14:20.000000000 +0100
@@ -0,0 +1,70 @@
+1 % 1
+2 % 1
+16 % 4
+15 % 4
+17 % 4
+2389473 % 5
+39240687239 % 1
+346728934 % 23958
+3496723859067234 % 298375462837546928347623059375486
+-1 % 1
+-2 % 1
+-47589634875689345 % 37869235
+-1274852934765 % 2387628935486273546
+-6324758963 % 237854962
+1 % -1
+2 % -1
+2 % -2
+2 % -3
+16 % 5
+15 % 5
+14 % 5
+89237423 % -237856923854
+123647238946 % -12467
+-1 % -1
+-2 % -1
+-2 % -2
+-2 % -3
+-13 % -7
+-14 % -7
+-15 % -7
+-12784956 % -32746
+-127849612 % -23712347682193
+1 % 0.2395672438567234
+scale = 0
+1 % 1
+2 % 1
+16 % 4
+15 % 4
+17 % 4
+2389473 % 5
+39240687239 % 1
+346728934 % 23958
+3496723859067234 % 298375462837546928347623059375486
+-1 % 1
+-2 % 1
+-47589634875689345 % 37869235
+-1274852934765 % 2387628935486273546
+-6324758963 % 237854962
+1 % -1
+2 % -1
+2 % -2
+2 % -3
+16 % 5
+15 % 5
+14 % 5
+89237423 % -237856923854
+123647238946 % -12467
+-1 % -1
+-2 % -1
+-2 % -2
+-2 % -3
+-13 % -7
+-14 % -7
+-15 % -7
+-12784956 % -32746
+-127849612 % -23712347682193
+-3191280681 % 641165986
+scale = 0; -899510228 % -2448300078.40314
+scale = 0; -7424863 % -207.2609738667
+scale = 0; 3769798918 % 0.6
diff -urpN busybox-1.29.3/testsuite/bc_modulus_results.txt busybox-1.30.0/testsuite/bc_modulus_results.txt
--- busybox-1.29.3/testsuite/bc_modulus_results.txt	1970-01-01 01:00:00.000000000 +0100
+++ busybox-1.30.0/testsuite/bc_modulus_results.txt	2018-12-30 16:14:20.000000000 +0100
@@ -0,0 +1,69 @@
+0
+0
+0
+0
+0
+0
+0
+.00000000000000002026
+2747189239559.46904933397471305894
+0
+0
+-.00000000000011057855
+-.00076922992566770712
+-.00000000000050364144
+0
+0
+0
+.00000000000000000002
+0
+0
+0
+.00000000070585524350
+.00000000000000002898
+0
+0
+0
+-.00000000000000000002
+-.00000000000000000005
+0
+-.00000000000000000002
+-.00000000000000011722
+-.00000002640923745817
+.000000000000000000000404744340951948
+0
+0
+0
+3
+1
+3
+0
+8758
+3496723859067234
+0
+0
+-8236960
+-1274852934765
+-140529951
+0
+0
+0
+2
+1
+0
+4
+89237423
+6692
+0
+0
+0
+-2
+-6
+0
+-1
+-14016
+-127849612
+-626616737
+-899510228.00000
+-153.1331732059
+.4
diff -urpN busybox-1.29.3/testsuite/bc_multiply.bc busybox-1.30.0/testsuite/bc_multiply.bc
--- busybox-1.29.3/testsuite/bc_multiply.bc	1970-01-01 01:00:00.000000000 +0100
+++ busybox-1.30.0/testsuite/bc_multiply.bc	2018-12-30 16:14:20.000000000 +0100
@@ -0,0 +1,42 @@
+0 * 0
+0.000 * 0
+1 * 0
+0 * 1
+0 * 2498752389672835476
+873246913745129084576134 * 0
+1 * 472638590273489273456
+12374861230476103672835496 * 1
+1 * 1
+2 * 1
+1 * 2
+2 * 2
+3 * 14
+17 * 8
+1892467513846753 * 1872439821374591038746
+328962735862.2973546835638947635 * 1728465791348762356
+38745962374538.387427384672934867234 * 0.1932476528394672837568923754
+9878894576289457634856.2738627161689017387608947567654 * 37842939768237596237854203.29874372139852739126739621793162
+-1 * 1
+-1 * 2
+78893457 * -34876238956
+235678324957634 * -0.2349578349672389576
+-12849567821934 * 12738462937681
+1274861293467.927843682937462 * -28935678239
+2936077239872.12937462836 * -0.012842357682435762
+2387692387566.2378569237546 * -272189345628.123875629835876
+0.012348629356782835962 * -23487692356
+0.4768349567348675934 * -0.23756834576934857638495
+0.98748395367485962735486 * -4675839462354867.376834956738456
+-321784627934586 * -235762378596
+-32578623567892356 * -0.32567384579638456
+-35768232346876 * -2348672935602387620.28375682349576237856
+-0.2356728394765234 * -238759624356978
+-0.2345768212346780 * -0.235768124697074385948943532045
+-0.370873860736785306278630 * -7835678398607.7086378076867096270
+-78365713707.7089637863786730 * -738580798679306780
+-73867038956790490258249 * -0.7379862716391723672803679
+-378621971598721837710387 * -98465373878350798.09743896037963078560
+37164201 * 2931559660
+679468076118972457796560530571.46287161642138401685 * 93762.2836
+.000000000000000000000000001 * .0000000000000000000000001
+scale = 0; 237854962 * -26
diff -urpN busybox-1.29.3/testsuite/bc_multiply_results.txt busybox-1.30.0/testsuite/bc_multiply_results.txt
--- busybox-1.29.3/testsuite/bc_multiply_results.txt	1970-01-01 01:00:00.000000000 +0100
+++ busybox-1.30.0/testsuite/bc_multiply_results.txt	2018-12-30 16:14:20.000000000 +0100
@@ -0,0 +1,43 @@
+0
+0
+0
+0
+0
+0
+472638590273489273456
+12374861230476103672835496
+1
+2
+2
+4
+42
+136
+3543531533584430580556128344529291738
+568600835566479683035874339053.4411638427543228060
+7487566285885.8557453089005171423976251098
+373846412427291014394738378015501363938345620046.7869650248829232267\
+2297002026819
+-1
+-2
+-2751507058396910892
+-55374468980751.0837656919743223184
+-163683743464924630346895054
+-36888976187143312550878.567134791289418
+-37706154097.69662826215753378160
+-649904428532907022680241.94791869424754101064
+-290040807.350385412976669306472
+-.11328089187650139309272
+-4617316439035114.40320367843985107357898
+75864709277486862054521256
+10610005628108234.92015040406042336
+84007879267445533366251128067927.91168012197674537856
+56269158624557.1027018519702852
+.055305737239900889424090264801
+2906048299183.472237078104362540110129
+57879411419313585866282299201.3825582163029400
+54512860676747314187949.9414724679950990587298071
+37281153992026463004361915151761464058058.54968338992209002720
+108949072447731660
+63708478450213482928510139572007971.83536929222529239687
+0
+-6184229012
diff -urpN busybox-1.29.3/testsuite/bc_numbers1.bc busybox-1.30.0/testsuite/bc_numbers1.bc
--- busybox-1.29.3/testsuite/bc_numbers1.bc	1970-01-01 01:00:00.000000000 +0100
+++ busybox-1.30.0/testsuite/bc_numbers1.bc	2018-12-30 16:14:20.000000000 +0100
@@ -0,0 +1,23 @@
+ibase=G
+define f() {
+a00=00;a01=01;a02=02;a03=03;a04=04;a05=05;a06=06;a07=07;a08=08;a09=09;a0a=0A;a0b=0B;a0c=0C;a0d=0D;a0e=0E;a0f=0F
+a10=10;a11=11;a12=12;a13=13;a14=14;a15=15;a16=16;a17=17;a18=18;a19=19;a1a=1A;a1b=1B;a1c=1C;a1d=1D;a1e=1E;a1f=1F
+a20=20;a21=21;a22=22;a23=23;a24=24;a25=25;a26=26;a27=27;a28=28;a29=29;a2a=2A;a2b=2B;a2c=2C;a2d=2D;a2e=2E;a2f=2F
+a30=30;a31=31;a32=32;a33=33;a34=34;a35=35;a36=36;a37=37;a38=38;a39=39;a3a=3A;a3b=3B;a3c=3C;a3d=3D;a3e=3E;a3f=3F
+a40=40;a41=41;a42=42;a43=43;a44=44;a45=45;a46=46;a47=47;a48=48;a49=49;a4a=4A;a4b=4B;a4c=4C;a4d=4D;a4e=4E;a4f=4F
+a50=50;a51=51;a52=52;a53=53;a54=54;a55=55;a56=56;a57=57;a58=58;a59=59;a5a=5A;a5b=5B;a5c=5C;a5d=5D;a5e=5E;a5f=5F
+a60=60;a61=61;a62=62;a63=63;a64=64;a65=65;a66=66;a67=67;a68=68;a69=69;a6a=6A;a6b=6B;a6c=6C;a6d=6D;a6e=6E;a6f=6F
+a70=70;a71=71;a72=72;a73=73;a74=74;a75=75;a76=76;a77=77;a78=78;a79=79;a7a=7A;a7b=7B;a7c=7C;a7d=7D;a7e=7E;a7f=7F
+a80=80;a81=81;a82=82;a83=83;a84=84;a85=85;a86=86;a87=87;a88=88;a89=89;a8a=8A;a8b=8B;a8c=8C;a8d=8D;a8e=8E;a8f=8F
+a90=90;a91=91;a92=92;a93=93;a94=94;a95=95;a96=96;a97=97;a98=98;a99=99;a9a=9A;a9b=9B;a9c=9C;a9d=9D;a9e=9E;a9f=9F
+aa0=A0;aa1=A1;aa2=A2;aa3=A3;aa4=A4;aa5=A5;aa6=A6;aa7=A7;aa8=A8;aa9=A9;aaa=AA;aab=AB;aac=AC;aad=AD;aae=AE;aaf=AF
+ab0=B0;ab1=B1;ab2=B2;ab3=B3;ab4=B4;ab5=B5;ab6=B6;ab7=B7;ab8=B8;ab9=B9;aba=BA;abb=BB;abc=BC;abd=BD;abe=BE;abf=BF
+ac0=C0;ac1=C1;ac2=C2;ac3=C3;ac4=C4;ac5=C5;ac6=C6;ac7=C7;ac8=C8;ac9=C9;aca=CA;acb=CB;acc=CC;acd=CD;ace=CE;acf=CF
+ad0=D0;ad1=D1;ad2=D2;ad3=D3;ad4=D4;ad5=D5;ad6=D6;ad7=D7;ad8=D8;ad9=D9;ada=DA;adb=DB;adc=DC;add=DD;ade=DE;adf=DF
+ae0=E0;ae1=E1;ae2=E2;ae3=E3;ae4=E4;ae5=E5;ae6=E6;ae7=E7;ae8=E8;ae9=E9;aea=EA;aeb=EB;aec=EC;aed=ED;aee=EE;aef=EF
+af0=F0;af1=F1;af2=F2;af3=F3;af4=F4;af5=F5;af6=F6;af7=F7;af8=F8;af9=F9;afa=FA;afb=FB;afc=FC;afd=FD;afe=FE;aff=FF
+# this tests "index encoding" in bc.c: are numbers after 0xfc encoded correctly?
+af0;af1;af2;af3;af4;af5;af6;af7;af8;af9;afa;afb;afc;afd;afe;aff
+}
+f()
+halt
diff -urpN busybox-1.29.3/testsuite/bc_numbers1_results.txt busybox-1.30.0/testsuite/bc_numbers1_results.txt
--- busybox-1.29.3/testsuite/bc_numbers1_results.txt	1970-01-01 01:00:00.000000000 +0100
+++ busybox-1.30.0/testsuite/bc_numbers1_results.txt	2018-12-30 16:14:20.000000000 +0100
@@ -0,0 +1,17 @@
+240
+241
+242
+243
+244
+245
+246
+247
+248
+249
+250
+251
+252
+253
+254
+255
+0
diff -urpN busybox-1.29.3/testsuite/bc_numbers2.bc busybox-1.30.0/testsuite/bc_numbers2.bc
--- busybox-1.29.3/testsuite/bc_numbers2.bc	1970-01-01 01:00:00.000000000 +0100
+++ busybox-1.30.0/testsuite/bc_numbers2.bc	2018-12-30 16:14:20.000000000 +0100
@@ -0,0 +1,18 @@
+define f() {
+	"ibase:";ibase
+	a=A;a
+	a=F;a
+	a=G;a
+	a=Z;a
+	a=0A;a
+	a=0F;a
+	a=0G;a
+	a=0Z;a
+}
+f()
+ibase=9;f()
+ibase=A;f()
+ibase=F;f()
+ibase=G;f()
+#ibase=Z;f()
+halt
diff -urpN busybox-1.29.3/testsuite/bc_numbers2_results.txt busybox-1.30.0/testsuite/bc_numbers2_results.txt
--- busybox-1.29.3/testsuite/bc_numbers2_results.txt	1970-01-01 01:00:00.000000000 +0100
+++ busybox-1.30.0/testsuite/bc_numbers2_results.txt	2018-12-30 16:14:20.000000000 +0100
@@ -0,0 +1,50 @@
+ibase:10
+10
+15
+16
+35
+10
+15
+16
+35
+0
+ibase:9
+10
+15
+16
+35
+10
+15
+16
+35
+0
+ibase:10
+10
+15
+16
+35
+10
+15
+16
+35
+0
+ibase:15
+10
+15
+16
+35
+10
+15
+16
+35
+0
+ibase:16
+10
+15
+16
+35
+10
+15
+16
+35
+0
diff -urpN busybox-1.29.3/testsuite/bc_pi.bc busybox-1.30.0/testsuite/bc_pi.bc
--- busybox-1.29.3/testsuite/bc_pi.bc	1970-01-01 01:00:00.000000000 +0100
+++ busybox-1.30.0/testsuite/bc_pi.bc	2018-12-30 16:14:20.000000000 +0100
@@ -0,0 +1,4 @@
+for (i = 0; i <= 100; ++i) {
+	scale = i
+	4 * a(1)
+}
diff -urpN busybox-1.29.3/testsuite/bc_pi_results.txt busybox-1.30.0/testsuite/bc_pi_results.txt
--- busybox-1.29.3/testsuite/bc_pi_results.txt	1970-01-01 01:00:00.000000000 +0100
+++ busybox-1.30.0/testsuite/bc_pi_results.txt	2018-12-30 16:14:20.000000000 +0100
@@ -0,0 +1,135 @@
+0
+2.8
+3.12
+3.140
+3.1412
+3.14156
+3.141592
+3.1415924
+3.14159264
+3.141592652
+3.1415926532
+3.14159265356
+3.141592653588
+3.1415926535896
+3.14159265358976
+3.141592653589792
+3.1415926535897932
+3.14159265358979320
+3.141592653589793236
+3.1415926535897932384
+3.14159265358979323844
+3.141592653589793238460
+3.1415926535897932384624
+3.14159265358979323846264
+3.141592653589793238462640
+3.1415926535897932384626432
+3.14159265358979323846264336
+3.141592653589793238462643380
+3.1415926535897932384626433832
+3.14159265358979323846264338324
+3.141592653589793238462643383276
+3.1415926535897932384626433832792
+3.14159265358979323846264338327948
+3.141592653589793238462643383279500
+3.1415926535897932384626433832795028
+3.14159265358979323846264338327950288
+3.141592653589793238462643383279502884
+3.1415926535897932384626433832795028840
+3.14159265358979323846264338327950288416
+3.141592653589793238462643383279502884196
+3.1415926535897932384626433832795028841968
+3.14159265358979323846264338327950288419716
+3.141592653589793238462643383279502884197168
+3.1415926535897932384626433832795028841971692
+3.14159265358979323846264338327950288419716936
+3.141592653589793238462643383279502884197169396
+3.1415926535897932384626433832795028841971693992
+3.14159265358979323846264338327950288419716939936
+3.141592653589793238462643383279502884197169399372
+3.1415926535897932384626433832795028841971693993748
+3.14159265358979323846264338327950288419716939937508
+3.141592653589793238462643383279502884197169399375104
+3.1415926535897932384626433832795028841971693993751056
+3.14159265358979323846264338327950288419716939937510580
+3.141592653589793238462643383279502884197169399375105820
+3.1415926535897932384626433832795028841971693993751058208
+3.14159265358979323846264338327950288419716939937510582096
+3.141592653589793238462643383279502884197169399375105820972
+3.1415926535897932384626433832795028841971693993751058209748
+3.14159265358979323846264338327950288419716939937510582097492
+3.141592653589793238462643383279502884197169399375105820974944
+3.1415926535897932384626433832795028841971693993751058209749444
+3.14159265358979323846264338327950288419716939937510582097494456
+3.141592653589793238462643383279502884197169399375105820974944592
+3.1415926535897932384626433832795028841971693993751058209749445920
+3.14159265358979323846264338327950288419716939937510582097494459228
+3.141592653589793238462643383279502884197169399375105820974944592304
+3.141592653589793238462643383279502884197169399375105820974944592307\
+6
+3.141592653589793238462643383279502884197169399375105820974944592307\
+80
+3.141592653589793238462643383279502884197169399375105820974944592307\
+816
+3.141592653589793238462643383279502884197169399375105820974944592307\
+8164
+3.141592653589793238462643383279502884197169399375105820974944592307\
+81640
+3.141592653589793238462643383279502884197169399375105820974944592307\
+816404
+3.141592653589793238462643383279502884197169399375105820974944592307\
+8164060
+3.141592653589793238462643383279502884197169399375105820974944592307\
+81640628
+3.141592653589793238462643383279502884197169399375105820974944592307\
+816406284
+3.141592653589793238462643383279502884197169399375105820974944592307\
+8164062860
+3.141592653589793238462643383279502884197169399375105820974944592307\
+81640628620
+3.141592653589793238462643383279502884197169399375105820974944592307\
+816406286208
+3.141592653589793238462643383279502884197169399375105820974944592307\
+8164062862088
+3.141592653589793238462643383279502884197169399375105820974944592307\
+81640628620896
+3.141592653589793238462643383279502884197169399375105820974944592307\
+816406286208996
+3.141592653589793238462643383279502884197169399375105820974944592307\
+8164062862089984
+3.141592653589793238462643383279502884197169399375105820974944592307\
+81640628620899860
+3.141592653589793238462643383279502884197169399375105820974944592307\
+816406286208998628
+3.141592653589793238462643383279502884197169399375105820974944592307\
+8164062862089986280
+3.141592653589793238462643383279502884197169399375105820974944592307\
+81640628620899862800
+3.141592653589793238462643383279502884197169399375105820974944592307\
+816406286208998628032
+3.141592653589793238462643383279502884197169399375105820974944592307\
+8164062862089986280348
+3.141592653589793238462643383279502884197169399375105820974944592307\
+81640628620899862803480
+3.141592653589793238462643383279502884197169399375105820974944592307\
+816406286208998628034824
+3.141592653589793238462643383279502884197169399375105820974944592307\
+8164062862089986280348252
+3.141592653589793238462643383279502884197169399375105820974944592307\
+81640628620899862803482532
+3.141592653589793238462643383279502884197169399375105820974944592307\
+816406286208998628034825340
+3.141592653589793238462643383279502884197169399375105820974944592307\
+8164062862089986280348253420
+3.141592653589793238462643383279502884197169399375105820974944592307\
+81640628620899862803482534208
+3.141592653589793238462643383279502884197169399375105820974944592307\
+816406286208998628034825342116
+3.141592653589793238462643383279502884197169399375105820974944592307\
+8164062862089986280348253421168
+3.141592653589793238462643383279502884197169399375105820974944592307\
+81640628620899862803482534211704
+3.141592653589793238462643383279502884197169399375105820974944592307\
+816406286208998628034825342117064
+3.141592653589793238462643383279502884197169399375105820974944592307\
+8164062862089986280348253421170676
diff -urpN busybox-1.29.3/testsuite/bc_power.bc busybox-1.30.0/testsuite/bc_power.bc
--- busybox-1.29.3/testsuite/bc_power.bc	1970-01-01 01:00:00.000000000 +0100
+++ busybox-1.30.0/testsuite/bc_power.bc	2018-12-30 16:14:20.000000000 +0100
@@ -0,0 +1,44 @@
+0 ^ 0
+0 ^ 1
+0 ^ 1894
+1 ^ 0
+39746823 ^ 0
+0.238672983047682 ^ 0
+18394762374689237468.97354862973846 ^ 0
+1 ^ 1
+2 ^ 1
+18927361346 ^ 1
+0.23523785962738592635777 ^ 1
+328956734869213746.89782398457234 ^ 1
+8937 ^ 98
+0.124876812394 ^ 2396
+93762.2836 ^ 13
+1 ^ -1
+2 ^ -1
+10 ^ -1
+683734768 ^ -1
+38579623756.897937568235 ^ -1
+1 ^ -32467
+2 ^ -53
+23897 ^ -213
+-1 ^ 1
+-1 ^ 2
+-2 ^ 1
+-2 ^ 2
+-237 ^ 294
+-3746 ^ 28
+-0.3548 ^ 35
+-4267.234 ^ 37
+-326.3246 ^ 78
+-1 ^ -1
+-1 ^ -2
+-2 ^ -1
+-2 ^ -2
+-237 ^ -293
+-784 ^ -23
+-86 ^ -7
+-0.23424398 ^ -781
+-178.234786 ^ -879
+-1274.346 ^ -768
+0 ^ -251
+-0.2959371298 ^ 227
diff -urpN busybox-1.29.3/testsuite/bc_power_results.txt busybox-1.30.0/testsuite/bc_power_results.txt
--- busybox-1.29.3/testsuite/bc_power_results.txt	1970-01-01 01:00:00.000000000 +0100
+++ busybox-1.30.0/testsuite/bc_power_results.txt	2018-12-30 16:14:20.000000000 +0100
@@ -0,0 +1,73 @@
+1
+0
+0
+1
+1
+1
+1
+1
+2
+18927361346
+.23523785962738592635777
+328956734869213746.89782398457234
+16473742664221279051571200630760751138799221376964991600670000200609\
+08006052596520320731708604393844468006290371918262741885989163144389\
+39367835091560809036359941703341471396407660150658436796925310445979\
+21333166245765946557344383284626113908419359990042883048537750217279\
+17481980123593363177308481941550382845381799410533956718500484099889\
+610805653325917409549921909941664118421333562129
+0
+43287877285033571298394739716218787350087163435619825150259705419.98\
+016445740928054425
+1.00000000000000000000
+.50000000000000000000
+.10000000000000000000
+.00000000146255543348
+.00000000002592041867
+1.00000000000000000000
+.00000000000000011102
+0
+-1
+1
+-2
+4
+14997322375665265051328725757939209353051902095893907150382724666290\
+49749481660976421019742616298227588464420182758442163654172400528243\
+00885441207762486233574213374503090372518590691583139696652847404883\
+08573912261119588874308960204159666762789603037188471170006223907416\
+60492840269152716750700089148882139254399347568222390231015487895905\
+73727080561379177721440905866857248917982113340543176658480139248897\
+54802503253413282808814063861470711399810899724515727713334909764746\
+27910290211411231279325882505708287941671508154740003122373284699097\
+78346501539634198926772266511968381368929692275950529960923432771985\
+12597189390708050983487158873301681237787429436264801751664042999180\
+3448659818912436089
+11478830555358864333472551120140548480416206583184496764727387456058\
+792742209537931243951391229607936
+-.00000000000000017759
+-2067373624686414405470850679965010694114490999957199847684803894306\
+56243666149296582304582679590231948238805965642713928910384741502707\
+.23224479257866798694
+11606078892843496082360561256965139908586179418605021706789617179085\
+85768049299693425729565480314913006780973928345684673490252494674985\
+0186164225375953066263609289359900615361965737717208159874390.293769\
+70206344604971
+-1.00000000000000000000
+1.00000000000000000000
+-.50000000000000000000
+.25000000000000000000
+0
+0
+-.00000000000002874159
+-1945134149489344891879057554905782841936258356736314337975569799825\
+94091939572752348215929683891336730843553721422164737465108229034947\
+87333189564755763444242676978610321731298729194092653999616928308494\
+26419468484566422775668903315088810746121307679948574976162519479931\
+18935243698160094347216562490000767121041786977792546155155934655909\
+14123833869470494708767968978717730012864171105540029928688274136791\
+98175053824022144065005509214813689232148489884560100200475909009813\
+340098100705258138.98542904577525702068
+0
+0
+0
+0
diff -urpN busybox-1.29.3/testsuite/bc_sine.bc busybox-1.30.0/testsuite/bc_sine.bc
--- busybox-1.29.3/testsuite/bc_sine.bc	1970-01-01 01:00:00.000000000 +0100
+++ busybox-1.30.0/testsuite/bc_sine.bc	2018-12-30 16:14:20.000000000 +0100
@@ -0,0 +1,207 @@
+scale = 25
+p = 4 * a(1)
+scale = 20
+s(0)
+s(0.5)
+s(1)
+s(2)
+s(3)
+s(-0.5)
+s(-1)
+s(-2)
+s(-3)
+s(p / 7)
+s(-p / 7)
+s(p / 4)
+s(-p / 4)
+s(p / 3)
+s(-p / 3)
+s(p / 2)
+s(-p / 2)
+s(3 * p / 4)
+s(3 * -p / 4)
+s(p)
+s(-p)
+s(3 * p / 2)
+s(3 * -p / 2)
+s(7 * p / 4)
+s(7 * -p / 4)
+s(13 * p / 4)
+s(13 * -p / 4)
+s(2 * p)
+s(2 * -p)
+s(131231)
+s(-131231)
+s(69.1967507777)
+s(10828)
+s(-16248506.847013148)
+s(2050281000)
+s(8224939)
+s(11334231.1154662464)
+s(-4109411249.2986954846)
+s(-2395915402.13984)
+s(-2795874313)
+s(-2262647256)
+s(3323158182.1239222084)
+s(99901384)
+s(-4202726050.2780080957)
+s(2870000621.3228830588)
+s(-4230239450.981045150)
+s(-1517506941.2678857223)
+s(4004582176)
+s(-4193724543.1108508063)
+s(-3432511261)
+s(1804484812)
+s(3229084127)
+s(-3565317246.583937244)
+s(3503281621)
+s(-3469146313.1766891244)
+s(-2257308049.307721068)
+s(-3978441809)
+s(3431564304.3752537)
+s(1249644440.2464914559)
+s(2395558891.1188487974)
+s(-2607820706.4079280116)
+s(1208310007)
+s(-3758597557.863203175)
+s(1186920672)
+s(-3988103872)
+s(-4280635328.4194857577)
+s(1051748072)
+s(-1884006279)
+s(-1046568719.2698663389)
+s(2482991410)
+s(-2106101268.1154045959)
+s(3530359346.77217900)
+s(-3373362543)
+s(2601598062)
+s(2987020862)
+s(-12033356.2057140648)
+s(-3721760707)
+s(2842387705.4145759704)
+s(3515832681.1808393297)
+s(-3658522034.16149)
+s(3963658030.2860423992)
+s(2977802215.597946655)
+s(-4271392570.4091498761)
+s(2378692585)
+s(-3545193743.629374782)
+s(-1762458738)
+s(-1174277828.4264040126)
+s(-1724994857)
+s(2802750230.1783499408)
+s(-3068133550)
+s(3324811474.621822235)
+s(2873024984)
+s(-3509056632.3888206298)
+s(1772903162.647192879)
+s(2836543102)
+s(4117858580.186)
+s(2988632386.4063754522)
+s(-4256784971.1770067447)
+s(2280820447)
+s(-2865200306)
+s(-3329592486)
+s(519126268)
+s(-2452430452)
+s(-2693220186.62104082)
+s(-3796811992.14485798)
+s(3619792326)
+s(2697791049.3038381550)
+s(3751267834.2808166557)
+s(-3761719074)
+s(-3824087631)
+s(2119301150)
+s(1398148974)
+s(-3386564819.1351816969)
+s(-3171483098)
+s(3688944941.3273318162)
+s(3060521119)
+s(-3527110404)
+s(3699631193)
+s(3872838898)
+s(3880350192)
+s(-4109411249.2986954846)
+s(-2395915402.13984)
+s(-2795874313)
+s(-2262647256)
+s(3323158182.1239222084)
+s(99901384)
+s(-4202726050.2780080957)
+s(2870000621.3228830588)
+s(-4230239450.981045150)
+s(-1517506941.2678857223)
+s(4004582176)
+s(-4193724543.1108508063)
+s(-3432511261)
+s(1804484812)
+s(3229084127)
+s(-3565317246.583937244)
+s(3503281621)
+s(-3469146313.1766891244)
+s(-2257308049.307721068)
+s(-3978441809)
+s(3431564304.3752537)
+s(1249644440.2464914559)
+s(2395558891.1188487974)
+s(-2607820706.4079280116)
+s(1208310007)
+s(-3758597557.863203175)
+s(1186920672)
+s(-3988103872)
+s(-4280635328.4194857577)
+s(1051748072)
+s(-1884006279)
+s(-1046568719.2698663389)
+s(2482991410)
+s(-2106101268.1154045959)
+s(3530359346.77217900)
+s(-3373362543)
+s(2601598062)
+s(2576349783.2446436039)
+s(2987020862)
+s(-12033356.2057140648)
+s(-3721760707)
+s(2842387705.4145759704)
+s(3515832681.1808393297)
+s(-3658522034.16149)
+s(3963658030.2860423992)
+s(2977802215.597946655)
+s(-4271392570.4091498761)
+s(2378692585)
+s(-3545193743.629374782)
+s(-1762458738)
+s(-1174277828.4264040126)
+s(-1724994857)
+s(2802750230.1783499408)
+s(-3068133550)
+s(3324811474.621822235)
+s(2873024984)
+s(-3509056632.3888206298)
+s(1772903162.647192879)
+s(2836543102)
+s(4117858580.186)
+s(2988632386.4063754522)
+s(-4256784971.1770067447)
+s(2280820447)
+s(-2865200306)
+s(-3329592486)
+s(519126268)
+s(-2452430452)
+s(-2693220186.62104082)
+s(-3796811992.14485798)
+s(3619792326)
+s(2697791049.3038381550)
+s(3751267834.2808166557)
+s(-3761719074)
+s(-3824087631)
+s(2119301150)
+s(1398148974)
+s(-3386564819.1351816969)
+s(-3171483098)
+s(3688944941.3273318162)
+s(3060521119)
+s(-3527110404)
+s(3699631193)
+s(3872838898)
+s(3880350192)
diff -urpN busybox-1.29.3/testsuite/bc_sine_results.txt busybox-1.30.0/testsuite/bc_sine_results.txt
--- busybox-1.29.3/testsuite/bc_sine_results.txt	1970-01-01 01:00:00.000000000 +0100
+++ busybox-1.30.0/testsuite/bc_sine_results.txt	2018-12-30 16:14:20.000000000 +0100
@@ -0,0 +1,204 @@
+0
+.47942553860420300027
+.84147098480789650665
+.90929742682568169539
+.14112000805986722210
+-.47942553860420300027
+-.84147098480789650665
+-.90929742682568169539
+-.14112000805986722210
+.43388373911755812047
+-.43388373911755812047
+.70710678118654752439
+-.70710678118654752439
+.86602540378443864676
+-.86602540378443864676
+1.00000000000000000000
+-1.00000000000000000000
+.70710678118654752440
+-.70710678118654752440
+0
+0
+-1.00000000000000000000
+1.00000000000000000000
+-.70710678118654752440
+.70710678118654752440
+-.70710678118654752439
+.70710678118654752439
+0
+0
+.38173640790989719211
+-.38173640790989719211
+.08162149793819434415
+.87714140586973771462
+-.91157035998052051623
+-.69638975047120679880
+-.94806056135672896231
+-.54548669379730874215
+.14605234154783145589
+-.12183062787430962391
+-.89832305526331682409
+-.99513029384033555290
+.76528428398894958149
+.51077956237618482050
+-.75908868040685122962
+-.37015497140201575652
+-.51432535569032144654
+.68890201397514289831
+.88200006249578882510
+-.01188893762444044480
+-.55298206739629427055
+-.39165958853437135625
+.17732674488831117445
+-.09648816960119759281
+.15728984163381104344
+-.31554983227150461370
+-.72225704678824601977
+.96170480789326775287
+-.47636475887571231114
+-.98999375714278585763
+-.06715264746977580303
+-.69464867397161089634
+.58037673122614640119
+-.44244898040675115062
+.04242496278231069061
+.96417934585711006987
+-.54513053517818430563
+-.28604677908958958915
+-.68003854521180919710
+.26597321569379963920
+-.34591048991595943570
+-.17084074152217894535
+-.42880744669595980174
+.36518031021580667844
+-.03514839609475800827
+.93891962312087620513
+-.69421849362562852947
+.15169857474887222961
+-.00226070393499995347
+.96209233301706432156
+-.79937182245558378826
+.99966966326862290520
+.85234799672007656117
+-.20824280061137520443
+-.00761257856348159450
+.10708922858398661064
+-.80233147080821341443
+.26521358383069223461
+-.95173930946495828679
+.66210405748455769256
+.30054820568403786217
+.21640593048970779808
+-.87596287572245980692
+.74627849623707962934
+-.25747200288605259984
+-.14700538617135227740
+-.06294254604551440990
+.67948313824962059899
+.83714389089726798409
+.33805040346429707760
+.80273418514828673749
+.72262501870089953244
+-.77469383027517310713
+-.15575896025754423345
+.22191568853026376075
+.25137052589938954082
+-.80534308288073574163
+-.44963537508211028805
+-.92368907556208259630
+-.80963411623457804531
+-.96822928101198069490
+-.46604999828123759716
+.63275578793565409192
+-.40563425346575205109
+.13095444406203282638
+.96217617474547242151
+-.16256793375739137005
+.71791623784197898982
+-.10713685791219679248
+.50758780541979250307
+-.09795373670371402656
+.14605234154783145589
+-.12183062787430962391
+-.89832305526331682409
+-.99513029384033555290
+.76528428398894958149
+.51077956237618482050
+-.75908868040685122962
+-.37015497140201575652
+-.51432535569032144654
+.68890201397514289831
+.88200006249578882510
+-.01188893762444044480
+-.55298206739629427055
+-.39165958853437135625
+.17732674488831117445
+-.09648816960119759281
+.15728984163381104344
+-.31554983227150461370
+-.72225704678824601977
+.96170480789326775287
+-.47636475887571231114
+-.98999375714278585763
+-.06715264746977580303
+-.69464867397161089634
+.58037673122614640119
+-.44244898040675115062
+.04242496278231069061
+.96417934585711006987
+-.54513053517818430563
+-.28604677908958958915
+-.68003854521180919710
+.26597321569379963920
+-.34591048991595943570
+-.17084074152217894535
+-.42880744669595980174
+.36518031021580667844
+-.03514839609475800827
+.75884554410943292265
+.93891962312087620513
+-.69421849362562852947
+.15169857474887222961
+-.00226070393499995347
+.96209233301706432156
+-.79937182245558378826
+.99966966326862290520
+.85234799672007656117
+-.20824280061137520443
+-.00761257856348159450
+.10708922858398661064
+-.80233147080821341443
+.26521358383069223461
+-.95173930946495828679
+.66210405748455769256
+.30054820568403786217
+.21640593048970779808
+-.87596287572245980692
+.74627849623707962934
+-.25747200288605259984
+-.14700538617135227740
+-.06294254604551440990
+.67948313824962059899
+.83714389089726798409
+.33805040346429707760
+.80273418514828673749
+.72262501870089953244
+-.77469383027517310713
+-.15575896025754423345
+.22191568853026376075
+.25137052589938954082
+-.80534308288073574163
+-.44963537508211028805
+-.92368907556208259630
+-.80963411623457804531
+-.96822928101198069490
+-.46604999828123759716
+.63275578793565409192
+-.40563425346575205109
+.13095444406203282638
+.96217617474547242151
+-.16256793375739137005
+.71791623784197898982
+-.10713685791219679248
+.50758780541979250307
+-.09795373670371402656
diff -urpN busybox-1.29.3/testsuite/bc_sqrt.bc busybox-1.30.0/testsuite/bc_sqrt.bc
--- busybox-1.29.3/testsuite/bc_sqrt.bc	1970-01-01 01:00:00.000000000 +0100
+++ busybox-1.30.0/testsuite/bc_sqrt.bc	2018-12-30 16:14:20.000000000 +0100
@@ -0,0 +1,18 @@
+scale = 20
+sqrt(0)
+sqrt(2)
+sqrt(4)
+sqrt(9)
+sqrt(16)
+sqrt(25)
+sqrt(121)
+sqrt(48765)
+sqrt(9287356207356)
+sqrt(0.189274385967238956872354)
+sqrt(12389467137496823.134567829387456283946)
+sqrt(.0000000000000000000000000000123)
+sqrt(1)
+scale = 0;
+sqrt(1407)
+sqrt(79101)
+scale = 6; sqrt(88.1247699921300025847737099094480986051698668662822009535526240)
diff -urpN busybox-1.29.3/testsuite/bc_sqrt_results.txt busybox-1.30.0/testsuite/bc_sqrt_results.txt
--- busybox-1.29.3/testsuite/bc_sqrt_results.txt	1970-01-01 01:00:00.000000000 +0100
+++ busybox-1.30.0/testsuite/bc_sqrt_results.txt	2018-12-30 16:14:20.000000000 +0100
@@ -0,0 +1,16 @@
+0
+1.41421356237309504880
+2.00000000000000000000
+3.00000000000000000000
+4.00000000000000000000
+5.00000000000000000000
+11.00000000000000000000
+220.82798735667542192643
+3047516.39985021245496456781
+.435056761776252544285578
+111307983.260397019622398608908
+.0000000000000035071355833500363
+1.00000000000000000000
+37
+281
+9.3874794269883757005315658512340070115147163425837869223395574
diff -urpN busybox-1.29.3/testsuite/bc_strings.bc busybox-1.30.0/testsuite/bc_strings.bc
--- busybox-1.29.3/testsuite/bc_strings.bc	1970-01-01 01:00:00.000000000 +0100
+++ busybox-1.30.0/testsuite/bc_strings.bc	2018-12-30 16:14:20.000000000 +0100
@@ -0,0 +1,12 @@
+"string"
+"another string"
+"yet
+another
+string"
+"noescapes\n"
+"newline
+"
+print "string"
+print "newline\n"
+
+print "\\\e\n"
diff -urpN busybox-1.29.3/testsuite/bc_strings_results.txt busybox-1.30.0/testsuite/bc_strings_results.txt
--- busybox-1.29.3/testsuite/bc_strings_results.txt	1970-01-01 01:00:00.000000000 +0100
+++ busybox-1.30.0/testsuite/bc_strings_results.txt	2018-12-30 16:14:20.000000000 +0100
@@ -0,0 +1,5 @@
+stringanother stringyet
+another
+stringnoescapes\nnewline
+stringnewline
+\\
diff -urpN busybox-1.29.3/testsuite/bc_subtract.bc busybox-1.30.0/testsuite/bc_subtract.bc
--- busybox-1.29.3/testsuite/bc_subtract.bc	1970-01-01 01:00:00.000000000 +0100
+++ busybox-1.30.0/testsuite/bc_subtract.bc	2018-12-30 16:14:20.000000000 +0100
@@ -0,0 +1,32 @@
+0 - 0
+0 - 1
+1 - 0
+1 - 1
+5 - 2
+2 - 9
+321974 - 12845976238457
+2874519803456710938465 - 384723854
+10000000000000000000000000000000000000000 - 999999999999999999999999999999999999999
+10000000000000000000000000000000000000000 - 9999999999999999999999999999999999999999
+10000000000000000000000000000000000000000 - 999999999999999999999999999999999999999.99999999999999999999999999999999999
+10000000000000000000000000000000000000000 - 9999999999999999999999999999999999999999.9999999999999999999999999999999999
+10000000000000000000000000000000000000000 - 0.00000000000000000000000000000000000000000000000000000000000000000000000000000000000001
+10000000000000000000000000000000000000001 - 0.00000000000000000000000000000000000000000000000000000000000000000000000000000000000001
+10000000000000000000000000000000000000000.0000000001 - 0.0000000000000000000000000000000000000000000000000000000000000000000000000001
+-2 - 6
+-23784692345 - 182934721309467230894628735496027345
+-224352354962873059862 - -1245723576829456278354960278345
+-3468273598 - -12354243
+-0.92345768293 - -2354768923
+-712384634.123476823 - -24768293376
+-1879234638 - -0.917234869234
+-0.9172438692134 - -0.971284967124
+-0.1283475123465 - -0.937462346
+-124765829346.2837468293562 - -0.923467829346
+-12476829385769 - -1928476259034.8378629356
+-0.38476284395876345 - -94875394587623.2357869324857
+-4674596708467.34754789403674343567 - -48672394852354698.237548629345
+979519669 - 3018100865
+929002449 - 3280677283
+0 - -525898
+3- - -3
diff -urpN busybox-1.29.3/testsuite/bc_subtract_results.txt busybox-1.30.0/testsuite/bc_subtract_results.txt
--- busybox-1.29.3/testsuite/bc_subtract_results.txt	1970-01-01 01:00:00.000000000 +0100
+++ busybox-1.30.0/testsuite/bc_subtract_results.txt	2018-12-30 16:14:20.000000000 +0100
@@ -0,0 +1,36 @@
+0
+-1
+1
+0
+3
+-7
+-12845975916483
+2874519803456326214611
+9000000000000000000000000000000000000001
+1
+9000000000000000000000000000000000000000.000000000000000000000000000\
+00000001
+.0000000000000000000000000000000001
+9999999999999999999999999999999999999999.999999999999999999999999999\
+99999999999999999999999999999999999999999999999999999999999
+10000000000000000000000000000000000000000.99999999999999999999999999\
+999999999999999999999999999999999999999999999999999999999999
+10000000000000000000000000000000000000000.00000000009999999999999999\
+99999999999999999999999999999999999999999999999999
+-8
+-182934721309467230894628759280719690
+1245723576605103923392087218483
+-3455919355
+2354768922.07654231707
+24055908741.876523177
+-1879234637.082765130766
+.0540410979106
+.8091148336535
+-124765829345.3602790000102
+-10548353126734.1621370644
+94875394587622.85102408852693655
+48667720255646230.89000073530825656433
+-2038581196
+-2351674834
+525898
+0
diff -urpN busybox-1.29.3/testsuite/bc_vars.bc busybox-1.30.0/testsuite/bc_vars.bc
--- busybox-1.29.3/testsuite/bc_vars.bc	1970-01-01 01:00:00.000000000 +0100
+++ busybox-1.30.0/testsuite/bc_vars.bc	2018-12-30 16:14:20.000000000 +0100
@@ -0,0 +1,7 @@
+scale=10;123981239.981273987 * 12983791827398.29836472638
+scale=100;759634576394.3946587934658364895 / 9834759834895386.36459364958346
+34895734986539489834759837489573498573.398475984759837485734987598345 + 9823749832749872384234872934.28347982374987239847982374
+a=123123123.987239874; b=123123123.239479823748; a+b
+20347023.23498723984 - 28934723874.234720384
+scale=100;a=739534985.895347284957;b=238746782364.2374623784; c = a / b; c
+s7298367203972395108367910823465293084561329084561390845613409516734503870691837451 + 785621394067928346918023476190834672198467134908618723249671349062187346898241093486139046139084613490817356023871869102746182749061872609129847
diff -urpN busybox-1.29.3/testsuite/bc_vars_results.txt busybox-1.30.0/testsuite/bc_vars_results.txt
--- busybox-1.29.3/testsuite/bc_vars_results.txt	1970-01-01 01:00:00.000000000 +0100
+++ busybox-1.30.0/testsuite/bc_vars_results.txt	2018-12-30 16:14:20.000000000 +0100
@@ -0,0 +1,12 @@
+1609746610419572350599.59456175545
+.0000772397688552681359718594121969204138521230712049526233926741658\
+845368495051158801794834809672994
+34895734996363239667509709873808371507.68195580850970988421481133834\
+5
+246246247.226719697748
+-28914376850.99973314416
+.0030975704827179453786044330548590249517387192084765414205077089498\
+482709063381782183114683451531598
+78562139406792834691802347619083467219846713490861872324967134906218\
+73468982410934861390461390846134908173560238718691027461827490618726\
+09129847
diff -urpN busybox-1.29.3/testsuite/dc.tests busybox-1.30.0/testsuite/dc.tests
--- busybox-1.29.3/testsuite/dc.tests	2018-07-02 13:23:06.000000000 +0200
+++ busybox-1.30.0/testsuite/dc.tests	2018-12-30 16:14:20.000000000 +0100
@@ -12,45 +12,81 @@ testing "dc basic syntax (stdin, multipl
 	"" "10 20+p"
 
 testing "dc basic syntax (argv, single arg)" \
-	"dc '10 20+p'" \
+	"dc -e'10 20+p'" \
 	"30\n" \
 	"" ""
 
 testing "dc basic syntax (argv, multiple args)" \
-	"dc 10 20+p" \
+	"dc -e10 -e20+p" \
 	"30\n" \
 	"" ""
 
 testing "dc complex with spaces (single arg)" \
-	"dc '8 8 * 2 2 + / p'" \
+	"dc -e'8 8 * 2 2 + / p'" \
 	"16\n" \
 	"" ""
 
 testing "dc complex without spaces (single arg)" \
-	"dc '8 8*2 2+/p'" \
+	"dc -e'8 8*2 2+/p'" \
 	"16\n" \
 	"" ""
 
 testing "dc complex with spaces (multiple args)" \
-	"dc 8 8 \* 2 2 + / p" \
+	"dc -e8 -e8 -e\* -e2 -e2 -e+ -e/ -ep" \
 	"16\n" \
 	"" ""
 
 testing "dc complex without spaces (multiple args)" \
-	"dc 8 8\*2 2+/p" \
+	"dc -e8 -e8\*2 -e2+/p" \
 	"16\n" \
 	"" ""
 
-exit $FAILCOUNT
-
-# we do not support arguments
-testing "dc -e <exprs>" \
-	"dc -e '10 2+f'" \
-	"12\n" \
-	"" ""
+optional FEATURE_DC_BIG
+# All tests below depend on FEATURE_DC_BIG
 
-testing "dc -f <exprs-from-given-file>" \
-	"dc -f input" \
-	"12\n" \
-	"10 2+f" ""
+testing "dc '>a' (conditional execute string) 1" \
+	"dc" \
+	"1\n9\n" \
+	"" "[1p]sa [2p]sb 1 2>a\n9p"
+
+testing "dc '>a' (conditional execute string) 2" \
+	"dc" \
+	"9\n" \
+	"" "[1p]sa [2p]sb 2 1>a\n9p"
+
+testing "dc '>aeb' (conditional execute string with else)" \
+	"dc" \
+	"2\n9\n" \
+	"" "[1p]sa [2p]sb 2 1>aeb\n9p"
+
+testing "dc space can be a register" \
+	"dc" \
+	"2\n9\n" \
+	"" "[2p]s \n[3p]\nl x\n9p"
+
+testing "dc newline can be a register" \
+	"dc" \
+	"2\n9\n" \
+	"" "[2p]s\n[3p]l\nx\n9p"
+
+for f in dc_*.dc; do
+	r="`basename "$f" .dc`_results.txt"
+	test -f "$r" || continue
+	# testing "test name" "command" "expected result" "file input" "stdin"
+	testing "dc $f" \
+		"{ { dc $f 2>&1; echo E:\$? >&2; } | diff -u - $r; echo E:\$?; } 2>&1" \
+		"E:0\nE:0\n" \
+		"" ""
+done
+
+for f in dcx_*.dc; do
+	r="`basename "$f" .dc`_results.txt"
+	test -f "$r" || continue
+	# testing "test name" "command" "expected result" "file input" "stdin"
+	testing "dc -x $f" \
+		"{ { dc -x $f 2>&1; echo E:\$? >&2; } | diff -u - $r; echo E:\$?; } 2>&1" \
+		"E:0\nE:0\n" \
+		"" ""
+done
 
+exit $FAILCOUNT
diff -urpN busybox-1.29.3/testsuite/dc_add.dc busybox-1.30.0/testsuite/dc_add.dc
--- busybox-1.29.3/testsuite/dc_add.dc	1970-01-01 01:00:00.000000000 +0100
+++ busybox-1.30.0/testsuite/dc_add.dc	2018-12-30 16:14:20.000000000 +0100
@@ -0,0 +1,33 @@
+0 0+pR
+0 0 0++pR
+0 1+pR
+0 1 1++pR
+1 1+pR
+1 0+pR
+2 5+pR
+237 483+pR
+999 999+pR
+2374623 324869356734856+pR
+2378639084586723980562 23468729367839+pR
+37298367203972395108367910823465293084561329084561390845613409516734503870691837451 785621394067928346918023476190834672198467134908618723249671349062187346898241093486139046139084613490817356023871869102746182749061872609129847+pR
+1.1 0+pR
+0 1.1+pR
+457283.731284923576 37842934672834.3874629385672354+pR
+1.0 0.1+pR
+3746289134067138046 0.138375863945672398456712389456273486293+pR
+_1 _1+pR
+_4 _15+pR
+_1346782 _1287904651762468913476+pR
+99999999999999999999999999999999999999999999999999999999999.999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999 0.000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000001+pR
+99999999999999999999999999999999999999999999999999999999999.999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999995 0.000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000005+pR
+99999999999999999999999999999999999999999999999999999999999.999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999 0.00000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000001+pR
+99999999999999999999999999999999999999999999999999999999999.999999999999999999999999999999999999999999999999999999999899999999999999999999999999999999999999999999999999999999999999 0.00000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000001+pR
+99999999999999999999999999999999999989999999999999999999999.999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999 0.00000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000001+pR
+_1889985797 2012747315+pR
+0 _14338.391079082+pR
+_2422297 1.3134942556+pR
+_1289374 1289374.2893417 0.238971 28937.28971+++pR
+1289374 1289374.2893417 _0.238971 28937.28971+++pR
+1289374 1289374.2893417 0.238971 _28937.28971+++pR
+1289374 1289374.2893417 _0.238971 _28937.28971+++pR
+1289374 _1289374.2893417 _0.238971 _28937.28971+++pR
diff -urpN busybox-1.29.3/testsuite/dc_add_results.txt busybox-1.30.0/testsuite/dc_add_results.txt
--- busybox-1.29.3/testsuite/dc_add_results.txt	1970-01-01 01:00:00.000000000 +0100
+++ busybox-1.30.0/testsuite/dc_add_results.txt	2018-12-30 16:14:20.000000000 +0100
@@ -0,0 +1,45 @@
+0
+0
+1
+2
+2
+1
+7
+720
+1998
+324869359109479
+2378639108055453348401
+78562139406792834691802347619083467219846713490861872324967138636055\
+45508706362018540498696043776980521464405852627147161556994835657433\
+00967298
+1.1
+1.1
+37842935130118.1187478621432354
+1.1
+3746289134067138046.138375863945672398456712389456273486293
+-2
+-19
+-1287904651762470260258
+100000000000000000000000000000000000000000000000000000000000.0000000\
+00000000000000000000000000000000000000000000000000000000000000000000\
+000000000000000000000000000000000000000000000
+100000000000000000000000000000000000000000000000000000000000.0000000\
+00000000000000000000000000000000000000000000000000000000000000000000\
+000000000000000000000000000000000000000000000
+100000000000000000000000000000000000000000000000000000000000.0000000\
+00000000000000000000000000000000000000000000000000000000000000000000\
+000000000000000000000000000000000000000009999
+99999999999999999999999999999999999999999999999999999999999.99999999\
+99999999999999999999999999999999999999999999999999000000000000000000\
+00000000000000000000000000000000000000009999
+99999999999999999999999999999999999990000000000000000000000.00000000\
+00000000000000000000000000000000000000000000000000000000000000000000\
+00000000000000000000000000000000000000009999
+122761518
+-14338.391079082
+-2422295.6865057444
+28937.8180227
+2607685.3400807
+2549811.2386027
+2549810.7606607
+-28937.8180227
diff -urpN busybox-1.29.3/testsuite/dc_boolean.dc busybox-1.30.0/testsuite/dc_boolean.dc
--- busybox-1.29.3/testsuite/dc_boolean.dc	1970-01-01 01:00:00.000000000 +0100
+++ busybox-1.30.0/testsuite/dc_boolean.dc	2018-12-30 16:14:20.000000000 +0100
@@ -0,0 +1,27 @@
+0 1(pR
+1 1(pR
+2 1(pR
+_1 1(pR
+_1 0(pR
+_1 _1(pR
+_1 _2(pR
+0 1{pR
+1 1{pR
+2 1{pR
+_1 1{pR
+_1 0{pR
+_1 _1{pR
+_1 _2{pR
+0 0GpR
+0 1GpR
+1 0GpR
+_1 _1GpR
+0 _1GpR
+_1 0GpR
+1 1GpR
+238 2GpR
+0NpR
+1NpR
+_1NpR
+2398NpR
+_2983.2389NpR
diff -urpN busybox-1.29.3/testsuite/dc_boolean_results.txt busybox-1.30.0/testsuite/dc_boolean_results.txt
--- busybox-1.29.3/testsuite/dc_boolean_results.txt	1970-01-01 01:00:00.000000000 +0100
+++ busybox-1.30.0/testsuite/dc_boolean_results.txt	2018-12-30 16:14:20.000000000 +0100
@@ -0,0 +1,27 @@
+0
+0
+1
+0
+0
+0
+1
+0
+1
+1
+0
+0
+1
+1
+1
+0
+0
+1
+0
+0
+1
+0
+1
+0
+0
+0
+0
diff -urpN busybox-1.29.3/testsuite/dc_decimal.dc busybox-1.30.0/testsuite/dc_decimal.dc
--- busybox-1.29.3/testsuite/dc_decimal.dc	1970-01-01 01:00:00.000000000 +0100
+++ busybox-1.30.0/testsuite/dc_decimal.dc	2018-12-30 16:14:20.000000000 +0100
@@ -0,0 +1,36 @@
+0pR
+0.0pR
+.0000pR
+000000000000000000000000.00000000000000000000000pR
+000000000000000000000000000135482346782356pR
+000000000000000000000000002pR
+1pR
+11pR
+123pR
+7505pR
+1023468723275435238491972521917846pR
+4343472432431705867392073517038270398027352709027389273920739037937960379637893607893607893670530278200795207952702873892786172916728961783907893607418973587857386079679267926737520730925372983782793652793pR
+_1pR
+_203pR
+_57pR
+_18586pR
+_31378682943772818461924738352952347258pR
+_823945628745673589495067238723986520375698237620834674509627345273096287563846592384526349872634895763257893467523987578690283762897568459072348758071071087813501875908127359018715023841710239872301387278pR
+.123521346523546pR
+0.1245923756273856pR
+_.1024678456387pR
+_0.8735863475634587pR
+4.0pR
+_6.0pR
+234237468293576.000000000000000000000000000000pR
+23987623568943567.00000000000000000005677834650000000000000pR
+23856934568940675.000000000000000435676782300000000000000456784pR
+77567648698496.000000000000000000587674750000000000458563800000000000000pR
+2348672354968723.2374823546000000000003256987394502346892435623870000000034578pR
+_2354768.000000000000000000000000000000000000pR
+_96739874567.000000000347683456pR
+_3764568345.000000000004573845000000347683460pR
+_356784356.934568495770004586495678300000000pR
+74325437345273852773827101738273127312738521733017537073520735207307570358738257390761276072160719802671980267018728630178.7082681027680521760217867841276127681270867827821768173178207830710978017738178678012767377058785378278207385237085237803278203782037237582795870pR
+_756752732785273851273728537852738257837283678965738527385272983678372867327835672967385278372637862738627836279863782673862783670.71738178361738718367186378610738617836781603760178367018603760178107735278372832783728367826738627836278378260736270367362073867097307925pR
+9812734012837410982345719208345712908357412903587192048571920458712.23957182459817249058172945781pR
diff -urpN busybox-1.29.3/testsuite/dc_decimal_results.txt busybox-1.30.0/testsuite/dc_decimal_results.txt
--- busybox-1.29.3/testsuite/dc_decimal_results.txt	1970-01-01 01:00:00.000000000 +0100
+++ busybox-1.30.0/testsuite/dc_decimal_results.txt	2018-12-30 16:14:20.000000000 +0100
@@ -0,0 +1,51 @@
+0
+0
+0
+0
+135482346782356
+2
+1
+11
+123
+7505
+1023468723275435238491972521917846
+43434724324317058673920735170382703980273527090273892739207390379379\
+60379637893607893607893670530278200795207952702873892786172916728961\
+78390789360741897358785738607967926792673752073092537298378279365279\
+3
+-1
+-203
+-57
+-18586
+-31378682943772818461924738352952347258
+-8239456287456735894950672387239865203756982376208346745096273452730\
+96287563846592384526349872634895763257893467523987578690283762897568\
+45907234875807107108781350187590812735901871502384171023987230138727\
+8
+.123521346523546
+.1245923756273856
+-.1024678456387
+-.8735863475634587
+4.0
+-6.0
+234237468293576.000000000000000000000000000000
+23987623568943567.00000000000000000005677834650000000000000
+23856934568940675.000000000000000435676782300000000000000456784
+77567648698496.00000000000000000058767475000000000045856380000000000\
+0000
+2348672354968723.237482354600000000000325698739450234689243562387000\
+0000034578
+-2354768.000000000000000000000000000000000000
+-96739874567.000000000347683456
+-3764568345.000000000004573845000000347683460
+-356784356.934568495770004586495678300000000
+74325437345273852773827101738273127312738521733017537073520735207307\
+570358738257390761276072160719802671980267018728630178.7082681027680\
+52176021786784127612768127086782782176817317820783071097801773817867\
+8012767377058785378278207385237085237803278203782037237582795870
+-7567527327852738512737285378527382578372836789657385273852729836783\
+72867327835672967385278372637862738627836279863782673862783670.71738\
+17836173871836718637861073861783678160376017836701860376017810773527\
+8372832783728367826738627836278378260736270367362073867097307925
+9812734012837410982345719208345712908357412903587192048571920458712.\
+23957182459817249058172945781
diff -urpN busybox-1.29.3/testsuite/dc_divide.dc busybox-1.30.0/testsuite/dc_divide.dc
--- busybox-1.29.3/testsuite/dc_divide.dc	1970-01-01 01:00:00.000000000 +0100
+++ busybox-1.30.0/testsuite/dc_divide.dc	2018-12-30 16:14:20.000000000 +0100
@@ -0,0 +1,33 @@
+20k
+0 1/pR
+0 321566/pR
+0 0.3984567238456/pR
+1 1/pR
+1 1287469297356/pR
+1 0.2395672438567234/pR
+1 237586239856.0293596728392360/pR
+1249687284356 3027949207835207/pR
+378617298617396719 35748521/pR
+9348576237845624358 0.9857829375461/pR
+35768293846193284 2374568947.045762839567823/pR
+_78987234567812345 876542837618936/pR
+_356789237555535468 0.3375273860984786903/pR
+_5203475364850390 435742903748307.70869378534043296404530458/pR
+_0.37861723347576903 7385770896/pR
+_0.399454682043962 0.34824389304/pR
+_0.6920414523873204 356489645223.76076045304879030/pR
+_35872917389671.7573280963748 73924708/pR
+_78375896314.4836709876983 0.78356798637817/pR
+_2374123896417.143789621437581 347821469423789.1473856783960/pR
+_896729350238549726 _34976289345762/pR
+_2374568293458762348596 _0.8792370647234987679/pR
+_237584692306721845726038 _21783910782374529637.978102738746189024761/pR
+_0.23457980123576298375682 _1375486293874612/pR
+_0.173897061862478951264 _0.8179327486017634987516298745/pR
+_0.9186739823576829347586 _0.235678293458756239846/pR
+_0.9375896183746982374568 _13784962873546.0928729395476283745/pR
+_2930754618923467.12323745862937465 _734869238465/pR
+_23745861923467.874675129834675 _0.23542357869124756/pR
+_3878923750692883.7238596702834756902 _7384192674957215364986723.9738461923487621983/pR
+1 0.00000000000000000000000000000000000000000002346728372937352457354204563027/pR
+239854711289345712 2891374 182 .2893 ///pR
diff -urpN busybox-1.29.3/testsuite/dc_divide_results.txt busybox-1.30.0/testsuite/dc_divide_results.txt
--- busybox-1.29.3/testsuite/dc_divide_results.txt	1970-01-01 01:00:00.000000000 +0100
+++ busybox-1.30.0/testsuite/dc_divide_results.txt	2018-12-30 16:14:20.000000000 +0100
@@ -0,0 +1,32 @@
+0
+0
+0
+1.00000000000000000000
+.00000000000077671755
+4.17419336592637110778
+.00000000000420899796
+.00041271738677857404
+10591131829.40901859967857131767
+9483402361494453751.52388015648196297248
+15063068.13735316451497043884
+-90.11223545260531110575
+-1057067521778623447.45138528213564485251
+-11.94161814246320631346
+-.00000000005126306228
+-1.14705437777218917343
+-.00000000000194126663
+-485262.88923145638029569727
+-100024372711.74763635544535424582
+-.00682569681609989277
+25638.20711150436682153521
+2700714504347599627864.24626421085374010264
+10906.42973524078145692731
+.00000000000000017054
+.21260557443109085166
+3.89799997647407910677
+.00000000000006801538
+3988.13076601933678578945
+100864416620775.31076855630746548983
+.00000000052530099381
+42612515855353136519261264261472677699404182.78776061098893912189
+52187553294928.31582417732156163799
diff -urpN busybox-1.29.3/testsuite/dc_divmod.dc busybox-1.30.0/testsuite/dc_divmod.dc
--- busybox-1.29.3/testsuite/dc_divmod.dc	1970-01-01 01:00:00.000000000 +0100
+++ busybox-1.30.0/testsuite/dc_divmod.dc	2018-12-30 16:14:20.000000000 +0100
@@ -0,0 +1,64 @@
+20k
+0 1~pRpR
+0 321566~pRpR
+0 0.3984567238456~pRpR
+1 1~pRpR
+1 1287469297356~pRpR
+1 0.2395672438567234~pRpR
+1 237586239856.0293596728392360~pRpR
+1249687284356 3027949207835207~pRpR
+378617298617396719 35748521~pRpR
+9348576237845624358 0.9857829375461~pRpR
+35768293846193284 2374568947.045762839567823~pRpR
+_78987234567812345 876542837618936~pRpR
+_356789237555535468 0.3375273860984786903~pRpR
+_5203475364850390 435742903748307.70869378534043296404530458~pRpR
+_0.37861723347576903 7385770896~pRpR
+_0.399454682043962 0.34824389304~pRpR
+_0.6920414523873204 356489645223.76076045304879030~pRpR
+_35872917389671.7573280963748 73924708~pRpR
+_78375896314.4836709876983 0.78356798637817~pRpR
+_2374123896417.143789621437581 347821469423789.1473856783960~pRpR
+_896729350238549726 _34976289345762~pRpR
+_2374568293458762348596 _0.8792370647234987679~pRpR
+_237584692306721845726038 _21783910782374529637.978102738746189024761~pRpR
+_0.23457980123576298375682 _1375486293874612~pRpR
+_0.173897061862478951264 _0.8179327486017634987516298745~pRpR
+_0.9186739823576829347586 _0.235678293458756239846~pRpR
+_0.9375896183746982374568 _13784962873546.0928729395476283745~pRpR
+_2930754618923467.12323745862937465 _734869238465~pRpR
+_23745861923467.874675129834675 _0.23542357869124756~pRpR
+_3878923750692883.7238596702834756902 _7384192674957215364986723.9738461923487621983~pRpR
+1 0.00000000000000000000000000000000000000000002346728372937352457354204563027~pRpR
+0k
+0 1~pRpR
+0 321566~pRpR
+0 0.3984567238456~pRpR
+1 1~pRpR
+1 1287469297356~pRpR
+1 0.2395672438567234~pRpR
+1 237586239856.0293596728392360~pRpR
+1249687284356 3027949207835207~pRpR
+378617298617396719 35748521~pRpR
+9348576237845624358 0.9857829375461~pRpR
+35768293846193284 2374568947.045762839567823~pRpR
+_78987234567812345 876542837618936~pRpR
+_356789237555535468 0.3375273860984786903~pRpR
+_5203475364850390 435742903748307.70869378534043296404530458~pRpR
+_0.37861723347576903 7385770896~pRpR
+_0.399454682043962 0.34824389304~pRpR
+_0.6920414523873204 356489645223.76076045304879030~pRpR
+_35872917389671.7573280963748 73924708~pRpR
+_78375896314.4836709876983 0.78356798637817~pRpR
+_2374123896417.143789621437581 347821469423789.1473856783960~pRpR
+_896729350238549726 _34976289345762~pRpR
+_2374568293458762348596 _0.8792370647234987679~pRpR
+_237584692306721845726038 _21783910782374529637.978102738746189024761~pRpR
+_0.23457980123576298375682 _1375486293874612~pRpR
+_0.173897061862478951264 _0.8179327486017634987516298745~pRpR
+_0.9186739823576829347586 _0.235678293458756239846~pRpR
+_0.9375896183746982374568 _13784962873546.0928729395476283745~pRpR
+_2930754618923467.12323745862937465 _734869238465~pRpR
+_23745861923467.874675129834675 _0.23542357869124756~pRpR
+_3878923750692883.7238596702834756902 _7384192674957215364986723.9738461923487621983~pRpR
+1 0.00000000000000000000000000000000000000000002346728372937352457354204563027~pRpR
diff -urpN busybox-1.29.3/testsuite/dc_divmod_results.txt busybox-1.30.0/testsuite/dc_divmod_results.txt
--- busybox-1.29.3/testsuite/dc_divmod_results.txt	1970-01-01 01:00:00.000000000 +0100
+++ busybox-1.30.0/testsuite/dc_divmod_results.txt	2018-12-30 16:14:20.000000000 +0100
@@ -0,0 +1,126 @@
+0
+0
+0
+0
+0
+0
+0
+1.00000000000000000000
+.00000000165742620220
+.00000000000077671755
+.000000000000000000000404744340951948
+4.17419336592637110778
+.000000001121901731436913388268041440
+.00000000000420899796
+.00000053204123177372
+.00041271738677857404
+.00000000000027633393
+10591131829.40901859967857131767
+.000000000000000000008615446968672
+9483402361494453751.52388015648196297248
+.00000000001477790730322167374655468
+15063068.13735316451497043884
+-.00000456715270151800
+-90.11223545260531110575
+-.000000000000000000002529869118878532347
+-1057067521778623447.45138528213564485251
+-.0000022326265743225222025732006233770753463532
+-11.94161814246320631346
+-.00000000004830962712
+-.00000000005126306228
+-.0000000000000000000013970700728
+-1.14705437777218917343
+-.0000000001738947526290727016287423110
+-.00000000000194126663
+-.00000000000045885284
+-485262.88923145638029569727
+-.0000000000000000000075040663382506
+-100024372711.74763635544535424582
+-.000001609445227594519190694403080
+-.00682569681609989277
+-.00000019041665271998
+25638.20711150436682153521
+-.000000000000000000005200979673140462744
+2700714504347599627864.24626421085374010264
+-.15832010238185026960887316509782343287709
+10906.42973524078145692731
+-.00000436867838665327682
+.00000000000000017054
+-.000000000000000000004322546241638067588696083330
+.21260557443109085166
+-.00000000000000000000103666428264443764258
+3.89799997647407910677
+-.000000130244568783188524951028009600190
+.00000000000006801538
+-.00000000467404345575
+3988.13076601933678578945
+-.0000000000000000000004406586308076852
+100864416620775.31076855630746548983
+-53336.193401942302558132911110799109649707477
+.00000000052530099381
+.0000000000000000000000000000000000000000000000000000000000000001907\
+266929376630027064745963897
+42612515855353136519261264261472677699404182.78776061098893912189
+0
+0
+0
+0
+0
+0
+0
+1
+1
+0
+.0417310245731064
+4
+1.0000000000000000
+0
+1249687284356
+0
+14621810
+10591131829
+.5164321195789
+9483402361494453751
+326154559.235716791539036
+15063068
+-98379182108105
+-90
+-.1523548944025685359
+-1057067521778623447
+-410303423619005.20436836125523739550164962
+-11
+-.37861723347576903
+0
+-.051210789003962
+-1
+-.69204145238732040
+0
+-65736175.7573280963748
+-485262
+-.58582391357943
+-100024372711
+-2374123896417.143789621437581
+0
+-7243991903570
+25638
+-.2165246218974912344
+2700714504347599627864
+-9361314145225494248.811531234062495956534
+10906
+-.23457980123576298375682
+0
+-.1738970618624789512640000000
+0
+-.2116391019814142152206
+3
+-.9375896183746982374568
+0
+-96095925047.12323745862937465
+3988
+-.07316224567061600
+100864416620775
+-3878923750692883.7238596702834756902
+0
+.0000000000000000000000000000000000000000000184866017689020776005643\
+3621086
+42612515855353136519261264261472677699404182
diff -urpN busybox-1.29.3/testsuite/dc_misc.dc busybox-1.30.0/testsuite/dc_misc.dc
--- busybox-1.29.3/testsuite/dc_misc.dc	1970-01-01 01:00:00.000000000 +0100
+++ busybox-1.30.0/testsuite/dc_misc.dc	2018-12-30 16:14:20.000000000 +0100
@@ -0,0 +1 @@
+zp198202389.289374pzp[Hello, World!]pzpzpfrfczpfR
diff -urpN busybox-1.29.3/testsuite/dc_misc_results.txt busybox-1.30.0/testsuite/dc_misc_results.txt
--- busybox-1.29.3/testsuite/dc_misc_results.txt	1970-01-01 01:00:00.000000000 +0100
+++ busybox-1.30.0/testsuite/dc_misc_results.txt	2018-12-30 16:14:20.000000000 +0100
@@ -0,0 +1,20 @@
+0
+198202389.289374
+2
+Hello, World!
+4
+5
+5
+4
+Hello, World!
+2
+198202389.289374
+0
+4
+5
+Hello, World!
+2
+198202389.289374
+0
+0
+0
diff -urpN busybox-1.29.3/testsuite/dc_modexp.dc busybox-1.30.0/testsuite/dc_modexp.dc
--- busybox-1.29.3/testsuite/dc_modexp.dc	1970-01-01 01:00:00.000000000 +0100
+++ busybox-1.30.0/testsuite/dc_modexp.dc	2018-12-30 16:14:20.000000000 +0100
@@ -0,0 +1,103 @@
+0 0 1|pR
+1 0 1|pR
+1 0 2|pR
+0 10 1|pR
+1 293 1|pR
+1 2789365 2|pR
+100 8 7|pR
+10922384 15031007 201|pR
+3346529 189 254|pR
+4113416930 197 14|pR
+7709 5887 111|pR
+5487406 3252 128|pR
+2080527 2279453822 219|pR
+48895 50678 232|pR
+1535808383 2902995144 18|pR
+8437837 2882198 69|pR
+35363 25806 2|pR
+3221177403 1560419989 189|pR
+227 42775 163|pR
+2811398069 37500 173|pR
+15046850 3859895697 195|pR
+15770756 3621999893 119|pR
+6937927 3719297189 183|pR
+12573 43819 209|pR
+42098463 7584603 136|pR
+8656683 1328292415 226|pR
+209 81 157|pR
+141 13317429 26|pR
+809485795 60745 101|pR
+4882 1388217898 38|pR
+750704 78 119|pR
+668879580 2888860497 179|pR
+1152725844 15295742 154|pR
+16160694 8981529 154|pR
+216 102 3|pR
+3691227289 5344109 232|pR
+2195559299 61 222|pR
+2478990626 13007440 30|pR
+45083 44 117|pR
+224 55824 53|pR
+1372700133 89 94|pR
+205 10422 48|pR
+11887 12 73|pR
+5955 24353 114|pR
+1201697310 789722419 6|pR
+56577 231 229|pR
+96 38841 189|pR
+6529661 5636520 209|pR
+11005 15955685 27|pR
+9709 231 132|pR
+59790 1034579699 166|pR
+47892 14536879 79|pR
+48 208 21|pR
+33036 3877 65|pR
+164 6527085 249|pR
+12146850 224 37|pR
+218 16425679 62|pR
+51 27641 95|pR
+3076735605 49154 32|pR
+515652717 4117874315 143|pR
+300672671 720768884 110|pR
+9422066 206 5|pR
+43 97 13|pR
+545174510 65319 126|pR
+3317462730 704990271 51|pR
+47316 23231 202|pR
+7236571 4379567 106|pR
+2584584521 2459274189 29|pR
+61562 5035178 178|pR
+65302 112 151|pR
+63040 2168854052 213|pR
+9039611 2370306559 62|pR
+16414384 1020652061 83|pR
+7491 3853569905 172|pR
+1180322494 46670 84|pR
+3823343557 3865107254 127|pR
+6240872 55335 39|pR
+2281401897 1098411 251|pR
+61 2949190429 231|pR
+8981024 162 43|pR
+1 3568883218 212|pR
+4217100969 3471787779 8|pR
+3232237 13 243|pR
+29280 3972452706 100|pR
+13077 6431923 216|pR
+104 3098510775 140|pR
+9503298 174 242|pR
+3424695712 12184 23|pR
+184 15066347 151|pR
+2935856 14003205 184|pR
+1386637762 2128151420 71|pR
+154 11960656 12|pR
+743976432 4004778779 136|pR
+3909160595 3575680922 21|pR
+26133 3580 147|pR
+409154 170 68|pR
+149 55629 40|pR
+5753 13776176 32|pR
+3831447473 658273178 98|pR
+1527252003 2300622 207|pR
+3363824553 8244645 215|pR
+20 145 101|pR
+4005077294 2196555621 94|pR
diff -urpN busybox-1.29.3/testsuite/dc_modexp_results.txt busybox-1.30.0/testsuite/dc_modexp_results.txt
--- busybox-1.29.3/testsuite/dc_modexp_results.txt	1970-01-01 01:00:00.000000000 +0100
+++ busybox-1.30.0/testsuite/dc_modexp_results.txt	2018-12-30 16:14:20.000000000 +0100
@@ -0,0 +1,103 @@
+1
+1
+1
+0
+0
+1
+4
+74
+1
+0
+98
+0
+72
+1
+1
+1
+1
+108
+36
+52
+65
+8
+181
+22
+7
+123
+93
+21
+17
+20
+1
+108
+58
+22
+0
+105
+161
+16
+40
+15
+45
+25
+64
+69
+0
+225
+27
+1
+22
+73
+92
+38
+15
+16
+173
+33
+32
+21
+25
+109
+71
+1
+4
+62
+15
+90
+29
+5
+40
+84
+40
+53
+8
+31
+64
+44
+14
+13
+145
+1
+1
+1
+76
+0
+189
+104
+192
+9
+119
+56
+45
+4
+32
+16
+135
+4
+29
+1
+49
+0
+128
+6
+18
diff -urpN busybox-1.29.3/testsuite/dc_modulus.dc busybox-1.30.0/testsuite/dc_modulus.dc
--- busybox-1.29.3/testsuite/dc_modulus.dc	1970-01-01 01:00:00.000000000 +0100
+++ busybox-1.30.0/testsuite/dc_modulus.dc	2018-12-30 16:14:20.000000000 +0100
@@ -0,0 +1,70 @@
+20k
+1 1%pR
+2 1%pR
+16 4%pR
+15 4%pR
+17 4%pR
+2389473 5%pR
+39240687239 1%pR
+346728934 23958%pR
+3496723859067234 298375462837546928347623059375486%pR
+_1 1%pR
+_2 1%pR
+_47589634875689345 37869235%pR
+_1274852934765 2387628935486273546%pR
+_6324758963 237854962%pR
+1 _1%pR
+2 _1%pR
+2 _2%pR
+2 _3%pR
+16 5%pR
+15 5%pR
+14 5%pR
+89237423 _237856923854%pR
+123647238946 _12467%pR
+_1 _1%pR
+_2 _1%pR
+_2 _2%pR
+_2 _3%pR
+_13 _7%pR
+_14 _7%pR
+_15 _7%pR
+_12784956 _32746%pR
+_127849612 _23712347682193%pR
+0k
+1 1%pR
+2 1%pR
+16 4%pR
+15 4%pR
+17 4%pR
+2389473 5%pR
+39240687239 1%pR
+346728934 23958%pR
+3496723859067234 298375462837546928347623059375486%pR
+_1 1%pR
+_2 1%pR
+_47589634875689345 37869235%pR
+_1274852934765 2387628935486273546%pR
+_6324758963 237854962%pR
+1 _1%pR
+2 _1%pR
+2 _2%pR
+2 _3%pR
+16 5%pR
+15 5%pR
+14 5%pR
+89237423 _237856923854%pR
+123647238946 _12467%pR
+_1 _1%pR
+_2 _1%pR
+_2 _2%pR
+_2 _3%pR
+_13 _7%pR
+_14 _7%pR
+_15 _7%pR
+_12784956 _32746%pR
+_127849612 _23712347682193%pR
+_3191280681 641165986%pR
+0k _899510228 _2448300078.40314%pR
+0k _7424863 _207.2609738667%pR
+0k 3769798918 0.6%pR
diff -urpN busybox-1.29.3/testsuite/dc_modulus_results.txt busybox-1.30.0/testsuite/dc_modulus_results.txt
--- busybox-1.29.3/testsuite/dc_modulus_results.txt	1970-01-01 01:00:00.000000000 +0100
+++ busybox-1.30.0/testsuite/dc_modulus_results.txt	2018-12-30 16:14:20.000000000 +0100
@@ -0,0 +1,68 @@
+0
+0
+0
+0
+0
+0
+0
+.00000000000000002026
+2747189239559.46904933397471305894
+0
+0
+-.00000000000011057855
+-.00076922992566770712
+-.00000000000050364144
+0
+0
+0
+.00000000000000000002
+0
+0
+0
+.00000000070585524350
+.00000000000000002898
+0
+0
+0
+-.00000000000000000002
+-.00000000000000000005
+0
+-.00000000000000000002
+-.00000000000000011722
+-.00000002640923745817
+0
+0
+0
+3
+1
+3
+0
+8758
+3496723859067234
+0
+0
+-8236960
+-1274852934765
+-140529951
+0
+0
+0
+2
+1
+0
+4
+89237423
+6692
+0
+0
+0
+-2
+-6
+0
+-1
+-14016
+-127849612
+-626616737
+-899510228.00000
+-153.1331732059
+.4
diff -urpN busybox-1.29.3/testsuite/dc_multiply.dc busybox-1.30.0/testsuite/dc_multiply.dc
--- busybox-1.29.3/testsuite/dc_multiply.dc	1970-01-01 01:00:00.000000000 +0100
+++ busybox-1.30.0/testsuite/dc_multiply.dc	2018-12-30 16:14:20.000000000 +0100
@@ -0,0 +1,42 @@
+0 0*pR
+0.000 0*pR
+1 0*pR
+0 1*pR
+0 2498752389672835476*pR
+873246913745129084576134 0*pR
+1 472638590273489273456*pR
+12374861230476103672835496 1*pR
+1 1*pR
+2 1*pR
+1 2*pR
+2 2*pR
+3 14*pR
+17 8*pR
+1892467513846753 1872439821374591038746*pR
+328962735862.2973546835638947635 1728465791348762356*pR
+38745962374538.387427384672934867234 0.1932476528394672837568923754*pR
+9878894576289457634856.2738627161689017387608947567654 37842939768237596237854203.29874372139852739126739621793162*pR
+_1 1*pR
+_1 2*pR
+78893457 _34876238956*pR
+235678324957634 _0.2349578349672389576*pR
+_12849567821934 12738462937681*pR
+1274861293467.927843682937462 _28935678239*pR
+2936077239872.12937462836 _0.012842357682435762*pR
+2387692387566.2378569237546 _272189345628.123875629835876*pR
+0.012348629356782835962 _23487692356*pR
+0.4768349567348675934 _0.23756834576934857638495*pR
+0.98748395367485962735486 _4675839462354867.376834956738456*pR
+_321784627934586 _235762378596*pR
+_32578623567892356 _0.32567384579638456*pR
+_35768232346876 _2348672935602387620.28375682349576237856*pR
+_0.2356728394765234 _238759624356978*pR
+_0.2345768212346780 _0.235768124697074385948943532045*pR
+_0.370873860736785306278630 _7835678398607.7086378076867096270*pR
+_78365713707.7089637863786730 _738580798679306780*pR
+_73867038956790490258249 _0.7379862716391723672803679*pR
+_378621971598721837710387 _98465373878350798.09743896037963078560*pR
+37164201 2931559660*pR
+679468076118972457796560530571.46287161642138401685 93762.2836*pR
+.000000000000000000000000001 .0000000000000000000000001*pR
+239 289 _98 .8937 _.1893 28937*****pR
diff -urpN busybox-1.29.3/testsuite/dc_multiply_results.txt busybox-1.30.0/testsuite/dc_multiply_results.txt
--- busybox-1.29.3/testsuite/dc_multiply_results.txt	1970-01-01 01:00:00.000000000 +0100
+++ busybox-1.30.0/testsuite/dc_multiply_results.txt	2018-12-30 16:14:20.000000000 +0100
@@ -0,0 +1,43 @@
+0
+0
+0
+0
+0
+0
+472638590273489273456
+12374861230476103672835496
+1
+2
+2
+4
+42
+136
+3543531533584430580556128344529291738
+568600835566479683035874339053.4411638427543228060
+7487566285885.8557453089005171423976251098
+373846412427291014394738378015501363938345620046.7869650248829232267\
+2297002026819
+-1
+-2
+-2751507058396910892
+-55374468980751.0837656919743223184
+-163683743464924630346895054
+-36888976187143312550878.567134791289418
+-37706154097.696628262157533781
+-649904428532907022680241.947918694247541
+-290040807.350385412976669306472
+-.11328089187650139309272
+-4617316439035114.40320367843985107357898
+75864709277486862054521256
+10610005628108234.92015040406042336
+84007879267445533366251128067927.91168012197674537856
+56269158624557.1027018519702852
+.055305737239900889424090264801
+2906048299183.472237078104362540110129
+57879411419313585866282299201.3825582163029400
+54512860676747314187949.9414724679950990587298071
+37281153992026463004361915151761464058058.54968338992209002720
+108949072447731660
+63708478450213482928510139572007971.83536929222529239687
+0
+33137343861.8586
diff -urpN busybox-1.29.3/testsuite/dc_power.dc busybox-1.30.0/testsuite/dc_power.dc
--- busybox-1.29.3/testsuite/dc_power.dc	1970-01-01 01:00:00.000000000 +0100
+++ busybox-1.30.0/testsuite/dc_power.dc	2018-12-30 16:14:20.000000000 +0100
@@ -0,0 +1,45 @@
+20k
+0 0^pR
+0 1^pR
+0 1894^pR
+1 0^pR
+39746823 0^pR
+0.238672983047682 0^pR
+18394762374689237468.97354862973846 0^pR
+1 1^pR
+2 1^pR
+18927361346 1^pR
+0.23523785962738592635777 1^pR
+328956734869213746.89782398457234 1^pR
+8937 98^pR
+0.124876812394 2396^pR
+93762.2836 13^pR
+1 _1^pR
+2 _1^pR
+10 _1^pR
+683734768 _1^pR
+38579623756.897937568235 _1^pR
+1 _32467^pR
+2 _53^pR
+23897 _213^pR
+_1 1^pR
+_1 2^pR
+_2 1^pR
+_2 2^pR
+_237 294^pR
+_3746 28^pR
+_0.3548 35^pR
+_4267.234 37^pR
+_326.3246 78^pR
+_1 _1^pR
+_1 _2^pR
+_2 _1^pR
+_2 _2^pR
+_237 _293^pR
+_784 _23^pR
+_86 _7^pR
+_0.23424398 _781^pR
+_178.234786 _879^pR
+_1274.346 _768^pR
+0 _251^pR
+_0.2959371298 227^pR
diff -urpN busybox-1.29.3/testsuite/dc_power_results.txt busybox-1.30.0/testsuite/dc_power_results.txt
--- busybox-1.29.3/testsuite/dc_power_results.txt	1970-01-01 01:00:00.000000000 +0100
+++ busybox-1.30.0/testsuite/dc_power_results.txt	2018-12-30 16:14:20.000000000 +0100
@@ -0,0 +1,73 @@
+1
+0
+0
+1
+1
+1
+1
+1
+2
+18927361346
+.23523785962738592635777
+328956734869213746.89782398457234
+16473742664221279051571200630760751138799221376964991600670000200609\
+08006052596520320731708604393844468006290371918262741885989163144389\
+39367835091560809036359941703341471396407660150658436796925310445979\
+21333166245765946557344383284626113908419359990042883048537750217279\
+17481980123593363177308481941550382845381799410533956718500484099889\
+610805653325917409549921909941664118421333562129
+0
+43287877285033571298394739716218787350087163435619825150259705419.98\
+016445740928054425
+1.00000000000000000000
+.50000000000000000000
+.10000000000000000000
+.00000000146255543348
+.00000000002592041867
+1.00000000000000000000
+.00000000000000011102
+0
+-1
+1
+-2
+4
+14997322375665265051328725757939209353051902095893907150382724666290\
+49749481660976421019742616298227588464420182758442163654172400528243\
+00885441207762486233574213374503090372518590691583139696652847404883\
+08573912261119588874308960204159666762789603037188471170006223907416\
+60492840269152716750700089148882139254399347568222390231015487895905\
+73727080561379177721440905866857248917982113340543176658480139248897\
+54802503253413282808814063861470711399810899724515727713334909764746\
+27910290211411231279325882505708287941671508154740003122373284699097\
+78346501539634198926772266511968381368929692275950529960923432771985\
+12597189390708050983487158873301681237787429436264801751664042999180\
+3448659818912436089
+11478830555358864333472551120140548480416206583184496764727387456058\
+792742209537931243951391229607936
+-.00000000000000017759
+-2067373624686414405470850679965010694114490999957199847684803894306\
+56243666149296582304582679590231948238805965642713928910384741502707\
+.23224479257866798694
+11606078892843496082360561256965139908586179418605021706789617179085\
+85768049299693425729565480314913006780973928345684673490252494674985\
+0186164225375953066263609289359900615361965737717208159874390.293769\
+70206344604971
+-1.00000000000000000000
+1.00000000000000000000
+-.50000000000000000000
+.25000000000000000000
+0
+0
+-.00000000000002874159
+-1945134149489344891879057554905782841936258356736314337975569799825\
+94091939572752348215929683891336730843553721422164737465108229034947\
+87333189564755763444242676978610321731298729194092653999616928308494\
+26419468484566422775668903315088810746121307679948574976162519479931\
+18935243698160094347216562490000767121041786977792546155155934655909\
+14123833869470494708767968978717730012864171105540029928688274136791\
+98175053824022144065005509214813689232148489884560100200475909009813\
+340098100705258138.98542904577525702068
+0
+0
+0
+0
diff -urpN busybox-1.29.3/testsuite/dc_sqrt.dc busybox-1.30.0/testsuite/dc_sqrt.dc
--- busybox-1.29.3/testsuite/dc_sqrt.dc	1970-01-01 01:00:00.000000000 +0100
+++ busybox-1.30.0/testsuite/dc_sqrt.dc	2018-12-30 16:14:20.000000000 +0100
@@ -0,0 +1,14 @@
+20k
+0vpR
+2vpR
+4vpR
+9vpR
+16vpR
+25vpR
+121vpR
+48765vpR
+9287356207356vpR
+0.189274385967238956872354vpR
+12389467137496823.134567829387456283946vpR
+.0000000000000000000000000000123vpR
+1vpR
diff -urpN busybox-1.29.3/testsuite/dc_sqrt_results.txt busybox-1.30.0/testsuite/dc_sqrt_results.txt
--- busybox-1.29.3/testsuite/dc_sqrt_results.txt	1970-01-01 01:00:00.000000000 +0100
+++ busybox-1.30.0/testsuite/dc_sqrt_results.txt	2018-12-30 16:14:20.000000000 +0100
@@ -0,0 +1,13 @@
+0
+1.41421356237309504880
+2.00000000000000000000
+3.00000000000000000000
+4.00000000000000000000
+5.00000000000000000000
+11.00000000000000000000
+220.82798735667542192643
+3047516.39985021245496456781
+.435056761776252544285578
+111307983.260397019622398608908
+.0000000000000035071355833500363
+1.00000000000000000000
diff -urpN busybox-1.29.3/testsuite/dc_strings.dc busybox-1.30.0/testsuite/dc_strings.dc
--- busybox-1.29.3/testsuite/dc_strings.dc	1970-01-01 01:00:00.000000000 +0100
+++ busybox-1.30.0/testsuite/dc_strings.dc	2018-12-30 16:14:20.000000000 +0100
@@ -0,0 +1,37 @@
+[Hello, World!]ZpR
+[Hello, World!]pR
+[Hello, \[ World!]ZpR
+[Hello, \[ World!]pR
+[Hello, \] World!]ZpR
+[Hello, \] World!]pR
+[30pR]
+[29pR]
+[28pR]
+[27pR]
+[26pR]
+[25pR]
+[24pR]
+[23pR]
+[22pR]
+[21pR]
+[20pR]
+[19pR]
+[18pR]
+[17pR]
+[16pR]
+[15pR]
+[14pR]
+[13pR]
+[12pR]
+[11pR]
+[10pR]
+[9pR]
+[8pR]
+[7pR]
+[6pR]
+[5pR]
+[4pR]
+[3pR]
+[2pR]
+[1pR]
+[xz0<x]dsxx
diff -urpN busybox-1.29.3/testsuite/dc_strings_results.txt busybox-1.30.0/testsuite/dc_strings_results.txt
--- busybox-1.29.3/testsuite/dc_strings_results.txt	1970-01-01 01:00:00.000000000 +0100
+++ busybox-1.30.0/testsuite/dc_strings_results.txt	2018-12-30 16:14:20.000000000 +0100
@@ -0,0 +1,36 @@
+13
+Hello, World!
+Hello, \[ World!]ZpR
+[Hello, \[ World!]pR
+[Hello, \] World!]ZpR
+[Hello, \] World!
+1
+2
+3
+4
+5
+6
+7
+8
+9
+10
+11
+12
+13
+14
+15
+16
+17
+18
+19
+20
+21
+22
+23
+24
+25
+26
+27
+28
+29
+30
diff -urpN busybox-1.29.3/testsuite/dc_subtract.dc busybox-1.30.0/testsuite/dc_subtract.dc
--- busybox-1.29.3/testsuite/dc_subtract.dc	1970-01-01 01:00:00.000000000 +0100
+++ busybox-1.30.0/testsuite/dc_subtract.dc	2018-12-30 16:14:20.000000000 +0100
@@ -0,0 +1,33 @@
+0 0-pR
+0 1-pR
+1 0-pR
+1 1-pR
+5 2-pR
+2 9-pR
+321974 12845976238457-pR
+2874519803456710938465 384723854-pR
+10000000000000000000000000000000000000000 999999999999999999999999999999999999999-pR
+10000000000000000000000000000000000000000 9999999999999999999999999999999999999999-pR
+10000000000000000000000000000000000000000 999999999999999999999999999999999999999.99999999999999999999999999999999999-pR
+10000000000000000000000000000000000000000 9999999999999999999999999999999999999999.9999999999999999999999999999999999-pR
+10000000000000000000000000000000000000000 0.00000000000000000000000000000000000000000000000000000000000000000000000000000000000001-pR
+10000000000000000000000000000000000000001 0.00000000000000000000000000000000000000000000000000000000000000000000000000000000000001-pR
+10000000000000000000000000000000000000000.0000000001 0.0000000000000000000000000000000000000000000000000000000000000000000000000001-pR
+_2 6-pR
+_23784692345 182934721309467230894628735496027345-pR
+_224352354962873059862 _1245723576829456278354960278345-pR
+_3468273598 _12354243-pR
+_0.92345768293 _2354768923-pR
+_712384634.123476823 _24768293376-pR
+_1879234638 _0.917234869234-pR
+_0.9172438692134 _0.971284967124-pR
+_0.1283475123465 _0.937462346-pR
+_124765829346.2837468293562 _0.923467829346-pR
+_12476829385769 _1928476259034.8378629356-pR
+_0.38476284395876345 _94875394587623.2357869324857-pR
+_4674596708467.34754789403674343567 _48672394852354698.237548629345-pR
+979519669 3018100865-pR
+929002449 3280677283-pR
+0 _525898-pR
+3 _3-pR
+2 _1 2893714 _2189367411289 _.8921374 3.9201384----pR
diff -urpN busybox-1.29.3/testsuite/dc_subtract_results.txt busybox-1.30.0/testsuite/dc_subtract_results.txt
--- busybox-1.29.3/testsuite/dc_subtract_results.txt	1970-01-01 01:00:00.000000000 +0100
+++ busybox-1.30.0/testsuite/dc_subtract_results.txt	2018-12-30 16:14:20.000000000 +0100
@@ -0,0 +1,37 @@
+0
+-1
+1
+0
+3
+-7
+-12845975916483
+2874519803456326214611
+9000000000000000000000000000000000000001
+1
+9000000000000000000000000000000000000000.000000000000000000000000000\
+00000001
+.0000000000000000000000000000000001
+9999999999999999999999999999999999999999.999999999999999999999999999\
+99999999999999999999999999999999999999999999999999999999999
+10000000000000000000000000000000000000000.99999999999999999999999999\
+999999999999999999999999999999999999999999999999999999999999
+10000000000000000000000000000000000000000.00000000009999999999999999\
+99999999999999999999999999999999999999999999999999
+-8
+-182934721309467230894628759280719690
+1245723576605103923392087218483
+-3455919355
+2354768922.07654231707
+24055908741.876523177
+-1879234637.082765130766
+.0540410979106
+.8091148336535
+-124765829345.3602790000102
+-10548353126734.1621370644
+94875394587622.85102408852693655
+48667720255646230.89000073530825656433
+-2038581196
+-2351674834
+525898
+6
+-2189370304999.1877242
diff -urpN busybox-1.29.3/testsuite/dcx_vars.dc busybox-1.30.0/testsuite/dcx_vars.dc
--- busybox-1.29.3/testsuite/dcx_vars.dc	1970-01-01 01:00:00.000000000 +0100
+++ busybox-1.30.0/testsuite/dcx_vars.dc	2018-12-30 16:14:20.000000000 +0100
@@ -0,0 +1,2 @@
+298734.8921702348sx_928374892.28937syzpRlxly+pR
+298734.8921702348S xotj _928374892.28937S yotp zpRl xotj l yotp-pRzpR L xotj L yotp-pR
diff -urpN busybox-1.29.3/testsuite/dcx_vars_results.txt busybox-1.30.0/testsuite/dcx_vars_results.txt
--- busybox-1.29.3/testsuite/dcx_vars_results.txt	1970-01-01 01:00:00.000000000 +0100
+++ busybox-1.30.0/testsuite/dcx_vars_results.txt	2018-12-30 16:14:20.000000000 +0100
@@ -0,0 +1,6 @@
+0
+-928076157.3971997652
+0
+928673627.1815402348
+0
+928673627.1815402348
diff -urpN busybox-1.29.3/testsuite/echo/echo-prints-dash busybox-1.30.0/testsuite/echo/echo-prints-dash
--- busybox-1.29.3/testsuite/echo/echo-prints-dash	2018-07-02 13:23:06.000000000 +0200
+++ busybox-1.30.0/testsuite/echo/echo-prints-dash	2018-12-05 15:44:34.000000000 +0100
@@ -1 +1,2 @@
+# FEATURE: CONFIG_DESKTOP
 test "`busybox echo - | od -t x1 | head -n 1`" = "0000000 2d 0a"
diff -urpN busybox-1.29.3/testsuite/echo/echo-prints-non-opts busybox-1.30.0/testsuite/echo/echo-prints-non-opts
--- busybox-1.29.3/testsuite/echo/echo-prints-non-opts	2018-07-02 13:23:06.000000000 +0200
+++ busybox-1.30.0/testsuite/echo/echo-prints-non-opts	2018-12-05 15:44:34.000000000 +0100
@@ -1 +1,2 @@
+# FEATURE: CONFIG_DESKTOP
 test "`busybox echo -neEZ | od -t x1 | head -n 1`" = "0000000 2d 6e 65 45 5a 0a"
diff -urpN busybox-1.29.3/testsuite/echo/echo-prints-slash-zero busybox-1.30.0/testsuite/echo/echo-prints-slash-zero
--- busybox-1.29.3/testsuite/echo/echo-prints-slash-zero	2018-07-02 13:23:06.000000000 +0200
+++ busybox-1.30.0/testsuite/echo/echo-prints-slash-zero	2018-12-05 15:44:34.000000000 +0100
@@ -1,3 +1,3 @@
-# FEATURE: CONFIG_FEATURE_FANCY_ECHO
+# FEATURE: CONFIG_FEATURE_FANCY_ECHO CONFIG_DESKTOP
 
 test "`busybox echo -e -n 'msg\n\0' | od -t x1 | head -n 1`" = "0000000 6d 73 67 0a 00"
diff -urpN busybox-1.29.3/testsuite/echo/echo-prints-slash_00041 busybox-1.30.0/testsuite/echo/echo-prints-slash_00041
--- busybox-1.29.3/testsuite/echo/echo-prints-slash_00041	2018-07-02 13:23:06.000000000 +0200
+++ busybox-1.30.0/testsuite/echo/echo-prints-slash_00041	2018-12-05 15:44:34.000000000 +0100
@@ -1,3 +1,3 @@
-# FEATURE: CONFIG_FEATURE_FANCY_ECHO
+# FEATURE: CONFIG_FEATURE_FANCY_ECHO CONFIG_DESKTOP
 
 test "`busybox echo -ne '\00041z' | od -t x1 | head -n 1`" = "0000000 04 31 7a"
diff -urpN busybox-1.29.3/testsuite/echo/echo-prints-slash_0041 busybox-1.30.0/testsuite/echo/echo-prints-slash_0041
--- busybox-1.29.3/testsuite/echo/echo-prints-slash_0041	2018-07-02 13:23:06.000000000 +0200
+++ busybox-1.30.0/testsuite/echo/echo-prints-slash_0041	2018-12-05 15:44:34.000000000 +0100
@@ -1,3 +1,3 @@
-# FEATURE: CONFIG_FEATURE_FANCY_ECHO
+# FEATURE: CONFIG_FEATURE_FANCY_ECHO CONFIG_DESKTOP
 
 test "`busybox echo -ne '\0041z' | od -t x1 | head -n 1`" = "0000000 21 7a"
diff -urpN busybox-1.29.3/testsuite/echo/echo-prints-slash_041 busybox-1.30.0/testsuite/echo/echo-prints-slash_041
--- busybox-1.29.3/testsuite/echo/echo-prints-slash_041	2018-07-02 13:23:06.000000000 +0200
+++ busybox-1.30.0/testsuite/echo/echo-prints-slash_041	2018-12-05 15:44:34.000000000 +0100
@@ -1,3 +1,3 @@
-# FEATURE: CONFIG_FEATURE_FANCY_ECHO
+# FEATURE: CONFIG_FEATURE_FANCY_ECHO CONFIG_DESKTOP
 
 test "`busybox echo -ne '\041z' | od -t x1 | head -n 1`" = "0000000 21 7a"
diff -urpN busybox-1.29.3/testsuite/echo/echo-prints-slash_41 busybox-1.30.0/testsuite/echo/echo-prints-slash_41
--- busybox-1.29.3/testsuite/echo/echo-prints-slash_41	2018-07-02 13:23:06.000000000 +0200
+++ busybox-1.30.0/testsuite/echo/echo-prints-slash_41	2018-12-05 15:44:34.000000000 +0100
@@ -1,3 +1,3 @@
-# FEATURE: CONFIG_FEATURE_FANCY_ECHO
+# FEATURE: CONFIG_FEATURE_FANCY_ECHO CONFIG_DESKTOP
 
 test "`busybox echo -ne '\41z' | od -t x1 | head -n 1`" = "0000000 21 7a"
diff -urpN busybox-1.29.3/testsuite/head/head-n-works busybox-1.30.0/testsuite/head/head-n-works
--- busybox-1.29.3/testsuite/head/head-n-works	2018-07-02 13:23:06.000000000 +0200
+++ busybox-1.30.0/testsuite/head/head-n-works	1970-01-01 01:00:00.000000000 +0100
@@ -1,4 +0,0 @@
-[ -n "$d" ] || d=..
-head -n 2 "$d/README" > logfile.gnu
-busybox head -n 2 "$d/README" > logfile.bb
-cmp logfile.gnu logfile.bb
diff -urpN busybox-1.29.3/testsuite/head/head-works busybox-1.30.0/testsuite/head/head-works
--- busybox-1.29.3/testsuite/head/head-works	2018-07-02 13:23:06.000000000 +0200
+++ busybox-1.30.0/testsuite/head/head-works	1970-01-01 01:00:00.000000000 +0100
@@ -1,4 +0,0 @@
-[ -n "$d" ] || d=..
-head "$d/README" > logfile.gnu
-busybox head "$d/README" > logfile.bb
-cmp logfile.gnu logfile.bb
diff -urpN busybox-1.29.3/testsuite/head.tests busybox-1.30.0/testsuite/head.tests
--- busybox-1.29.3/testsuite/head.tests	1970-01-01 01:00:00.000000000 +0100
+++ busybox-1.30.0/testsuite/head.tests	2018-12-30 16:14:20.000000000 +0100
@@ -0,0 +1,43 @@
+#!/bin/sh
+# Copyright 2018 Thomas De Schampheleire <thomas.de_schampheleire@nokia.com>
+# Licensed under GPLv2 or later, see file LICENSE in this source tree.
+
+. ./testing.sh
+
+# testing "test name" "command" "expected result" "file input" "stdin"
+
+cat <<EOF > head.input
+line 1
+line 2
+line 3
+line 4
+line 5
+line 6
+line 7
+line 8
+line 9
+line 10
+line 11
+line 12
+EOF
+
+testing "head (without args)" \
+	"head head.input" \
+	"line 1\nline 2\nline 3\nline 4\nline 5\nline 6\nline 7\nline 8\nline 9\nline 10\n" \
+	"" ""
+
+testing "head -n <positive number>" \
+	"head -n 2 head.input" \
+	"line 1\nline 2\n" \
+	"" ""
+
+optional FEATURE_FANCY_HEAD
+testing "head -n <negative number>" \
+	"head -n -9 head.input" \
+	"line 1\nline 2\nline 3\n" \
+	"" ""
+SKIP=
+
+rm head.input
+
+exit $FAILCOUNT
diff -urpN busybox-1.29.3/testsuite/hexdump.tests busybox-1.30.0/testsuite/hexdump.tests
--- busybox-1.29.3/testsuite/hexdump.tests	1970-01-01 01:00:00.000000000 +0100
+++ busybox-1.30.0/testsuite/hexdump.tests	2018-12-05 15:44:34.000000000 +0100
@@ -0,0 +1,18 @@
+#!/bin/sh
+
+# Copyright 2018 by Denys Vlasenko <vda.linux@googlemail.com>
+# Licensed under GPLv2, see file LICENSE in this source tree.
+
+. ./testing.sh
+
+# testing "description" "command" "result" "infile" "stdin"
+testing 'hexdump -C with four NULs' \
+	'hexdump -C' \
+	"\
+00000000  00 00 00 00                                       |....|
+00000004
+" \
+	'' \
+	'\0\0\0\0'
+
+exit $FAILCOUNT
diff -urpN busybox-1.29.3/testsuite/printf.tests busybox-1.30.0/testsuite/printf.tests
--- busybox-1.29.3/testsuite/printf.tests	2018-07-02 13:23:06.000000000 +0200
+++ busybox-1.30.0/testsuite/printf.tests	2018-12-05 15:44:34.000000000 +0100
@@ -79,6 +79,39 @@ testing "printf understands %Ld" \
 	"-5\n""0\n" \
 	"" ""
 
+testing "printf handles positive numbers for %d" \
+	"${bb}printf '%d\n' 3 +3 '   3' '   +3' 2>&1; echo \$?" \
+	"3\n"\
+"3\n"\
+"3\n"\
+"3\n""0\n" \
+	"" ""
+
+testing "printf handles positive numbers for %i" \
+	"${bb}printf '%i\n' 3 +3 '   3' '   +3' 2>&1; echo \$?" \
+	"3\n"\
+"3\n"\
+"3\n"\
+"3\n""0\n" \
+	"" ""
+
+testing "printf handles positive numbers for %x" \
+	"${bb}printf '%x\n' 42 +42 '   42' '   +42' 2>&1; echo \$?" \
+	"2a\n"\
+"2a\n"\
+"2a\n"\
+"2a\n""0\n" \
+	"" ""
+
+testing "printf handles positive numbers for %f" \
+	"${bb}printf '%0.3f\n' .42 +.42 '   .42' '   +.42' 2>&1; echo \$?" \
+	"0.420\n"\
+"0.420\n"\
+"0.420\n"\
+"0.420\n""0\n" \
+	"" ""
+
+
 # "FIXED" now to act compatibly
 ## We are "more correct" here than bash/coreutils: they happily print -2
 ## as if it is a huge unsigned number
diff -urpN busybox-1.29.3/testsuite/unzip.tests busybox-1.30.0/testsuite/unzip.tests
--- busybox-1.29.3/testsuite/unzip.tests	2018-07-02 13:23:06.000000000 +0200
+++ busybox-1.30.0/testsuite/unzip.tests	2018-12-30 16:14:20.000000000 +0100
@@ -31,10 +31,10 @@ rmdir foo
 rm foo.zip
 
 # File containing some damaged encrypted stream
-optional FEATURE_UNZIP_CDF
+optional FEATURE_UNZIP_CDF CONFIG_UNICODE_SUPPORT
 testing "unzip (bad archive)" "uudecode; unzip bad.zip 2>&1; echo \$?" \
 "Archive:  bad.zip
-  inflating: ]3jrIK-%Ix
+  inflating: ]3jrI??K-%Ix
 unzip: corrupted data
 unzip: inflate error
 1
diff -urpN busybox-1.29.3/util-linux/acpid.c busybox-1.30.0/util-linux/acpid.c
--- busybox-1.29.3/util-linux/acpid.c	2018-07-02 13:23:06.000000000 +0200
+++ busybox-1.30.0/util-linux/acpid.c	2018-12-30 16:14:20.000000000 +0100
@@ -7,7 +7,7 @@
  * Licensed under GPLv2, see file LICENSE in this source tree.
  */
 //config:config ACPID
-//config:	bool "acpid (8.7 kb)"
+//config:	bool "acpid (9 kb)"
 //config:	default y
 //config:	select PLATFORM_LINUX
 //config:	help
diff -urpN busybox-1.29.3/util-linux/blkdiscard.c busybox-1.30.0/util-linux/blkdiscard.c
--- busybox-1.29.3/util-linux/blkdiscard.c	2018-07-02 13:23:06.000000000 +0200
+++ busybox-1.30.0/util-linux/blkdiscard.c	2018-12-30 16:14:20.000000000 +0100
@@ -6,7 +6,7 @@
  * Licensed under GPLv2 or later, see file LICENSE in this source tree.
  */
 //config:config BLKDISCARD
-//config:	bool "blkdiscard (5.3 kb)"
+//config:	bool "blkdiscard (4.3 kb)"
 //config:	default y
 //config:	select PLATFORM_LINUX
 //config:	help
diff -urpN busybox-1.29.3/util-linux/blkid.c busybox-1.30.0/util-linux/blkid.c
--- busybox-1.29.3/util-linux/blkid.c	2018-07-02 13:23:06.000000000 +0200
+++ busybox-1.30.0/util-linux/blkid.c	2018-12-30 16:14:20.000000000 +0100
@@ -7,7 +7,7 @@
  * Licensed under GPLv2, see file LICENSE in this source tree.
  */
 //config:config BLKID
-//config:	bool "blkid (11 kb)"
+//config:	bool "blkid (12 kb)"
 //config:	default y
 //config:	select PLATFORM_LINUX
 //config:	select VOLUMEID
diff -urpN busybox-1.29.3/util-linux/blockdev.c busybox-1.30.0/util-linux/blockdev.c
--- busybox-1.29.3/util-linux/blockdev.c	2018-07-02 13:23:06.000000000 +0200
+++ busybox-1.30.0/util-linux/blockdev.c	2018-12-30 16:14:20.000000000 +0100
@@ -6,7 +6,7 @@
  * Licensed under GPLv2, see file LICENSE in this source tree.
  */
 //config:config BLOCKDEV
-//config:	bool "blockdev (2.4 kb)"
+//config:	bool "blockdev (2.3 kb)"
 //config:	default y
 //config:	help
 //config:	Performs some ioctls with block devices.
diff -urpN busybox-1.29.3/util-linux/cal.c busybox-1.30.0/util-linux/cal.c
--- busybox-1.29.3/util-linux/cal.c	2018-07-02 13:23:06.000000000 +0200
+++ busybox-1.30.0/util-linux/cal.c	2018-12-30 16:14:20.000000000 +0100
@@ -11,7 +11,7 @@
  * Major size reduction... over 50% (>1.5k) on i386.
  */
 //config:config CAL
-//config:	bool "cal (6.5 kb)"
+//config:	bool "cal (5.8 kb)"
 //config:	default y
 //config:	help
 //config:	cal is used to display a monthly calendar.
diff -urpN busybox-1.29.3/util-linux/chrt.c busybox-1.30.0/util-linux/chrt.c
--- busybox-1.29.3/util-linux/chrt.c	2018-07-02 13:23:06.000000000 +0200
+++ busybox-1.30.0/util-linux/chrt.c	2018-12-30 16:14:20.000000000 +0100
@@ -6,7 +6,7 @@
  * Licensed under GPLv2 or later, see file LICENSE in this source tree.
  */
 //config:config CHRT
-//config:	bool "chrt (4.4 kb)"
+//config:	bool "chrt (4.7 kb)"
 //config:	default y
 //config:	help
 //config:	Manipulate real-time attributes of a process.
diff -urpN busybox-1.29.3/util-linux/dmesg.c busybox-1.30.0/util-linux/dmesg.c
--- busybox-1.29.3/util-linux/dmesg.c	2018-07-02 13:23:06.000000000 +0200
+++ busybox-1.30.0/util-linux/dmesg.c	2018-12-30 16:14:20.000000000 +0100
@@ -9,7 +9,7 @@
  * Licensed under GPLv2, see file LICENSE in this source tree.
  */
 //config:config DMESG
-//config:	bool "dmesg (3.5 kb)"
+//config:	bool "dmesg (3.7 kb)"
 //config:	default y
 //config:	select PLATFORM_LINUX
 //config:	help
diff -urpN busybox-1.29.3/util-linux/eject.c busybox-1.30.0/util-linux/eject.c
--- busybox-1.29.3/util-linux/eject.c	2018-07-02 13:23:06.000000000 +0200
+++ busybox-1.30.0/util-linux/eject.c	2018-12-30 16:14:20.000000000 +0100
@@ -13,7 +13,7 @@
  * Most of the dirty work blatantly ripped off from cat.c =)
  */
 //config:config EJECT
-//config:	bool "eject (4.1 kb)"
+//config:	bool "eject (4 kb)"
 //config:	default y
 //config:	select PLATFORM_LINUX
 //config:	help
diff -urpN busybox-1.29.3/util-linux/fallocate.c busybox-1.30.0/util-linux/fallocate.c
--- busybox-1.29.3/util-linux/fallocate.c	2018-07-02 13:23:06.000000000 +0200
+++ busybox-1.30.0/util-linux/fallocate.c	2018-12-30 16:14:20.000000000 +0100
@@ -5,7 +5,7 @@
  * Licensed under GPLv2, see file LICENSE in this source tree.
  */
 //config:config FALLOCATE
-//config:	bool "fallocate (5 kb)"
+//config:	bool "fallocate (4.1 kb)"
 //config:	default y
 //config:	help
 //config:	Preallocate space for files.
diff -urpN busybox-1.29.3/util-linux/fbset.c busybox-1.30.0/util-linux/fbset.c
--- busybox-1.29.3/util-linux/fbset.c	2018-07-02 13:23:06.000000000 +0200
+++ busybox-1.30.0/util-linux/fbset.c	2018-12-30 16:14:20.000000000 +0100
@@ -12,7 +12,7 @@
  *     Geert Uytterhoeven (Geert.Uytterhoeven@cs.kuleuven.ac.be)
  */
 //config:config FBSET
-//config:	bool "fbset (5.8 kb)"
+//config:	bool "fbset (5.9 kb)"
 //config:	default y
 //config:	select PLATFORM_LINUX
 //config:	help
diff -urpN busybox-1.29.3/util-linux/fdformat.c busybox-1.30.0/util-linux/fdformat.c
--- busybox-1.29.3/util-linux/fdformat.c	2018-07-02 13:23:06.000000000 +0200
+++ busybox-1.30.0/util-linux/fdformat.c	2018-12-30 16:14:20.000000000 +0100
@@ -6,7 +6,7 @@
  * Licensed under GPLv2, see file LICENSE in this source tree.
  */
 //config:config FDFORMAT
-//config:	bool "fdformat (4.5 kb)"
+//config:	bool "fdformat (4.4 kb)"
 //config:	default y
 //config:	select PLATFORM_LINUX
 //config:	help
diff -urpN busybox-1.29.3/util-linux/fdisk.c busybox-1.30.0/util-linux/fdisk.c
--- busybox-1.29.3/util-linux/fdisk.c	2018-07-30 18:02:27.000000000 +0200
+++ busybox-1.30.0/util-linux/fdisk.c	2018-12-30 16:14:20.000000000 +0100
@@ -8,7 +8,7 @@
  * Licensed under GPLv2 or later, see file LICENSE in this source tree.
  */
 //config:config FDISK
-//config:	bool "fdisk (41 kb)"
+//config:	bool "fdisk (37 kb)"
 //config:	default y
 //config:	select PLATFORM_LINUX
 //config:	help
@@ -1631,6 +1631,26 @@ read_int(sector_t low, sector_t dflt, se
 			case 'k':
 				scale_shift = 10; /* 1024 */
 				break;
+/*
+ * fdisk from util-linux 2.31 seems to round '+NNNk' and '+NNNK' to megabytes,
+ * (512-byte) sector count of the partition does not equal NNN*2:
+ *
+ * Last sector, +sectors or +size{K,M,G,T,P} (1953792-1000215215, default 1000215215): +9727k
+ *   Device     Boot   Start     End Sectors  Size Id Type
+ *   /dev/sdaN       1953792 1972223   18432    9M 83 Linux   <-- size exactly 9*1024*1024 bytes
+ *
+ * Last sector, +sectors or +size{K,M,G,T,P} (1953792-1000215215, default 1000215215): +9728k
+ *   /dev/sdaN       1953792 1974271   20480   10M 83 Linux   <-- size exactly 10*1024*1024 bytes
+ *
+ * If 'k' means 1000 bytes (not 1024), then 9728k = 9728*1000 = 9500*1024,
+ * exactly halfway from 9000 to 10000, which explains why it jumps to next mbyte
+ * at this value.
+ *
+ * 'm' does not seem to behave this way: it means 1024*1024 bytes.
+ *
+ * Not sure we want to copy this. If user says he wants 1234kbyte partition,
+ * we do _exactly that_: 1234kbytes = 2468 sectors.
+ */
 			case 'm':
 				scale_shift = 20; /* 1024*1024 */
 				break;
@@ -1725,8 +1745,9 @@ get_existing_partition(int warn, unsigne
 }
 
 static int
-get_nonexisting_partition(int warn, unsigned max)
+get_nonexisting_partition(void)
 {
+	const int max = 4;
 	int pno = -1;
 	unsigned i;
 
@@ -1748,7 +1769,7 @@ get_nonexisting_partition(int warn, unsi
 	return -1;
 
  not_unique:
-	return get_partition(warn, max);
+	return get_partition(/*warn*/ 0, max);
 }
 
 
@@ -2619,8 +2640,9 @@ new_partition(void)
 			"l   logical (5 or over)" : "e   extended"));
 		while (1) {
 			c = read_nonempty(line);
-			if ((c | 0x20) == 'p') {
-				i = get_nonexisting_partition(0, 4);
+			c |= 0x20; /* lowercase */
+			if (c == 'p') {
+				i = get_nonexisting_partition();
 				if (i >= 0)
 					add_partition(i, LINUX_NATIVE);
 				return;
@@ -2630,7 +2652,7 @@ new_partition(void)
 				return;
 			}
 			if (c == 'e' && !extended_offset) {
-				i = get_nonexisting_partition(0, 4);
+				i = get_nonexisting_partition();
 				if (i >= 0)
 					add_partition(i, EXTENDED);
 				return;
diff -urpN busybox-1.29.3/util-linux/fdisk_gpt.c busybox-1.30.0/util-linux/fdisk_gpt.c
--- busybox-1.29.3/util-linux/fdisk_gpt.c	2018-07-02 13:23:06.000000000 +0200
+++ busybox-1.30.0/util-linux/fdisk_gpt.c	2018-12-05 15:44:34.000000000 +0100
@@ -87,7 +87,7 @@ gpt_print_wide36(uint16_t *s)
 	}
 	wc[i] = 0;
 	if (wcstombs(buf, wc, sizeof(buf)) <= sizeof(buf)-1)
-		fputs(printable_string(NULL, buf), stdout);
+		fputs(printable_string(buf), stdout);
 #else
 	char buf[37];
 	int i = 0;
diff -urpN busybox-1.29.3/util-linux/findfs.c busybox-1.30.0/util-linux/findfs.c
--- busybox-1.29.3/util-linux/findfs.c	2018-07-02 13:23:06.000000000 +0200
+++ busybox-1.30.0/util-linux/findfs.c	2018-12-30 16:14:20.000000000 +0100
@@ -8,7 +8,7 @@
  * Licensed under GPLv2 or later, see file LICENSE in this source tree.
  */
 //config:config FINDFS
-//config:	bool "findfs (11 kb)"
+//config:	bool "findfs (12 kb)"
 //config:	default y
 //config:	select PLATFORM_LINUX
 //config:	select VOLUMEID
diff -urpN busybox-1.29.3/util-linux/flock.c busybox-1.30.0/util-linux/flock.c
--- busybox-1.29.3/util-linux/flock.c	2018-07-02 13:23:06.000000000 +0200
+++ busybox-1.30.0/util-linux/flock.c	2018-12-30 16:14:20.000000000 +0100
@@ -4,7 +4,7 @@
  * This is free software, licensed under the GNU General Public License v2.
  */
 //config:config FLOCK
-//config:	bool "flock (6.1 kb)"
+//config:	bool "flock (6.3 kb)"
 //config:	default y
 //config:	help
 //config:	Manage locks from shell scripts
diff -urpN busybox-1.29.3/util-linux/freeramdisk.c busybox-1.30.0/util-linux/freeramdisk.c
--- busybox-1.29.3/util-linux/freeramdisk.c	2018-07-02 13:23:06.000000000 +0200
+++ busybox-1.30.0/util-linux/freeramdisk.c	2018-12-30 16:14:20.000000000 +0100
@@ -9,7 +9,7 @@
  * Licensed under GPLv2, see file LICENSE in this source tree.
  */
 //config:config FDFLUSH
-//config:	bool "fdflush (1.4 kb)"
+//config:	bool "fdflush (1.3 kb)"
 //config:	default y
 //config:	select PLATFORM_LINUX
 //config:	help
@@ -22,7 +22,7 @@
 //config:	leave this disabled.
 //config:
 //config:config FREERAMDISK
-//config:	bool "freeramdisk (1.4 kb)"
+//config:	bool "freeramdisk (1.3 kb)"
 //config:	default y
 //config:	select PLATFORM_LINUX
 //config:	help
diff -urpN busybox-1.29.3/util-linux/fsck_minix.c busybox-1.30.0/util-linux/fsck_minix.c
--- busybox-1.29.3/util-linux/fsck_minix.c	2018-07-02 13:23:06.000000000 +0200
+++ busybox-1.30.0/util-linux/fsck_minix.c	2018-12-30 16:14:20.000000000 +0100
@@ -86,7 +86,7 @@
  * enforced (but it's not much fun on a character device :-).
  */
 //config:config FSCK_MINIX
-//config:	bool "fsck_minix"
+//config:	bool "fsck.minix (13 kb)"
 //config:	default y
 //config:	help
 //config:	The minix filesystem is a nice, small, compact, read-write filesystem
diff -urpN busybox-1.29.3/util-linux/fsfreeze.c busybox-1.30.0/util-linux/fsfreeze.c
--- busybox-1.29.3/util-linux/fsfreeze.c	2018-07-02 13:23:06.000000000 +0200
+++ busybox-1.30.0/util-linux/fsfreeze.c	2018-12-30 16:14:20.000000000 +0100
@@ -5,7 +5,7 @@
  * Licensed under GPLv2, see file LICENSE in this source tree.
  */
 //config:config FSFREEZE
-//config:	bool "fsfreeze (3.6 kb)"
+//config:	bool "fsfreeze (3.5 kb)"
 //config:	default y
 //config:	select PLATFORM_LINUX
 //config:	select LONG_OPTS
diff -urpN busybox-1.29.3/util-linux/fstrim.c busybox-1.30.0/util-linux/fstrim.c
--- busybox-1.29.3/util-linux/fstrim.c	2018-07-02 13:23:06.000000000 +0200
+++ busybox-1.30.0/util-linux/fstrim.c	2018-12-30 16:14:20.000000000 +0100
@@ -8,7 +8,7 @@
  * Licensed under GPLv2 or later, see file LICENSE in this source tree.
  */
 //config:config FSTRIM
-//config:	bool "fstrim (5.5 kb)"
+//config:	bool "fstrim (4.4 kb)"
 //config:	default y
 //config:	select PLATFORM_LINUX
 //config:	help
diff -urpN busybox-1.29.3/util-linux/getopt.c busybox-1.30.0/util-linux/getopt.c
--- busybox-1.29.3/util-linux/getopt.c	2018-07-02 13:23:06.000000000 +0200
+++ busybox-1.30.0/util-linux/getopt.c	2018-12-30 16:14:20.000000000 +0100
@@ -29,7 +29,7 @@
  *  Replaced our_malloc with xmalloc and our_realloc with xrealloc
  */
 //config:config GETOPT
-//config:	bool "getopt (5.6 kb)"
+//config:	bool "getopt (5.8 kb)"
 //config:	default y
 //config:	help
 //config:	The getopt utility is used to break up (parse) options in command
diff -urpN busybox-1.29.3/util-linux/hexdump.c busybox-1.30.0/util-linux/hexdump.c
--- busybox-1.29.3/util-linux/hexdump.c	2018-07-02 13:23:06.000000000 +0200
+++ busybox-1.30.0/util-linux/hexdump.c	2018-12-30 16:14:20.000000000 +0100
@@ -9,7 +9,7 @@
  * Licensed under GPLv2 or later, see file LICENSE in this source tree.
  */
 //config:config HEXDUMP
-//config:	bool "hexdump (8.8 kb)"
+//config:	bool "hexdump (8.6 kb)"
 //config:	default y
 //config:	help
 //config:	The hexdump utility is used to display binary data in a readable
@@ -26,7 +26,7 @@
 //config:	aimed to be portable.
 //config:
 //config:config HD
-//config:	bool "hd (8 kb)"
+//config:	bool "hd (7.8 kb)"
 //config:	default y
 //config:	help
 //config:	hd is an alias to hexdump -C.
diff -urpN busybox-1.29.3/util-linux/ionice.c busybox-1.30.0/util-linux/ionice.c
--- busybox-1.29.3/util-linux/ionice.c	2018-07-02 13:23:06.000000000 +0200
+++ busybox-1.30.0/util-linux/ionice.c	2018-12-30 16:14:20.000000000 +0100
@@ -7,7 +7,7 @@
  * Licensed under GPLv2 or later, see file LICENSE in this source tree.
  */
 //config:config IONICE
-//config:	bool "ionice (3.6 kb)"
+//config:	bool "ionice (3.8 kb)"
 //config:	default y
 //config:	select PLATFORM_LINUX
 //config:	help
diff -urpN busybox-1.29.3/util-linux/ipcrm.c busybox-1.30.0/util-linux/ipcrm.c
--- busybox-1.29.3/util-linux/ipcrm.c	2018-07-02 13:23:06.000000000 +0200
+++ busybox-1.30.0/util-linux/ipcrm.c	2018-12-30 16:14:20.000000000 +0100
@@ -8,7 +8,7 @@
  * Licensed under GPLv2 or later, see file LICENSE in this source tree.
  */
 //config:config IPCRM
-//config:	bool "ipcrm (2.9 kb)"
+//config:	bool "ipcrm (3.2 kb)"
 //config:	default y
 //config:	help
 //config:	The ipcrm utility allows the removal of System V interprocess
diff -urpN busybox-1.29.3/util-linux/last.c busybox-1.30.0/util-linux/last.c
--- busybox-1.29.3/util-linux/last.c	2018-07-02 13:23:06.000000000 +0200
+++ busybox-1.30.0/util-linux/last.c	2018-12-30 16:14:20.000000000 +0100
@@ -7,7 +7,7 @@
  * Licensed under GPLv2, see file LICENSE in this source tree.
  */
 //config:config LAST
-//config:	bool "last (6.2 kb)"
+//config:	bool "last (6.1 kb)"
 //config:	default y
 //config:	depends on FEATURE_WTMP
 //config:	help
diff -urpN busybox-1.29.3/util-linux/losetup.c busybox-1.30.0/util-linux/losetup.c
--- busybox-1.29.3/util-linux/losetup.c	2018-07-02 13:23:06.000000000 +0200
+++ busybox-1.30.0/util-linux/losetup.c	2018-12-30 16:14:20.000000000 +0100
@@ -7,7 +7,7 @@
  * Licensed under GPLv2 or later, see file LICENSE in this source tree.
  */
 //config:config LOSETUP
-//config:	bool "losetup (5.4 kb)"
+//config:	bool "losetup (5.5 kb)"
 //config:	default y
 //config:	select PLATFORM_LINUX
 //config:	help
diff -urpN busybox-1.29.3/util-linux/lspci.c busybox-1.30.0/util-linux/lspci.c
--- busybox-1.29.3/util-linux/lspci.c	2018-07-02 13:23:06.000000000 +0200
+++ busybox-1.30.0/util-linux/lspci.c	2018-12-30 16:14:20.000000000 +0100
@@ -7,7 +7,7 @@
  * Licensed under GPLv2 or later, see file LICENSE in this source tree.
  */
 //config:config LSPCI
-//config:	bool "lspci (5.7 kb)"
+//config:	bool "lspci (6.3 kb)"
 //config:	default y
 //config:	#select PLATFORM_LINUX
 //config:	help
diff -urpN busybox-1.29.3/util-linux/lsusb.c busybox-1.30.0/util-linux/lsusb.c
--- busybox-1.29.3/util-linux/lsusb.c	2018-07-02 13:23:06.000000000 +0200
+++ busybox-1.30.0/util-linux/lsusb.c	2018-12-30 16:14:20.000000000 +0100
@@ -7,7 +7,7 @@
  * Licensed under GPLv2 or later, see file LICENSE in this source tree.
  */
 //config:config LSUSB
-//config:	bool "lsusb (3.5 kb)"
+//config:	bool "lsusb (4.2 kb)"
 //config:	default y
 //config:	#select PLATFORM_LINUX
 //config:	help
diff -urpN busybox-1.29.3/util-linux/mdev.c busybox-1.30.0/util-linux/mdev.c
--- busybox-1.29.3/util-linux/mdev.c	2018-07-02 13:23:06.000000000 +0200
+++ busybox-1.30.0/util-linux/mdev.c	2018-12-30 16:14:20.000000000 +0100
@@ -8,7 +8,7 @@
  * Licensed under GPLv2, see file LICENSE in this source tree.
  */
 //config:config MDEV
-//config:	bool "mdev (16 kb)"
+//config:	bool "mdev (17 kb)"
 //config:	default y
 //config:	select PLATFORM_LINUX
 //config:	help
@@ -808,6 +808,16 @@ static void make_device(char *device_nam
 	} /* for (;;) */
 }
 
+static ssize_t readlink2(char *buf, size_t bufsize)
+{
+	// Grr... gcc 8.1.1:
+	// "passing argument 2 to restrict-qualified parameter aliases with argument 1"
+	// dance around that...
+	char *obuf FIX_ALIASING;
+	obuf = buf;
+	return readlink(buf, obuf, bufsize);
+}
+
 /* File callback for /sys/ traversal.
  * We act only on "/sys/.../dev" (pseudo)file
  */
@@ -831,7 +841,7 @@ static int FAST_FUNC fileAction(const ch
 	/* Read ".../subsystem" symlink in the same directory where ".../dev" is */
 	strcpy(subsys, path);
 	strcpy(subsys + len, "/subsystem");
-	res = readlink(subsys, subsys, sizeof(subsys)-1);
+	res = readlink2(subsys, sizeof(subsys)-1);
 	if (res > 0) {
 		subsys[res] = '\0';
 		free(G.subsystem);
diff -urpN busybox-1.29.3/util-linux/mesg.c busybox-1.30.0/util-linux/mesg.c
--- busybox-1.29.3/util-linux/mesg.c	2018-07-02 13:23:06.000000000 +0200
+++ busybox-1.30.0/util-linux/mesg.c	2018-12-30 16:14:20.000000000 +0100
@@ -7,7 +7,7 @@
  * Licensed under GPLv2 or later, see file LICENSE in this source tree.
  */
 //config:config MESG
-//config:	bool "mesg (1.2 kb)"
+//config:	bool "mesg (1.4 kb)"
 //config:	default y
 //config:	help
 //config:	Mesg controls access to your terminal by others. It is typically
diff -urpN busybox-1.29.3/util-linux/mkfs_ext2.c busybox-1.30.0/util-linux/mkfs_ext2.c
--- busybox-1.29.3/util-linux/mkfs_ext2.c	2018-07-02 13:23:06.000000000 +0200
+++ busybox-1.30.0/util-linux/mkfs_ext2.c	2018-12-30 16:14:20.000000000 +0100
@@ -8,14 +8,14 @@
  * Licensed under GPLv2, see file LICENSE in this source tree.
  */
 //config:config MKE2FS
-//config:	bool "mke2fs (9.7 kb)"
+//config:	bool "mke2fs (10 kb)"
 //config:	default y
 //config:	select PLATFORM_LINUX
 //config:	help
 //config:	Utility to create EXT2 filesystems.
 //config:
 //config:config MKFS_EXT2
-//config:	bool "mkfs.ext2 (9.8 kb)"
+//config:	bool "mkfs.ext2 (10 kb)"
 //config:	default y
 //config:	select PLATFORM_LINUX
 //config:	help
@@ -78,23 +78,6 @@
 #define EXT2_FLAGS_SIGNED_HASH   0x0001
 #define EXT2_FLAGS_UNSIGNED_HASH 0x0002
 
-// storage helpers
-char BUG_wrong_field_size(void);
-#define STORE_LE(field, value) \
-do { \
-	if (sizeof(field) == 4) \
-		field = SWAP_LE32((uint32_t)(value)); \
-	else if (sizeof(field) == 2) \
-		field = SWAP_LE16((uint16_t)(value)); \
-	else if (sizeof(field) == 1) \
-		field = (uint8_t)(value); \
-	else \
-		BUG_wrong_field_size(); \
-} while (0)
-
-#define FETCH_LE32(field) \
-	(sizeof(field) == 4 ? SWAP_LE32(field) : BUG_wrong_field_size())
-
 // All fields are little-endian
 struct ext2_dir {
 	uint32_t inode1;
diff -urpN busybox-1.29.3/util-linux/mkfs_minix.c busybox-1.30.0/util-linux/mkfs_minix.c
--- busybox-1.29.3/util-linux/mkfs_minix.c	2018-07-02 13:23:06.000000000 +0200
+++ busybox-1.30.0/util-linux/mkfs_minix.c	2018-12-30 16:14:20.000000000 +0100
@@ -63,7 +63,7 @@
  *	removed getopt based parser and added a hand rolled one.
  */
 //config:config MKFS_MINIX
-//config:	bool "mkfs_minix"
+//config:	bool "mkfs.minix (10 kb)"
 //config:	default y
 //config:	select PLATFORM_LINUX
 //config:	help
diff -urpN busybox-1.29.3/util-linux/mkfs_reiser.c busybox-1.30.0/util-linux/mkfs_reiser.c
--- busybox-1.29.3/util-linux/mkfs_reiser.c	2018-07-02 13:23:06.000000000 +0200
+++ busybox-1.30.0/util-linux/mkfs_reiser.c	2018-12-05 15:44:34.000000000 +0100
@@ -28,22 +28,6 @@
 #include "libbb.h"
 #include <linux/fs.h>
 
-char BUG_wrong_field_size(void);
-#define STORE_LE(field, value) \
-do { \
-	if (sizeof(field) == 4) \
-		field = SWAP_LE32(value); \
-	else if (sizeof(field) == 2) \
-		field = SWAP_LE16(value); \
-	else if (sizeof(field) == 1) \
-		field = (value); \
-	else \
-		BUG_wrong_field_size(); \
-} while (0)
-
-#define FETCH_LE32(field) \
-	(sizeof(field) == 4 ? SWAP_LE32(field) : BUG_wrong_field_size())
-
 struct journal_params {
 	uint32_t jp_journal_1st_block;      /* where does journal start from on its device */
 	uint32_t jp_journal_dev;            /* journal device st_rdev */
diff -urpN busybox-1.29.3/util-linux/mkfs_vfat.c busybox-1.30.0/util-linux/mkfs_vfat.c
--- busybox-1.29.3/util-linux/mkfs_vfat.c	2018-07-02 13:23:06.000000000 +0200
+++ busybox-1.30.0/util-linux/mkfs_vfat.c	2018-12-30 16:14:20.000000000 +0100
@@ -8,14 +8,14 @@
  * Licensed under GPLv2, see file LICENSE in this source tree.
  */
 //config:config MKDOSFS
-//config:	bool "mkdosfs (6.8 kb)"
+//config:	bool "mkdosfs (7.2 kb)"
 //config:	default y
 //config:	select PLATFORM_LINUX
 //config:	help
 //config:	Utility to create FAT32 filesystems.
 //config:
 //config:config MKFS_VFAT
-//config:	bool "mkfs.vfat (6.8 kb)"
+//config:	bool "mkfs.vfat (7.2 kb)"
 //config:	default y
 //config:	select PLATFORM_LINUX
 //config:	help
@@ -206,19 +206,6 @@ static const char boot_code[] ALIGN1 =
 #define MARK_CLUSTER(cluster, value) \
 	((uint32_t *)fat)[cluster] = SWAP_LE32(value)
 
-void BUG_unsupported_field_size(void);
-#define STORE_LE(field, value) \
-do { \
-	if (sizeof(field) == 4) \
-		field = SWAP_LE32((uint32_t)(value)); \
-	else if (sizeof(field) == 2) \
-		field = SWAP_LE16((uint16_t)(value)); \
-	else if (sizeof(field) == 1) \
-		field = (uint8_t)(value); \
-	else \
-		BUG_unsupported_field_size(); \
-} while (0)
-
 /* compat:
  * mkdosfs 2.11 (12 Mar 2005)
  * Usage: mkdosfs [-A] [-c] [-C] [-v] [-I] [-l bad-block-file]
diff -urpN busybox-1.29.3/util-linux/mkswap.c busybox-1.30.0/util-linux/mkswap.c
--- busybox-1.29.3/util-linux/mkswap.c	2018-07-02 13:23:06.000000000 +0200
+++ busybox-1.30.0/util-linux/mkswap.c	2018-12-30 16:14:20.000000000 +0100
@@ -7,7 +7,7 @@
  * Licensed under GPLv2, see file LICENSE in this source tree.
  */
 //config:config MKSWAP
-//config:	bool "mkswap (5.8 kb)"
+//config:	bool "mkswap (6.3 kb)"
 //config:	default y
 //config:	help
 //config:	The mkswap utility is used to configure a file or disk partition as
diff -urpN busybox-1.29.3/util-linux/more.c busybox-1.30.0/util-linux/more.c
--- busybox-1.29.3/util-linux/more.c	2018-07-02 13:23:06.000000000 +0200
+++ busybox-1.30.0/util-linux/more.c	2018-12-30 16:14:20.000000000 +0100
@@ -14,7 +14,7 @@
  * Licensed under GPLv2 or later, see file LICENSE in this source tree.
  */
 //config:config MORE
-//config:	bool "more (6.7 kb)"
+//config:	bool "more (7 kb)"
 //config:	default y
 //config:	help
 //config:	more is a simple utility which allows you to read text one screen
diff -urpN busybox-1.29.3/util-linux/mount.c busybox-1.30.0/util-linux/mount.c
--- busybox-1.29.3/util-linux/mount.c	2018-07-02 13:23:06.000000000 +0200
+++ busybox-1.30.0/util-linux/mount.c	2018-12-30 16:14:20.000000000 +0100
@@ -18,7 +18,7 @@
 //
 
 //config:config MOUNT
-//config:	bool "mount (30 kb)"
+//config:	bool "mount (23 kb)"
 //config:	default y
 //config:	select PLATFORM_LINUX
 //config:	help
diff -urpN busybox-1.29.3/util-linux/mountpoint.c busybox-1.30.0/util-linux/mountpoint.c
--- busybox-1.29.3/util-linux/mountpoint.c	2018-07-02 13:23:06.000000000 +0200
+++ busybox-1.30.0/util-linux/mountpoint.c	2018-12-30 16:14:20.000000000 +0100
@@ -9,7 +9,7 @@
  * Based on sysvinit's mountpoint
  */
 //config:config MOUNTPOINT
-//config:	bool "mountpoint (4.5 kb)"
+//config:	bool "mountpoint (4.9 kb)"
 //config:	default y
 //config:	help
 //config:	mountpoint checks if the directory is a mountpoint.
diff -urpN busybox-1.29.3/util-linux/nologin.c busybox-1.30.0/util-linux/nologin.c
--- busybox-1.29.3/util-linux/nologin.c	1970-01-01 01:00:00.000000000 +0100
+++ busybox-1.30.0/util-linux/nologin.c	2018-12-05 15:44:34.000000000 +0100
@@ -0,0 +1,27 @@
+//config:config NOLOGIN
+//config:	bool "nologin"
+//config:	default y
+//config:	depends on FEATURE_SH_EMBEDDED_SCRIPTS
+//config:	help
+//config:	Politely refuse a login
+//config:
+//config:config NOLOGIN_DEPENDENCIES
+//config:	bool "Enable dependencies for nologin"
+//config:	default y
+//config:	depends on NOLOGIN
+//config:	select CAT
+//config:	select ECHO
+//config:	select SLEEP
+//config:	help
+//config:	nologin is implemented as a shell script. It requires the
+//config:	following in the runtime environment:
+//config:		cat echo sleep
+//config:	If you know these will be available externally you can
+//config:	disable this option.
+
+//applet:IF_NOLOGIN(APPLET_SCRIPTED(nologin, scripted, BB_DIR_USR_SBIN, BB_SUID_DROP, nologin))
+
+//usage:#define nologin_trivial_usage
+//usage:	""
+//usage:#define nologin_full_usage "\n\n"
+//usage:	"Politely refuse a login"
diff -urpN busybox-1.29.3/util-linux/nsenter.c busybox-1.30.0/util-linux/nsenter.c
--- busybox-1.29.3/util-linux/nsenter.c	2018-07-02 13:23:06.000000000 +0200
+++ busybox-1.30.0/util-linux/nsenter.c	2018-12-30 16:14:20.000000000 +0100
@@ -7,7 +7,7 @@
  * Licensed under GPLv2 or later, see file LICENSE in this source tree.
  */
 //config:config NSENTER
-//config:	bool "nsenter (8.6 kb)"
+//config:	bool "nsenter (6.5 kb)"
 //config:	default y
 //config:	select PLATFORM_LINUX
 //config:	help
diff -urpN busybox-1.29.3/util-linux/pivot_root.c busybox-1.30.0/util-linux/pivot_root.c
--- busybox-1.29.3/util-linux/pivot_root.c	2018-07-02 13:23:06.000000000 +0200
+++ busybox-1.30.0/util-linux/pivot_root.c	2018-12-30 16:14:20.000000000 +0100
@@ -9,7 +9,7 @@
  * Licensed under GPLv2, see file LICENSE in this source tree.
  */
 //config:config PIVOT_ROOT
-//config:	bool "pivot_root (898 bytes)"
+//config:	bool "pivot_root (1.1 kb)"
 //config:	default y
 //config:	select PLATFORM_LINUX
 //config:	help
diff -urpN busybox-1.29.3/util-linux/rdate.c busybox-1.30.0/util-linux/rdate.c
--- busybox-1.29.3/util-linux/rdate.c	2018-07-02 13:23:06.000000000 +0200
+++ busybox-1.30.0/util-linux/rdate.c	2018-12-30 16:14:20.000000000 +0100
@@ -8,7 +8,7 @@
  * Licensed under GPLv2 or later, see file LICENSE in this source tree.
  */
 //config:config RDATE
-//config:	bool "rdate (6 kb)"
+//config:	bool "rdate (5.6 kb)"
 //config:	default y
 //config:	help
 //config:	The rdate utility allows you to synchronize the date and time of your
diff -urpN busybox-1.29.3/util-linux/rdev.c busybox-1.30.0/util-linux/rdev.c
--- busybox-1.29.3/util-linux/rdev.c	2018-07-02 13:23:06.000000000 +0200
+++ busybox-1.30.0/util-linux/rdev.c	2018-12-30 16:14:20.000000000 +0100
@@ -8,7 +8,7 @@
  * Licensed under GPLv2, see file LICENSE in this source tree.
  */
 //config:config RDEV
-//config:	bool "rdev (1.4 kb)"
+//config:	bool "rdev (1.8 kb)"
 //config:	default y
 //config:	help
 //config:	Print the device node associated with the filesystem mounted at '/'.
diff -urpN busybox-1.29.3/util-linux/readprofile.c busybox-1.30.0/util-linux/readprofile.c
--- busybox-1.29.3/util-linux/readprofile.c	2018-07-02 13:23:06.000000000 +0200
+++ busybox-1.30.0/util-linux/readprofile.c	2018-12-30 16:14:20.000000000 +0100
@@ -32,7 +32,7 @@
  * Paul Mundt <lethal@linux-sh.org>.
  */
 //config:config READPROFILE
-//config:	bool "readprofile (7.2 kb)"
+//config:	bool "readprofile (7.1 kb)"
 //config:	default y
 //config:	#select PLATFORM_LINUX
 //config:	help
diff -urpN busybox-1.29.3/util-linux/renice.c busybox-1.30.0/util-linux/renice.c
--- busybox-1.29.3/util-linux/renice.c	2018-07-02 13:23:06.000000000 +0200
+++ busybox-1.30.0/util-linux/renice.c	2018-12-30 16:14:20.000000000 +0100
@@ -18,7 +18,7 @@
  *   following IDs (if any).  Multiple switches are allowed.
  */
 //config:config RENICE
-//config:	bool "renice (3.8 kb)"
+//config:	bool "renice (4.2 kb)"
 //config:	default y
 //config:	help
 //config:	Renice alters the scheduling priority of one or more running
diff -urpN busybox-1.29.3/util-linux/rev.c busybox-1.30.0/util-linux/rev.c
--- busybox-1.29.3/util-linux/rev.c	2018-07-02 13:23:06.000000000 +0200
+++ busybox-1.30.0/util-linux/rev.c	2018-12-30 16:14:20.000000000 +0100
@@ -6,7 +6,7 @@
  * Licensed under GPLv2, see file LICENSE in this source tree.
  */
 //config:config REV
-//config:	bool "rev (4.5 kb)"
+//config:	bool "rev (4.4 kb)"
 //config:	default y
 //config:	help
 //config:	Reverse lines of a file or files.
diff -urpN busybox-1.29.3/util-linux/rtcwake.c busybox-1.30.0/util-linux/rtcwake.c
--- busybox-1.29.3/util-linux/rtcwake.c	2018-07-02 13:23:06.000000000 +0200
+++ busybox-1.30.0/util-linux/rtcwake.c	2018-12-30 16:14:20.000000000 +0100
@@ -23,7 +23,7 @@
  * That flag should not be needed on systems with adjtime support.
  */
 //config:config RTCWAKE
-//config:	bool "rtcwake (6.4 kb)"
+//config:	bool "rtcwake (6.8 kb)"
 //config:	default y
 //config:	select PLATFORM_LINUX
 //config:	help
diff -urpN busybox-1.29.3/util-linux/script.c busybox-1.30.0/util-linux/script.c
--- busybox-1.29.3/util-linux/script.c	2018-07-02 13:23:06.000000000 +0200
+++ busybox-1.30.0/util-linux/script.c	2018-12-30 16:14:20.000000000 +0100
@@ -11,7 +11,7 @@
  * Licensed under GPLv2 or later, see file LICENSE in this source tree.
  */
 //config:config SCRIPT
-//config:	bool "script (8 kb)"
+//config:	bool "script (8.6 kb)"
 //config:	default y
 //config:	help
 //config:	The script makes typescript of terminal session.
diff -urpN busybox-1.29.3/util-linux/scriptreplay.c busybox-1.30.0/util-linux/scriptreplay.c
--- busybox-1.29.3/util-linux/scriptreplay.c	2018-07-02 13:23:06.000000000 +0200
+++ busybox-1.30.0/util-linux/scriptreplay.c	2018-12-30 16:14:20.000000000 +0100
@@ -7,7 +7,7 @@
  * Licensed under GPLv2 or later, see file LICENSE in this source tree.
  */
 //config:config SCRIPTREPLAY
-//config:	bool "scriptreplay (2.6 kb)"
+//config:	bool "scriptreplay (2.4 kb)"
 //config:	default y
 //config:	help
 //config:	This program replays a typescript, using timing information
diff -urpN busybox-1.29.3/util-linux/setarch.c busybox-1.30.0/util-linux/setarch.c
--- busybox-1.29.3/util-linux/setarch.c	2018-07-02 13:23:06.000000000 +0200
+++ busybox-1.30.0/util-linux/setarch.c	2018-12-30 16:14:20.000000000 +0100
@@ -7,7 +7,7 @@
  * Licensed under GPLv2 or later, see file LICENSE in this source tree.
  */
 //config:config SETARCH
-//config:	bool "setarch (3.4 kb)"
+//config:	bool "setarch (3.6 kb)"
 //config:	default y
 //config:	select PLATFORM_LINUX
 //config:	help
@@ -17,14 +17,14 @@
 //config:	(like amd64/x86, ppc64/ppc, sparc64/sparc, etc...).
 //config:
 //config:config LINUX32
-//config:	bool "linux32 (3.2 kb)"
+//config:	bool "linux32 (3.3 kb)"
 //config:	default y
 //config:	select PLATFORM_LINUX
 //config:	help
 //config:	Alias to "setarch linux32".
 //config:
 //config:config LINUX64
-//config:	bool "linux64 (3.2 kb)"
+//config:	bool "linux64 (3.3 kb)"
 //config:	default y
 //config:	select PLATFORM_LINUX
 //config:	help
diff -urpN busybox-1.29.3/util-linux/setpriv.c busybox-1.30.0/util-linux/setpriv.c
--- busybox-1.29.3/util-linux/setpriv.c	2018-07-02 13:23:06.000000000 +0200
+++ busybox-1.30.0/util-linux/setpriv.c	2018-12-30 16:14:20.000000000 +0100
@@ -7,7 +7,7 @@
  * Licensed under GPLv2 or later, see file LICENSE in this source tree.
  */
 //config:config SETPRIV
-//config:	bool "setpriv (3.4 kb)"
+//config:	bool "setpriv (6.6 kb)"
 //config:	default y
 //config:	select PLATFORM_LINUX
 //config:	select LONG_OPTS
diff -urpN busybox-1.29.3/util-linux/setsid.c busybox-1.30.0/util-linux/setsid.c
--- busybox-1.29.3/util-linux/setsid.c	2018-07-02 13:23:06.000000000 +0200
+++ busybox-1.30.0/util-linux/setsid.c	2018-12-30 16:14:20.000000000 +0100
@@ -14,7 +14,7 @@
  * - busyboxed
  */
 //config:config SETSID
-//config:	bool "setsid (3.9 kb)"
+//config:	bool "setsid (3.6 kb)"
 //config:	default y
 //config:	help
 //config:	setsid runs a program in a new session
diff -urpN busybox-1.29.3/util-linux/swaponoff.c busybox-1.30.0/util-linux/swaponoff.c
--- busybox-1.29.3/util-linux/swaponoff.c	2018-07-02 13:23:06.000000000 +0200
+++ busybox-1.30.0/util-linux/swaponoff.c	2018-12-30 16:14:20.000000000 +0100
@@ -7,7 +7,7 @@
  * Licensed under GPLv2, see file LICENSE in this source tree.
  */
 //config:config SWAPON
-//config:	bool "swapon (4.9 kb)"
+//config:	bool "swapon (15 kb)"
 //config:	default y
 //config:	select PLATFORM_LINUX
 //config:	help
@@ -34,7 +34,7 @@
 //config:	Enable support for setting swap device priority in swapon.
 //config:
 //config:config SWAPOFF
-//config:	bool "swapoff (4.3 kb)"
+//config:	bool "swapoff (14 kb)"
 //config:	default y
 //config:	select PLATFORM_LINUX
 //config:
diff -urpN busybox-1.29.3/util-linux/switch_root.c busybox-1.30.0/util-linux/switch_root.c
--- busybox-1.29.3/util-linux/switch_root.c	2018-07-02 13:23:06.000000000 +0200
+++ busybox-1.30.0/util-linux/switch_root.c	2018-12-30 16:14:20.000000000 +0100
@@ -7,7 +7,7 @@
  * Licensed under GPLv2, see file LICENSE in this source tree.
  */
 //config:config SWITCH_ROOT
-//config:	bool "switch_root (5.2 kb)"
+//config:	bool "switch_root (5.5 kb)"
 //config:	default y
 //config:	select PLATFORM_LINUX
 //config:	help
diff -urpN busybox-1.29.3/util-linux/taskset.c busybox-1.30.0/util-linux/taskset.c
--- busybox-1.29.3/util-linux/taskset.c	2018-07-02 13:23:06.000000000 +0200
+++ busybox-1.30.0/util-linux/taskset.c	2018-12-30 16:14:20.000000000 +0100
@@ -6,7 +6,7 @@
  * Licensed under GPLv2 or later, see file LICENSE in this source tree.
  */
 //config:config TASKSET
-//config:	bool "taskset (4.1 kb)"
+//config:	bool "taskset (4.2 kb)"
 //config:	default y
 //config:	help
 //config:	Retrieve or set a processes's CPU affinity.
diff -urpN busybox-1.29.3/util-linux/uevent.c busybox-1.30.0/util-linux/uevent.c
--- busybox-1.29.3/util-linux/uevent.c	2018-07-02 13:23:06.000000000 +0200
+++ busybox-1.30.0/util-linux/uevent.c	2018-12-30 16:14:20.000000000 +0100
@@ -4,7 +4,7 @@
  * Licensed under GPLv2, see file LICENSE in this source tree.
  */
 //config:config UEVENT
-//config:	bool "uevent (3.2 kb)"
+//config:	bool "uevent (3.1 kb)"
 //config:	default y
 //config:	select PLATFORM_LINUX
 //config:	help
diff -urpN busybox-1.29.3/util-linux/umount.c busybox-1.30.0/util-linux/umount.c
--- busybox-1.29.3/util-linux/umount.c	2018-07-02 13:23:06.000000000 +0200
+++ busybox-1.30.0/util-linux/umount.c	2018-12-30 16:14:20.000000000 +0100
@@ -8,7 +8,7 @@
  * Licensed under GPLv2, see file LICENSE in this source tree.
  */
 //config:config UMOUNT
-//config:	bool "umount (4.5 kb)"
+//config:	bool "umount (5.1 kb)"
 //config:	default y
 //config:	select PLATFORM_LINUX
 //config:	help
diff -urpN busybox-1.29.3/util-linux/unshare.c busybox-1.30.0/util-linux/unshare.c
--- busybox-1.29.3/util-linux/unshare.c	2018-07-02 13:23:06.000000000 +0200
+++ busybox-1.30.0/util-linux/unshare.c	2018-12-30 16:14:20.000000000 +0100
@@ -7,7 +7,7 @@
  * Licensed under GPLv2 or later, see file LICENSE in this source tree.
  */
 //config:config UNSHARE
-//config:	bool "unshare (9.2 kb)"
+//config:	bool "unshare (7.2 kb)"
 //config:	default y
 //config:	depends on !NOMMU
 //config:	select PLATFORM_LINUX
@@ -73,7 +73,7 @@
 #include "libbb.h"
 
 static void mount_or_die(const char *source, const char *target,
-                 const char *fstype, unsigned long mountflags)
+		const char *fstype, unsigned long mountflags)
 {
 	if (mount(source, target, fstype, mountflags, NULL)) {
 		bb_perror_msg_and_die("can't mount %s on %s (flags:0x%lx)",
diff -urpN busybox-1.29.3/util-linux/wall.c busybox-1.30.0/util-linux/wall.c
--- busybox-1.29.3/util-linux/wall.c	2018-07-02 13:23:06.000000000 +0200
+++ busybox-1.30.0/util-linux/wall.c	2018-12-30 16:14:20.000000000 +0100
@@ -6,7 +6,7 @@
  * Licensed under GPLv2 or later, see file LICENSE in this source tree.
  */
 //config:config WALL
-//config:	bool "wall (2.5 kb)"
+//config:	bool "wall (2.6 kb)"
 //config:	default y
 //config:	depends on FEATURE_UTMP
 //config:	help

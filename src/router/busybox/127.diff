diff -urpN busybox-1.26.2/AUTHORS busybox-1.27.0/AUTHORS
--- busybox-1.26.2/AUTHORS	2016-09-27 18:53:50.000000000 +0200
+++ busybox-1.27.0/AUTHORS	2017-04-05 18:27:36.000000000 +0200
@@ -178,3 +178,6 @@ Mike Frysinger <vapier@gentoo.org>
 
 Jie Zhang <jie.zhang@analog.com>
     fixed two bugs in msh and hush (exitcode of killed processes)
+
+Maxime Coste <mawww@kakoune.org>
+    paste implementation
diff -urpN busybox-1.26.2/Config.in busybox-1.27.0/Config.in
--- busybox-1.26.2/Config.in	2016-12-10 18:46:36.000000000 +0100
+++ busybox-1.27.0/Config.in	2017-01-15 00:18:53.000000000 +0100
@@ -22,7 +22,7 @@ config DESKTOP
 
 	  If you are preparing your build to be used on an embedded box
 	  where you have tighter control over the entire set of userspace
-	  tools, you can unselect this option for smaller code size. 
+	  tools, you can unselect this option for smaller code size.
 
 config EXTRA_COMPAT
 	bool "Provide compatible behavior for rare corner cases (bigger code)"
@@ -50,17 +50,6 @@ config USE_PORTABLE_CODE
 	  compiler other than gcc.
 	  If you do use gcc, this option may needlessly increase code size.
 
-config PLATFORM_LINUX
-	bool "Enable Linux-specific applets and features"
-	default y
-	help
-	  For the most part, busybox requires only POSIX compatibility
-	  from the target system, but some applets and features use
-	  Linux-specific interfaces.
-
-	  Answering 'N' here will disable such applets and hide the
-	  corresponding configuration options.
-
 config SHOW_USAGE
 	bool "Show applet usage messages"
 	default y
@@ -124,14 +113,14 @@ config INSTALL_NO_USR
 	  never to /usr/bin or /usr/sbin.
 
 config PAM
-	bool "Support for PAM (Pluggable Authentication Modules)"
+	bool "Support PAM (Pluggable Authentication Modules)"
 	default n
 	help
 	  Use PAM in some busybox applets (currently login and httpd) instead
 	  of direct access to password database.
 
 config LONG_OPTS
-	bool "Support for --long-options"
+	bool "Support --long-options"
 	default y
 	help
 	  Enable this if you want busybox applets to use the gnu --long-option
@@ -198,7 +187,7 @@ config PID_FILE_PATH
 	  specify a pidfile path.
 
 config FEATURE_SUID
-	bool "Support for SUID/SGID handling"
+	bool "Support SUID/SGID handling"
 	default y
 	help
 	  With this option you can install the busybox binary belonging
@@ -338,6 +327,17 @@ config FEATURE_HAVE_RPC
 	#  This is automatically selected if any of enabled applets need it.
 	#  You do not need to select it manually.
 
+config PLATFORM_LINUX
+	bool #No description makes it a hidden option
+	default n
+	#help
+	#  For the most part, busybox requires only POSIX compatibility
+	#  from the target system, but some applets and features use
+	#  Linux-specific interfaces.
+	#
+	#  This is automatically selected if any applet or feature requires
+	#  Linux-specific interfaces. You do not need to select it manually.
+
 comment 'Build Options'
 
 config STATIC
@@ -611,6 +611,8 @@ config DEBUG_SANITIZE
 	  catch bad memory accesses (e.g. buffer overflows), but will make
 	  the executable larger and slow down runtime a bit.
 
+	  This adds -fsanitize=foo options to gcc command line.
+
 	  If you aren't developing/testing busybox, say N here.
 
 config UNIT_TEST
@@ -625,7 +627,7 @@ config WERROR
 	bool "Abort compilation on any warning"
 	default n
 	help
-	  Selecting this will add -Werror to gcc command line.
+	  This adds -Werror to gcc command line.
 
 	  Most people should answer N.
 
diff -urpN busybox-1.26.2/Makefile busybox-1.27.0/Makefile
--- busybox-1.26.2/Makefile	2017-01-10 17:01:16.000000000 +0100
+++ busybox-1.27.0/Makefile	2017-07-03 13:40:43.000000000 +0200
@@ -1,6 +1,6 @@
 VERSION = 1
-PATCHLEVEL = 26
-SUBLEVEL = 2
+PATCHLEVEL = 27
+SUBLEVEL = 0
 EXTRAVERSION =
 NAME = Unnamed
 
diff -urpN busybox-1.26.2/applets/usage_compressed busybox-1.27.0/applets/usage_compressed
--- busybox-1.26.2/applets/usage_compressed	2016-09-27 18:53:50.000000000 +0200
+++ busybox-1.27.0/applets/usage_compressed	2017-01-08 14:34:07.000000000 +0100
@@ -36,6 +36,9 @@ echo ''
 #0000040 114 105 135 040 133 055 141 040 101 103 124 111 117 116 106 111
 #         042514 020135 026533 020141 041501 044524 047117 044506
 
+echo "#define UNPACKED_USAGE_LENGTH `$loc/usage | wc -c`"
+echo
+
 echo '#define PACKED_USAGE \'
 ## Breaks on big-endian systems!
 ## # Extra effort to avoid using "od -t x1": -t is not available
diff -urpN busybox-1.26.2/archival/Config.src busybox-1.27.0/archival/Config.src
--- busybox-1.26.2/archival/Config.src	2016-12-10 18:46:36.000000000 +0100
+++ busybox-1.27.0/archival/Config.src	2017-01-10 16:31:40.000000000 +0100
@@ -8,32 +8,22 @@ menu "Archival Utilities"
 config FEATURE_SEAMLESS_XZ
 	bool "Make tar, rpm, modprobe etc understand .xz data"
 	default y
-	help
-	  Make tar, rpm, modprobe etc understand .xz data.
 
 config FEATURE_SEAMLESS_LZMA
 	bool "Make tar, rpm, modprobe etc understand .lzma data"
 	default y
-	help
-	  Make tar, rpm, modprobe etc understand .lzma data.
 
 config FEATURE_SEAMLESS_BZ2
 	bool "Make tar, rpm, modprobe etc understand .bz2 data"
 	default y
-	help
-	  Make tar, rpm, modprobe etc understand .bz2 data.
 
 config FEATURE_SEAMLESS_GZ
 	bool "Make tar, rpm, modprobe etc understand .gz data"
 	default y
-	help
-	  Make tar, rpm, modprobe etc understand .gz data.
 
 config FEATURE_SEAMLESS_Z
 	bool "Make tar, rpm, modprobe etc understand .Z data"
 	default n  # it is ancient
-	help
-	  Make tar, rpm, modprobe etc understand .Z data.
 
 INSERT
 
diff -urpN busybox-1.26.2/archival/ar.c busybox-1.27.0/archival/ar.c
--- busybox-1.26.2/archival/ar.c	2016-09-27 18:53:50.000000000 +0200
+++ busybox-1.27.0/archival/ar.c	2017-01-10 16:31:40.000000000 +0100
@@ -31,7 +31,7 @@
 //config:	  probably say N here: most compilers come with their own ar utility.
 //config:
 //config:config FEATURE_AR_LONG_FILENAMES
-//config:	bool "Support for long filenames (not needed for debs)"
+//config:	bool "Support long filenames (not needed for debs)"
 //config:	default y
 //config:	depends on AR
 //config:	help
diff -urpN busybox-1.26.2/archival/bbunzip.c busybox-1.27.0/archival/bbunzip.c
--- busybox-1.26.2/archival/bbunzip.c	2017-01-01 13:01:04.000000000 +0100
+++ busybox-1.27.0/archival/bbunzip.c	2017-07-01 22:51:12.000000000 +0200
@@ -12,20 +12,21 @@
 //kbuild:lib-$(CONFIG_LZOPCAT) += bbunzip.o
 //kbuild:lib-$(CONFIG_UNLZOP) += bbunzip.o
 /* bzip2_main() too: */
-//kbuild:lib-$(CONFIG_BZIP2) += bbunzip.o
+//kbuild:lib-$(CONFIG_FEATURE_BZIP2_DECOMPRESS) += bbunzip.o
 /* gzip_main() too: */
-//kbuild:lib-$(CONFIG_GZIP) += bbunzip.o
+//kbuild:lib-$(CONFIG_FEATURE_GZIP_DECOMPRESS) += bbunzip.o
 
 /* Note: must be kept in sync with archival/lzop.c */
 enum {
 	OPT_STDOUT     = 1 << 0,
 	OPT_FORCE      = 1 << 1,
 	/* only some decompressors: */
-	OPT_VERBOSE    = 1 << 2,
-	OPT_QUIET      = 1 << 3,
-	OPT_DECOMPRESS = 1 << 4,
-	OPT_TEST       = 1 << 5,
-	SEAMLESS_MAGIC = (1 << 31) * SEAMLESS_COMPRESSION,
+	OPT_KEEP       = 1 << 2,
+	OPT_VERBOSE    = 1 << 3,
+	OPT_QUIET      = 1 << 4,
+	OPT_DECOMPRESS = 1 << 5,
+	OPT_TEST       = 1 << 6,
+	SEAMLESS_MAGIC = (1 << 31) * ENABLE_ZCAT * SEAMLESS_COMPRESSION,
 };
 
 static
@@ -127,7 +128,7 @@ int FAST_FUNC bbunpack(char **argv,
 
 		if (!(option_mask32 & SEAMLESS_MAGIC)) {
 			init_transformer_state(&xstate);
-			xstate.signature_skipped = 0;
+			/*xstate.signature_skipped = 0; - already is */
 			/*xstate.src_fd = STDIN_FILENO; - already is */
 			xstate.dst_fd = STDOUT_FILENO;
 			status = unpacker(&xstate);
@@ -182,8 +183,11 @@ int FAST_FUNC bbunpack(char **argv,
 				}
 				/* Delete _source_ file */
 				del = filename;
+				if (option_mask32 & OPT_KEEP) /* ... unless -k */
+					del = NULL;
 			}
-			xunlink(del);
+			if (del)
+				xunlink(del);
  free_name:
 			if (new_name != filename)
 				free(new_name);
@@ -197,7 +201,7 @@ int FAST_FUNC bbunpack(char **argv,
 }
 
 #if ENABLE_UNCOMPRESS \
- || ENABLE_BUNZIP2 || ENABLE_BZCAT \
+ || ENABLE_FEATURE_BZIP2_DECOMPRESS \
  || ENABLE_UNLZMA || ENABLE_LZCAT || ENABLE_LZMA \
  || ENABLE_UNXZ || ENABLE_XZCAT || ENABLE_XZ
 static
@@ -240,7 +244,16 @@ char* FAST_FUNC make_new_name_generic(ch
 int uncompress_main(int argc, char **argv) MAIN_EXTERNALLY_VISIBLE;
 int uncompress_main(int argc UNUSED_PARAM, char **argv)
 {
+// (N)compress 4.2.4.4:
+// -d If given, decompression is done instead
+// -c Write output on stdout, don't remove original
+// -b Parameter limits the max number of bits/code
+// -f Forces output file to be generated
+// -v Write compression statistics
+// -V Output vesion and compile options
+// -r Recursive. If a filename is a directory, descend into it and compress everything
 	getopt32(argv, "cf");
+
 	argv += optind;
 
 	return bbunpack(argv, unpack_Z_stream, make_new_name_generic, "Z");
@@ -273,11 +286,12 @@ int uncompress_main(int argc UNUSED_PARA
  * Ken Turkowski, Dave Mack and Peter Jannesen.
  */
 //usage:#define gunzip_trivial_usage
-//usage:       "[-cft] [FILE]..."
+//usage:       "[-cfkt] [FILE]..."
 //usage:#define gunzip_full_usage "\n\n"
 //usage:       "Decompress FILEs (or stdin)\n"
 //usage:     "\n	-c	Write to stdout"
 //usage:     "\n	-f	Force"
+//usage:     "\n	-k	Keep input files"
 //usage:     "\n	-t	Test file integrity"
 //usage:
 //usage:#define gunzip_example_usage
@@ -295,6 +309,7 @@ int uncompress_main(int argc UNUSED_PARA
 //config:config GUNZIP
 //config:	bool "gunzip"
 //config:	default y
+//config:	select FEATURE_GZIP_DECOMPRESS
 //config:	help
 //config:	  gunzip is used to decompress archives created by gzip.
 //config:	  You can use the `-t' option to test the integrity of
@@ -303,6 +318,7 @@ int uncompress_main(int argc UNUSED_PARA
 //config:config ZCAT
 //config:	bool "zcat"
 //config:	default y
+//config:	select FEATURE_GZIP_DECOMPRESS
 //config:	help
 //config:	  Alias to "gunzip -c".
 //config:
@@ -310,14 +326,11 @@ int uncompress_main(int argc UNUSED_PARA
 //config:	bool "Enable long options"
 //config:	default y
 //config:	depends on (GUNZIP || ZCAT) && LONG_OPTS
-//config:	help
-//config:	  Enable use of long options.
 
 //applet:IF_GUNZIP(APPLET(gunzip, BB_DIR_BIN, BB_SUID_DROP))
+//               APPLET_ODDNAME:name  main    location    suid_type     help
 //applet:IF_ZCAT(APPLET_ODDNAME(zcat, gunzip, BB_DIR_BIN, BB_SUID_DROP, zcat))
-//kbuild:lib-$(CONFIG_GUNZIP) += bbunzip.o
-//kbuild:lib-$(CONFIG_ZCAT) += bbunzip.o
-#if ENABLE_GUNZIP || ENABLE_ZCAT
+#if ENABLE_FEATURE_GZIP_DECOMPRESS
 static
 char* FAST_FUNC make_new_name_gunzip(char *filename, const char *expected_ext UNUSED_PARAM)
 {
@@ -373,7 +386,7 @@ int gunzip_main(int argc UNUSED_PARAM, c
 #if ENABLE_FEATURE_GUNZIP_LONG_OPTIONS
 	applet_long_options = gunzip_longopts;
 #endif
-	getopt32(argv, "cfvqdtn");
+	getopt32(argv, "cfkvqdtn");
 	argv += optind;
 
 	/* If called as zcat...
@@ -385,7 +398,7 @@ int gunzip_main(int argc UNUSED_PARAM, c
 
 	return bbunpack(argv, unpack_gz_stream, make_new_name_gunzip, /*unused:*/ NULL);
 }
-#endif
+#endif /* FEATURE_GZIP_DECOMPRESS */
 
 
 /*
@@ -395,11 +408,12 @@ int gunzip_main(int argc UNUSED_PARAM, c
  * Licensed under GPLv2 or later, see file LICENSE in this source tree.
  */
 //usage:#define bunzip2_trivial_usage
-//usage:       "[-cf] [FILE]..."
+//usage:       "[-cfk] [FILE]..."
 //usage:#define bunzip2_full_usage "\n\n"
 //usage:       "Decompress FILEs (or stdin)\n"
 //usage:     "\n	-c	Write to stdout"
 //usage:     "\n	-f	Force"
+//usage:     "\n	-k	Keep input files"
 //usage:#define bzcat_trivial_usage
 //usage:       "[FILE]..."
 //usage:#define bzcat_full_usage "\n\n"
@@ -408,6 +422,7 @@ int gunzip_main(int argc UNUSED_PARAM, c
 //config:config BUNZIP2
 //config:	bool "bunzip2"
 //config:	default y
+//config:	select FEATURE_BZIP2_DECOMPRESS
 //config:	help
 //config:	  bunzip2 is a compression utility using the Burrows-Wheeler block
 //config:	  sorting text compression algorithm, and Huffman coding. Compression
@@ -421,18 +436,18 @@ int gunzip_main(int argc UNUSED_PARAM, c
 //config:config BZCAT
 //config:	bool "bzcat"
 //config:	default y
+//config:	select FEATURE_BZIP2_DECOMPRESS
 //config:	help
 //config:	  Alias to "bunzip2 -c".
 
 //applet:IF_BUNZIP2(APPLET(bunzip2, BB_DIR_USR_BIN, BB_SUID_DROP))
+//                APPLET_ODDNAME:name   main     location        suid_type     help
 //applet:IF_BZCAT(APPLET_ODDNAME(bzcat, bunzip2, BB_DIR_USR_BIN, BB_SUID_DROP, bzcat))
-//kbuild:lib-$(CONFIG_BUNZIP2) += bbunzip.o
-//kbuild:lib-$(CONFIG_BZCAT) += bbunzip.o
-#if ENABLE_BUNZIP2 || ENABLE_BZCAT
+#if ENABLE_FEATURE_BZIP2_DECOMPRESS
 int bunzip2_main(int argc, char **argv) MAIN_EXTERNALLY_VISIBLE;
 int bunzip2_main(int argc UNUSED_PARAM, char **argv)
 {
-	getopt32(argv, "cfvqdt");
+	getopt32(argv, "cfkvqdt");
 	argv += optind;
 	if (ENABLE_BZCAT && applet_name[2] == 'c') /* bzcat */
 		option_mask32 |= OPT_STDOUT;
@@ -451,44 +466,26 @@ int bunzip2_main(int argc UNUSED_PARAM,
  * Licensed under GPLv2, see file LICENSE in this source tree.
  */
 //usage:#define unlzma_trivial_usage
-//usage:       "[-cf] [FILE]..."
+//usage:       "[-cfk] [FILE]..."
 //usage:#define unlzma_full_usage "\n\n"
 //usage:       "Decompress FILE (or stdin)\n"
 //usage:     "\n	-c	Write to stdout"
 //usage:     "\n	-f	Force"
+//usage:     "\n	-k	Keep input files"
 //usage:
 //usage:#define lzma_trivial_usage
-//usage:       "-d [-cf] [FILE]..."
+//usage:       "-d [-cfk] [FILE]..."
 //usage:#define lzma_full_usage "\n\n"
 //usage:       "Decompress FILE (or stdin)\n"
 //usage:     "\n	-d	Decompress"
 //usage:     "\n	-c	Write to stdout"
 //usage:     "\n	-f	Force"
+//usage:     "\n	-k	Keep input files"
 //usage:
 //usage:#define lzcat_trivial_usage
 //usage:       "[FILE]..."
 //usage:#define lzcat_full_usage "\n\n"
 //usage:       "Decompress to stdout"
-//usage:
-//usage:#define unxz_trivial_usage
-//usage:       "[-cf] [FILE]..."
-//usage:#define unxz_full_usage "\n\n"
-//usage:       "Decompress FILE (or stdin)\n"
-//usage:     "\n	-c	Write to stdout"
-//usage:     "\n	-f	Force"
-//usage:
-//usage:#define xz_trivial_usage
-//usage:       "-d [-cf] [FILE]..."
-//usage:#define xz_full_usage "\n\n"
-//usage:       "Decompress FILE (or stdin)\n"
-//usage:     "\n	-d	Decompress"
-//usage:     "\n	-c	Write to stdout"
-//usage:     "\n	-f	Force"
-//usage:
-//usage:#define xzcat_trivial_usage
-//usage:       "[FILE]..."
-//usage:#define xzcat_full_usage "\n\n"
-//usage:       "Decompress to stdout"
 
 //config:config UNLZMA
 //config:	bool "unlzma"
@@ -522,7 +519,7 @@ int bunzip2_main(int argc UNUSED_PARAM,
 //config:	  IOW: you'll get lzma applet, but it will always require -d option.
 //config:
 //config:config FEATURE_LZMA_FAST
-//config:	bool "Optimize unlzma for speed"
+//config:	bool "Optimize for speed"
 //config:	default n
 //config:	depends on UNLZMA || LZCAT || LZMA
 //config:	help
@@ -530,8 +527,9 @@ int bunzip2_main(int argc UNUSED_PARAM,
 //config:	  a 1K bigger binary.
 
 //applet:IF_UNLZMA(APPLET(unlzma, BB_DIR_USR_BIN, BB_SUID_DROP))
+//                APPLET_ODDNAME:name   main    location        suid_type     help
 //applet:IF_LZCAT(APPLET_ODDNAME(lzcat, unlzma, BB_DIR_USR_BIN, BB_SUID_DROP, lzcat))
-//applet:IF_LZMA(APPLET_ODDNAME(lzma, unlzma, BB_DIR_USR_BIN, BB_SUID_DROP, lzma))
+//applet:IF_LZMA( APPLET_ODDNAME(lzma,  unlzma, BB_DIR_USR_BIN, BB_SUID_DROP, lzma))
 //kbuild:lib-$(CONFIG_UNLZMA) += bbunzip.o
 //kbuild:lib-$(CONFIG_LZCAT) += bbunzip.o
 //kbuild:lib-$(CONFIG_LZMA) += bbunzip.o
@@ -539,7 +537,7 @@ int bunzip2_main(int argc UNUSED_PARAM,
 int unlzma_main(int argc, char **argv) MAIN_EXTERNALLY_VISIBLE;
 int unlzma_main(int argc UNUSED_PARAM, char **argv)
 {
-	IF_LZMA(int opts =) getopt32(argv, "cfvqdt");
+	IF_LZMA(int opts =) getopt32(argv, "cfkvqdt");
 # if ENABLE_LZMA
 	/* lzma without -d or -t? */
 	if (applet_name[2] == 'm' && !(opts & (OPT_DECOMPRESS|OPT_TEST)))
@@ -555,6 +553,28 @@ int unlzma_main(int argc UNUSED_PARAM, c
 #endif
 
 
+//usage:#define unxz_trivial_usage
+//usage:       "[-cfk] [FILE]..."
+//usage:#define unxz_full_usage "\n\n"
+//usage:       "Decompress FILE (or stdin)\n"
+//usage:     "\n	-c	Write to stdout"
+//usage:     "\n	-f	Force"
+//usage:     "\n	-k	Keep input files"
+//usage:
+//usage:#define xz_trivial_usage
+//usage:       "-d [-cfk] [FILE]..."
+//usage:#define xz_full_usage "\n\n"
+//usage:       "Decompress FILE (or stdin)\n"
+//usage:     "\n	-d	Decompress"
+//usage:     "\n	-c	Write to stdout"
+//usage:     "\n	-f	Force"
+//usage:     "\n	-k	Keep input files"
+//usage:
+//usage:#define xzcat_trivial_usage
+//usage:       "[FILE]..."
+//usage:#define xzcat_full_usage "\n\n"
+//usage:       "Decompress to stdout"
+
 //config:config UNXZ
 //config:	bool "unxz"
 //config:	default y
@@ -575,8 +595,9 @@ int unlzma_main(int argc UNUSED_PARAM, c
 //config:	  IOW: you'll get xz applet, but it will always require -d option.
 
 //applet:IF_UNXZ(APPLET(unxz, BB_DIR_USR_BIN, BB_SUID_DROP))
+//                APPLET_ODDNAME:name   main  location        suid_type     help
 //applet:IF_XZCAT(APPLET_ODDNAME(xzcat, unxz, BB_DIR_USR_BIN, BB_SUID_DROP, xzcat))
-//applet:IF_XZ(APPLET_ODDNAME(xz, unxz, BB_DIR_USR_BIN, BB_SUID_DROP, xz))
+//applet:IF_XZ(   APPLET_ODDNAME(xz,    unxz, BB_DIR_USR_BIN, BB_SUID_DROP, xz))
 //kbuild:lib-$(CONFIG_UNXZ) += bbunzip.o
 //kbuild:lib-$(CONFIG_XZCAT) += bbunzip.o
 //kbuild:lib-$(CONFIG_XZ) += bbunzip.o
@@ -584,7 +605,7 @@ int unlzma_main(int argc UNUSED_PARAM, c
 int unxz_main(int argc, char **argv) MAIN_EXTERNALLY_VISIBLE;
 int unxz_main(int argc UNUSED_PARAM, char **argv)
 {
-	IF_XZ(int opts =) getopt32(argv, "cfvqdt");
+	IF_XZ(int opts =) getopt32(argv, "cfkvqdt");
 # if ENABLE_XZ
 	/* xz without -d or -t? */
 	if (applet_name[2] == '\0' && !(opts & (OPT_DECOMPRESS|OPT_TEST)))
diff -urpN busybox-1.26.2/archival/bzip2.c busybox-1.27.0/archival/bzip2.c
--- busybox-1.26.2/archival/bzip2.c	2016-09-27 18:53:50.000000000 +0200
+++ busybox-1.27.0/archival/bzip2.c	2017-07-01 22:51:12.000000000 +0200
@@ -19,6 +19,15 @@
 //config:
 //config:	  Unless you have a specific application which requires bzip2, you
 //config:	  should probably say N here.
+//config:
+//config:config FEATURE_BZIP2_DECOMPRESS
+//config:	bool "Enable decompression"
+//config:	default y
+//config:	depends on BZIP2 || BUNZIP2 || BZCAT
+//config:	help
+//config:	  Enable -d (--decompress) and -t (--test) options for bzip2.
+//config:	  This will be automatically selected if bunzip2 or bzcat is
+//config:	  enabled.
 
 //applet:IF_BZIP2(APPLET(bzip2, BB_DIR_USR_BIN, BB_SUID_DROP))
 //kbuild:lib-$(CONFIG_BZIP2) += bzip2.o
@@ -28,9 +37,13 @@
 //usage:#define bzip2_full_usage "\n\n"
 //usage:       "Compress FILEs (or stdin) with bzip2 algorithm\n"
 //usage:     "\n	-1..9	Compression level"
+//usage:	IF_FEATURE_BZIP2_DECOMPRESS(
 //usage:     "\n	-d	Decompress"
+//usage:     "\n	-t	Test file integrity"
+//usage:	)
 //usage:     "\n	-c	Write to stdout"
 //usage:     "\n	-f	Force"
+//usage:     "\n	-k	Keep input files"
 
 #include "libbb.h"
 #include "bb_archive.h"
@@ -184,13 +197,13 @@ int bzip2_main(int argc UNUSED_PARAM, ch
 
 	opt_complementary = "s2"; /* -s means -2 (compatibility) */
 	/* Must match bbunzip's constants OPT_STDOUT, OPT_FORCE! */
-	opt = getopt32(argv, "cfv" IF_BUNZIP2("dt") "123456789qzs");
-#if ENABLE_BUNZIP2 /* bunzip2_main may not be visible... */
-	if (opt & 0x18) // -d and/or -t
+	opt = getopt32(argv, "cfkv" IF_FEATURE_BZIP2_DECOMPRESS("dt") "123456789qzs");
+#if ENABLE_FEATURE_BZIP2_DECOMPRESS /* bunzip2_main may not be visible... */
+	if (opt & 0x30) // -d and/or -t
 		return bunzip2_main(argc, argv);
-	opt >>= 5;
+	opt >>= 6;
 #else
-	opt >>= 3;
+	opt >>= 4;
 #endif
 	opt = (uint8_t)opt; /* isolate bits for -1..-8 */
 	opt |= 0x100; /* if nothing else, assume -9 */
@@ -201,6 +214,6 @@ int bzip2_main(int argc UNUSED_PARAM, ch
 	}
 
 	argv += optind;
-	option_mask32 &= 0x7; /* ignore all except -cfv */
+	option_mask32 &= 0xf; /* ignore all except -cfkv */
 	return bbunpack(argv, compressStream, append_ext, "bz2");
 }
diff -urpN busybox-1.26.2/archival/cpio.c busybox-1.27.0/archival/cpio.c
--- busybox-1.26.2/archival/cpio.c	2016-09-27 18:53:50.000000000 +0200
+++ busybox-1.27.0/archival/cpio.c	2017-01-10 16:31:40.000000000 +0100
@@ -29,7 +29,7 @@
 //config:	  should probably say N here.
 //config:
 //config:config FEATURE_CPIO_O
-//config:	bool "Support for archive creation"
+//config:	bool "Support archive creation"
 //config:	default y
 //config:	depends on CPIO
 //config:	help
@@ -37,7 +37,7 @@
 //config:	  format only.
 //config:
 //config:config FEATURE_CPIO_P
-//config:	bool "Support for passthrough mode"
+//config:	bool "Support passthrough mode"
 //config:	default y
 //config:	depends on FEATURE_CPIO_O
 //config:	help
diff -urpN busybox-1.26.2/archival/dpkg.c busybox-1.27.0/archival/dpkg.c
--- busybox-1.26.2/archival/dpkg.c	2017-01-01 13:01:04.000000000 +0100
+++ busybox-1.27.0/archival/dpkg.c	2017-07-01 22:51:12.000000000 +0200
@@ -18,7 +18,7 @@
  * known difference between busybox dpkg and the official dpkg that i don't
  * consider important, its worth keeping a note of differences anyway, just to
  * make it easier to maintain.
- *  - the first value for the confflile: field isnt placed on a new line.
+ *  - the first value for the confflile: field isn't placed on a new line.
  *  - when installing a package the status: field is placed at the end of the
  *      section, rather than just after the package: field.
  *
@@ -110,7 +110,7 @@ typedef struct common_node_s {
 	edge_t **edge;
 } common_node_t;
 
-/* Currently it doesnt store packages that have state-status of not-installed
+/* Currently it doesn't store packages that have state-status of not-installed
  * So it only really has to be the size of the maximum number of packages
  * likely to be installed at any one time, so there is a bit of leeway here */
 #define STATUS_HASH_PRIME 8191
@@ -205,7 +205,7 @@ static int search_name_hashtable(const c
 	return probe_address;
 }
 
-/* this DOESNT add the key to the hashtable
+/* this DOESN'T add the key to the hashtable
  * TODO make it consistent with search_name_hashtable
  */
 static unsigned search_status_hashtable(const char *key)
@@ -467,7 +467,7 @@ static void add_split_dependencies(commo
 			version = strchr(field2, '(');
 			if (version == NULL) {
 				edge->operator = VER_ANY;
-				/* Get the versions hash number, adding it if the number isnt already in there */
+				/* Get the versions hash number, adding it if the number isn't already in there */
 				edge->version = search_name_hashtable("ANY");
 			} else {
 				/* Skip leading ' ' or '(' */
@@ -496,7 +496,7 @@ static void add_split_dependencies(commo
 
 				/* Truncate version at trailing ' ' or ')' */
 				version[strcspn(version, " )")] = '\0';
-				/* Get the versions hash number, adding it if the number isnt already in there */
+				/* Get the versions hash number, adding it if the number isn't already in there */
 				edge->version = search_name_hashtable(version);
 			}
 
@@ -562,7 +562,7 @@ static int read_package_field(const char
 					offset_name_end = offset;
 					offset_value_start = next_offset;
 				}
-				/* TODO: Name might still have trailing spaces if ':' isnt
+				/* TODO: Name might still have trailing spaces if ':' isn't
 				 * immediately after name */
 				break;
 			case '\n':
@@ -776,7 +776,7 @@ static void index_status_file(const char
 		const unsigned package_num = fill_package_struct(control_buffer);
 		if (package_num != -1) {
 			status_node = xmalloc(sizeof(status_node_t));
-			/* fill_package_struct doesnt handle the status field */
+			/* fill_package_struct doesn't handle the status field */
 			status_line = strstr(control_buffer, "Status:");
 			if (status_line != NULL) {
 				status_line += 7;
@@ -850,7 +850,7 @@ static void write_status_file(deb_file_t
 		if (status_hashtable[status_num] != NULL) {
 			const char *status_from_hashtable = name_hashtable[status_hashtable[status_num]->status];
 			if (strcmp(status_from_file, status_from_hashtable) != 0) {
-				/* New status isnt exactly the same as old status */
+				/* New status isn't exactly the same as old status */
 				const int state_status = get_status(status_num, 3);
 				if ((strcmp("installed", name_hashtable[state_status]) == 0)
 				 || (strcmp("unpacked", name_hashtable[state_status]) == 0)
@@ -919,7 +919,7 @@ static void write_status_file(deb_file_t
 				}
 			}
 		}
-		/* If the package from the status file wasnt handle above, do it now*/
+		/* If the package from the status file wasn't handle above, do it now*/
 		if (!write_flag) {
 			fprintf(new_status_file, "%s\n\n", control_buffer);
 		}
@@ -946,7 +946,7 @@ static void write_status_file(deb_file_t
 		if (errno != ENOENT)
 			bb_error_msg_and_die("can't create backup status file");
 		/* Its ok if renaming the status file fails because status
-		 * file doesnt exist, maybe we are starting from scratch */
+		 * file doesn't exist, maybe we are starting from scratch */
 		bb_error_msg("no status file found, creating new one");
 	}
 
@@ -1061,7 +1061,7 @@ static int check_deps(deb_file_t **deb_f
 	}
 
 
-	/* Check dependendcies */
+	/* Check dependentcies */
 	for (i = 0; i < PACKAGE_HASH_PRIME; i++) {
 		int status_num = 0;
 		int number_of_alternatives = 0;
@@ -1244,7 +1244,7 @@ static void run_package_script_or_die(co
 
 	script_path = xasprintf("/var/lib/dpkg/info/%s.%s", package_name, script_type);
 
-	/* If the file doesnt exist is isnt fatal */
+	/* If the file doesn't exist it isn't fatal */
 	result = access(script_path, F_OK) ? EXIT_SUCCESS : system(script_path);
 	free(script_path);
 	if (result)
@@ -1839,7 +1839,7 @@ int dpkg_main(int argc UNUSED_PARAM, cha
 				) {
 					status_node = xmalloc(sizeof(status_node_t));
 					status_node->package = deb_file[deb_count]->package;
-					/* reinstreq isnt changed to "ok" until the package control info
+					/* reinstreq isn't changed to "ok" until the package control info
 					 * is written to the status file*/
 					status_node->status = search_name_hashtable("install reinstreq not-installed");
 					status_hashtable[status_num] = status_node;
diff -urpN busybox-1.26.2/archival/gzip.c busybox-1.27.0/archival/gzip.c
--- busybox-1.26.2/archival/gzip.c	2016-09-27 18:53:50.000000000 +0200
+++ busybox-1.27.0/archival/gzip.c	2017-07-01 22:51:12.000000000 +0200
@@ -48,11 +48,9 @@ aa:      85.1% -- replaced with aa.gz
 //config:	bool "Enable long options"
 //config:	default y
 //config:	depends on GZIP && LONG_OPTS
-//config:	help
-//config:	  Enable use of long options, increases size by about 106 Bytes
 //config:
 //config:config GZIP_FAST
-//config:	int "Trade memory for gzip speed (0:small,slow - 2:fast,big)"
+//config:	int "Trade memory for speed (0:small,slow - 2:fast,big)"
 //config:	default 0
 //config:	range 0 2
 //config:	depends on GZIP
@@ -72,22 +70,33 @@ aa:      85.1% -- replaced with aa.gz
 //config:	  is 6. If levels 1-3 are specified, 4 is used.
 //config:	  If this option is not selected, -N options are ignored and -9
 //config:	  is used.
+//config:
+//config:config FEATURE_GZIP_DECOMPRESS
+//config:	bool "Enable decompression"
+//config:	default y
+//config:	depends on GZIP || GUNZIP || ZCAT
+//config:	help
+//config:	  Enable -d (--decompress) and -t (--test) options for gzip.
+//config:	  This will be automatically selected if gunzip or zcat is
+//config:	  enabled.
 
 //applet:IF_GZIP(APPLET(gzip, BB_DIR_BIN, BB_SUID_DROP))
 //kbuild:lib-$(CONFIG_GZIP) += gzip.o
 
 //usage:#define gzip_trivial_usage
-//usage:       "[-cf" IF_GUNZIP("d") IF_FEATURE_GZIP_LEVELS("123456789") "] [FILE]..."
+//usage:       "[-cfk" IF_FEATURE_GZIP_DECOMPRESS("dt") IF_FEATURE_GZIP_LEVELS("123456789") "] [FILE]..."
 //usage:#define gzip_full_usage "\n\n"
 //usage:       "Compress FILEs (or stdin)\n"
 //usage:	IF_FEATURE_GZIP_LEVELS(
 //usage:     "\n	-1..9	Compression level"
 //usage:	)
-//usage:	IF_GUNZIP(
+//usage:	IF_FEATURE_GZIP_DECOMPRESS(
 //usage:     "\n	-d	Decompress"
+//usage:     "\n	-t	Test file integrity"
 //usage:	)
 //usage:     "\n	-c	Write to stdout"
 //usage:     "\n	-f	Force"
+//usage:     "\n	-k	Keep input files"
 //usage:
 //usage:#define gzip_example_usage
 //usage:       "$ ls -la /tmp/busybox*\n"
@@ -267,7 +276,7 @@ enum {
  * input file length plus MIN_LOOKAHEAD.
  */
 
-#ifndef ENABLE_FEATURE_GZIP_LEVELS
+#if !ENABLE_FEATURE_GZIP_LEVELS
 
 	max_chain_length = 4096,
 /* To speed up deflation, hash chains are never searched beyond this length.
@@ -306,7 +315,7 @@ enum {
 
 struct globals {
 
-#ifdef ENABLE_FEATURE_GZIP_LEVELS
+#if ENABLE_FEATURE_GZIP_LEVELS
 	unsigned max_chain_length;
 	unsigned max_lazy_match;
 	unsigned good_match;
@@ -2154,7 +2163,7 @@ static const char gzip_longopts[] ALIGN1
 	"to-stdout\0"           No_argument       "c"
 	"force\0"               No_argument       "f"
 	"verbose\0"             No_argument       "v"
-#if ENABLE_GUNZIP
+#if ENABLE_FEATURE_GZIP_DECOMPRESS
 	"decompress\0"          No_argument       "d"
 	"uncompress\0"          No_argument       "d"
 	"test\0"                No_argument       "t"
@@ -2181,14 +2190,14 @@ static const char gzip_longopts[] ALIGN1
  */
 
 int gzip_main(int argc, char **argv) MAIN_EXTERNALLY_VISIBLE;
-#if ENABLE_GUNZIP
+#if ENABLE_FEATURE_GZIP_DECOMPRESS
 int gzip_main(int argc, char **argv)
 #else
 int gzip_main(int argc UNUSED_PARAM, char **argv)
 #endif
 {
 	unsigned opt;
-#ifdef ENABLE_FEATURE_GZIP_LEVELS
+#if ENABLE_FEATURE_GZIP_LEVELS
 	static const struct {
 		uint8_t good;
 		uint8_t chain_shift;
@@ -2211,13 +2220,13 @@ int gzip_main(int argc UNUSED_PARAM, cha
 	applet_long_options = gzip_longopts;
 #endif
 	/* Must match bbunzip's constants OPT_STDOUT, OPT_FORCE! */
-	opt = getopt32(argv, "cfv" IF_GUNZIP("dt") "qn123456789");
-#if ENABLE_GUNZIP /* gunzip_main may not be visible... */
-	if (opt & 0x18) // -d and/or -t
+	opt = getopt32(argv, "cfkv" IF_FEATURE_GZIP_DECOMPRESS("dt") "qn123456789");
+#if ENABLE_FEATURE_GZIP_DECOMPRESS /* gunzip_main may not be visible... */
+	if (opt & 0x30) // -d and/or -t
 		return gunzip_main(argc, argv);
 #endif
-#ifdef ENABLE_FEATURE_GZIP_LEVELS
-	opt >>= ENABLE_GUNZIP ? 7 : 5; /* drop cfv[dt]qn bits */
+#if ENABLE_FEATURE_GZIP_LEVELS
+	opt >>= ENABLE_FEATURE_GZIP_DECOMPRESS ? 8 : 6; /* drop cfkv[dt]qn bits */
 	if (opt == 0)
 		opt = 1 << 6; /* default: 6 */
 	opt = ffs(opt >> 4); /* Maps -1..-4 to [0], -5 to [1] ... -9 to [5] */
@@ -2226,7 +2235,7 @@ int gzip_main(int argc UNUSED_PARAM, cha
 	max_lazy_match	 = gzip_level_config[opt].lazy2 * 2;
 	nice_match	 = gzip_level_config[opt].nice2 * 2;
 #endif
-	option_mask32 &= 0x7; /* retain only -cfv */
+	option_mask32 &= 0xf; /* retain only -cfkv */
 
 	/* Allocate all global buffers (for DYN_ALLOC option) */
 	ALLOC(uch, G1.l_buf, INBUFSIZ);
diff -urpN busybox-1.26.2/archival/libarchive/Kbuild.src busybox-1.27.0/archival/libarchive/Kbuild.src
--- busybox-1.26.2/archival/libarchive/Kbuild.src	2016-12-10 18:46:36.000000000 +0100
+++ busybox-1.27.0/archival/libarchive/Kbuild.src	2017-04-05 18:27:36.000000000 +0200
@@ -51,16 +51,19 @@ lib-$(CONFIG_LZOP)
 lib-$(CONFIG_UNLZOP)                    += lzo1x_1.o lzo1x_1o.o lzo1x_d.o
 lib-$(CONFIG_LZOPCAT)                   += lzo1x_1.o lzo1x_1o.o lzo1x_d.o
 lib-$(CONFIG_LZOP_COMPR_HIGH)           += lzo1x_9x.o
-lib-$(CONFIG_BUNZIP2)                   += open_transformer.o decompress_bunzip2.o
-lib-$(CONFIG_BZCAT)                     += open_transformer.o decompress_bunzip2.o
+# 'bzip2 -d', bunzip2 or bzcat selects FEATURE_BZIP2_DECOMPRESS
+lib-$(CONFIG_FEATURE_BZIP2_DECOMPRESS)  += open_transformer.o decompress_bunzip2.o
+lib-$(CONFIG_FEATURE_UNZIP_BZIP2)       += open_transformer.o decompress_bunzip2.o
 lib-$(CONFIG_UNLZMA)                    += open_transformer.o decompress_unlzma.o
 lib-$(CONFIG_LZCAT)                     += open_transformer.o decompress_unlzma.o
 lib-$(CONFIG_LZMA)                      += open_transformer.o decompress_unlzma.o
+lib-$(CONFIG_FEATURE_UNZIP_LZMA)        += open_transformer.o decompress_unlzma.o
 lib-$(CONFIG_UNXZ)                      += open_transformer.o decompress_unxz.o
 lib-$(CONFIG_XZCAT)                     += open_transformer.o decompress_unxz.o
 lib-$(CONFIG_XZ)                        += open_transformer.o decompress_unxz.o
-lib-$(CONFIG_GUNZIP)                    += open_transformer.o decompress_gunzip.o
-lib-$(CONFIG_ZCAT)                      += open_transformer.o decompress_gunzip.o
+lib-$(CONFIG_FEATURE_UNZIP_XZ)          += open_transformer.o decompress_unxz.o
+# 'gzip -d', gunzip or zcat selects FEATURE_GZIP_DECOMPRESS
+lib-$(CONFIG_FEATURE_GZIP_DECOMPRESS)   += open_transformer.o decompress_gunzip.o
 lib-$(CONFIG_UNCOMPRESS)                += open_transformer.o decompress_uncompress.o
 lib-$(CONFIG_UNZIP)                     += open_transformer.o decompress_gunzip.o unsafe_prefix.o
 lib-$(CONFIG_RPM2CPIO)                  += open_transformer.o decompress_gunzip.o get_header_cpio.o
diff -urpN busybox-1.26.2/archival/libarchive/data_extract_all.c busybox-1.27.0/archival/libarchive/data_extract_all.c
--- busybox-1.26.2/archival/libarchive/data_extract_all.c	2016-09-27 18:53:50.000000000 +0200
+++ busybox-1.27.0/archival/libarchive/data_extract_all.c	2017-01-30 21:57:30.000000000 +0100
@@ -127,8 +127,9 @@ void FAST_FUNC data_extract_all(archive_
 	if (hard_link) {
 		res = link(hard_link, dst_name);
 		if (res != 0 && !(archive_handle->ah_flags & ARCHIVE_EXTRACT_QUIET)) {
+			/* shared message */
 			bb_perror_msg("can't create %slink "
-					"from %s to %s", "hard",
+					"%s to %s", "hard",
 					dst_name,
 					hard_link);
 		}
@@ -181,8 +182,9 @@ void FAST_FUNC data_extract_all(archive_
 		if (res != 0
 		 && !(archive_handle->ah_flags & ARCHIVE_EXTRACT_QUIET)
 		) {
+			/* shared message */
 			bb_perror_msg("can't create %slink "
-				"from %s to %s", "sym",
+				"%s to %s", "sym",
 				dst_name,
 				file_header->link_target);
 		}
diff -urpN busybox-1.26.2/archival/libarchive/decompress_bunzip2.c busybox-1.27.0/archival/libarchive/decompress_bunzip2.c
--- busybox-1.26.2/archival/libarchive/decompress_bunzip2.c	2016-09-27 18:53:50.000000000 +0200
+++ busybox-1.27.0/archival/libarchive/decompress_bunzip2.c	2017-07-01 22:51:12.000000000 +0200
@@ -134,7 +134,7 @@ static unsigned get_bits(bunzip_data *bd
 
 		/* Avoid 32-bit overflow (dump bit buffer to top of output) */
 		if (bit_count >= 24) {
-			bits = bd->inbufBits & ((1 << bit_count) - 1);
+			bits = bd->inbufBits & ((1U << bit_count) - 1);
 			bits_wanted -= bit_count;
 			bits <<= bits_wanted;
 			bit_count = 0;
@@ -158,11 +158,11 @@ static int get_next_block(bunzip_data *b
 {
 	struct group_data *hufGroup;
 	int dbufCount, dbufSize, groupCount, *base, *limit, selector,
-		i, j, t, runPos, symCount, symTotal, nSelectors, byteCount[256];
+		i, j, runPos, symCount, symTotal, nSelectors, byteCount[256];
 	int runCnt = runCnt; /* for compiler */
 	uint8_t uc, symToByte[256], mtfSymbol[256], *selectors;
 	uint32_t *dbuf;
-	unsigned origPtr;
+	unsigned origPtr, t;
 
 	dbuf = bd->dbuf;
 	dbufSize = bd->dbufSize;
@@ -308,7 +308,7 @@ static int get_next_block(bunzip_data *b
 		base = hufGroup->base - 1;
 		limit = hufGroup->limit - 1;
 
-		/* Calculate permute[].  Concurently, initialize temp[] and limit[]. */
+		/* Calculate permute[].  Concurrently, initialize temp[] and limit[]. */
 		pp = 0;
 		for (i = minLen; i <= maxLen; i++) {
 			int k;
diff -urpN busybox-1.26.2/archival/libarchive/decompress_unlzma.c busybox-1.27.0/archival/libarchive/decompress_unlzma.c
--- busybox-1.26.2/archival/libarchive/decompress_unlzma.c	2016-09-27 18:53:50.000000000 +0200
+++ busybox-1.27.0/archival/libarchive/decompress_unlzma.c	2017-01-09 16:01:33.000000000 +0100
@@ -278,9 +278,10 @@ unpack_lzma_stream(transformer_state_t *
 
 			if (state >= LZMA_NUM_LIT_STATES) {
 				int match_byte;
-				uint32_t pos = buffer_pos - rep0;
+				uint32_t pos;
 
-				while (pos >= header.dict_size)
+				pos = buffer_pos - rep0;
+				if ((int32_t)pos < 0)
 					pos += header.dict_size;
 				match_byte = buffer[pos];
 				do {
@@ -336,9 +337,11 @@ unpack_lzma_stream(transformer_state_t *
 					);
 					if (!rc_is_bit_1(rc, prob2)) {
 #if ENABLE_FEATURE_LZMA_FAST
-						uint32_t pos = buffer_pos - rep0;
+						uint32_t pos;
 						state = state < LZMA_NUM_LIT_STATES ? 9 : 11;
-						while (pos >= header.dict_size)
+
+						pos = buffer_pos - rep0;
+						if ((int32_t)pos < 0)
 							pos += header.dict_size;
 						previous_byte = buffer[pos];
 						goto one_byte1;
@@ -429,10 +432,25 @@ unpack_lzma_stream(transformer_state_t *
 			}
 
 			len += LZMA_MATCH_MIN_LEN;
+			/*
+			 * LZMA SDK has this optimized:
+			 * it precalculates size and copies many bytes
+			 * in a loop with simpler checks, a-la:
+			 *	do
+			 *		*(dest) = *(dest + ofs);
+			 *	while (++dest != lim);
+			 * and
+			 *	do {
+			 *		buffer[buffer_pos++] = buffer[pos];
+			 *		if (++pos == header.dict_size)
+			 *			pos = 0;
+			 *	} while (--cur_len != 0);
+			 * Our code is slower (more checks per byte copy):
+			 */
  IF_NOT_FEATURE_LZMA_FAST(string:)
 			do {
 				uint32_t pos = buffer_pos - rep0;
-				while (pos >= header.dict_size)
+				if ((int32_t)pos < 0)
 					pos += header.dict_size;
 				previous_byte = buffer[pos];
  IF_NOT_FEATURE_LZMA_FAST(one_byte2:)
@@ -448,6 +466,9 @@ unpack_lzma_stream(transformer_state_t *
 			} while (len != 0 && buffer_pos < header.dst_size);
 			/* FIXME: ...........^^^^^
 			 * shouldn't it be "global_pos + buffer_pos < header.dst_size"?
+			 * It probably should, but it is a "do we accidentally
+			 * unpack more bytes than expected?" check - which
+			 * never happens for well-formed compression data...
 			 */
 		}
 	}
diff -urpN busybox-1.26.2/archival/libarchive/unxz/xz_dec_lzma2.c busybox-1.27.0/archival/libarchive/unxz/xz_dec_lzma2.c
--- busybox-1.26.2/archival/libarchive/unxz/xz_dec_lzma2.c	2016-09-27 18:53:50.000000000 +0200
+++ busybox-1.27.0/archival/libarchive/unxz/xz_dec_lzma2.c	2017-07-01 22:51:12.000000000 +0200
@@ -486,11 +486,11 @@ static __always_inline void XZ_FUNC rc_n
 }
 
 /*
- * Decode one bit. In some versions, this function has been splitted in three
+ * Decode one bit. In some versions, this function has been split in three
  * functions so that the compiler is supposed to be able to more easily avoid
  * an extra branch. In this particular version of the LZMA decoder, this
  * doesn't seem to be a good idea (tested with GCC 3.3.6, 3.4.6, and 4.3.3
- * on x86). Using a non-splitted version results in nicer looking code too.
+ * on x86). Using a non-split version results in nicer looking code too.
  *
  * NOTE: This must return an int. Do not make it return a bool or the speed
  * of the code generated by GCC 3.x decreases 10-15 %. (GCC 4.3 doesn't care,
diff -urpN busybox-1.26.2/archival/lzop.c busybox-1.27.0/archival/lzop.c
--- busybox-1.26.2/archival/lzop.c	2016-12-10 18:46:36.000000000 +0100
+++ busybox-1.27.0/archival/lzop.c	2017-07-01 22:51:12.000000000 +0200
@@ -33,13 +33,13 @@
 //config:
 //config:config UNLZOP
 //config:	bool "unlzop"
-//config:	default y
+//config:	default n  # INCOMPAT: upstream lzop does not provide such tool
 //config:	help
 //config:	  Lzop decompresion.
 //config:
 //config:config LZOPCAT
 //config:	bool "lzopcat"
-//config:	default y
+//config:	default n  # INCOMPAT: upstream lzop does not provide such tool
 //config:	help
 //config:	  Alias to "unlzop -c".
 //config:
@@ -53,19 +53,22 @@
 //config:	  and take up 3.2K of code.
 
 //applet:IF_LZOP(APPLET(lzop, BB_DIR_BIN, BB_SUID_DROP))
-//applet:IF_UNLZOP(APPLET_ODDNAME(unlzop, lzop, BB_DIR_USR_BIN, BB_SUID_DROP, unlzop))
+//                  APPLET_ODDNAME:name     main  location        suid_type     help
+//applet:IF_UNLZOP( APPLET_ODDNAME(unlzop,  lzop, BB_DIR_USR_BIN, BB_SUID_DROP, unlzop))
 //applet:IF_LZOPCAT(APPLET_ODDNAME(lzopcat, lzop, BB_DIR_USR_BIN, BB_SUID_DROP, lzopcat))
 //kbuild:lib-$(CONFIG_LZOP) += lzop.o
 //kbuild:lib-$(CONFIG_UNLZOP) += lzop.o
 //kbuild:lib-$(CONFIG_LZOPCAT) += lzop.o
 
 //usage:#define lzop_trivial_usage
-//usage:       "[-cfvd123456789CF] [FILE]..."
+//usage:       "[-cfUvd123456789CF] [FILE]..."
 //usage:#define lzop_full_usage "\n\n"
 //usage:       "	-1..9	Compression level"
 //usage:     "\n	-d	Decompress"
 //usage:     "\n	-c	Write to stdout"
 //usage:     "\n	-f	Force"
+//usage:     "\n	-U	Delete input files"
+///////:     "\n	-k	Keep input files" (default, so why bother documenting?)
 //usage:     "\n	-v	Verbose"
 //usage:     "\n	-F	Don't store or verify checksum"
 //usage:     "\n	-C	Also write checksum of compressed block"
@@ -77,10 +80,12 @@
 //usage:     "\n	-F	Don't verify checksum"
 //usage:
 //usage:#define unlzop_trivial_usage
-//usage:       "[-cfvF] [FILE]..."
+//usage:       "[-cfkvF] [FILE]..."
 //usage:#define unlzop_full_usage "\n\n"
 //usage:       "	-c	Write to stdout"
 //usage:     "\n	-f	Force"
+//usage:     "\n	-U	Delete input files"
+///////:     "\n	-k	Keep input files" (default, so why bother documenting?)
 //usage:     "\n	-v	Verbose"
 //usage:     "\n	-F	Don't verify checksum"
 
@@ -471,27 +476,33 @@ struct globals {
 //#define LZOP_VERSION_STRING     "1.01"
 //#define LZOP_VERSION_DATE       "Apr 27th 2003"
 
-#define OPTION_STRING "cfvqdt123456789CF"
+// lzop wants to be weird:
+// unlike all other compressosrs, its -k "keep" option is the default,
+// and -U is used to delete the source. We will invert the bit after getopt().
+#define OPTION_STRING "cfUvqdt123456789CFk"
 
 /* Note: must be kept in sync with archival/bbunzip.c */
 enum {
 	OPT_STDOUT      = (1 << 0),
 	OPT_FORCE       = (1 << 1),
-	OPT_VERBOSE     = (1 << 2),
-	OPT_QUIET       = (1 << 3),
-	OPT_DECOMPRESS  = (1 << 4),
-	OPT_TEST        = (1 << 5),
-	OPT_1           = (1 << 6),
-	OPT_2           = (1 << 7),
-	OPT_3           = (1 << 8),
-	OPT_4           = (1 << 9),
-	OPT_5           = (1 << 10),
-	OPT_6           = (1 << 11),
-	OPT_789         = (7 << 12),
+	OPT_KEEP        = (1 << 2),
+	OPT_VERBOSE     = (1 << 3),
+	OPT_QUIET       = (1 << 4),
+	OPT_DECOMPRESS  = (1 << 5),
+	OPT_TEST        = (1 << 6),
+	OPT_1           = (1 << 7),
+	OPT_2           = (1 << 8),
+	OPT_3           = (1 << 9),
+	OPT_4           = (1 << 10),
+	OPT_5           = (1 << 11),
+	OPT_6           = (1 << 12),
 	OPT_7           = (1 << 13),
 	OPT_8           = (1 << 14),
-	OPT_C           = (1 << 15),
-	OPT_F           = (1 << 16),
+	OPT_9           = (1 << 15),
+	OPT_C           = (1 << 16),
+	OPT_F           = (1 << 17),
+	OPT_k           = (1 << 18),
+	OPT_789         = OPT_7 | OPT_8 | OPT_9
 };
 
 /**********************************************************************/
@@ -1124,6 +1135,13 @@ int lzop_main(int argc UNUSED_PARAM, cha
 {
 	getopt32(argv, OPTION_STRING);
 	argv += optind;
+	/* -U is "anti -k", invert bit for bbunpack(): */
+	option_mask32 ^= OPT_KEEP;
+	/* -k disables -U (if any): */
+	/* opt_complementary = "k-U"; - nope, only handles -Uk, not -kU */
+	if (option_mask32 & OPT_k)
+		option_mask32 |= OPT_KEEP;
+
 	/* lzopcat? */
 	if (ENABLE_LZOPCAT && applet_name[4] == 'c')
 		option_mask32 |= (OPT_STDOUT | OPT_DECOMPRESS);
diff -urpN busybox-1.26.2/archival/tar.c busybox-1.27.0/archival/tar.c
--- busybox-1.26.2/archival/tar.c	2016-09-27 18:53:50.000000000 +0200
+++ busybox-1.27.0/archival/tar.c	2017-07-01 22:51:12.000000000 +0200
@@ -49,13 +49,15 @@
 //config:	  create compressed archives. It's probably the most widely used
 //config:	  UNIX archive program.
 //config:
+//config:config FEATURE_TAR_LONG_OPTIONS
+//config:	bool "Enable long options"
+//config:	default y
+//config:	depends on TAR && LONG_OPTS
+//config:
 //config:config FEATURE_TAR_CREATE
-//config:	bool "Enable archive creation"
+//config:	bool "Enable -c (archive creation)"
 //config:	default y
 //config:	depends on TAR
-//config:	help
-//config:	  If you enable this option you'll be able to create
-//config:	  tar archives using the `-c' option.
 //config:
 //config:config FEATURE_TAR_AUTODETECT
 //config:	bool "Autodetect compressed tarballs"
@@ -74,7 +76,7 @@
 //config:	  a list of files to include or exclude from an archive.
 //config:
 //config:config FEATURE_TAR_OLDGNU_COMPATIBILITY
-//config:	bool "Support for old tar header format"
+//config:	bool "Support old tar header format"
 //config:	default y
 //config:	depends on TAR || DPKG
 //config:	help
@@ -93,22 +95,12 @@
 //config:	  tarballs still exist.
 //config:
 //config:config FEATURE_TAR_GNU_EXTENSIONS
-//config:	bool "Support for GNU tar extensions (long filenames)"
+//config:	bool "Support GNU tar extensions (long filenames)"
 //config:	default y
 //config:	depends on TAR || DPKG
-//config:	help
-//config:	  With this option busybox supports GNU long filenames and
-//config:	  linknames.
-//config:
-//config:config FEATURE_TAR_LONG_OPTIONS
-//config:	bool "Enable long options"
-//config:	default y
-//config:	depends on TAR && LONG_OPTS
-//config:	help
-//config:	  Enable use of long options, increases size by about 400 Bytes
 //config:
 //config:config FEATURE_TAR_TO_COMMAND
-//config:	bool "Support for writing to an external program"
+//config:	bool "Support writing to an external program (--to-command)"
 //config:	default y
 //config:	depends on TAR && FEATURE_TAR_LONG_OPTIONS
 //config:	help
@@ -121,20 +113,17 @@
 //config:	default y
 //config:	depends on TAR
 //config:	help
-//config:	  Enables use of user and group names in tar. This affects contents
+//config:	  Enable use of user and group names in tar. This affects contents
 //config:	  listings (-t) and preserving permissions when unpacking (-p).
 //config:	  +200 bytes.
 //config:
 //config:config FEATURE_TAR_NOPRESERVE_TIME
-//config:	bool "Enable -m (do not preserve time) option"
+//config:	bool "Enable -m (do not preserve time) GNU option"
 //config:	default y
 //config:	depends on TAR
-//config:	help
-//config:	  With this option busybox supports GNU tar -m
-//config:	  (do not preserve time) option.
 //config:
 //config:config FEATURE_TAR_SELINUX
-//config:	bool "Support for extracting SELinux labels"
+//config:	bool "Support extracting SELinux labels"
 //config:	default n
 //config:	depends on TAR && SELINUX
 //config:	help
@@ -540,8 +529,8 @@ static int FAST_FUNC writeFileToTarball(
 	/*
 	 * Check to see if we are dealing with a hard link.
 	 * If so -
-	 * Treat the first occurance of a given dev/inode as a file while
-	 * treating any additional occurances as hard links.  This is done
+	 * Treat the first occurrence of a given dev/inode as a file while
+	 * treating any additional occurrences as hard links.  This is done
 	 * by adding the file information to the HardLinkInfo linked list.
 	 */
 	tbInfo->hlInfo = NULL;
@@ -1227,21 +1216,26 @@ int tar_main(int argc UNUSED_PARAM, char
 		USE_FOR_MMU(IF_DESKTOP(long long) int FAST_FUNC (*xformer)(transformer_state_t *xstate);)
 		USE_FOR_NOMMU(const char *xformer_prog;)
 
-		if (opt & OPT_COMPRESS)
-			USE_FOR_MMU(xformer = unpack_Z_stream;)
+		if (opt & OPT_COMPRESS) {
+			USE_FOR_MMU(IF_FEATURE_SEAMLESS_Z(xformer = unpack_Z_stream;))
 			USE_FOR_NOMMU(xformer_prog = "uncompress";)
-		if (opt & OPT_GZIP)
-			USE_FOR_MMU(xformer = unpack_gz_stream;)
+		}
+		if (opt & OPT_GZIP) {
+			USE_FOR_MMU(IF_FEATURE_SEAMLESS_GZ(xformer = unpack_gz_stream;))
 			USE_FOR_NOMMU(xformer_prog = "gunzip";)
-		if (opt & OPT_BZIP2)
-			USE_FOR_MMU(xformer = unpack_bz2_stream;)
+		}
+		if (opt & OPT_BZIP2) {
+			USE_FOR_MMU(IF_FEATURE_SEAMLESS_BZ2(xformer = unpack_bz2_stream;))
 			USE_FOR_NOMMU(xformer_prog = "bunzip2";)
-		if (opt & OPT_LZMA)
-			USE_FOR_MMU(xformer = unpack_lzma_stream;)
+		}
+		if (opt & OPT_LZMA) {
+			USE_FOR_MMU(IF_FEATURE_SEAMLESS_LZMA(xformer = unpack_lzma_stream;))
 			USE_FOR_NOMMU(xformer_prog = "unlzma";)
-		if (opt & OPT_XZ)
-			USE_FOR_MMU(xformer = unpack_xz_stream;)
+		}
+		if (opt & OPT_XZ) {
+			USE_FOR_MMU(IF_FEATURE_SEAMLESS_XZ(xformer = unpack_xz_stream;))
 			USE_FOR_NOMMU(xformer_prog = "unxz";)
+		}
 
 		fork_transformer_with_sig(tar_handle->src_fd, xformer, xformer_prog);
 		/* Can't lseek over pipes */
diff -urpN busybox-1.26.2/archival/unzip.c busybox-1.27.0/archival/unzip.c
--- busybox-1.26.2/archival/unzip.c	2016-09-27 18:53:50.000000000 +0200
+++ busybox-1.27.0/archival/unzip.c	2017-04-05 18:27:36.000000000 +0200
@@ -16,7 +16,6 @@
  * TODO
  * Zip64 + other methods
  */
-
 //config:config UNZIP
 //config:	bool "unzip"
 //config:	default y
@@ -24,8 +23,34 @@
 //config:	  unzip will list or extract files from a ZIP archive,
 //config:	  commonly found on DOS/WIN systems. The default behavior
 //config:	  (with no options) is to extract the archive into the
-//config:	  current directory. Use the `-d' option to extract to a
-//config:	  directory of your choice.
+//config:	  current directory.
+//config:
+//config:config FEATURE_UNZIP_CDF
+//config:	bool "Read and use Central Directory data"
+//config:	default y
+//config:	depends on UNZIP
+//config:	help
+//config:	  If you know that you only need to deal with simple
+//config:	  ZIP files without deleted/updated files, SFX archives etc,
+//config:	  you can reduce code size by unselecting this option.
+//config:	  To support less trivial ZIPs, say Y.
+//config:
+//config:config FEATURE_UNZIP_BZIP2
+//config:	bool "Support compression method 12 (bzip2)"
+//config:	default y
+//config:	depends on FEATURE_UNZIP_CDF && DESKTOP
+// FEATURE_UNZIP_CDF is needed, otherwise we can't find start of next file
+// DESKTOP is needed to get back uncompressed length
+//config:
+//config:config FEATURE_UNZIP_LZMA
+//config:	bool "Support compression method 14 (lzma)"
+//config:	default y
+//config:	depends on FEATURE_UNZIP_CDF && DESKTOP
+//config:
+//config:config FEATURE_UNZIP_XZ
+//config:	bool "Support compression method 95 (xz)"
+//config:	default y
+//config:	depends on FEATURE_UNZIP_CDF && DESKTOP
 
 //applet:IF_UNZIP(APPLET(unzip, BB_DIR_USR_BIN, BB_SUID_DROP))
 //kbuild:lib-$(CONFIG_UNZIP) += unzip.o
@@ -54,8 +79,8 @@
 enum {
 #if BB_BIG_ENDIAN
 	ZIP_FILEHEADER_MAGIC = 0x504b0304,
-	ZIP_CDF_MAGIC        = 0x504b0102, /* central directory's file header */
-	ZIP_CDE_MAGIC        = 0x504b0506, /* "end of central directory" record */
+	ZIP_CDF_MAGIC        = 0x504b0102, /* CDF item */
+	ZIP_CDE_MAGIC        = 0x504b0506, /* End of CDF */
 	ZIP_DD_MAGIC         = 0x504b0708,
 #else
 	ZIP_FILEHEADER_MAGIC = 0x04034b50,
@@ -80,30 +105,20 @@ typedef union {
 		uint32_t ucmpsize PACKED;       /* 18-21 */
 		uint16_t filename_len;          /* 22-23 */
 		uint16_t extra_len;             /* 24-25 */
-	} formatted PACKED;
+		/* filename follows (not NUL terminated) */
+		/* extra field follows */
+		/* data follows */
+	} fmt PACKED;
 } zip_header_t; /* PACKED - gcc 4.2.1 doesn't like it (spews warning) */
 
-/* Check the offset of the last element, not the length.  This leniency
- * allows for poor packing, whereby the overall struct may be too long,
- * even though the elements are all in the right place.
- */
-struct BUG_zip_header_must_be_26_bytes {
-	char BUG_zip_header_must_be_26_bytes[
-		offsetof(zip_header_t, formatted.extra_len) + 2
-			== ZIP_HEADER_LEN ? 1 : -1];
-};
-
-#define FIX_ENDIANNESS_ZIP(zip_header) do { \
-	(zip_header).formatted.version      = SWAP_LE16((zip_header).formatted.version     ); \
-	(zip_header).formatted.method       = SWAP_LE16((zip_header).formatted.method      ); \
-	(zip_header).formatted.modtime      = SWAP_LE16((zip_header).formatted.modtime     ); \
-	(zip_header).formatted.moddate      = SWAP_LE16((zip_header).formatted.moddate     ); \
-	(zip_header).formatted.crc32        = SWAP_LE32((zip_header).formatted.crc32       ); \
-	(zip_header).formatted.cmpsize      = SWAP_LE32((zip_header).formatted.cmpsize     ); \
-	(zip_header).formatted.ucmpsize     = SWAP_LE32((zip_header).formatted.ucmpsize    ); \
-	(zip_header).formatted.filename_len = SWAP_LE16((zip_header).formatted.filename_len); \
-	(zip_header).formatted.extra_len    = SWAP_LE16((zip_header).formatted.extra_len   ); \
-} while (0)
+#define FIX_ENDIANNESS_ZIP(zip) \
+do { if (BB_BIG_ENDIAN) { \
+	(zip).fmt.crc32         = SWAP_LE32((zip).fmt.crc32       ); \
+	(zip).fmt.cmpsize       = SWAP_LE32((zip).fmt.cmpsize     ); \
+	(zip).fmt.ucmpsize      = SWAP_LE32((zip).fmt.ucmpsize    ); \
+	(zip).fmt.filename_len  = SWAP_LE16((zip).fmt.filename_len); \
+	(zip).fmt.extra_len     = SWAP_LE16((zip).fmt.extra_len   ); \
+}} while (0)
 
 #define CDF_HEADER_LEN 42
 
@@ -115,44 +130,44 @@ typedef union {
 		uint16_t version_needed;        /* 2-3 */
 		uint16_t cdf_flags;             /* 4-5 */
 		uint16_t method;                /* 6-7 */
-		uint16_t mtime;                 /* 8-9 */
-		uint16_t mdate;                 /* 10-11 */
+		uint16_t modtime;               /* 8-9 */
+		uint16_t moddate;               /* 10-11 */
 		uint32_t crc32;                 /* 12-15 */
 		uint32_t cmpsize;               /* 16-19 */
 		uint32_t ucmpsize;              /* 20-23 */
-		uint16_t file_name_length;      /* 24-25 */
-		uint16_t extra_field_length;    /* 26-27 */
+		uint16_t filename_len;          /* 24-25 */
+		uint16_t extra_len;             /* 26-27 */
 		uint16_t file_comment_length;   /* 28-29 */
 		uint16_t disk_number_start;     /* 30-31 */
-		uint16_t internal_file_attributes; /* 32-33 */
-		uint32_t external_file_attributes PACKED; /* 34-37 */
+		uint16_t internal_attributes;   /* 32-33 */
+		uint32_t external_attributes PACKED; /* 34-37 */
 		uint32_t relative_offset_of_local_header PACKED; /* 38-41 */
-	} formatted PACKED;
+		/* filename follows (not NUL terminated) */
+		/* extra field follows */
+		/* file comment follows */
+	} fmt PACKED;
 } cdf_header_t;
 
-struct BUG_cdf_header_must_be_42_bytes {
-	char BUG_cdf_header_must_be_42_bytes[
-		offsetof(cdf_header_t, formatted.relative_offset_of_local_header) + 4
-			== CDF_HEADER_LEN ? 1 : -1];
-};
-
-#define FIX_ENDIANNESS_CDF(cdf_header) do { \
-	(cdf_header).formatted.crc32        = SWAP_LE32((cdf_header).formatted.crc32       ); \
-	(cdf_header).formatted.cmpsize      = SWAP_LE32((cdf_header).formatted.cmpsize     ); \
-	(cdf_header).formatted.ucmpsize     = SWAP_LE32((cdf_header).formatted.ucmpsize    ); \
-	(cdf_header).formatted.file_name_length = SWAP_LE16((cdf_header).formatted.file_name_length); \
-	(cdf_header).formatted.extra_field_length = SWAP_LE16((cdf_header).formatted.extra_field_length); \
-	(cdf_header).formatted.file_comment_length = SWAP_LE16((cdf_header).formatted.file_comment_length); \
-	IF_DESKTOP( \
-	(cdf_header).formatted.version_made_by = SWAP_LE16((cdf_header).formatted.version_made_by); \
-	(cdf_header).formatted.external_file_attributes = SWAP_LE32((cdf_header).formatted.external_file_attributes); \
-	) \
-} while (0)
+#define FIX_ENDIANNESS_CDF(cdf) \
+do { if (BB_BIG_ENDIAN) { \
+	(cdf).fmt.version_made_by = SWAP_LE16((cdf).fmt.version_made_by); \
+	(cdf).fmt.version_needed = SWAP_LE16((cdf).fmt.version_needed); \
+	(cdf).fmt.method        = SWAP_LE16((cdf).fmt.method      ); \
+	(cdf).fmt.modtime       = SWAP_LE16((cdf).fmt.modtime     ); \
+	(cdf).fmt.moddate       = SWAP_LE16((cdf).fmt.moddate     ); \
+	(cdf).fmt.crc32         = SWAP_LE32((cdf).fmt.crc32       ); \
+	(cdf).fmt.cmpsize       = SWAP_LE32((cdf).fmt.cmpsize     ); \
+	(cdf).fmt.ucmpsize      = SWAP_LE32((cdf).fmt.ucmpsize    ); \
+	(cdf).fmt.filename_len  = SWAP_LE16((cdf).fmt.filename_len); \
+	(cdf).fmt.extra_len     = SWAP_LE16((cdf).fmt.extra_len   ); \
+	(cdf).fmt.file_comment_length = SWAP_LE16((cdf).fmt.file_comment_length); \
+	(cdf).fmt.external_attributes = SWAP_LE32((cdf).fmt.external_attributes); \
+}} while (0)
 
-#define CDE_HEADER_LEN 16
+#define CDE_LEN 16
 
 typedef union {
-	uint8_t raw[CDE_HEADER_LEN];
+	uint8_t raw[CDE_LEN];
 	struct {
 		/* uint32_t signature; 50 4b 05 06 */
 		uint16_t this_disk_no;
@@ -161,25 +176,43 @@ typedef union {
 		uint16_t cdf_entries_total;
 		uint32_t cdf_size;
 		uint32_t cdf_offset;
-		/* uint16_t file_comment_length; */
-		/* .ZIP file comment (variable size) */
-	} formatted PACKED;
-} cde_header_t;
-
-struct BUG_cde_header_must_be_16_bytes {
-	char BUG_cde_header_must_be_16_bytes[
-		sizeof(cde_header_t) == CDE_HEADER_LEN ? 1 : -1];
+		/* uint16_t archive_comment_length; */
+		/* archive comment follows */
+	} fmt PACKED;
+} cde_t;
+
+#define FIX_ENDIANNESS_CDE(cde) \
+do { if (BB_BIG_ENDIAN) { \
+	(cde).fmt.cdf_offset = SWAP_LE32((cde).fmt.cdf_offset); \
+}} while (0)
+
+struct BUG {
+	/* Check the offset of the last element, not the length.  This leniency
+	 * allows for poor packing, whereby the overall struct may be too long,
+	 * even though the elements are all in the right place.
+	 */
+	char BUG_zip_header_must_be_26_bytes[
+		offsetof(zip_header_t, fmt.extra_len) + 2
+			== ZIP_HEADER_LEN ? 1 : -1];
+	char BUG_cdf_header_must_be_42_bytes[
+		offsetof(cdf_header_t, fmt.relative_offset_of_local_header) + 4
+			== CDF_HEADER_LEN ? 1 : -1];
+	char BUG_cde_must_be_16_bytes[
+		sizeof(cde_t) == CDE_LEN ? 1 : -1];
 };
 
-#define FIX_ENDIANNESS_CDE(cde_header) do { \
-	(cde_header).formatted.cdf_offset = SWAP_LE32((cde_header).formatted.cdf_offset); \
-} while (0)
 
 enum { zip_fd = 3 };
 
 
-#if ENABLE_DESKTOP
+/* This value means that we failed to find CDF */
+#define BAD_CDF_OFFSET ((uint32_t)0xffffffff)
+
+#if !ENABLE_FEATURE_UNZIP_CDF
+
+# define find_cdf_offset() BAD_CDF_OFFSET
 
+#else
 /* Seen in the wild:
  * Self-extracting PRO2K3XP_32.exe contains 19078464 byte zip archive,
  * where CDE was nearly 48 kbytes before EOF.
@@ -188,30 +221,31 @@ enum { zip_fd = 3 };
  * To make extraction work, bumped PEEK_FROM_END from 16k to 64k.
  */
 #define PEEK_FROM_END (64*1024)
-
-/* This value means that we failed to find CDF */
-#define BAD_CDF_OFFSET ((uint32_t)0xffffffff)
-
 /* NB: does not preserve file position! */
 static uint32_t find_cdf_offset(void)
 {
-	cde_header_t cde_header;
+	cde_t cde;
+	unsigned char *buf;
 	unsigned char *p;
 	off_t end;
-	unsigned char *buf = xzalloc(PEEK_FROM_END);
 	uint32_t found;
 
-	end = xlseek(zip_fd, 0, SEEK_END);
+	end = lseek(zip_fd, 0, SEEK_END);
+	if (end == (off_t) -1)
+		return BAD_CDF_OFFSET;
+
 	end -= PEEK_FROM_END;
 	if (end < 0)
 		end = 0;
+
 	dbg("Looking for cdf_offset starting from 0x%"OFF_FMT"x", end);
- 	xlseek(zip_fd, end, SEEK_SET);
+	xlseek(zip_fd, end, SEEK_SET);
+	buf = xzalloc(PEEK_FROM_END);
 	full_read(zip_fd, buf, PEEK_FROM_END);
 
 	found = BAD_CDF_OFFSET;
 	p = buf;
-	while (p <= buf + PEEK_FROM_END - CDE_HEADER_LEN - 4) {
+	while (p <= buf + PEEK_FROM_END - CDE_LEN - 4) {
 		if (*p != 'P') {
 			p++;
 			continue;
@@ -223,19 +257,19 @@ static uint32_t find_cdf_offset(void)
 		if (*++p != 6)
 			continue;
 		/* we found CDE! */
-		memcpy(cde_header.raw, p + 1, CDE_HEADER_LEN);
-		FIX_ENDIANNESS_CDE(cde_header);
+		memcpy(cde.raw, p + 1, CDE_LEN);
+		FIX_ENDIANNESS_CDE(cde);
 		/*
 		 * I've seen .ZIP files with seemingly valid CDEs
 		 * where cdf_offset points past EOF - ??
 		 * This check ignores such CDEs:
 		 */
-		if (cde_header.formatted.cdf_offset < end + (p - buf)) {
-			found = cde_header.formatted.cdf_offset;
+		if (cde.fmt.cdf_offset < end + (p - buf)) {
+			found = cde.fmt.cdf_offset;
 			dbg("Possible cdf_offset:0x%x at 0x%"OFF_FMT"x",
 				(unsigned)found, end + (p-3 - buf));
 			dbg("  cdf_offset+cdf_size:0x%x",
-				(unsigned)(found + SWAP_LE32(cde_header.formatted.cdf_size)));
+				(unsigned)(found + SWAP_LE32(cde.fmt.cdf_size)));
 			/*
 			 * We do not "break" here because only the last CDE is valid.
 			 * I've seen a .zip archive which contained a .zip file,
@@ -249,33 +283,36 @@ static uint32_t find_cdf_offset(void)
 	return found;
 };
 
-static uint32_t read_next_cdf(uint32_t cdf_offset, cdf_header_t *cdf_ptr)
+static uint32_t read_next_cdf(uint32_t cdf_offset, cdf_header_t *cdf)
 {
-	off_t org;
-
-	org = xlseek(zip_fd, 0, SEEK_CUR);
+	uint32_t magic;
 
-	if (!cdf_offset)
-		cdf_offset = find_cdf_offset();
+	if (cdf_offset == BAD_CDF_OFFSET)
+		return cdf_offset;
 
-	if (cdf_offset != BAD_CDF_OFFSET) {
-		dbg("Reading CDF at 0x%x", (unsigned)cdf_offset);
-		xlseek(zip_fd, cdf_offset + 4, SEEK_SET);
-		xread(zip_fd, cdf_ptr->raw, CDF_HEADER_LEN);
-		FIX_ENDIANNESS_CDF(*cdf_ptr);
-		dbg("  file_name_length:%u extra_field_length:%u file_comment_length:%u",
-			(unsigned)cdf_ptr->formatted.file_name_length,
-			(unsigned)cdf_ptr->formatted.extra_field_length,
-			(unsigned)cdf_ptr->formatted.file_comment_length
-		);
-		cdf_offset += 4 + CDF_HEADER_LEN
-			+ cdf_ptr->formatted.file_name_length
-			+ cdf_ptr->formatted.extra_field_length
-			+ cdf_ptr->formatted.file_comment_length;
+	dbg("Reading CDF at 0x%x", (unsigned)cdf_offset);
+	xlseek(zip_fd, cdf_offset, SEEK_SET);
+	xread(zip_fd, &magic, 4);
+	/* Central Directory End? Assume CDF has ended.
+	 * (more correct method is to use cde.cdf_entries_total counter)
+	 */
+	if (magic == ZIP_CDE_MAGIC) {
+		dbg("got ZIP_CDE_MAGIC");
+		return 0; /* EOF */
 	}
+	xread(zip_fd, cdf->raw, CDF_HEADER_LEN);
+
+	FIX_ENDIANNESS_CDF(*cdf);
+	dbg("  filename_len:%u extra_len:%u file_comment_length:%u",
+		(unsigned)cdf->fmt.filename_len,
+		(unsigned)cdf->fmt.extra_len,
+		(unsigned)cdf->fmt.file_comment_length
+	);
+	cdf_offset += 4 + CDF_HEADER_LEN
+		+ cdf->fmt.filename_len
+		+ cdf->fmt.extra_len
+		+ cdf->fmt.file_comment_length;
 
-	dbg("Returning file position to 0x%"OFF_FMT"x", org);
-	xlseek(zip_fd, org, SEEK_SET);
 	return cdf_offset;
 };
 #endif
@@ -297,32 +334,66 @@ static void unzip_create_leading_dirs(co
 	free(name);
 }
 
-static void unzip_extract(zip_header_t *zip_header, int dst_fd)
+static void unzip_extract(zip_header_t *zip, int dst_fd)
 {
-	if (zip_header->formatted.method == 0) {
+	transformer_state_t xstate;
+
+	if (zip->fmt.method == 0) {
 		/* Method 0 - stored (not compressed) */
-		off_t size = zip_header->formatted.ucmpsize;
+		off_t size = zip->fmt.ucmpsize;
 		if (size)
 			bb_copyfd_exact_size(zip_fd, dst_fd, size);
-	} else {
+		return;
+	}
+
+	init_transformer_state(&xstate);
+	xstate.bytes_in = zip->fmt.cmpsize;
+	xstate.src_fd = zip_fd;
+	xstate.dst_fd = dst_fd;
+	if (zip->fmt.method == 8) {
 		/* Method 8 - inflate */
-		transformer_state_t xstate;
-		init_transformer_state(&xstate);
-		xstate.bytes_in = zip_header->formatted.cmpsize;
-		xstate.src_fd = zip_fd;
-		xstate.dst_fd = dst_fd;
 		if (inflate_unzip(&xstate) < 0)
 			bb_error_msg_and_die("inflate error");
 		/* Validate decompression - crc */
-		if (zip_header->formatted.crc32 != (xstate.crc32 ^ 0xffffffffL)) {
+		if (zip->fmt.crc32 != (xstate.crc32 ^ 0xffffffffL)) {
 			bb_error_msg_and_die("crc error");
 		}
-		/* Validate decompression - size */
-		if (zip_header->formatted.ucmpsize != xstate.bytes_out) {
-			/* Don't die. Who knows, maybe len calculation
-			 * was botched somewhere. After all, crc matched! */
-			bb_error_msg("bad length");
-		}
+	}
+#if ENABLE_FEATURE_UNZIP_BZIP2
+	else if (zip->fmt.method == 12) {
+		/* Tested. Unpacker reads too much, but we use CDF
+		 * and will seek to the correct beginning of next file.
+		 */
+		xstate.bytes_out = unpack_bz2_stream(&xstate);
+		if (xstate.bytes_out < 0)
+			bb_error_msg_and_die("inflate error");
+	}
+#endif
+#if ENABLE_FEATURE_UNZIP_LZMA
+	else if (zip->fmt.method == 14) {
+		/* Not tested yet */
+		xstate.bytes_out = unpack_lzma_stream(&xstate);
+		if (xstate.bytes_out < 0)
+			bb_error_msg_and_die("inflate error");
+	}
+#endif
+#if ENABLE_FEATURE_UNZIP_XZ
+	else if (zip->fmt.method == 95) {
+		/* Not tested yet */
+		xstate.bytes_out = unpack_xz_stream(&xstate);
+		if (xstate.bytes_out < 0)
+			bb_error_msg_and_die("inflate error");
+	}
+#endif
+	else {
+		bb_error_msg_and_die("unsupported method %u", zip->fmt.method);
+	}
+
+	/* Validate decompression - size */
+	if (zip->fmt.ucmpsize != xstate.bytes_out) {
+		/* Don't die. Who knows, maybe len calculation
+		 * was botched somewhere. After all, crc matched! */
+		bb_error_msg("bad length");
 	}
 }
 
@@ -339,15 +410,12 @@ int unzip_main(int argc, char **argv)
 {
 	enum { O_PROMPT, O_NEVER, O_ALWAYS };
 
-	zip_header_t zip_header;
 	smallint quiet = 0;
-	IF_NOT_DESKTOP(const) smallint verbose = 0;
+	IF_NOT_FEATURE_UNZIP_CDF(const) smallint verbose = 0;
 	smallint listing = 0;
 	smallint overwrite = O_PROMPT;
 	smallint x_opt_seen;
-#if ENABLE_DESKTOP
 	uint32_t cdf_offset;
-#endif
 	unsigned long total_usize;
 	unsigned long total_size;
 	unsigned total_entries;
@@ -430,7 +498,7 @@ int unzip_main(int argc, char **argv)
 			break;
 
 		case 'v': /* Verbose list */
-			IF_DESKTOP(verbose++;)
+			IF_FEATURE_UNZIP_CDF(verbose++;)
 			listing = 1;
 			break;
 
@@ -545,91 +613,114 @@ int unzip_main(int argc, char **argv)
 	total_usize = 0;
 	total_size = 0;
 	total_entries = 0;
-#if ENABLE_DESKTOP
-	cdf_offset = 0;
-#endif
+	cdf_offset = find_cdf_offset();	/* try to seek to the end, find CDE and CDF start */
 	while (1) {
-		uint32_t magic;
+		zip_header_t zip;
 		mode_t dir_mode = 0777;
-#if ENABLE_DESKTOP
+#if ENABLE_FEATURE_UNZIP_CDF
 		mode_t file_mode = 0666;
 #endif
 
-		/* Check magic number */
-		xread(zip_fd, &magic, 4);
-		/* Central directory? It's at the end, so exit */
-		if (magic == ZIP_CDF_MAGIC) {
-			dbg("got ZIP_CDF_MAGIC");
-			break;
-		}
-#if ENABLE_DESKTOP
-		/* Data descriptor? It was a streaming file, go on */
-		if (magic == ZIP_DD_MAGIC) {
-			dbg("got ZIP_DD_MAGIC");
-			/* skip over duplicate crc32, cmpsize and ucmpsize */
-			unzip_skip(3 * 4);
-			continue;
-		}
-#endif
-		if (magic != ZIP_FILEHEADER_MAGIC)
-			bb_error_msg_and_die("invalid zip magic %08X", (int)magic);
-		dbg("got ZIP_FILEHEADER_MAGIC");
-
-		/* Read the file header */
-		xread(zip_fd, zip_header.raw, ZIP_HEADER_LEN);
-		FIX_ENDIANNESS_ZIP(zip_header);
-		if ((zip_header.formatted.method != 0) && (zip_header.formatted.method != 8)) {
-			bb_error_msg_and_die("unsupported method %d", zip_header.formatted.method);
-		}
-#if !ENABLE_DESKTOP
-		if (zip_header.formatted.zip_flags & SWAP_LE16(0x0009)) {
-			bb_error_msg_and_die("zip flags 1 and 8 are not supported");
-		}
-#else
-		if (zip_header.formatted.zip_flags & SWAP_LE16(0x0001)) {
-			/* 0x0001 - encrypted */
-			bb_error_msg_and_die("zip flag 1 (encryption) is not supported");
-		}
-
-		if (cdf_offset != BAD_CDF_OFFSET) {
-			cdf_header_t cdf_header;
-			cdf_offset = read_next_cdf(cdf_offset, &cdf_header);
-			/*
-			 * Note: cdf_offset can become BAD_CDF_OFFSET after the above call.
+		if (!ENABLE_FEATURE_UNZIP_CDF || cdf_offset == BAD_CDF_OFFSET) {
+			/* Normally happens when input is unseekable.
+			 *
+			 * Valid ZIP file has Central Directory at the end
+			 * with central directory file headers (CDFs).
+			 * After it, there is a Central Directory End structure.
+			 * CDFs identify what files are in the ZIP and where
+			 * they are located. This allows ZIP readers to load
+			 * the list of files without reading the entire ZIP archive.
+			 * ZIP files may be appended to, only files specified in
+			 * the CD are valid. Scanning for local file headers is
+			 * not a correct algorithm.
+			 *
+			 * We try to do the above, and resort to "linear" reading
+			 * of ZIP file only if seek failed or CDE wasn't found.
 			 */
-			if (zip_header.formatted.zip_flags & SWAP_LE16(0x0008)) {
+			uint32_t magic;
+
+			/* Check magic number */
+			xread(zip_fd, &magic, 4);
+			/* CDF item? Assume there are no more files, exit */
+			if (magic == ZIP_CDF_MAGIC) {
+				dbg("got ZIP_CDF_MAGIC");
+				break;
+			}
+			/* Data descriptor? It was a streaming file, go on */
+			if (magic == ZIP_DD_MAGIC) {
+				dbg("got ZIP_DD_MAGIC");
+				/* skip over duplicate crc32, cmpsize and ucmpsize */
+				unzip_skip(3 * 4);
+				continue;
+			}
+			if (magic != ZIP_FILEHEADER_MAGIC)
+				bb_error_msg_and_die("invalid zip magic %08X", (int)magic);
+			dbg("got ZIP_FILEHEADER_MAGIC");
+
+			xread(zip_fd, zip.raw, ZIP_HEADER_LEN);
+			FIX_ENDIANNESS_ZIP(zip);
+			if (zip.fmt.zip_flags & SWAP_LE16(0x0008)) {
+				bb_error_msg_and_die("zip flag %s is not supported",
+					"8 (streaming)");
+			}
+		}
+#if ENABLE_FEATURE_UNZIP_CDF
+		else {
+			/* cdf_offset is valid (and we know the file is seekable) */
+			cdf_header_t cdf;
+			cdf_offset = read_next_cdf(cdf_offset, &cdf);
+			if (cdf_offset == 0) /* EOF? */
+				break;
+# if 1
+			xlseek(zip_fd,
+				SWAP_LE32(cdf.fmt.relative_offset_of_local_header) + 4,
+				SEEK_SET);
+			xread(zip_fd, zip.raw, ZIP_HEADER_LEN);
+			FIX_ENDIANNESS_ZIP(zip);
+			if (zip.fmt.zip_flags & SWAP_LE16(0x0008)) {
 				/* 0x0008 - streaming. [u]cmpsize can be reliably gotten
-				 * only from Central Directory. See unzip_doc.txt
+				 * only from Central Directory.
 				 */
-				zip_header.formatted.crc32    = cdf_header.formatted.crc32;
-				zip_header.formatted.cmpsize  = cdf_header.formatted.cmpsize;
-				zip_header.formatted.ucmpsize = cdf_header.formatted.ucmpsize;
+				zip.fmt.crc32    = cdf.fmt.crc32;
+				zip.fmt.cmpsize  = cdf.fmt.cmpsize;
+				zip.fmt.ucmpsize = cdf.fmt.ucmpsize;
 			}
-			if ((cdf_header.formatted.version_made_by >> 8) == 3) {
+# else
+			/* CDF has the same data as local header, no need to read the latter...
+			 * ...not really. An archive was seen with cdf.extra_len == 6 but
+			 * zip.extra_len == 0.
+			 */
+			memcpy(&zip.fmt.version,
+				&cdf.fmt.version_needed, ZIP_HEADER_LEN);
+			xlseek(zip_fd,
+				SWAP_LE32(cdf.fmt.relative_offset_of_local_header) + 4 + ZIP_HEADER_LEN,
+				SEEK_SET);
+# endif
+			if ((cdf.fmt.version_made_by >> 8) == 3) {
 				/* This archive is created on Unix */
-				dir_mode = file_mode = (cdf_header.formatted.external_file_attributes >> 16);
+				dir_mode = file_mode = (cdf.fmt.external_attributes >> 16);
 			}
 		}
-		if (cdf_offset == BAD_CDF_OFFSET
-		 && (zip_header.formatted.zip_flags & SWAP_LE16(0x0008))
-		) {
-			/* If it's a streaming zip, we _require_ CDF */
-			bb_error_msg_and_die("can't find file table");
-		}
 #endif
+
+		if (zip.fmt.zip_flags & SWAP_LE16(0x0001)) {
+			/* 0x0001 - encrypted */
+			bb_error_msg_and_die("zip flag %s is not supported",
+					"1 (encryption)");
+		}
 		dbg("File cmpsize:0x%x extra_len:0x%x ucmpsize:0x%x",
-			(unsigned)zip_header.formatted.cmpsize,
-			(unsigned)zip_header.formatted.extra_len,
-			(unsigned)zip_header.formatted.ucmpsize
+			(unsigned)zip.fmt.cmpsize,
+			(unsigned)zip.fmt.extra_len,
+			(unsigned)zip.fmt.ucmpsize
 		);
 
 		/* Read filename */
 		free(dst_fn);
-		dst_fn = xzalloc(zip_header.formatted.filename_len + 1);
-		xread(zip_fd, dst_fn, zip_header.formatted.filename_len);
+		dst_fn = xzalloc(zip.fmt.filename_len + 1);
+		xread(zip_fd, dst_fn, zip.fmt.filename_len);
 
 		/* Skip extra header bytes */
-		unzip_skip(zip_header.formatted.extra_len);
+		unzip_skip(zip.fmt.extra_len);
 
 		/* Guard against "/abspath", "/../" and similar attacks */
 		overlapping_strcpy(dst_fn, strip_unsafe_prefix(dst_fn));
@@ -638,129 +729,129 @@ int unzip_main(int argc, char **argv)
 		if (find_list_entry(zreject, dst_fn)
 		 || (zaccept && !find_list_entry(zaccept, dst_fn))
 		) { /* Skip entry */
-			i = 'n';
-		} else {
-			if (listing) {
-				/* List entry */
-				char dtbuf[sizeof("mm-dd-yyyy hh:mm")];
-				sprintf(dtbuf, "%02u-%02u-%04u %02u:%02u",
-					(zip_header.formatted.moddate >> 5) & 0xf,  // mm: 0x01e0
-					(zip_header.formatted.moddate)      & 0x1f, // dd: 0x001f
-					(zip_header.formatted.moddate >> 9) + 1980, // yy: 0xfe00
-					(zip_header.formatted.modtime >> 11),       // hh: 0xf800
-					(zip_header.formatted.modtime >> 5) & 0x3f  // mm: 0x07e0
-					// seconds/2 are not shown, encoded in ----------- 0x001f
-				);
-				if (!verbose) {
-					//      "  Length      Date    Time    Name\n"
-					//      "---------  ---------- -----   ----"
-					printf(       "%9u  " "%s   "         "%s\n",
-						(unsigned)zip_header.formatted.ucmpsize,
-						dtbuf,
-						dst_fn);
-				} else {
-					unsigned long percents = zip_header.formatted.ucmpsize - zip_header.formatted.cmpsize;
-					if ((int32_t)percents < 0)
-						percents = 0; /* happens if ucmpsize < cmpsize */
-					percents = percents * 100;
-					if (zip_header.formatted.ucmpsize)
-						percents /= zip_header.formatted.ucmpsize;
-					//      " Length   Method    Size  Cmpr    Date    Time   CRC-32   Name\n"
-					//      "--------  ------  ------- ---- ---------- ----- --------  ----"
-					printf(      "%8u  %s"        "%9u%4u%% " "%s "         "%08x  "  "%s\n",
-						(unsigned)zip_header.formatted.ucmpsize,
-						zip_header.formatted.method == 0 ? "Stored" : "Defl:N", /* Defl is method 8 */
-/* TODO: show other methods?
- *  1 - Shrunk
- *  2 - Reduced with compression factor 1
- *  3 - Reduced with compression factor 2
- *  4 - Reduced with compression factor 3
- *  5 - Reduced with compression factor 4
- *  6 - Imploded
- *  7 - Reserved for Tokenizing compression algorithm
- *  9 - Deflate64
- * 10 - PKWARE Data Compression Library Imploding
- * 11 - Reserved by PKWARE
- * 12 - BZIP2
- */
-						(unsigned)zip_header.formatted.cmpsize,
-						(unsigned)percents,
-						dtbuf,
-						zip_header.formatted.crc32,
-						dst_fn);
-					total_size += zip_header.formatted.cmpsize;
+			goto skip_cmpsize;
+		}
+
+		if (listing) {
+			/* List entry */
+			char dtbuf[sizeof("mm-dd-yyyy hh:mm")];
+			sprintf(dtbuf, "%02u-%02u-%04u %02u:%02u",
+				(zip.fmt.moddate >> 5) & 0xf,  // mm: 0x01e0
+				(zip.fmt.moddate)      & 0x1f, // dd: 0x001f
+				(zip.fmt.moddate >> 9) + 1980, // yy: 0xfe00
+				(zip.fmt.modtime >> 11),       // hh: 0xf800
+				(zip.fmt.modtime >> 5) & 0x3f  // mm: 0x07e0
+				// seconds/2 not shown, encoded in -- 0x001f
+			);
+			if (!verbose) {
+				//      "  Length      Date    Time    Name\n"
+				//      "---------  ---------- -----   ----"
+				printf(       "%9u  " "%s   "         "%s\n",
+					(unsigned)zip.fmt.ucmpsize,
+					dtbuf,
+					dst_fn);
+			} else {
+				char method6[7];
+				unsigned long percents;
+
+				sprintf(method6, "%6u", zip.fmt.method);
+				if (zip.fmt.method == 0) {
+					strcpy(method6, "Stored");
+				}
+				if (zip.fmt.method == 8) {
+					strcpy(method6, "Defl:N");
+					/* normal, maximum, fast, superfast */
+					IF_DESKTOP(method6[5] = "NXFS"[(zip.fmt.zip_flags >> 1) & 3];)
+				}
+				percents = zip.fmt.ucmpsize - zip.fmt.cmpsize;
+				if ((int32_t)percents < 0)
+					percents = 0; /* happens if ucmpsize < cmpsize */
+				percents = percents * 100;
+				if (zip.fmt.ucmpsize)
+					percents /= zip.fmt.ucmpsize;
+				//      " Length   Method    Size  Cmpr    Date    Time   CRC-32   Name\n"
+				//      "--------  ------  ------- ---- ---------- ----- --------  ----"
+				printf(      "%8u  %s"        "%9u%4u%% " "%s "         "%08x  "  "%s\n",
+					(unsigned)zip.fmt.ucmpsize,
+					method6,
+					(unsigned)zip.fmt.cmpsize,
+					(unsigned)percents,
+					dtbuf,
+					zip.fmt.crc32,
+					dst_fn);
+				total_size += zip.fmt.cmpsize;
+			}
+			total_usize += zip.fmt.ucmpsize;
+			goto skip_cmpsize;
+		}
+
+		if (dst_fd == STDOUT_FILENO) {
+			/* Extracting to STDOUT */
+			goto do_extract;
+		}
+		if (last_char_is(dst_fn, '/')) {
+			/* Extract directory */
+			if (stat(dst_fn, &stat_buf) == -1) {
+				if (errno != ENOENT) {
+					bb_perror_msg_and_die("can't stat '%s'", dst_fn);
 				}
-				total_usize += zip_header.formatted.ucmpsize;
-				i = 'n';
-			} else if (dst_fd == STDOUT_FILENO) {
-				/* Extracting to STDOUT */
-				i = -1;
-			} else if (last_char_is(dst_fn, '/')) {
-				/* Extract directory */
-				if (stat(dst_fn, &stat_buf) == -1) {
-					if (errno != ENOENT) {
-						bb_perror_msg_and_die("can't stat '%s'", dst_fn);
-					}
-					if (!quiet) {
-						printf("   creating: %s\n", dst_fn);
-					}
-					unzip_create_leading_dirs(dst_fn);
-					if (bb_make_directory(dst_fn, dir_mode, FILEUTILS_IGNORE_CHMOD_ERR)) {
-						xfunc_die();
-					}
-				} else {
-					if (!S_ISDIR(stat_buf.st_mode)) {
-						bb_error_msg_and_die("'%s' exists but is not a %s",
-							dst_fn, "directory");
-					}
+				if (!quiet) {
+					printf("   creating: %s\n", dst_fn);
+				}
+				unzip_create_leading_dirs(dst_fn);
+				if (bb_make_directory(dst_fn, dir_mode, FILEUTILS_IGNORE_CHMOD_ERR)) {
+					xfunc_die();
 				}
-				i = 'n';
 			} else {
-				/* Extract file */
- check_file:
-				if (stat(dst_fn, &stat_buf) == -1) {
-					/* File does not exist */
-					if (errno != ENOENT) {
-						bb_perror_msg_and_die("can't stat '%s'", dst_fn);
-					}
-					i = 'y';
-				} else {
-					/* File already exists */
-					if (overwrite == O_NEVER) {
-						i = 'n';
-					} else if (S_ISREG(stat_buf.st_mode)) {
-						/* File is regular file */
-						if (overwrite == O_ALWAYS) {
-							i = 'y';
-						} else {
-							printf("replace %s? [y]es, [n]o, [A]ll, [N]one, [r]ename: ", dst_fn);
-							my_fgets80(key_buf);
-							i = key_buf[0];
-						}
-					} else {
-						/* File is not regular file */
-						bb_error_msg_and_die("'%s' exists but is not a %s",
-							dst_fn, "regular file");
-					}
+				if (!S_ISDIR(stat_buf.st_mode)) {
+					bb_error_msg_and_die("'%s' exists but is not a %s",
+						dst_fn, "directory");
 				}
 			}
+			goto skip_cmpsize;
+		}
+ check_file:
+		/* Extract file */
+		if (stat(dst_fn, &stat_buf) == -1) {
+			/* File does not exist */
+			if (errno != ENOENT) {
+				bb_perror_msg_and_die("can't stat '%s'", dst_fn);
+			}
+			goto do_open_and_extract;
 		}
+		/* File already exists */
+		if (overwrite == O_NEVER) {
+			goto skip_cmpsize;
+		}
+		if (!S_ISREG(stat_buf.st_mode)) {
+			/* File is not regular file */
+			bb_error_msg_and_die("'%s' exists but is not a %s",
+				dst_fn, "regular file");
+		}
+		/* File is regular file */
+		if (overwrite == O_ALWAYS)
+			goto do_open_and_extract;
+		printf("replace %s? [y]es, [n]o, [A]ll, [N]one, [r]ename: ", dst_fn);
+		my_fgets80(key_buf);
 
-		switch (i) {
+		switch (key_buf[0]) {
 		case 'A':
 			overwrite = O_ALWAYS;
 		case 'y': /* Open file and fall into unzip */
+ do_open_and_extract:
 			unzip_create_leading_dirs(dst_fn);
-#if ENABLE_DESKTOP
+#if ENABLE_FEATURE_UNZIP_CDF
 			dst_fd = xopen3(dst_fn, O_WRONLY | O_CREAT | O_TRUNC, file_mode);
 #else
 			dst_fd = xopen(dst_fn, O_WRONLY | O_CREAT | O_TRUNC);
 #endif
-		case -1: /* Unzip */
+ do_extract:
 			if (!quiet) {
-				printf("  inflating: %s\n", dst_fn);
+				printf(/* zip.fmt.method == 0
+					? " extracting: %s\n"
+					: */ "  inflating: %s\n", dst_fn);
 			}
-			unzip_extract(&zip_header, dst_fd);
+			unzip_extract(&zip, dst_fd);
 			if (dst_fd != STDOUT_FILENO) {
 				/* closing STDOUT is potentially bad for future business */
 				close(dst_fd);
@@ -769,9 +860,9 @@ int unzip_main(int argc, char **argv)
 
 		case 'N':
 			overwrite = O_NEVER;
-		case 'n':
-			/* Skip entry data */
-			unzip_skip(zip_header.formatted.cmpsize);
+		case 'n': /* Skip entry data */
+ skip_cmpsize:
+			unzip_skip(zip.fmt.cmpsize);
 			break;
 
 		case 'r':
@@ -784,7 +875,7 @@ int unzip_main(int argc, char **argv)
 			goto check_file;
 
 		default:
-			printf("error: invalid response [%c]\n", (char)i);
+			printf("error: invalid response [%c]\n", (char)key_buf[0]);
 			goto check_file;
 		}
 
diff -urpN busybox-1.26.2/configs/TEST_nommu_defconfig busybox-1.27.0/configs/TEST_nommu_defconfig
--- busybox-1.26.2/configs/TEST_nommu_defconfig	2016-12-10 18:46:36.000000000 +0100
+++ busybox-1.27.0/configs/TEST_nommu_defconfig	2017-01-30 21:57:30.000000000 +0100
@@ -266,11 +266,6 @@ CONFIG_YES=y
 CONFIG_FEATURE_PRESERVE_HARDLINKS=y
 
 #
-# Common options for ls, more and telnet
-#
-CONFIG_FEATURE_AUTOWIDTH=y
-
-#
 # Common options for df, du, ls
 #
 CONFIG_FEATURE_HUMAN_READABLE=y
@@ -387,7 +382,7 @@ CONFIG_FEATURE_KILL_REMOVED=y
 CONFIG_FEATURE_KILL_DELAY=1
 CONFIG_FEATURE_INIT_SCTTY=y
 CONFIG_FEATURE_INIT_SYSLOG=y
-CONFIG_FEATURE_EXTRA_QUIET=y
+CONFIG_FEATURE_INIT_QUIET=y
 CONFIG_FEATURE_INIT_COREDUMPS=y
 CONFIG_LINUXRC=y
 CONFIG_HALT=y
@@ -457,15 +452,12 @@ CONFIG_FEATURE_MODPROBE_SMALL_CHECK_ALRE
 # Options common to multiple modutils
 #
 # CONFIG_FEATURE_2_4_MODULES is not set
-CONFIG_FEATURE_INSMOD_TRY_MMAP=y
 # CONFIG_FEATURE_INSMOD_VERSION_CHECKING is not set
 # CONFIG_FEATURE_INSMOD_KSYMOOPS_SYMBOLS is not set
 # CONFIG_FEATURE_INSMOD_LOADINKMEM is not set
 # CONFIG_FEATURE_INSMOD_LOAD_MAP is not set
 # CONFIG_FEATURE_INSMOD_LOAD_MAP_FULL is not set
 # CONFIG_FEATURE_CHECK_TAINTED_MODULE is not set
-# CONFIG_FEATURE_MODUTILS_ALIAS is not set
-# CONFIG_FEATURE_MODUTILS_SYMBOLS is not set
 CONFIG_DEFAULT_MODULES_DIR="/lib/modules"
 CONFIG_DEFAULT_DEPMOD_FILE="modules.dep"
 
@@ -524,7 +516,6 @@ CONFIG_FEATURE_MDEV_LOAD_FIRMWARE=y
 CONFIG_MKSWAP=y
 CONFIG_FEATURE_MKSWAP_UUID=y
 CONFIG_MORE=y
-CONFIG_FEATURE_USE_TERMIOS=y
 CONFIG_VOLUMEID=y
 CONFIG_FEATURE_VOLUMEID_EXT=y
 CONFIG_FEATURE_VOLUMEID_BTRFS=y
@@ -879,9 +870,9 @@ CONFIG_FEATURE_SH_IS_HUSH=y
 # CONFIG_ASH_JOB_CONTROL is not set
 # CONFIG_ASH_ALIAS is not set
 # CONFIG_ASH_GETOPTS is not set
-# CONFIG_ASH_BUILTIN_ECHO is not set
-# CONFIG_ASH_BUILTIN_PRINTF is not set
-# CONFIG_ASH_BUILTIN_TEST is not set
+# CONFIG_ASH_ECHO is not set
+# CONFIG_ASH_PRINTF is not set
+# CONFIG_ASH_TEST is not set
 # CONFIG_ASH_CMDCMD is not set
 # CONFIG_ASH_MAIL is not set
 # CONFIG_ASH_OPTIMIZE_FOR_SIZE is not set
diff -urpN busybox-1.26.2/configs/TEST_noprintf_defconfig busybox-1.27.0/configs/TEST_noprintf_defconfig
--- busybox-1.26.2/configs/TEST_noprintf_defconfig	2016-12-10 18:46:36.000000000 +0100
+++ busybox-1.27.0/configs/TEST_noprintf_defconfig	2017-01-15 00:18:53.000000000 +0100
@@ -277,7 +277,6 @@ CONFIG_TRUE=y
 # CONFIG_WHOAMI is not set
 # CONFIG_YES is not set
 # CONFIG_FEATURE_PRESERVE_HARDLINKS is not set
-# CONFIG_FEATURE_AUTOWIDTH is not set
 # CONFIG_FEATURE_HUMAN_READABLE is not set
 # CONFIG_FEATURE_MD5_SHA1_SUM_CHECK is not set
 
@@ -392,7 +391,7 @@ CONFIG_FEATURE_VI_MAX_LEN=0
 CONFIG_FEATURE_KILL_DELAY=0
 # CONFIG_FEATURE_INIT_SCTTY is not set
 # CONFIG_FEATURE_INIT_SYSLOG is not set
-# CONFIG_FEATURE_EXTRA_QUIET is not set
+# CONFIG_FEATURE_INIT_QUIET is not set
 # CONFIG_FEATURE_INIT_COREDUMPS is not set
 # CONFIG_LINUXRC is not set
 # CONFIG_HALT is not set
@@ -527,7 +526,6 @@ CONFIG_FDISK_SUPPORT_LARGE_DISKS=y
 # CONFIG_MKSWAP is not set
 # CONFIG_FEATURE_MKSWAP_UUID is not set
 # CONFIG_MORE is not set
-# CONFIG_FEATURE_USE_TERMIOS is not set
 CONFIG_VOLUMEID=y
 # CONFIG_FEATURE_VOLUMEID_EXT is not set
 # CONFIG_FEATURE_VOLUMEID_BTRFS is not set
@@ -873,9 +871,9 @@ CONFIG_SV_DEFAULT_SERVICE_DIR=""
 # CONFIG_ASH_JOB_CONTROL is not set
 # CONFIG_ASH_ALIAS is not set
 # CONFIG_ASH_GETOPTS is not set
-# CONFIG_ASH_BUILTIN_ECHO is not set
-# CONFIG_ASH_BUILTIN_PRINTF is not set
-# CONFIG_ASH_BUILTIN_TEST is not set
+# CONFIG_ASH_ECHO is not set
+# CONFIG_ASH_PRINTF is not set
+# CONFIG_ASH_TEST is not set
 # CONFIG_ASH_CMDCMD is not set
 # CONFIG_ASH_MAIL is not set
 # CONFIG_ASH_OPTIMIZE_FOR_SIZE is not set
diff -urpN busybox-1.26.2/configs/TEST_rh9_defconfig busybox-1.27.0/configs/TEST_rh9_defconfig
--- busybox-1.26.2/configs/TEST_rh9_defconfig	2016-12-10 18:46:36.000000000 +0100
+++ busybox-1.27.0/configs/TEST_rh9_defconfig	2017-01-30 21:57:30.000000000 +0100
@@ -277,11 +277,6 @@ CONFIG_YES=y
 CONFIG_FEATURE_PRESERVE_HARDLINKS=y
 
 #
-# Common options for ls, more and telnet
-#
-CONFIG_FEATURE_AUTOWIDTH=y
-
-#
 # Common options for df, du, ls
 #
 CONFIG_FEATURE_HUMAN_READABLE=y
@@ -404,7 +399,7 @@ CONFIG_FEATURE_USE_INITTAB=y
 CONFIG_FEATURE_KILL_DELAY=0
 CONFIG_FEATURE_INIT_SCTTY=y
 CONFIG_FEATURE_INIT_SYSLOG=y
-CONFIG_FEATURE_EXTRA_QUIET=y
+CONFIG_FEATURE_INIT_QUIET=y
 CONFIG_FEATURE_INIT_COREDUMPS=y
 CONFIG_LINUXRC=y
 CONFIG_HALT=y
@@ -472,15 +467,12 @@ CONFIG_FEATURE_MODPROBE_SMALL_CHECK_ALRE
 # Options common to multiple modutils
 #
 # CONFIG_FEATURE_2_4_MODULES is not set
-# CONFIG_FEATURE_INSMOD_TRY_MMAP is not set
 # CONFIG_FEATURE_INSMOD_VERSION_CHECKING is not set
 # CONFIG_FEATURE_INSMOD_KSYMOOPS_SYMBOLS is not set
 # CONFIG_FEATURE_INSMOD_LOADINKMEM is not set
 # CONFIG_FEATURE_INSMOD_LOAD_MAP is not set
 # CONFIG_FEATURE_INSMOD_LOAD_MAP_FULL is not set
 # CONFIG_FEATURE_CHECK_TAINTED_MODULE is not set
-# CONFIG_FEATURE_MODUTILS_ALIAS is not set
-# CONFIG_FEATURE_MODUTILS_SYMBOLS is not set
 CONFIG_DEFAULT_MODULES_DIR="/lib/modules"
 CONFIG_DEFAULT_DEPMOD_FILE="modules.dep"
 
@@ -540,7 +532,6 @@ CONFIG_FEATURE_MDEV_LOAD_FIRMWARE=y
 CONFIG_MKSWAP=y
 CONFIG_FEATURE_MKSWAP_UUID=y
 CONFIG_MORE=y
-CONFIG_FEATURE_USE_TERMIOS=y
 CONFIG_VOLUMEID=y
 CONFIG_FEATURE_VOLUMEID_EXT=y
 CONFIG_FEATURE_VOLUMEID_BTRFS=y
@@ -893,9 +884,9 @@ CONFIG_ASH_BASH_COMPAT=y
 CONFIG_ASH_JOB_CONTROL=y
 CONFIG_ASH_ALIAS=y
 CONFIG_ASH_GETOPTS=y
-CONFIG_ASH_BUILTIN_ECHO=y
-CONFIG_ASH_BUILTIN_PRINTF=y
-CONFIG_ASH_BUILTIN_TEST=y
+CONFIG_ASH_ECHO=y
+CONFIG_ASH_PRINTF=y
+CONFIG_ASH_TEST=y
 CONFIG_ASH_CMDCMD=y
 # CONFIG_ASH_MAIL is not set
 CONFIG_ASH_OPTIMIZE_FOR_SIZE=y
diff -urpN busybox-1.26.2/configs/android2_defconfig busybox-1.27.0/configs/android2_defconfig
--- busybox-1.26.2/configs/android2_defconfig	2016-12-10 18:46:36.000000000 +0100
+++ busybox-1.27.0/configs/android2_defconfig	2017-01-30 21:57:30.000000000 +0100
@@ -94,7 +94,6 @@ CONFIG_PASSWORD_MINLEN=6
 CONFIG_MD5_SMALL=1
 # CONFIG_FEATURE_FAST_TOP is not set
 # CONFIG_FEATURE_ETC_NETWORKS is not set
-CONFIG_FEATURE_USE_TERMIOS=y
 # CONFIG_FEATURE_EDITING is not set
 CONFIG_FEATURE_EDITING_MAX_LEN=0
 # CONFIG_FEATURE_EDITING_VI is not set
@@ -290,11 +289,6 @@ CONFIG_YES=y
 CONFIG_FEATURE_PRESERVE_HARDLINKS=y
 
 #
-# Common options for ls, more and telnet
-#
-CONFIG_FEATURE_AUTOWIDTH=y
-
-#
 # Common options for df, du, ls
 #
 CONFIG_FEATURE_HUMAN_READABLE=y
@@ -422,7 +416,7 @@ CONFIG_FEATURE_USE_INITTAB=y
 CONFIG_FEATURE_KILL_DELAY=0
 CONFIG_FEATURE_INIT_SCTTY=y
 CONFIG_FEATURE_INIT_SYSLOG=y
-CONFIG_FEATURE_EXTRA_QUIET=y
+CONFIG_FEATURE_INIT_QUIET=y
 CONFIG_FEATURE_INIT_COREDUMPS=y
 CONFIG_LINUXRC=y
 CONFIG_INIT_TERMINAL_TYPE="linux"
@@ -493,15 +487,12 @@ CONFIG_FEATURE_MODPROBE_SMALL_CHECK_ALRE
 # Options common to multiple modutils
 #
 # CONFIG_FEATURE_2_4_MODULES is not set
-# CONFIG_FEATURE_INSMOD_TRY_MMAP is not set
 # CONFIG_FEATURE_INSMOD_VERSION_CHECKING is not set
 # CONFIG_FEATURE_INSMOD_KSYMOOPS_SYMBOLS is not set
 # CONFIG_FEATURE_INSMOD_LOADINKMEM is not set
 # CONFIG_FEATURE_INSMOD_LOAD_MAP is not set
 # CONFIG_FEATURE_INSMOD_LOAD_MAP_FULL is not set
 # CONFIG_FEATURE_CHECK_TAINTED_MODULE is not set
-# CONFIG_FEATURE_MODUTILS_ALIAS is not set
-# CONFIG_FEATURE_MODUTILS_SYMBOLS is not set
 CONFIG_DEFAULT_MODULES_DIR="/lib/modules"
 CONFIG_DEFAULT_DEPMOD_FILE="modules.dep"
 
@@ -936,9 +927,9 @@ CONFIG_SOFTLIMIT=y
 # CONFIG_ASH_JOB_CONTROL is not set
 # CONFIG_ASH_ALIAS is not set
 # CONFIG_ASH_GETOPTS is not set
-# CONFIG_ASH_BUILTIN_ECHO is not set
-# CONFIG_ASH_BUILTIN_PRINTF is not set
-# CONFIG_ASH_BUILTIN_TEST is not set
+# CONFIG_ASH_ECHO is not set
+# CONFIG_ASH_PRINTF is not set
+# CONFIG_ASH_TEST is not set
 # CONFIG_ASH_CMDCMD is not set
 # CONFIG_ASH_MAIL is not set
 # CONFIG_ASH_OPTIMIZE_FOR_SIZE is not set
diff -urpN busybox-1.26.2/configs/android_502_defconfig busybox-1.27.0/configs/android_502_defconfig
--- busybox-1.26.2/configs/android_502_defconfig	2016-12-10 18:46:36.000000000 +0100
+++ busybox-1.27.0/configs/android_502_defconfig	2017-01-30 21:57:30.000000000 +0100
@@ -174,7 +174,6 @@ CONFIG_MD5_SMALL=1
 CONFIG_SHA3_SMALL=1
 # CONFIG_FEATURE_FAST_TOP is not set
 # CONFIG_FEATURE_ETC_NETWORKS is not set
-CONFIG_FEATURE_USE_TERMIOS=y
 CONFIG_FEATURE_EDITING=y
 CONFIG_FEATURE_EDITING_MAX_LEN=1024
 # CONFIG_FEATURE_EDITING_VI is not set
@@ -391,11 +390,6 @@ CONFIG_FEATURE_VERBOSE=y
 CONFIG_FEATURE_PRESERVE_HARDLINKS=y
 
 #
-# Common options for ls, more and telnet
-#
-CONFIG_FEATURE_AUTOWIDTH=y
-
-#
 # Common options for df, du, ls
 #
 CONFIG_FEATURE_HUMAN_READABLE=y
@@ -529,7 +523,7 @@ CONFIG_FEATURE_USE_INITTAB=y
 CONFIG_FEATURE_KILL_DELAY=0
 CONFIG_FEATURE_INIT_SCTTY=y
 CONFIG_FEATURE_INIT_SYSLOG=y
-CONFIG_FEATURE_EXTRA_QUIET=y
+CONFIG_FEATURE_INIT_QUIET=y
 CONFIG_FEATURE_INIT_COREDUMPS=y
 CONFIG_LINUXRC=y
 CONFIG_INIT_TERMINAL_TYPE="linux"
@@ -603,15 +597,12 @@ CONFIG_FEATURE_MODPROBE_SMALL_CHECK_ALRE
 # Options common to multiple modutils
 #
 # CONFIG_FEATURE_2_4_MODULES is not set
-# CONFIG_FEATURE_INSMOD_TRY_MMAP is not set
 # CONFIG_FEATURE_INSMOD_VERSION_CHECKING is not set
 # CONFIG_FEATURE_INSMOD_KSYMOOPS_SYMBOLS is not set
 # CONFIG_FEATURE_INSMOD_LOADINKMEM is not set
 # CONFIG_FEATURE_INSMOD_LOAD_MAP is not set
 # CONFIG_FEATURE_INSMOD_LOAD_MAP_FULL is not set
 # CONFIG_FEATURE_CHECK_TAINTED_MODULE is not set
-# CONFIG_FEATURE_MODUTILS_ALIAS is not set
-# CONFIG_FEATURE_MODUTILS_SYMBOLS is not set
 CONFIG_DEFAULT_MODULES_DIR="/lib/modules"
 CONFIG_DEFAULT_DEPMOD_FILE="modules.dep"
 
@@ -1081,9 +1072,9 @@ CONFIG_ASH_BASH_COMPAT=y
 CONFIG_ASH_JOB_CONTROL=y
 CONFIG_ASH_ALIAS=y
 CONFIG_ASH_GETOPTS=y
-CONFIG_ASH_BUILTIN_ECHO=y
-CONFIG_ASH_BUILTIN_PRINTF=y
-CONFIG_ASH_BUILTIN_TEST=y
+CONFIG_ASH_ECHO=y
+CONFIG_ASH_PRINTF=y
+CONFIG_ASH_TEST=y
 CONFIG_ASH_HELP=y
 CONFIG_ASH_CMDCMD=y
 # CONFIG_ASH_MAIL is not set
diff -urpN busybox-1.26.2/configs/android_defconfig busybox-1.27.0/configs/android_defconfig
--- busybox-1.26.2/configs/android_defconfig	2016-12-10 18:46:36.000000000 +0100
+++ busybox-1.27.0/configs/android_defconfig	2017-01-30 21:57:30.000000000 +0100
@@ -112,7 +112,6 @@ CONFIG_PASSWORD_MINLEN=6
 CONFIG_MD5_SMALL=1
 # CONFIG_FEATURE_FAST_TOP is not set
 # CONFIG_FEATURE_ETC_NETWORKS is not set
-CONFIG_FEATURE_USE_TERMIOS=y
 # CONFIG_FEATURE_EDITING is not set
 CONFIG_FEATURE_EDITING_MAX_LEN=0
 # CONFIG_FEATURE_EDITING_VI is not set
@@ -313,11 +312,6 @@ CONFIG_YES=y
 CONFIG_FEATURE_PRESERVE_HARDLINKS=y
 
 #
-# Common options for ls, more and telnet
-#
-CONFIG_FEATURE_AUTOWIDTH=y
-
-#
 # Common options for df, du, ls
 #
 CONFIG_FEATURE_HUMAN_READABLE=y
@@ -445,7 +439,7 @@ CONFIG_FEATURE_USE_INITTAB=y
 CONFIG_FEATURE_KILL_DELAY=0
 CONFIG_FEATURE_INIT_SCTTY=y
 CONFIG_FEATURE_INIT_SYSLOG=y
-CONFIG_FEATURE_EXTRA_QUIET=y
+CONFIG_FEATURE_INIT_QUIET=y
 CONFIG_FEATURE_INIT_COREDUMPS=y
 CONFIG_LINUXRC=y
 CONFIG_INIT_TERMINAL_TYPE="linux"
@@ -517,15 +511,12 @@ CONFIG_FEATURE_MODPROBE_SMALL_CHECK_ALRE
 # Options common to multiple modutils
 #
 # CONFIG_FEATURE_2_4_MODULES is not set
-# CONFIG_FEATURE_INSMOD_TRY_MMAP is not set
 # CONFIG_FEATURE_INSMOD_VERSION_CHECKING is not set
 # CONFIG_FEATURE_INSMOD_KSYMOOPS_SYMBOLS is not set
 # CONFIG_FEATURE_INSMOD_LOADINKMEM is not set
 # CONFIG_FEATURE_INSMOD_LOAD_MAP is not set
 # CONFIG_FEATURE_INSMOD_LOAD_MAP_FULL is not set
 # CONFIG_FEATURE_CHECK_TAINTED_MODULE is not set
-# CONFIG_FEATURE_MODUTILS_ALIAS is not set
-# CONFIG_FEATURE_MODUTILS_SYMBOLS is not set
 CONFIG_DEFAULT_MODULES_DIR="/lib/modules"
 CONFIG_DEFAULT_DEPMOD_FILE="modules.dep"
 
@@ -968,9 +959,9 @@ CONFIG_SOFTLIMIT=y
 # CONFIG_ASH_JOB_CONTROL is not set
 # CONFIG_ASH_ALIAS is not set
 # CONFIG_ASH_GETOPTS is not set
-# CONFIG_ASH_BUILTIN_ECHO is not set
-# CONFIG_ASH_BUILTIN_PRINTF is not set
-# CONFIG_ASH_BUILTIN_TEST is not set
+# CONFIG_ASH_ECHO is not set
+# CONFIG_ASH_PRINTF is not set
+# CONFIG_ASH_TEST is not set
 # CONFIG_ASH_CMDCMD is not set
 # CONFIG_ASH_MAIL is not set
 # CONFIG_ASH_OPTIMIZE_FOR_SIZE is not set
diff -urpN busybox-1.26.2/configs/android_ndk_defconfig busybox-1.27.0/configs/android_ndk_defconfig
--- busybox-1.26.2/configs/android_ndk_defconfig	2016-12-10 18:46:36.000000000 +0100
+++ busybox-1.27.0/configs/android_ndk_defconfig	2017-01-30 21:57:30.000000000 +0100
@@ -102,7 +102,6 @@ CONFIG_MD5_SMALL=1
 CONFIG_SHA3_SMALL=1
 # CONFIG_FEATURE_FAST_TOP is not set
 # CONFIG_FEATURE_ETC_NETWORKS is not set
-CONFIG_FEATURE_USE_TERMIOS=y
 # CONFIG_FEATURE_EDITING is not set
 CONFIG_FEATURE_EDITING_MAX_LEN=0
 # CONFIG_FEATURE_EDITING_VI is not set
@@ -317,11 +316,6 @@ CONFIG_FEATURE_VERBOSE=y
 CONFIG_FEATURE_PRESERVE_HARDLINKS=y
 
 #
-# Common options for ls, more and telnet
-#
-CONFIG_FEATURE_AUTOWIDTH=y
-
-#
 # Common options for df, du, ls
 #
 CONFIG_FEATURE_HUMAN_READABLE=y
@@ -455,7 +449,7 @@ CONFIG_FEATURE_USE_INITTAB=y
 CONFIG_FEATURE_KILL_DELAY=0
 CONFIG_FEATURE_INIT_SCTTY=y
 CONFIG_FEATURE_INIT_SYSLOG=y
-CONFIG_FEATURE_EXTRA_QUIET=y
+CONFIG_FEATURE_INIT_QUIET=y
 CONFIG_FEATURE_INIT_COREDUMPS=y
 CONFIG_LINUXRC=y
 CONFIG_INIT_TERMINAL_TYPE="linux"
@@ -528,15 +522,12 @@ CONFIG_FEATURE_MODPROBE_SMALL_CHECK_ALRE
 # Options common to multiple modutils
 #
 # CONFIG_FEATURE_2_4_MODULES is not set
-# CONFIG_FEATURE_INSMOD_TRY_MMAP is not set
 # CONFIG_FEATURE_INSMOD_VERSION_CHECKING is not set
 # CONFIG_FEATURE_INSMOD_KSYMOOPS_SYMBOLS is not set
 # CONFIG_FEATURE_INSMOD_LOADINKMEM is not set
 # CONFIG_FEATURE_INSMOD_LOAD_MAP is not set
 # CONFIG_FEATURE_INSMOD_LOAD_MAP_FULL is not set
 # CONFIG_FEATURE_CHECK_TAINTED_MODULE is not set
-# CONFIG_FEATURE_MODUTILS_ALIAS is not set
-# CONFIG_FEATURE_MODUTILS_SYMBOLS is not set
 CONFIG_DEFAULT_MODULES_DIR="/system/lib/modules"
 CONFIG_DEFAULT_DEPMOD_FILE="modules.dep"
 
@@ -996,9 +987,9 @@ CONFIG_SOFTLIMIT=y
 # CONFIG_ASH_JOB_CONTROL is not set
 # CONFIG_ASH_ALIAS is not set
 # CONFIG_ASH_GETOPTS is not set
-# CONFIG_ASH_BUILTIN_ECHO is not set
-# CONFIG_ASH_BUILTIN_PRINTF is not set
-# CONFIG_ASH_BUILTIN_TEST is not set
+# CONFIG_ASH_ECHO is not set
+# CONFIG_ASH_PRINTF is not set
+# CONFIG_ASH_TEST is not set
 # CONFIG_ASH_HELP is not set
 # CONFIG_ASH_CMDCMD is not set
 # CONFIG_ASH_MAIL is not set
diff -urpN busybox-1.26.2/configs/cygwin_defconfig busybox-1.27.0/configs/cygwin_defconfig
--- busybox-1.26.2/configs/cygwin_defconfig	2016-12-10 18:46:36.000000000 +0100
+++ busybox-1.27.0/configs/cygwin_defconfig	2017-01-15 00:18:53.000000000 +0100
@@ -94,7 +94,6 @@ CONFIG_PASSWORD_MINLEN=6
 CONFIG_MD5_SMALL=1
 CONFIG_FEATURE_FAST_TOP=y
 # CONFIG_FEATURE_ETC_NETWORKS is not set
-CONFIG_FEATURE_USE_TERMIOS=y
 CONFIG_FEATURE_EDITING=y
 CONFIG_FEATURE_EDITING_MAX_LEN=1024
 # CONFIG_FEATURE_EDITING_VI is not set
@@ -290,11 +289,6 @@ CONFIG_YES=y
 CONFIG_FEATURE_PRESERVE_HARDLINKS=y
 
 #
-# Common options for ls, more and telnet
-#
-CONFIG_FEATURE_AUTOWIDTH=y
-
-#
 # Common options for df, du, ls
 #
 CONFIG_FEATURE_HUMAN_READABLE=y
@@ -422,7 +416,7 @@ CONFIG_TELINIT_PATH=""
 CONFIG_FEATURE_KILL_DELAY=0
 # CONFIG_FEATURE_INIT_SCTTY is not set
 # CONFIG_FEATURE_INIT_SYSLOG is not set
-# CONFIG_FEATURE_EXTRA_QUIET is not set
+# CONFIG_FEATURE_INIT_QUIET is not set
 # CONFIG_FEATURE_INIT_COREDUMPS is not set
 # CONFIG_LINUXRC is not set
 CONFIG_INIT_TERMINAL_TYPE=""
@@ -936,9 +930,9 @@ CONFIG_ASH_BASH_COMPAT=y
 CONFIG_ASH_JOB_CONTROL=y
 CONFIG_ASH_ALIAS=y
 CONFIG_ASH_GETOPTS=y
-CONFIG_ASH_BUILTIN_ECHO=y
-CONFIG_ASH_BUILTIN_PRINTF=y
-CONFIG_ASH_BUILTIN_TEST=y
+CONFIG_ASH_ECHO=y
+CONFIG_ASH_PRINTF=y
+CONFIG_ASH_TEST=y
 CONFIG_ASH_CMDCMD=y
 # CONFIG_ASH_MAIL is not set
 CONFIG_ASH_OPTIMIZE_FOR_SIZE=y
diff -urpN busybox-1.26.2/configs/freebsd_defconfig busybox-1.27.0/configs/freebsd_defconfig
--- busybox-1.26.2/configs/freebsd_defconfig	2016-12-10 18:46:36.000000000 +0100
+++ busybox-1.27.0/configs/freebsd_defconfig	2017-01-15 00:18:53.000000000 +0100
@@ -93,7 +93,6 @@ CONFIG_PASSWORD_MINLEN=6
 CONFIG_MD5_SMALL=1
 CONFIG_FEATURE_FAST_TOP=y
 # CONFIG_FEATURE_ETC_NETWORKS is not set
-CONFIG_FEATURE_USE_TERMIOS=y
 CONFIG_FEATURE_EDITING=y
 CONFIG_FEATURE_EDITING_MAX_LEN=1024
 # CONFIG_FEATURE_EDITING_VI is not set
@@ -288,11 +287,6 @@ CONFIG_YES=y
 CONFIG_FEATURE_PRESERVE_HARDLINKS=y
 
 #
-# Common options for ls, more and telnet
-#
-CONFIG_FEATURE_AUTOWIDTH=y
-
-#
 # Common options for df, du, ls
 #
 CONFIG_FEATURE_HUMAN_READABLE=y
@@ -419,7 +413,7 @@ CONFIG_TELINIT_PATH=""
 CONFIG_FEATURE_KILL_DELAY=0
 # CONFIG_FEATURE_INIT_SCTTY is not set
 # CONFIG_FEATURE_INIT_SYSLOG is not set
-# CONFIG_FEATURE_EXTRA_QUIET is not set
+# CONFIG_FEATURE_INIT_QUIET is not set
 # CONFIG_FEATURE_INIT_COREDUMPS is not set
 # CONFIG_LINUXRC is not set
 CONFIG_INIT_TERMINAL_TYPE=""
@@ -912,9 +906,9 @@ CONFIG_ASH=y
 # CONFIG_ASH_JOB_CONTROL is not set
 # CONFIG_ASH_ALIAS is not set
 # CONFIG_ASH_GETOPTS is not set
-# CONFIG_ASH_BUILTIN_ECHO is not set
-# CONFIG_ASH_BUILTIN_PRINTF is not set
-# CONFIG_ASH_BUILTIN_TEST is not set
+# CONFIG_ASH_ECHO is not set
+# CONFIG_ASH_PRINTF is not set
+# CONFIG_ASH_TEST is not set
 # CONFIG_ASH_CMDCMD is not set
 # CONFIG_ASH_MAIL is not set
 # CONFIG_ASH_OPTIMIZE_FOR_SIZE is not set
diff -urpN busybox-1.26.2/console-tools/loadfont.c busybox-1.27.0/console-tools/loadfont.c
--- busybox-1.26.2/console-tools/loadfont.c	2016-12-10 18:46:36.000000000 +0100
+++ busybox-1.27.0/console-tools/loadfont.c	2017-01-10 16:31:40.000000000 +0100
@@ -42,18 +42,14 @@
 //config:	depends on LOADFONT || SETFONT
 //config:
 //config:config FEATURE_LOADFONT_PSF2
-//config:	bool "Support for PSF2 console fonts"
+//config:	bool "Support PSF2 console fonts"
 //config:	default y
 //config:	depends on LOADFONT || SETFONT
-//config:	help
-//config:	  Support PSF2 console fonts.
 //config:
 //config:config FEATURE_LOADFONT_RAW
-//config:	bool "Support for old (raw) console fonts"
+//config:	bool "Support old (raw) console fonts"
 //config:	default y
 //config:	depends on LOADFONT || SETFONT
-//config:	help
-//config:	  Support old (raw) console fonts.
 
 //applet:IF_LOADFONT(APPLET(loadfont, BB_DIR_USR_SBIN, BB_SUID_DROP))
 //applet:IF_SETFONT(APPLET(setfont, BB_DIR_USR_SBIN, BB_SUID_DROP))
diff -urpN busybox-1.26.2/console-tools/reset.c busybox-1.27.0/console-tools/reset.c
--- busybox-1.26.2/console-tools/reset.c	2016-12-10 18:46:36.000000000 +0100
+++ busybox-1.27.0/console-tools/reset.c	2017-04-05 18:27:36.000000000 +0200
@@ -56,6 +56,8 @@ int reset_main(int argc UNUSED_PARAM, ch
 #if ENABLE_STTY
 		return stty_main(2, (char**)args);
 #else
+		/* Make sure stdout gets drained before we execvp */
+		fflush_all();
 		execvp("stty", (char**)args);
 #endif
 	}
diff -urpN busybox-1.26.2/console-tools/setconsole.c busybox-1.27.0/console-tools/setconsole.c
--- busybox-1.26.2/console-tools/setconsole.c	2016-12-10 18:46:36.000000000 +0100
+++ busybox-1.27.0/console-tools/setconsole.c	2017-01-10 16:31:40.000000000 +0100
@@ -19,8 +19,6 @@
 //config:	bool "Enable long options"
 //config:	default y
 //config:	depends on SETCONSOLE && LONG_OPTS
-//config:	help
-//config:	  Support long options for the setconsole applet.
 
 //applet:IF_SETCONSOLE(APPLET(setconsole, BB_DIR_SBIN, BB_SUID_DROP))
 
diff -urpN busybox-1.26.2/coreutils/Config.src busybox-1.27.0/coreutils/Config.src
--- busybox-1.26.2/coreutils/Config.src	2016-12-10 18:46:36.000000000 +0100
+++ busybox-1.27.0/coreutils/Config.src	2017-01-10 16:31:40.000000000 +0100
@@ -27,25 +27,11 @@ config FEATURE_PRESERVE_HARDLINKS
 	help
 	  Allow cp and mv to preserve hard links.
 
-comment "Common options for ls, more and telnet"
-	depends on LS || MORE || TELNET
-
-config FEATURE_AUTOWIDTH
-	bool "Calculate terminal & column widths"
-	default y
-	depends on LS || MORE || TELNET
-	help
-	  This option allows utilities such as 'ls', 'more' and 'telnet'
-	  to determine the width of the screen, which can allow them to
-	  display additional text or avoid wrapping text onto the next line.
-	  If you leave this disabled, your utilities will be especially
-	  primitive and will be unable to determine the current screen width.
-
 comment "Common options for df, du, ls"
 	depends on DF || DU || LS
 
 config FEATURE_HUMAN_READABLE
-	bool "Support for human readable output (example 13k, 23M, 235G)"
+	bool "Support human readable output (example 13k, 23M, 235G)"
 	default y
 	depends on DF || DU || LS
 	help
diff -urpN busybox-1.26.2/coreutils/Kbuild.src busybox-1.27.0/coreutils/Kbuild.src
--- busybox-1.26.2/coreutils/Kbuild.src	2017-01-01 13:01:05.000000000 +0100
+++ busybox-1.27.0/coreutils/Kbuild.src	2017-01-10 16:31:40.000000000 +0100
@@ -14,12 +14,5 @@ lib-$(CONFIG_MORE)          += cat.o   #
 lib-$(CONFIG_LESS)          += cat.o   # less too
 lib-$(CONFIG_CRONTAB)       += cat.o   # crontab -l
 lib-$(CONFIG_ADDUSER)       += chown.o # used by adduser
-lib-$(CONFIG_ADDGROUP)      += chown.o # used by adduser
-lib-$(CONFIG_ASH)           += echo.o  # used by ash
-lib-$(CONFIG_SH_IS_ASH)     += echo.o  # used by ash
-lib-$(CONFIG_BASH_IS_ASH)   += echo.o  # used by ash
-lib-$(CONFIG_HUSH)          += echo.o  # used by hush
-lib-$(CONFIG_SH_IS_HUSH)    += echo.o  # used by hush
-lib-$(CONFIG_BASH_IS_HUSH)  += echo.o  # used by hush
+lib-$(CONFIG_ADDGROUP)      += chown.o # used by addgroup
 lib-$(CONFIG_FTPD)          += ls.o    # used by ftpd
-lib-$(CONFIG_ASH_BUILTIN_PRINTF) += printf.o
diff -urpN busybox-1.26.2/coreutils/cal.c busybox-1.27.0/coreutils/cal.c
--- busybox-1.26.2/coreutils/cal.c	2016-12-10 18:46:36.000000000 +0100
+++ busybox-1.27.0/coreutils/cal.c	1970-01-01 01:00:00.000000000 +0100
@@ -1,390 +0,0 @@
-/* vi: set sw=4 ts=4: */
-/*
- * Calendar implementation for busybox
- *
- * See original copyright at the end of this file
- *
- * Licensed under GPLv2 or later, see file LICENSE in this source tree.
- */
-/* Mar 16, 2003      Manuel Novoa III   (mjn3@codepoet.org)
- *
- * Major size reduction... over 50% (>1.5k) on i386.
- */
-//config:config CAL
-//config:	bool "cal"
-//config:	default y
-//config:	help
-//config:	  cal is used to display a monthly calendar.
-
-//applet:IF_CAL(APPLET(cal, BB_DIR_USR_BIN, BB_SUID_DROP))
-
-//kbuild:lib-$(CONFIG_CAL) += cal.o
-
-/* BB_AUDIT SUSv3 compliant with -j and -y extensions (from util-linux). */
-/* BB_AUDIT BUG: The output of 'cal -j 1752' is incorrect.  The upstream
- * BB_AUDIT BUG: version in util-linux seems to be broken as well. */
-/* http://www.opengroup.org/onlinepubs/007904975/utilities/cal.html */
-
-//usage:#define cal_trivial_usage
-//usage:       "[-jy] [[MONTH] YEAR]"
-//usage:#define cal_full_usage "\n\n"
-//usage:       "Display a calendar\n"
-//usage:     "\n	-j	Use julian dates"
-//usage:     "\n	-y	Display the entire year"
-
-#include "libbb.h"
-#include "unicode.h"
-
-/* We often use "unsigned" intead of "int", it's easier to div on most CPUs */
-
-#define	THURSDAY		4		/* for reformation */
-#define	SATURDAY		6		/* 1 Jan 1 was a Saturday */
-
-#define	FIRST_MISSING_DAY	639787		/* 3 Sep 1752 */
-#define	NUMBER_MISSING_DAYS	11		/* 11 day correction */
-
-#define	MAXDAYS			42		/* max slots in a month array */
-#define	SPACE			-1		/* used in day array */
-
-static const unsigned char days_in_month[] ALIGN1 = {
-	0, 31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31
-};
-
-static const unsigned char sep1752[] ALIGN1 = {
-		1,	2,	14,	15,	16,
-	17,	18,	19,	20,	21,	22,	23,
-	24,	25,	26,	27,	28,	29,	30
-};
-
-/* Set to 0 or 1 in main */
-#define julian ((unsigned)option_mask32)
-
-/* leap year -- account for Gregorian reformation in 1752 */
-static int leap_year(unsigned yr)
-{
-	if (yr <= 1752)
-		return !(yr % 4);
-	return (!(yr % 4) && (yr % 100)) || !(yr % 400);
-}
-
-/* number of centuries since 1700, not inclusive */
-#define	centuries_since_1700(yr) \
-	((yr) > 1700 ? (yr) / 100 - 17 : 0)
-
-/* number of centuries since 1700 whose modulo of 400 is 0 */
-#define	quad_centuries_since_1700(yr) \
-	((yr) > 1600 ? ((yr) - 1600) / 400 : 0)
-
-/* number of leap years between year 1 and this year, not inclusive */
-#define	leap_years_since_year_1(yr) \
-	((yr) / 4 - centuries_since_1700(yr) + quad_centuries_since_1700(yr))
-
-static void center(char *, unsigned, unsigned);
-static void day_array(unsigned, unsigned, unsigned *);
-static void trim_trailing_spaces_and_print(char *);
-
-static void blank_string(char *buf, size_t buflen);
-static char *build_row(char *p, unsigned *dp);
-
-#define	DAY_LEN		3		/* 3 spaces per day */
-#define	J_DAY_LEN	(DAY_LEN + 1)
-#define	WEEK_LEN	20		/* 7 * 3 - one space at the end */
-#define	J_WEEK_LEN	(WEEK_LEN + 7)
-#define	HEAD_SEP	2		/* spaces between day headings */
-
-int cal_main(int argc, char **argv) MAIN_EXTERNALLY_VISIBLE;
-int cal_main(int argc UNUSED_PARAM, char **argv)
-{
-	struct tm zero_tm;
-	time_t now;
-	unsigned month, year, flags, i;
-	char *month_names[12];
-	/* normal heading: */
-	/* "Su Mo Tu We Th Fr Sa" */
-	/* -j heading: */
-	/* " Su  Mo  Tu  We  Th  Fr  Sa" */
-	char day_headings[ENABLE_UNICODE_SUPPORT ? 28 * 6 : 28];
-	IF_UNICODE_SUPPORT(char *hp = day_headings;)
-	char buf[40];
-
-	init_unicode();
-
-	flags = getopt32(argv, "jy");
-	/* This sets julian = flags & 1: */
-	option_mask32 &= 1;
-	month = 0;
-	argv += optind;
-
-	if (!argv[0]) {
-		struct tm *ptm;
-
-		time(&now);
-		ptm = localtime(&now);
-		year = ptm->tm_year + 1900;
-		if (!(flags & 2)) { /* no -y */
-			month = ptm->tm_mon + 1;
-		}
-	} else {
-		if (argv[1]) {
-			if (argv[2]) {
-				bb_show_usage();
-			}
-			if (!(flags & 2)) { /* no -y */
-				month = xatou_range(*argv, 1, 12);
-			}
-			argv++;
-		}
-		year = xatou_range(*argv, 1, 9999);
-	}
-
-	blank_string(day_headings, sizeof(day_headings) - 7 + 7*julian);
-
-	i = 0;
-	do {
-		zero_tm.tm_mon = i;
-		/* full month name according to locale */
-		strftime(buf, sizeof(buf), "%B", &zero_tm);
-		month_names[i] = xstrdup(buf);
-
-		if (i < 7) {
-			zero_tm.tm_wday = i;
-			/* abbreviated weekday name according to locale */
-			strftime(buf, sizeof(buf), "%a", &zero_tm);
-#if ENABLE_UNICODE_SUPPORT
-			if (julian)
-				*hp++ = ' ';
-			{
-				char *two_wchars = unicode_conv_to_printable_fixedwidth(/*NULL,*/ buf, 2);
-				strcpy(hp, two_wchars);
-				free(two_wchars);
-			}
-			hp += strlen(hp);
-			*hp++ = ' ';
-#else
-			strncpy(day_headings + i * (3+julian) + julian, buf, 2);
-#endif
-		}
-	} while (++i < 12);
-	IF_UNICODE_SUPPORT(hp[-1] = '\0';)
-
-	if (month) {
-		unsigned row, len, days[MAXDAYS];
-		unsigned *dp = days;
-		char lineout[30];
-
-		day_array(month, year, dp);
-		len = sprintf(lineout, "%s %u", month_names[month - 1], year);
-		printf("%*s%s\n%s\n",
-				((7*julian + WEEK_LEN) - len) / 2, "",
-				lineout, day_headings);
-		for (row = 0; row < 6; row++) {
-			build_row(lineout, dp)[0] = '\0';
-			dp += 7;
-			trim_trailing_spaces_and_print(lineout);
-		}
-	} else {
-		unsigned row, which_cal, week_len, days[12][MAXDAYS];
-		unsigned *dp;
-		char lineout[80];
-
-		sprintf(lineout, "%u", year);
-		center(lineout,
-				(WEEK_LEN * 3 + HEAD_SEP * 2)
-				+ julian * (J_WEEK_LEN * 2 + HEAD_SEP
-						- (WEEK_LEN * 3 + HEAD_SEP * 2)),
-				0
-		);
-		puts("\n");		/* two \n's */
-		for (i = 0; i < 12; i++) {
-			day_array(i + 1, year, days[i]);
-		}
-		blank_string(lineout, sizeof(lineout));
-		week_len = WEEK_LEN + julian * (J_WEEK_LEN - WEEK_LEN);
-		for (month = 0; month < 12; month += 3-julian) {
-			center(month_names[month], week_len, HEAD_SEP);
-			if (!julian) {
-				center(month_names[month + 1], week_len, HEAD_SEP);
-			}
-			center(month_names[month + 2 - julian], week_len, 0);
-			printf("\n%s%*s%s", day_headings, HEAD_SEP, "", day_headings);
-			if (!julian) {
-				printf("%*s%s", HEAD_SEP, "", day_headings);
-			}
-			bb_putchar('\n');
-			for (row = 0; row < (6*7); row += 7) {
-				for (which_cal = 0; which_cal < 3-julian; which_cal++) {
-					dp = days[month + which_cal] + row;
-					build_row(lineout + which_cal * (week_len + 2), dp);
-				}
-				/* blank_string took care of nul termination. */
-				trim_trailing_spaces_and_print(lineout);
-			}
-		}
-	}
-
-	fflush_stdout_and_exit(EXIT_SUCCESS);
-}
-
-/*
- * day_array --
- *	Fill in an array of 42 integers with a calendar.  Assume for a moment
- *	that you took the (maximum) 6 rows in a calendar and stretched them
- *	out end to end.  You would have 42 numbers or spaces.  This routine
- *	builds that array for any month from Jan. 1 through Dec. 9999.
- */
-static void day_array(unsigned month, unsigned year, unsigned *days)
-{
-	unsigned long temp;
-	unsigned i;
-	unsigned day, dw, dm;
-
-	memset(days, SPACE, MAXDAYS * sizeof(int));
-
-	if ((month == 9) && (year == 1752)) {
-		/* Assumes the Gregorian reformation eliminates
-		 * 3 Sep. 1752 through 13 Sep. 1752.
-		 */
-		unsigned j_offset = julian * 244;
-		size_t oday = 0;
-
-		do {
-			days[oday+2] = sep1752[oday] + j_offset;
-		} while (++oday < sizeof(sep1752));
-
-		return;
-	}
-
-	/* day_in_year
-	 * return the 1 based day number within the year
-	 */
-	day = 1;
-	if ((month > 2) && leap_year(year)) {
-		++day;
-	}
-
-	i = month;
-	while (i) {
-		day += days_in_month[--i];
-	}
-
-	/* day_in_week
-	 * return the 0 based day number for any date from 1 Jan. 1 to
-	 * 31 Dec. 9999.  Assumes the Gregorian reformation eliminates
-	 * 3 Sep. 1752 through 13 Sep. 1752.  Returns Thursday for all
-	 * missing days.
-	 */
-	temp = (long)(year - 1) * 365 + leap_years_since_year_1(year - 1) + day;
-	if (temp < FIRST_MISSING_DAY) {
-		dw = ((temp - 1 + SATURDAY) % 7);
-	} else {
-		dw = (((temp - 1 + SATURDAY) - NUMBER_MISSING_DAYS) % 7);
-	}
-
-	if (!julian) {
-		day = 1;
-	}
-
-	dm = days_in_month[month];
-	if ((month == 2) && leap_year(year)) {
-		++dm;
-	}
-
-	do {
-		days[dw++] = day++;
-	} while (--dm);
-}
-
-static void trim_trailing_spaces_and_print(char *s)
-{
-	char *p = s;
-
-	while (*p) {
-		++p;
-	}
-	while (p != s) {
-		--p;
-		if (!isspace(*p)) {
-			p[1] = '\0';
-			break;
-		}
-	}
-
-	puts(s);
-}
-
-static void center(char *str, unsigned len, unsigned separate)
-{
-	unsigned n = strlen(str);
-	len -= n;
-	printf("%*s%*s", (len/2) + n, str, (len/2) + (len % 2) + separate, "");
-}
-
-static void blank_string(char *buf, size_t buflen)
-{
-	memset(buf, ' ', buflen);
-	buf[buflen-1] = '\0';
-}
-
-static char *build_row(char *p, unsigned *dp)
-{
-	unsigned col, val, day;
-
-	memset(p, ' ', (julian + DAY_LEN) * 7);
-
-	col = 0;
-	do {
-		day = *dp++;
-		if (day != SPACE) {
-			if (julian) {
-				++p;
-				if (day >= 100) {
-					*p = '0';
-					p[-1] = (day / 100) + '0';
-					day %= 100;
-				}
-			}
-			val = day / 10;
-			if (val > 0) {
-				*p = val + '0';
-			}
-			*++p = day % 10 + '0';
-			p += 2;
-		} else {
-			p += DAY_LEN + julian;
-		}
-	} while (++col < 7);
-
-	return p;
-}
-
-/*
- * Copyright (c) 1989, 1993, 1994
- *	The Regents of the University of California.  All rights reserved.
- *
- * This code is derived from software contributed to Berkeley by
- * Kim Letkeman.
- *
- * Redistribution and use in source and binary forms, with or without
- * modification, are permitted provided that the following conditions
- * are met:
- * 1. Redistributions of source code must retain the above copyright
- *    notice, this list of conditions and the following disclaimer.
- * 2. Redistributions in binary form must reproduce the above copyright
- *    notice, this list of conditions and the following disclaimer in the
- *    documentation and/or other materials provided with the distribution.
- * 3. Neither the name of the University nor the names of its contributors
- *    may be used to endorse or promote products derived from this software
- *    without specific prior written permission.
- *
- * THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND
- * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
- * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
- * ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE
- * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
- * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
- * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
- * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
- * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
- * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
- * SUCH DAMAGE.
- */
diff -urpN busybox-1.26.2/coreutils/cat.c busybox-1.27.0/coreutils/cat.c
--- busybox-1.26.2/coreutils/cat.c	2016-12-10 18:46:36.000000000 +0100
+++ busybox-1.27.0/coreutils/cat.c	2017-07-01 22:51:12.000000000 +0200
@@ -12,56 +12,168 @@
 //config:	help
 //config:	  cat is used to concatenate files and print them to the standard
 //config:	  output. Enable this option if you wish to enable the 'cat' utility.
+//config:
+//config:config FEATURE_CATV
+//config:	bool "cat -v[etA]"
+//config:	default y
+//config:	depends on CAT
+//config:	help
+//config:	  Display nonprinting characters as escape sequences
 
-//applet:IF_CAT(APPLET_NOFORK(cat, cat, BB_DIR_BIN, BB_SUID_DROP, cat))
+//applet:IF_CAT(APPLET(cat, BB_DIR_BIN, BB_SUID_DROP))
 
-//kbuild:lib-$(CONFIG_CAT)     += cat.o
+//kbuild:lib-$(CONFIG_CAT) += cat.o
 
 /* BB_AUDIT SUSv3 compliant */
 /* http://www.opengroup.org/onlinepubs/007904975/utilities/cat.html */
 
 //usage:#define cat_trivial_usage
-//usage:       "[FILE]..."
+//usage:       "[-nb"IF_FEATURE_CATV("vteA")"] [FILE]..."
 //usage:#define cat_full_usage "\n\n"
-//usage:       "Concatenate FILEs and print them to stdout"
+//usage:       "Print FILEs to stdout\n"
+//usage:     "\n	-n	Number output lines"
+//usage:     "\n	-b	Number nonempty lines"
+//usage:	IF_FEATURE_CATV(
+//usage:     "\n	-v	Show nonprinting characters as ^x or M-x"
+//usage:     "\n	-t	...and tabs as ^I"
+//usage:     "\n	-e	...and end lines with $"
+//usage:     "\n	-A	Same as -vte"
+//usage:	)
+/*
+  Longopts not implemented yet:
+      --number-nonblank    number nonempty output lines, overrides -n
+      --number             number all output lines
+      --show-nonprinting   use ^ and M- notation, except for LFD and TAB
+      --show-all           equivalent to -vet
+  Not implemented yet:
+  -E, --show-ends          display $ at end of each line (-e sans -v)
+  -T, --show-tabs          display TAB characters as ^I (-t sans -v)
+  -s, --squeeze-blank      suppress repeated empty output lines
+*/
 //usage:
 //usage:#define cat_example_usage
 //usage:       "$ cat /proc/uptime\n"
 //usage:       "110716.72 17.67"
 
 #include "libbb.h"
+#include "common_bufsiz.h"
 
-/* This is a NOFORK applet. Be very careful! */
-
-
-int bb_cat(char **argv)
+#if ENABLE_FEATURE_CATV
+/*
+ * cat -v implementation for busybox
+ *
+ * Copyright (C) 2006 Rob Landley <rob@landley.net>
+ *
+ * Licensed under GPLv2 or later, see file LICENSE in this source tree.
+ */
+/* Rob had "cat -v" implemented as a separate applet, catv.
+ * See "cat -v considered harmful" at
+ * http://cm.bell-labs.com/cm/cs/doc/84/kp.ps.gz
+ * From USENIX Summer Conference Proceedings, 1983
+ * """
+ * The talk reviews reasons for UNIX's popularity and shows, using UCB cat
+ * as a primary example, how UNIX has grown fat. cat isn't for printing
+ * files with line numbers, it isn't for compressing multiple blank lines,
+ * it's not for looking at non-printing ASCII characters, it's for
+ * concatenating files.
+ * We are reminded that ls isn't the place for code to break a single column
+ * into multiple ones, and that mailnews shouldn't have its own more
+ * processing or joke encryption code.
+ * """
+ *
+ * I agree with the argument. Unfortunately, this ship has sailed (1983...).
+ * There are dozens of Linux distros and each of them has "cat" which supports -v.
+ * It's unrealistic for us to "reeducate" them to use our, incompatible way
+ * to achieve "cat -v" effect. The actuall effect would be "users pissed off
+ * by gratuitous incompatibility".
+ */
+#define CATV_OPT_e (1<<0)
+#define CATV_OPT_t (1<<1)
+#define CATV_OPT_v (1<<2)
+static int catv(unsigned opts, char **argv)
 {
-	int fd;
 	int retval = EXIT_SUCCESS;
+	int fd;
 
-	if (!*argv)
-		argv = (char**) &bb_argv_dash;
+	BUILD_BUG_ON(CATV_OPT_e != VISIBLE_ENDLINE);
+	BUILD_BUG_ON(CATV_OPT_t != VISIBLE_SHOW_TABS);
+#if 0 /* These consts match, we can just pass "opts" to visible() */
+	if (opts & CATV_OPT_e)
+		flags |= VISIBLE_ENDLINE;
+	if (opts & CATV_OPT_t)
+		flags |= VISIBLE_SHOW_TABS;
+#endif
+
+	/* Read from stdin if there's nothing else to do. */
+	if (!argv[0])
+		*--argv = (char*)"-";
 
+#define read_buf bb_common_bufsiz1
+	setup_common_bufsiz();
 	do {
 		fd = open_or_warn_stdin(*argv);
-		if (fd >= 0) {
-			/* This is not a xfunc - never exits */
-			off_t r = bb_copyfd_eof(fd, STDOUT_FILENO);
-			if (fd != STDIN_FILENO)
-				close(fd);
-			if (r >= 0)
-				continue;
+		if (fd < 0) {
+			retval = EXIT_FAILURE;
+			continue;
+		}
+		for (;;) {
+			int i, res;
+
+			res = read(fd, read_buf, COMMON_BUFSIZE);
+			if (res < 0)
+				retval = EXIT_FAILURE;
+			if (res <= 0)
+				break;
+			for (i = 0; i < res; i++) {
+				unsigned char c = read_buf[i];
+				char buf[sizeof("M-^c")];
+				visible(c, buf, opts);
+				fputs(buf, stdout);
+			}
 		}
-		retval = EXIT_FAILURE;
+		if (ENABLE_FEATURE_CLEAN_UP && fd)
+			close(fd);
 	} while (*++argv);
 
-	return retval;
+	fflush_stdout_and_exit(retval);
 }
+#endif
 
 int cat_main(int argc, char **argv) MAIN_EXTERNALLY_VISIBLE;
 int cat_main(int argc UNUSED_PARAM, char **argv)
 {
-	getopt32(argv, "u");
+	struct number_state ns;
+	unsigned opts;
+
+	IF_FEATURE_CATV(opt_complementary = "Aetv"; /* -A == -vet */)
+	/* -u is ignored ("unbuffered") */
+	opts = getopt32(argv, IF_FEATURE_CATV("etvA")"nbu");
 	argv += optind;
-	return bb_cat(argv);
+
+#if ENABLE_FEATURE_CATV
+	if (opts & 7)
+		return catv(opts, argv);
+//BUG: -v,-e,-t,-A ignore -nb
+	opts >>= 4;
+#endif
+
+#define CAT_OPT_n (1<<0)
+#define CAT_OPT_b (1<<1)
+#define CAT_OPT_u (1<<2)
+	if (!(opts & (CAT_OPT_n|CAT_OPT_b))) /* no -n or -b */
+		return bb_cat(argv);
+
+	if (!*argv)
+		*--argv = (char*)"-";
+	ns.width = 6;
+	ns.start = 1;
+	ns.inc = 1;
+	ns.sep = "\t";
+	ns.empty_str = "\n";
+	ns.all = !(opts & CAT_OPT_b); /* -n without -b */
+	ns.nonempty = (opts & CAT_OPT_b); /* -b (with or without -n) */
+	do {
+		print_numbered_lines(&ns, *argv);
+	} while (*++argv);
+	fflush_stdout_and_exit(EXIT_SUCCESS);
 }
diff -urpN busybox-1.26.2/coreutils/catv.c busybox-1.27.0/coreutils/catv.c
--- busybox-1.26.2/coreutils/catv.c	2016-12-10 18:46:36.000000000 +0100
+++ busybox-1.27.0/coreutils/catv.c	1970-01-01 01:00:00.000000000 +0100
@@ -1,96 +0,0 @@
-/* vi: set sw=4 ts=4: */
-/*
- * cat -v implementation for busybox
- *
- * Copyright (C) 2006 Rob Landley <rob@landley.net>
- *
- * Licensed under GPLv2 or later, see file LICENSE in this source tree.
- */
-
-/* See "Cat -v considered harmful" at
- * http://cm.bell-labs.com/cm/cs/doc/84/kp.ps.gz */
-
-//config:config CATV
-//config:	bool "catv"
-//config:	default y
-//config:	help
-//config:	  Display nonprinting characters as escape sequences (like some
-//config:	  implementations' cat -v option).
-
-//applet:IF_CATV(APPLET(catv, BB_DIR_BIN, BB_SUID_DROP))
-
-//kbuild:lib-$(CONFIG_CATV) += catv.o
-
-//usage:#define catv_trivial_usage
-//usage:       "[-etv] [FILE]..."
-//usage:#define catv_full_usage "\n\n"
-//usage:       "Display nonprinting characters as ^x or M-x\n"
-//usage:     "\n	-e	End each line with $"
-//usage:     "\n	-t	Show tabs as ^I"
-//usage:     "\n	-v	Don't use ^x or M-x escapes"
-
-#include "libbb.h"
-#include "common_bufsiz.h"
-
-#define CATV_OPT_e (1<<0)
-#define CATV_OPT_t (1<<1)
-#define CATV_OPT_v (1<<2)
-struct BUG_const_mismatch {
-	char BUG_const_mismatch[
-		CATV_OPT_e == VISIBLE_ENDLINE && CATV_OPT_t == VISIBLE_SHOW_TABS
-		? 1 : -1
-	];
-};
-
-int catv_main(int argc, char **argv) MAIN_EXTERNALLY_VISIBLE;
-int catv_main(int argc UNUSED_PARAM, char **argv)
-{
-	int retval = EXIT_SUCCESS;
-	int fd;
-	unsigned opts;
-	opts = getopt32(argv, "etv");
-	argv += optind;
-#if 0 /* These consts match, we can just pass "opts" to visible() */
-	if (opts & CATV_OPT_e)
-		flags |= VISIBLE_ENDLINE;
-	if (opts & CATV_OPT_t)
-		flags |= VISIBLE_SHOW_TABS;
-#endif
-
-	/* Read from stdin if there's nothing else to do. */
-	if (!argv[0])
-		*--argv = (char*)"-";
-
-#define read_buf bb_common_bufsiz1
-	setup_common_bufsiz();
-	do {
-		fd = open_or_warn_stdin(*argv);
-		if (fd < 0) {
-			retval = EXIT_FAILURE;
-			continue;
-		}
-		for (;;) {
-			int i, res;
-
-			res = read(fd, read_buf, COMMON_BUFSIZE);
-			if (res < 0)
-				retval = EXIT_FAILURE;
-			if (res <= 0)
-				break;
-			for (i = 0; i < res; i++) {
-				unsigned char c = read_buf[i];
-				if (opts & CATV_OPT_v) {
-					putchar(c);
-				} else {
-					char buf[sizeof("M-^c")];
-					visible(c, buf, opts);
-					fputs(buf, stdout);
-				}
-			}
-		}
-		if (ENABLE_FEATURE_CLEAN_UP && fd)
-			close(fd);
-	} while (*++argv);
-
-	fflush_stdout_and_exit(retval);
-}
diff -urpN busybox-1.26.2/coreutils/chown.c busybox-1.27.0/coreutils/chown.c
--- busybox-1.26.2/coreutils/chown.c	2016-12-10 18:46:36.000000000 +0100
+++ busybox-1.27.0/coreutils/chown.c	2017-01-10 16:31:40.000000000 +0100
@@ -17,8 +17,6 @@
 //config:	bool "Enable long options"
 //config:	default y
 //config:	depends on CHOWN && LONG_OPTS
-//config:	help
-//config:	  Enable use of long options
 
 //applet:IF_CHOWN(APPLET_NOEXEC(chown, chown, BB_DIR_BIN, BB_SUID_DROP, chown))
 
diff -urpN busybox-1.26.2/coreutils/cksum.c busybox-1.27.0/coreutils/cksum.c
--- busybox-1.26.2/coreutils/cksum.c	2016-12-10 18:46:36.000000000 +0100
+++ busybox-1.27.0/coreutils/cksum.c	2017-07-01 22:51:12.000000000 +0200
@@ -17,9 +17,9 @@
 //kbuild:lib-$(CONFIG_CKSUM) += cksum.o
 
 //usage:#define cksum_trivial_usage
-//usage:       "FILES..."
+//usage:       "FILE..."
 //usage:#define cksum_full_usage "\n\n"
-//usage:       "Calculate the CRC32 checksums of FILES"
+//usage:       "Calculate the CRC32 checksums of FILEs"
 
 #include "libbb.h"
 #include "common_bufsiz.h"
diff -urpN busybox-1.26.2/coreutils/cp.c busybox-1.27.0/coreutils/cp.c
--- busybox-1.26.2/coreutils/cp.c	2016-12-10 18:46:36.000000000 +0100
+++ busybox-1.27.0/coreutils/cp.c	2017-01-10 16:31:40.000000000 +0100
@@ -18,11 +18,11 @@
 //config:	  cp is used to copy files and directories.
 //config:
 //config:config FEATURE_CP_LONG_OPTIONS
-//config:	bool "Enable long options for cp"
+//config:	bool "Enable long options"
 //config:	default y
 //config:	depends on CP && LONG_OPTS
 //config:	help
-//config:	  Enable long options for cp.
+//config:	  Enable long options.
 //config:	  Also add support for --parents option.
 
 //applet:IF_CP(APPLET_NOEXEC(cp, cp, BB_DIR_BIN, BB_SUID_DROP, cp))
diff -urpN busybox-1.26.2/coreutils/dd.c busybox-1.27.0/coreutils/dd.c
--- busybox-1.26.2/coreutils/dd.c	2016-12-10 18:46:36.000000000 +0100
+++ busybox-1.27.0/coreutils/dd.c	2017-04-05 18:27:36.000000000 +0200
@@ -41,7 +41,7 @@
 //config:	default y
 //config:	depends on DD
 //config:	help
-//config:	  Enables support for writing a certain number of bytes in and out,
+//config:	  Enable support for writing a certain number of bytes in and out,
 //config:	  at a time, and performing conversions on the data stream.
 //config:
 //config:config FEATURE_DD_STATUS
@@ -49,7 +49,7 @@
 //config:	default y
 //config:	depends on DD
 //config:	help
-//config:	  Enables support for status=noxfer/none option.
+//config:	  Enable support for status=noxfer/none option.
 
 //applet:IF_DD(APPLET_NOEXEC(dd, dd, BB_DIR_BIN, BB_SUID_DROP, dd))
 
@@ -532,11 +532,11 @@ int dd_main(int argc UNUSED_PARAM, char
 			if (write_and_stats(ibuf, n, obs, outfile))
 				goto out_status;
 		}
+	}
 
-		if (G.flags & FLAG_FSYNC) {
-			if (fsync(ofd) < 0)
-				goto die_outfile;
-		}
+	if (G.flags & FLAG_FSYNC) {
+		if (fsync(ofd) < 0)
+			goto die_outfile;
 	}
 
 	if (ENABLE_FEATURE_DD_IBS_OBS && oc) {
diff -urpN busybox-1.26.2/coreutils/df.c busybox-1.27.0/coreutils/df.c
--- busybox-1.26.2/coreutils/df.c	2016-12-22 14:10:40.000000000 +0100
+++ busybox-1.27.0/coreutils/df.c	2017-01-10 16:31:40.000000000 +0100
@@ -29,11 +29,9 @@
 //config:	default y
 //config:	depends on DF
 //config:	help
-//config:	  This option enables -a, -i and -B.
-//config:
-//config:	    -a Show all filesystems
-//config:	    -i Inodes
-//config:	    -B <SIZE> Blocksize
+//config:	  -a Show all filesystems
+//config:	  -i Inodes
+//config:	  -B <SIZE> Blocksize
 
 //applet:IF_DF(APPLET(df, BB_DIR_BIN, BB_SUID_DROP))
 
diff -urpN busybox-1.26.2/coreutils/dos2unix.c busybox-1.27.0/coreutils/dos2unix.c
--- busybox-1.26.2/coreutils/dos2unix.c	2016-12-10 18:46:36.000000000 +0100
+++ busybox-1.27.0/coreutils/dos2unix.c	2017-07-01 22:51:12.000000000 +0200
@@ -2,7 +2,7 @@
 /*
  * dos2unix for BusyBox
  *
- * dos2unix '\n' convertor 0.5.0
+ * dos2unix '\n' converter 0.5.0
  * based on Unix2Dos 0.9.0 by Peter Hanecak (made 19.2.1997)
  * Copyright 1997,.. by Peter Hanecak <hanecak@megaloman.sk>.
  * All rights reserved.
diff -urpN busybox-1.26.2/coreutils/echo.c busybox-1.27.0/coreutils/echo.c
--- busybox-1.26.2/coreutils/echo.c	2016-12-10 18:46:36.000000000 +0100
+++ busybox-1.27.0/coreutils/echo.c	2017-01-10 16:31:40.000000000 +0100
@@ -26,16 +26,17 @@
 //config:
 //config:# this entry also appears in shell/Config.in, next to the echo builtin
 //config:config FEATURE_FANCY_ECHO
-//config:	bool "Enable echo options (-n and -e)"
+//config:	bool "Enable -n and -e options"
 //config:	default y
-//config:	depends on ECHO || ASH_BUILTIN_ECHO || HUSH
-//config:	help
-//config:	  This adds options (-n and -e) to echo.
+//config:	depends on ECHO || ASH_ECHO || HUSH_ECHO
 
 //applet:IF_ECHO(APPLET_NOFORK(echo, echo, BB_DIR_BIN, BB_SUID_DROP, echo))
 
 //kbuild:lib-$(CONFIG_ECHO) += echo.o
 
+//kbuild:lib-$(CONFIG_ASH_ECHO)  += echo.o
+//kbuild:lib-$(CONFIG_HUSH_ECHO) += echo.o
+
 /* BB_AUDIT SUSv3 compliant -- unless configured as fancy echo. */
 /* http://www.opengroup.org/onlinepubs/007904975/utilities/echo.html */
 
diff -urpN busybox-1.26.2/coreutils/env.c busybox-1.27.0/coreutils/env.c
--- busybox-1.26.2/coreutils/env.c	2016-12-10 18:46:36.000000000 +0100
+++ busybox-1.27.0/coreutils/env.c	2017-01-10 16:31:40.000000000 +0100
@@ -35,8 +35,6 @@
 //config:	bool "Enable long options"
 //config:	default y
 //config:	depends on ENV && LONG_OPTS
-//config:	help
-//config:	  Support long options for the env applet.
 
 //applet:IF_ENV(APPLET_NOEXEC(env, env, BB_DIR_USR_BIN, BB_SUID_DROP, env))
 
diff -urpN busybox-1.26.2/coreutils/expand.c busybox-1.27.0/coreutils/expand.c
--- busybox-1.26.2/coreutils/expand.c	2016-12-10 18:46:36.000000000 +0100
+++ busybox-1.27.0/coreutils/expand.c	2017-01-30 21:57:30.000000000 +0100
@@ -8,13 +8,13 @@
  * David MacKenzie <djm@gnu.ai.mit.edu>
  *
  * Options for expand:
- * -t num  --tabs=NUM      Convert tabs to num spaces (default 8 spaces).
+ * -t num  --tabs NUM      Convert tabs to num spaces (default 8 spaces).
  * -i      --initial       Only convert initial tabs on each line to spaces.
  *
  * Options for unexpand:
  * -a      --all           Convert all blanks, instead of just initial blanks.
  * -f      --first-only    Convert only leading sequences of blanks (default).
- * -t num  --tabs=NUM      Have tabs num characters apart instead of 8.
+ * -t num  --tabs NUM      Have tabs num characters apart instead of 8.
  *
  *  Busybox version (C) 2007 by Tito Ragusa <farmatito@tiscali.it>
  *
@@ -30,8 +30,6 @@
 //config:	bool "Enable long options"
 //config:	default y
 //config:	depends on EXPAND && LONG_OPTS
-//config:	help
-//config:	  Support long options for the expand applet.
 //config:
 //config:config UNEXPAND
 //config:	bool "unexpand"
@@ -43,10 +41,9 @@
 //config:	bool "Enable long options"
 //config:	default y
 //config:	depends on UNEXPAND && LONG_OPTS
-//config:	help
-//config:	  Support long options for the unexpand applet.
 
 //applet:IF_EXPAND(APPLET(expand, BB_DIR_USR_BIN, BB_SUID_DROP))
+//                   APPLET_ODDNAME:name      main    location        suid_type     help
 //applet:IF_UNEXPAND(APPLET_ODDNAME(unexpand, expand, BB_DIR_USR_BIN, BB_SUID_DROP, unexpand))
 
 //kbuild:lib-$(CONFIG_EXPAND) += expand.o
@@ -58,7 +55,7 @@
 //usage:       "Convert tabs to spaces, writing to stdout\n"
 //usage:	IF_FEATURE_EXPAND_LONG_OPTIONS(
 //usage:     "\n	-i,--initial	Don't convert tabs after non blanks"
-//usage:     "\n	-t,--tabs=N	Tabstops every N chars"
+//usage:     "\n	-t,--tabs N	Tabstops every N chars"
 //usage:	)
 //usage:	IF_NOT_FEATURE_EXPAND_LONG_OPTIONS(
 //usage:     "\n	-i	Don't convert tabs after non blanks"
@@ -72,7 +69,7 @@
 //usage:	IF_FEATURE_UNEXPAND_LONG_OPTIONS(
 //usage:     "\n	-a,--all	Convert all blanks"
 //usage:     "\n	-f,--first-only	Convert only leading blanks"
-//usage:     "\n	-t,--tabs=N	Tabstops every N chars"
+//usage:     "\n	-t,--tabs N	Tabstops every N chars"
 //usage:	)
 //usage:	IF_NOT_FEATURE_UNEXPAND_LONG_OPTIONS(
 //usage:     "\n	-a	Convert all blanks"
diff -urpN busybox-1.26.2/coreutils/factor.c busybox-1.27.0/coreutils/factor.c
--- busybox-1.26.2/coreutils/factor.c	1970-01-01 01:00:00.000000000 +0100
+++ busybox-1.27.0/coreutils/factor.c	2017-07-01 22:51:12.000000000 +0200
@@ -0,0 +1,219 @@
+/*
+ * Copyright (C) 2017 Denys Vlasenko <vda.linux@googlemail.com>
+ *
+ * Licensed under GPLv2, see file LICENSE in this source tree.
+ */
+//config:config FACTOR
+//config:	bool "factor"
+//config:	default y
+//config:	help
+//config:	  factor factorizes integers
+
+//applet:IF_FACTOR(APPLET(factor, BB_DIR_USR_BIN, BB_SUID_DROP))
+
+//kbuild:lib-$(CONFIG_FACTOR) += factor.o
+
+//usage:#define factor_trivial_usage
+//usage:       "[NUMBER]..."
+//usage:#define factor_full_usage "\n\n"
+//usage:       "Print prime factors"
+
+#include "libbb.h"
+
+#if 0
+# define dbg(...) bb_error_msg(__VA_ARGS__)
+#else
+# define dbg(...) ((void)0)
+#endif
+
+typedef unsigned long long wide_t;
+
+#if ULLONG_MAX == (UINT_MAX * UINT_MAX + 2 * UINT_MAX)
+/* "unsigned" is half as wide as ullong */
+typedef unsigned half_t;
+#define HALF_MAX UINT_MAX
+#define HALF_FMT ""
+#elif ULLONG_MAX == (ULONG_MAX * ULONG_MAX + 2 * ULONG_MAX)
+/* long is half as wide as ullong */
+typedef unsigned long half_t;
+#define HALF_MAX ULONG_MAX
+#define HALF_FMT "l"
+#else
+#error Cant find an integer type which is half as wide as ullong
+#endif
+
+static half_t isqrt_odd(wide_t N)
+{
+	half_t s = isqrt(N);
+	/* Subtract 1 from even s, odd s won't change: */
+	/* (doesnt work for zero, but we know that s != 0 here) */
+	s = (s - 1) | 1;
+	return s;
+}
+
+static NOINLINE void factorize(wide_t N)
+{
+	half_t factor;
+	half_t max_factor;
+	// unsigned count3;
+	// unsigned count5;
+	// unsigned count7;
+	// ^^^^^^^^^^^^^^^ commented-out simple sieving code (easier to grasp).
+	// Faster sieving, using one word for potentially up to 6 counters:
+	// count upwards in each mask, counter "triggers" when it sets its mask to "100[0]..."
+	// 10987654321098765432109876543210 - bits 31-0 in 32-bit word
+	//    17777713333311111777775555333 - bit masks for counters for primes 3,5,7,11,13,17
+	//         100000100001000010001001 - value for adding 1 to each mask
+	//    10000010000010000100001000100 - value for checking that any mask reached msb
+	enum {
+		SHIFT_3 = 1 << 0,
+		SHIFT_5 = 1 << 3,
+		SHIFT_7 = 1 << 7,
+		INCREMENT_EACH = SHIFT_3 | SHIFT_5 | SHIFT_7,
+		MULTIPLE_OF_3 = 1 << 2,
+		MULTIPLE_OF_5 = 1 << 6,
+		MULTIPLE_OF_7 = 1 << 11,
+		MULTIPLE_DETECTED = MULTIPLE_OF_3 | MULTIPLE_OF_5 | MULTIPLE_OF_7,
+	};
+	unsigned sieve_word;
+
+	if (N < 4)
+		goto end;
+
+	while (!(N & 1)) {
+		printf(" 2");
+		N >>= 1;
+	}
+
+	/* The code needs to be optimized for the case where
+	 * there are large prime factors. For example,
+	 * this is not hard:
+	 * 8262075252869367027 = 3 7 17 23 47 101 113 127 131 137 823
+	 * (the largest factor to test is only ~sqrt(823) = 28)
+	 * but this is:
+	 * 18446744073709551601 = 53 348051774975651917
+	 * the last factor requires testing up to
+	 * 589959129 - about 100 million iterations.
+	 * The slowest case (largest prime) for N < 2^64 is
+	 * factor 18446744073709551557 (0xffffffffffffffc5).
+	 */
+	max_factor = isqrt_odd(N);
+	// count3 = 3;
+	// count5 = 6;
+	// count7 = 9;
+	sieve_word = 0
+		/* initial count for SHIFT_n is (n-1)/2*3: */
+		+ (MULTIPLE_OF_3 - 3 * SHIFT_3)
+		+ (MULTIPLE_OF_5 - 6 * SHIFT_5)
+		+ (MULTIPLE_OF_7 - 9 * SHIFT_7)
+		//+ (MULTIPLE_OF_11 - 15 * SHIFT_11)
+		//+ (MULTIPLE_OF_13 - 18 * SHIFT_13)
+		//+ (MULTIPLE_OF_17 - 24 * SHIFT_17)
+	;
+	factor = 3;
+	for (;;) {
+		/* The division is the most costly part of the loop.
+		 * On 64bit CPUs, takes at best 12 cycles, often ~20.
+		 */
+		while ((N % factor) == 0) { /* not likely */
+			N = N / factor;
+			printf(" %"HALF_FMT"u", factor);
+			max_factor = isqrt_odd(N);
+		}
+ next_factor:
+		if (factor >= max_factor)
+			break;
+		factor += 2;
+		/* Rudimentary wheel sieving: skip multiples of 3, 5 and 7:
+		 * Every third odd number is divisible by three and thus isn't a prime:
+		 * 5 7 9 11 13 15 17 19 21 23 25 27 29 31 33 35 37 39 41 43 45 47...
+		 * ^ ^   ^  ^     ^  ^     ^  _     ^  ^     _  ^     ^  ^     ^
+		 * (^ = primes, _ = would-be-primes-if-not-divisible-by-5)
+		 * The numbers with space under them are excluded by sieve 3.
+		 */
+		// count7--;
+		// count5--;
+		// count3--;
+		// if (count3 && count5 && count7)
+		// 	continue;
+		sieve_word += INCREMENT_EACH;
+		if (!(sieve_word & MULTIPLE_DETECTED))
+			continue;
+		/*
+		 * "factor" is multiple of 3 33% of the time (count3 reached 0),
+		 * else, multiple of 5 13% of the time,
+		 * else, multiple of 7 7.6% of the time.
+		 * Cumulatively, with 3,5,7 sieving we are here 54.3% of the time.
+		 */
+		// if (count3 == 0)
+		// 	count3 = 3;
+		if (sieve_word & MULTIPLE_OF_3)
+			sieve_word -= SHIFT_3 * 3;
+		// if (count5 == 0)
+		// 	count5 = 5;
+		if (sieve_word & MULTIPLE_OF_5)
+			sieve_word -= SHIFT_5 * 5;
+		// if (count7 == 0)
+		// 	count7 = 7;
+		if (sieve_word & MULTIPLE_OF_7)
+			sieve_word -= SHIFT_7 * 7;
+		goto next_factor;
+	}
+ end:
+	if (N > 1)
+		printf(" %llu", N);
+	bb_putchar('\n');
+}
+
+static void factorize_numstr(const char *numstr)
+{
+	wide_t N;
+
+	/* Leading + is ok (coreutils compat) */
+	if (*numstr == '+')
+		numstr++;
+	N = bb_strtoull(numstr, NULL, 10);
+	if (errno)
+		bb_show_usage();
+	printf("%llu:", N);
+	factorize(N);
+}
+
+int factor_main(int argc, char **argv) MAIN_EXTERNALLY_VISIBLE;
+int factor_main(int argc UNUSED_PARAM, char **argv)
+{
+	//// coreutils has undocumented option ---debug (three dashes)
+	//getopt32(argv, "");
+	//argv += optind;
+	argv++;
+
+	if (!*argv) {
+		/* Read from stdin, several numbers per line are accepted */
+		for (;;) {
+			char *numstr, *line;
+			line = xmalloc_fgetline(stdin);
+			if (!line)
+				return EXIT_SUCCESS;
+			numstr = line;
+			for (;;) {
+				char *end;
+				numstr = skip_whitespace(numstr);
+				if (!numstr[0])
+					break;
+				end = skip_non_whitespace(numstr);
+				if (*end != '\0')
+					*end++ = '\0';
+				factorize_numstr(numstr);
+				numstr = end;
+			}
+			free(line);
+		}
+	}
+
+	do {
+		/* Leading spaces are ok (coreutils compat) */
+		factorize_numstr(skip_whitespace(*argv));
+	} while (*++argv);
+
+	return EXIT_SUCCESS;
+}
diff -urpN busybox-1.26.2/coreutils/head.c busybox-1.27.0/coreutils/head.c
--- busybox-1.26.2/coreutils/head.c	2016-12-10 18:46:36.000000000 +0100
+++ busybox-1.27.0/coreutils/head.c	2017-01-10 16:31:40.000000000 +0100
@@ -14,11 +14,9 @@
 //config:	  from files.
 //config:
 //config:config FEATURE_FANCY_HEAD
-//config:	bool "Enable head options (-c, -q, and -v)"
+//config:	bool "Enable -c, -q, and -v"
 //config:	default y
 //config:	depends on HEAD
-//config:	help
-//config:	  This enables the head options (-c, -q, and -v).
 
 //applet:IF_HEAD(APPLET_NOEXEC(head, head, BB_DIR_USR_BIN, BB_SUID_DROP, head))
 
diff -urpN busybox-1.26.2/coreutils/install.c busybox-1.27.0/coreutils/install.c
--- busybox-1.26.2/coreutils/install.c	2016-12-10 18:46:36.000000000 +0100
+++ busybox-1.27.0/coreutils/install.c	2017-01-10 16:31:40.000000000 +0100
@@ -15,8 +15,6 @@
 //config:	bool "Enable long options"
 //config:	default y
 //config:	depends on INSTALL && LONG_OPTS
-//config:	help
-//config:	  Support long options for the install applet.
 
 //applet:IF_INSTALL(APPLET(install, BB_DIR_USR_BIN, BB_SUID_DROP))
 
diff -urpN busybox-1.26.2/coreutils/link.c busybox-1.27.0/coreutils/link.c
--- busybox-1.26.2/coreutils/link.c	1970-01-01 01:00:00.000000000 +0100
+++ busybox-1.27.0/coreutils/link.c	2017-01-30 21:57:30.000000000 +0100
@@ -0,0 +1,41 @@
+/*
+ * link implementation for busybox
+ *
+ * Copyright (C) 2017 Denys Vlasenko <vda.linux@googlemail.com>
+ *
+ * Licensed under GPLv2, see file LICENSE in this source tree.
+ */
+//config:config LINK
+//config:	bool "link"
+//config:	default y
+//config:	help
+//config:	  link creates hard links between files.
+
+//applet:IF_LINK(APPLET_NOFORK(link, link, BB_DIR_BIN, BB_SUID_DROP, link))
+
+//kbuild:lib-$(CONFIG_LINK) += link.o
+
+//usage:#define link_trivial_usage
+//usage:       "FILE LINK"
+//usage:#define link_full_usage "\n\n"
+//usage:       "Create hard LINK to FILE"
+
+#include "libbb.h"
+
+/* This is a NOFORK applet. Be very careful! */
+
+int link_main(int argc, char **argv) MAIN_EXTERNALLY_VISIBLE;
+int link_main(int argc UNUSED_PARAM, char **argv)
+{
+	opt_complementary = "=2"; /* exactly 2 params */
+	getopt32(argv, "");
+	argv += optind;
+	if (link(argv[0], argv[1]) != 0) {
+		/* shared message */
+		bb_perror_msg_and_die("can't create %slink "
+					"%s to %s", "hard",
+					argv[1], argv[0]
+		);
+	}
+	return EXIT_SUCCESS;
+}
diff -urpN busybox-1.26.2/coreutils/ls.c busybox-1.27.0/coreutils/ls.c
--- busybox-1.26.2/coreutils/ls.c	2016-12-10 18:46:36.000000000 +0100
+++ busybox-1.27.0/coreutils/ls.c	2017-07-01 22:51:12.000000000 +0200
@@ -37,22 +37,21 @@
 //config:	bool "Enable filetyping options (-p and -F)"
 //config:	default y
 //config:	depends on LS
-//config:	help
-//config:	  Enable the ls options (-p and -F).
 //config:
 //config:config FEATURE_LS_FOLLOWLINKS
 //config:	bool "Enable symlinks dereferencing (-L)"
 //config:	default y
 //config:	depends on LS
-//config:	help
-//config:	  Enable the ls option (-L).
 //config:
 //config:config FEATURE_LS_RECURSIVE
 //config:	bool "Enable recursion (-R)"
 //config:	default y
 //config:	depends on LS
-//config:	help
-//config:	  Enable the ls option (-R).
+//config:
+//config:config FEATURE_LS_WIDTH
+//config:	bool "Enable -w WIDTH and window size autodetection"
+//config:	default y
+//config:	depends on LS
 //config:
 //config:config FEATURE_LS_SORTFILES
 //config:	bool "Sort the file names"
@@ -102,18 +101,17 @@
 //usage:	IF_FEATURE_LS_FOLLOWLINKS("LH")
 //usage:	IF_FEATURE_LS_RECURSIVE("R")
 //usage:	IF_FEATURE_LS_FILETYPES("Fp") "lins"
-//usage:	IF_FEATURE_LS_TIMESTAMPS("e")
 //usage:	IF_FEATURE_HUMAN_READABLE("h")
 //usage:	IF_FEATURE_LS_SORTFILES("rSXv")
 //usage:	IF_FEATURE_LS_TIMESTAMPS("ctu")
-//usage:	IF_SELINUX("kKZ") "]"
-//usage:	IF_FEATURE_AUTOWIDTH(" [-w WIDTH]") " [FILE]..."
+//usage:	IF_SELINUX("kZ") "]"
+//usage:	IF_FEATURE_LS_WIDTH(" [-w WIDTH]") " [FILE]..."
 //usage:#define ls_full_usage "\n\n"
 //usage:       "List directory contents\n"
 //usage:     "\n	-1	One column output"
 //usage:     "\n	-a	Include entries which start with ."
 //usage:     "\n	-A	Like -a, but exclude . and .."
-//usage:     "\n	-C	List by columns"
+////usage:     "\n	-C	List by columns" - don't show, this is a default anyway
 //usage:     "\n	-x	List by lines"
 //usage:     "\n	-d	List directory entries instead of contents"
 //usage:	IF_FEATURE_LS_FOLLOWLINKS(
@@ -132,29 +130,34 @@
 //usage:     "\n	-n	List numeric UIDs and GIDs instead of names"
 //usage:     "\n	-s	List allocated blocks"
 //usage:	IF_FEATURE_LS_TIMESTAMPS(
-//usage:     "\n	-e	List full date and time"
+//usage:     "\n	-lc	List ctime"
+//usage:     "\n	-lu	List atime"
 //usage:	)
+//usage:	IF_FEATURE_LS_TIMESTAMPS(IF_LONG_OPTS(
+//usage:     "\n	--full-time	List full date and time"
+//usage:	))
 //usage:	IF_FEATURE_HUMAN_READABLE(
-//usage:     "\n	-h	List sizes in human readable format (1K 243M 2G)"
+//usage:     "\n	-h	Human readable sizes (1K 243M 2G)"
 //usage:	)
 //usage:	IF_FEATURE_LS_SORTFILES(
-//usage:     "\n	-r	Sort in reverse order"
+//usage:	IF_LONG_OPTS(
+//usage:     "\n	--group-directories-first"
+//usage:	)
 //usage:     "\n	-S	Sort by size"
 //usage:     "\n	-X	Sort by extension"
 //usage:     "\n	-v	Sort by version"
 //usage:	)
 //usage:	IF_FEATURE_LS_TIMESTAMPS(
-//usage:     "\n	-c	With -l: sort by ctime"
-//usage:     "\n	-t	With -l: sort by mtime"
-//usage:     "\n	-u	With -l: sort by atime"
+//usage:     "\n	-t	Sort by mtime"
+//usage:     "\n	-tc	Sort by ctime"
+//usage:     "\n	-tu	Sort by atime"
 //usage:	)
+//usage:     "\n	-r	Reverse sort order"
 //usage:	IF_SELINUX(
-//usage:     "\n	-k	List security context"
-//usage:     "\n	-K	List security context in long format"
 //usage:     "\n	-Z	List security context and permission"
 //usage:	)
-//usage:	IF_FEATURE_AUTOWIDTH(
-//usage:     "\n	-w N	Assume the terminal is N columns wide"
+//usage:	IF_FEATURE_LS_WIDTH(
+//usage:     "\n	-w N	Format N columns wide"
 //usage:	)
 //usage:	IF_FEATURE_LS_COLOR(
 //usage:     "\n	--color[={always,never,auto}]	Control coloring"
@@ -189,187 +192,90 @@ TERMINAL_WIDTH  = 80,           /* use 7
 SPLIT_FILE      = 0,
 SPLIT_DIR       = 1,
 SPLIT_SUBDIR    = 2,
-
-/* Bits in G.all_fmt: */
-
-/* 51306 lrwxrwxrwx  1 root     root         2 May 11 01:43 /bin/view -> vi* */
-/* what file information will be listed */
-LIST_INO        = 1 << 0,
-LIST_BLOCKS     = 1 << 1,
-LIST_MODEBITS   = 1 << 2,
-LIST_NLINKS     = 1 << 3,
-LIST_ID_NAME    = 1 << 4,
-LIST_ID_NUMERIC = 1 << 5,
-LIST_CONTEXT    = 1 << 6,
-LIST_SIZE       = 1 << 7,
-LIST_DATE_TIME  = 1 << 8,
-LIST_FULLTIME   = 1 << 9,
-LIST_SYMLINK    = 1 << 10,
-LIST_FILETYPE   = 1 << 11, /* show / suffix for dirs */
-LIST_CLASSIFY   = 1 << 12, /* requires LIST_FILETYPE, also show *,|,@,= suffixes */
-LIST_MASK       = (LIST_CLASSIFY << 1) - 1,
-
-/* what files will be displayed */
-DISP_DIRNAME    = 1 << 13,      /* 2 or more items? label directories */
-DISP_HIDDEN     = 1 << 14,      /* show filenames starting with . */
-DISP_DOT        = 1 << 15,      /* show . and .. */
-DISP_NOLIST     = 1 << 16,      /* show directory as itself, not contents */
-DISP_RECURSIVE  = 1 << 17,      /* show directory and everything below it */
-DISP_ROWS       = 1 << 18,      /* print across rows */
-DISP_MASK       = ((DISP_ROWS << 1) - 1) & ~(DISP_DIRNAME - 1),
-
-/* what is the overall style of the listing */
-STYLE_COLUMNAR  = 1 << 19,      /* many records per line */
-STYLE_LONG      = 2 << 19,      /* one record per line, extended info */
-STYLE_SINGLE    = 3 << 19,      /* one record per line */
-STYLE_MASK      = STYLE_SINGLE,
-
-/* which of the three times will be used */
-TIME_CHANGE     = (1 << 21) * ENABLE_FEATURE_LS_TIMESTAMPS,
-TIME_ACCESS     = (2 << 21) * ENABLE_FEATURE_LS_TIMESTAMPS,
-TIME_MASK       = (3 << 21) * ENABLE_FEATURE_LS_TIMESTAMPS,
-
-/* how will the files be sorted (CONFIG_FEATURE_LS_SORTFILES) */
-SORT_REVERSE    = 1 << 23,
-
-SORT_NAME       = 0,            /* sort by file name */
-SORT_SIZE       = 1 << 24,      /* sort by file size */
-SORT_ATIME      = 2 << 24,      /* sort by last access time */
-SORT_CTIME      = 3 << 24,      /* sort by last change time */
-SORT_MTIME      = 4 << 24,      /* sort by last modification time */
-SORT_VERSION    = 5 << 24,      /* sort by version */
-SORT_EXT        = 6 << 24,      /* sort by file name extension */
-SORT_DIR        = 7 << 24,      /* sort by file or directory */
-SORT_MASK       = (7 << 24) * ENABLE_FEATURE_LS_SORTFILES,
-
-LIST_LONG       = LIST_MODEBITS | LIST_NLINKS | LIST_ID_NAME | LIST_SIZE | \
-                  LIST_DATE_TIME | LIST_SYMLINK,
 };
 
-/* -Cadil1  Std options, busybox always supports */
+/* -Cadi1l  Std options, busybox always supports */
 /* -gnsxA   Std options, busybox always supports */
 /* -Q       GNU option, busybox always supports */
-/* -k       SELinux option, busybox always supports (ignores if !SELinux) */
-/*          Std has -k which means "show sizes in kbytes" */
+/* -k       Std option, busybox always supports (by ignoring) */
+/*          It means "for -s, show sizes in kbytes" */
+/*          Seems to only affect "POSIXLY_CORRECT=1 ls -sk" */
+/*          since otherwise -s shows kbytes anyway */
 /* -LHRctur Std options, busybox optionally supports */
 /* -Fp      Std options, busybox optionally supports */
 /* -SXvhTw  GNU options, busybox optionally supports */
 /* -T WIDTH Ignored (we don't use tabs on output) */
-/* -KZ      SELinux mandated options, busybox optionally supports */
-/*          (coreutils 8.4 has no -K, remove it?) */
-/* -e       I think we made this one up (looks similar to GNU --full-time) */
-/* We already used up all 32 bits, if we need to add more, candidates for removal: */
-/* -K, -T, -e (add --full-time instead) */
+/* -Z       SELinux mandated option, busybox optionally supports */
 static const char ls_options[] ALIGN1 =
-	"Cadil1gnsxQAk"      /* 13 opts, total 13 */
-	IF_FEATURE_LS_TIMESTAMPS("cetu") /* 4, 17 */
-	IF_FEATURE_LS_SORTFILES("SXrv")  /* 4, 21 */
-	IF_FEATURE_LS_FILETYPES("Fp")    /* 2, 23 */
-	IF_FEATURE_LS_RECURSIVE("R")     /* 1, 24 */
-	IF_SELINUX("KZ")                 /* 2, 26 */
-	IF_FEATURE_LS_FOLLOWLINKS("LH")  /* 2, 28 */
-	IF_FEATURE_HUMAN_READABLE("h")   /* 1, 29 */
-	IF_FEATURE_AUTOWIDTH("T:w:")     /* 2, 31 */
-	/* with --color, we use all 32 bits */;
+	"Cadi1lgnsxAk"       /* 12 opts, total 12 */
+	IF_FEATURE_LS_FILETYPES("Fp")    /* 2, 14 */
+	IF_FEATURE_LS_RECURSIVE("R")     /* 1, 15 */
+	IF_SELINUX("Z")                  /* 1, 16 */
+	"Q"                              /* 1, 17 */
+	IF_FEATURE_LS_TIMESTAMPS("ctu")  /* 3, 20 */
+	IF_FEATURE_LS_SORTFILES("SXrv")  /* 4, 24 */
+	IF_FEATURE_LS_FOLLOWLINKS("LH")  /* 2, 26 */
+	IF_FEATURE_HUMAN_READABLE("h")   /* 1, 27 */
+	IF_FEATURE_LS_WIDTH("T:w:")      /* 2, 29 */
+;
 enum {
-	//OPT_C = (1 << 0),
-	//OPT_a = (1 << 1),
-	//OPT_d = (1 << 2),
-	//OPT_i = (1 << 3),
-	//OPT_l = (1 << 4),
-	//OPT_1 = (1 << 5),
+	OPT_C = (1 << 0),
+	OPT_a = (1 << 1),
+	OPT_d = (1 << 2),
+	OPT_i = (1 << 3),
+	OPT_1 = (1 << 4),
+	OPT_l = (1 << 5),
 	OPT_g = (1 << 6),
-	//OPT_n = (1 << 7),
-	//OPT_s = (1 << 8),
-	//OPT_x = (1 << 9),
-	OPT_Q = (1 << 10),
-	//OPT_A = (1 << 11),
-	//OPT_k = (1 << 12),
-
-	OPTBIT_c = 13,
-	OPTBIT_e,
-	OPTBIT_t,
-	OPTBIT_u,
-	OPTBIT_S = OPTBIT_c + 4 * ENABLE_FEATURE_LS_TIMESTAMPS,
-	OPTBIT_X, /* 18 */
-	OPTBIT_r,
-	OPTBIT_v,
-	OPTBIT_F = OPTBIT_S + 4 * ENABLE_FEATURE_LS_SORTFILES,
-	OPTBIT_p, /* 22 */
+	OPT_n = (1 << 7),
+	OPT_s = (1 << 8),
+	OPT_x = (1 << 9),
+	OPT_A = (1 << 10),
+	//OPT_k = (1 << 11),
+
+	OPTBIT_F = 12,
+	OPTBIT_p, /* 13 */
 	OPTBIT_R = OPTBIT_F + 2 * ENABLE_FEATURE_LS_FILETYPES,
-	OPTBIT_K = OPTBIT_R + 1 * ENABLE_FEATURE_LS_RECURSIVE,
-	OPTBIT_Z, /* 25 */
-	OPTBIT_L = OPTBIT_K + 2 * ENABLE_SELINUX,
-	OPTBIT_H, /* 27 */
+	OPTBIT_Z = OPTBIT_R + 1 * ENABLE_FEATURE_LS_RECURSIVE,
+	OPTBIT_Q = OPTBIT_Z + 1 * ENABLE_SELINUX,
+	OPTBIT_c, /* 17 */
+	OPTBIT_t, /* 18 */
+	OPTBIT_u, /* 19 */
+	OPTBIT_S = OPTBIT_c + 3 * ENABLE_FEATURE_LS_TIMESTAMPS,
+	OPTBIT_X, /* 21 */
+	OPTBIT_r, /* 22 */
+	OPTBIT_v, /* 23 */
+	OPTBIT_L = OPTBIT_S + 4 * ENABLE_FEATURE_LS_SORTFILES,
+	OPTBIT_H, /* 25 */
 	OPTBIT_h = OPTBIT_L + 2 * ENABLE_FEATURE_LS_FOLLOWLINKS,
 	OPTBIT_T = OPTBIT_h + 1 * ENABLE_FEATURE_HUMAN_READABLE,
-	OPTBIT_w, /* 30 */
-	OPTBIT_color = OPTBIT_T + 2 * ENABLE_FEATURE_AUTOWIDTH,
+	OPTBIT_w, /* 28 */
+	OPTBIT_full_time = OPTBIT_T + 2 * ENABLE_FEATURE_LS_WIDTH,
+	OPTBIT_dirs_first,
+	OPTBIT_color, /* 31 */
+	/* with long opts, we use all 32 bits */
 
+	OPT_F = (1 << OPTBIT_F) * ENABLE_FEATURE_LS_FILETYPES,
+	OPT_p = (1 << OPTBIT_p) * ENABLE_FEATURE_LS_FILETYPES,
+	OPT_R = (1 << OPTBIT_R) * ENABLE_FEATURE_LS_RECURSIVE,
+	OPT_Z = (1 << OPTBIT_Z) * ENABLE_SELINUX,
+	OPT_Q = (1 << OPTBIT_Q),
 	OPT_c = (1 << OPTBIT_c) * ENABLE_FEATURE_LS_TIMESTAMPS,
-	OPT_e = (1 << OPTBIT_e) * ENABLE_FEATURE_LS_TIMESTAMPS,
 	OPT_t = (1 << OPTBIT_t) * ENABLE_FEATURE_LS_TIMESTAMPS,
 	OPT_u = (1 << OPTBIT_u) * ENABLE_FEATURE_LS_TIMESTAMPS,
 	OPT_S = (1 << OPTBIT_S) * ENABLE_FEATURE_LS_SORTFILES,
 	OPT_X = (1 << OPTBIT_X) * ENABLE_FEATURE_LS_SORTFILES,
 	OPT_r = (1 << OPTBIT_r) * ENABLE_FEATURE_LS_SORTFILES,
 	OPT_v = (1 << OPTBIT_v) * ENABLE_FEATURE_LS_SORTFILES,
-	OPT_F = (1 << OPTBIT_F) * ENABLE_FEATURE_LS_FILETYPES,
-	OPT_p = (1 << OPTBIT_p) * ENABLE_FEATURE_LS_FILETYPES,
-	OPT_R = (1 << OPTBIT_R) * ENABLE_FEATURE_LS_RECURSIVE,
-	OPT_K = (1 << OPTBIT_K) * ENABLE_SELINUX,
-	OPT_Z = (1 << OPTBIT_Z) * ENABLE_SELINUX,
 	OPT_L = (1 << OPTBIT_L) * ENABLE_FEATURE_LS_FOLLOWLINKS,
 	OPT_H = (1 << OPTBIT_H) * ENABLE_FEATURE_LS_FOLLOWLINKS,
 	OPT_h = (1 << OPTBIT_h) * ENABLE_FEATURE_HUMAN_READABLE,
-	OPT_T = (1 << OPTBIT_T) * ENABLE_FEATURE_AUTOWIDTH,
-	OPT_w = (1 << OPTBIT_w) * ENABLE_FEATURE_AUTOWIDTH,
-	OPT_color = (1 << OPTBIT_color) * ENABLE_FEATURE_LS_COLOR,
+	OPT_T = (1 << OPTBIT_T) * ENABLE_FEATURE_LS_WIDTH,
+	OPT_w = (1 << OPTBIT_w) * ENABLE_FEATURE_LS_WIDTH,
+	OPT_full_time  = (1 << OPTBIT_full_time ) * ENABLE_LONG_OPTS,
+	OPT_dirs_first = (1 << OPTBIT_dirs_first) * ENABLE_LONG_OPTS,
+	OPT_color      = (1 << OPTBIT_color     ) * ENABLE_FEATURE_LS_COLOR,
 };
 
-/* TODO: simple toggles may be stored as OPT_xxx bits instead */
-static const uint32_t opt_flags[] = {
-	STYLE_COLUMNAR,              /* C */
-	DISP_HIDDEN | DISP_DOT,      /* a */
-	DISP_NOLIST,                 /* d */
-	LIST_INO,                    /* i */
-	LIST_LONG | STYLE_LONG,      /* l */
-	STYLE_SINGLE,                /* 1 */
-	LIST_LONG | STYLE_LONG,      /* g (don't show owner) - handled via OPT_g. assumes l */
-	LIST_ID_NUMERIC | LIST_LONG | STYLE_LONG, /* n (assumes l) */
-	LIST_BLOCKS,                 /* s */
-	DISP_ROWS | STYLE_COLUMNAR,  /* x */
-	0,                           /* Q (quote filename) - handled via OPT_Q */
-	DISP_HIDDEN,                 /* A */
-	ENABLE_SELINUX * (LIST_CONTEXT|STYLE_SINGLE), /* k (ignored if !SELINUX) */
-#if ENABLE_FEATURE_LS_TIMESTAMPS
-	TIME_CHANGE | (ENABLE_FEATURE_LS_SORTFILES * SORT_CTIME), /* c */
-	LIST_FULLTIME,               /* e */
-	ENABLE_FEATURE_LS_SORTFILES * SORT_MTIME, /* t */
-	TIME_ACCESS | (ENABLE_FEATURE_LS_SORTFILES * SORT_ATIME), /* u */
-#endif
-#if ENABLE_FEATURE_LS_SORTFILES
-	SORT_SIZE,                   /* S */
-	SORT_EXT,                    /* X */
-	SORT_REVERSE,                /* r */
-	SORT_VERSION,                /* v */
-#endif
-#if ENABLE_FEATURE_LS_FILETYPES
-	LIST_FILETYPE | LIST_CLASSIFY, /* F */
-	LIST_FILETYPE,               /* p */
-#endif
-#if ENABLE_FEATURE_LS_RECURSIVE
-	DISP_RECURSIVE,              /* R */
-#endif
-#if ENABLE_SELINUX
-	LIST_MODEBITS|LIST_NLINKS|LIST_CONTEXT|LIST_SIZE|LIST_DATE_TIME|STYLE_SINGLE, /* K */
-	LIST_MODEBITS|LIST_ID_NAME|LIST_CONTEXT|STYLE_SINGLE, /* Z */
-#endif
-	(1U << 31)
-	/* options after Z are not processed through opt_flags */
-};
-
-
 /*
  * a directory entry and its stat info
  */
@@ -399,9 +305,7 @@ struct dnode {
 	mode_t    dn_mode; /* obtained with lstat OR stat, depending on -L etc */
 	off_t     dn_size;
 #if ENABLE_FEATURE_LS_TIMESTAMPS || ENABLE_FEATURE_LS_SORTFILES
-	time_t    dn_atime;
-	time_t    dn_mtime;
-	time_t    dn_ctime;
+	time_t    dn_time;
 #endif
 	ino_t     dn_ino;
 	blkcnt_t  dn_blocks;
@@ -422,8 +326,8 @@ struct globals {
 # define G_show_color 0
 #endif
 	smallint exit_code;
-	unsigned all_fmt;
-#if ENABLE_FEATURE_AUTOWIDTH
+	smallint show_dirname;
+#if ENABLE_FEATURE_LS_WIDTH
 	unsigned terminal_width;
 # define G_terminal_width (G.terminal_width)
 #else
@@ -439,7 +343,7 @@ struct globals {
 	setup_common_bufsiz(); \
 	/* we have to zero it out because of NOEXEC */ \
 	memset(&G, 0, sizeof(G)); \
-	IF_FEATURE_AUTOWIDTH(G_terminal_width = TERMINAL_WIDTH;) \
+	IF_FEATURE_LS_WIDTH(G_terminal_width = TERMINAL_WIDTH;) \
 	IF_FEATURE_LS_TIMESTAMPS(time(&G.current_time_t);) \
 } while (0)
 
@@ -496,11 +400,12 @@ static char bold(mode_t mode)
 #if ENABLE_FEATURE_LS_FILETYPES
 static char append_char(mode_t mode)
 {
-	if (!(G.all_fmt & LIST_FILETYPE))
+	if (!(option_mask32 & (OPT_F|OPT_p)))
 		return '\0';
+
 	if (S_ISDIR(mode))
 		return '/';
-	if (!(G.all_fmt & LIST_CLASSIFY))
+	if (!(option_mask32 & OPT_F))
 		return '\0';
 	if (S_ISREG(mode) && (mode & (S_IXUSR | S_IXGRP | S_IXOTH)))
 		return '*';
@@ -531,8 +436,8 @@ static unsigned calc_name_len(const char
 }
 
 /* Return the number of used columns.
- * Note that only STYLE_COLUMNAR uses return value.
- * STYLE_SINGLE and STYLE_LONG don't care.
+ * Note that only columnar output uses return value.
+ * -l and -1 modes don't care.
  * coreutils 7.2 also supports:
  * ls -b (--escape) = octal escapes (although it doesn't look like working)
  * ls -N (--literal) = not escape at all
@@ -565,13 +470,14 @@ static unsigned print_name(const char *n
 }
 
 /* Return the number of used columns.
- * Note that only STYLE_COLUMNAR uses return value,
- * STYLE_SINGLE and STYLE_LONG don't care.
+ * Note that only columnar output uses return value,
+ * -l and -1 modes don't care.
  */
 static NOINLINE unsigned display_single(const struct dnode *dn)
 {
 	unsigned column = 0;
 	char *lpath;
+	int opt;
 #if ENABLE_FEATURE_LS_FILETYPES || ENABLE_FEATURE_LS_COLOR
 	struct stat statbuf;
 	char append;
@@ -580,50 +486,61 @@ static NOINLINE unsigned display_single(
 #if ENABLE_FEATURE_LS_FILETYPES
 	append = append_char(dn->dn_mode);
 #endif
+	opt = option_mask32;
 
 	/* Do readlink early, so that if it fails, error message
 	 * does not appear *inside* the "ls -l" line */
 	lpath = NULL;
-	if (G.all_fmt & LIST_SYMLINK)
+	if (opt & OPT_l)
 		if (S_ISLNK(dn->dn_mode))
 			lpath = xmalloc_readlink_or_warn(dn->fullname);
 
-	if (G.all_fmt & LIST_INO)
+	if (opt & OPT_i) /* show inode# */
 		column += printf("%7llu ", (long long) dn->dn_ino);
 //TODO: -h should affect -s too:
-	if (G.all_fmt & LIST_BLOCKS)
+	if (opt & OPT_s) /* show allocated blocks */
 		column += printf("%6"OFF_FMT"u ", (off_t) (dn->dn_blocks >> 1));
-	if (G.all_fmt & LIST_MODEBITS)
+	if (opt & OPT_l) {
+		/* long listing: show mode */
 		column += printf("%-10s ", (char *) bb_mode_string(dn->dn_mode));
-	if (G.all_fmt & LIST_NLINKS)
+		/* long listing: show number of links */
 		column += printf("%4lu ", (long) dn->dn_nlink);
-	if (G.all_fmt & LIST_ID_NUMERIC) {
-		if (option_mask32 & OPT_g)
-			column += printf("%-8u ", (int) dn->dn_gid);
-		else
-			column += printf("%-8u %-8u ",
-					(int) dn->dn_uid,
-					(int) dn->dn_gid);
-	}
+		/* long listing: show user/group */
+		if (opt & OPT_n) {
+			if (opt & OPT_g)
+				column += printf("%-8u ", (int) dn->dn_gid);
+			else
+				column += printf("%-8u %-8u ",
+						(int) dn->dn_uid,
+						(int) dn->dn_gid);
+		}
 #if ENABLE_FEATURE_LS_USERNAME
-	else if (G.all_fmt & LIST_ID_NAME) {
-		if (option_mask32 & OPT_g) {
-			column += printf("%-8.8s ",
-				get_cached_groupname(dn->dn_gid));
-		} else {
-			column += printf("%-8.8s %-8.8s ",
-				get_cached_username(dn->dn_uid),
-				get_cached_groupname(dn->dn_gid));
+		else {
+			if (opt & OPT_g) {
+				column += printf("%-8.8s ",
+					get_cached_groupname(dn->dn_gid));
+			} else {
+				column += printf("%-8.8s %-8.8s ",
+					get_cached_username(dn->dn_uid),
+					get_cached_groupname(dn->dn_gid));
+			}
 		}
+#endif
+#if ENABLE_SELINUX
+	}
+	if (opt & OPT_Z) {
+		column += printf("%-32s ", dn->sid ? dn->sid : "?");
+		freecon(dn->sid);
 	}
+	if (opt & OPT_l) {
 #endif
-	if (G.all_fmt & LIST_SIZE) {
+		/* long listing: show size */
 		if (S_ISBLK(dn->dn_mode) || S_ISCHR(dn->dn_mode)) {
 			column += printf("%4u, %3u ",
 					dn->dn_rdev_maj,
 					dn->dn_rdev_min);
 		} else {
-			if (option_mask32 & OPT_h) {
+			if (opt & OPT_h) {
 				column += printf("%"HUMAN_READABLE_MAX_WIDTH_STR"s ",
 					/* print size, show one fractional, use suffixes */
 					make_human_readable_str(dn->dn_size, 1, 0)
@@ -632,25 +549,22 @@ static NOINLINE unsigned display_single(
 				column += printf("%9"OFF_FMT"u ", dn->dn_size);
 			}
 		}
-	}
 #if ENABLE_FEATURE_LS_TIMESTAMPS
-	if (G.all_fmt & (LIST_FULLTIME|LIST_DATE_TIME)) {
-		char *filetime;
-		const time_t *ttime = &dn->dn_mtime;
-		if (G.all_fmt & TIME_ACCESS)
-			ttime = &dn->dn_atime;
-		if (G.all_fmt & TIME_CHANGE)
-			ttime = &dn->dn_ctime;
-		filetime = ctime(ttime);
-		/* filetime's format: "Wed Jun 30 21:49:08 1993\n" */
-		if (G.all_fmt & LIST_FULLTIME) { /* -e */
-			/* Note: coreutils 8.4 ls --full-time prints:
+		/* long listing: show {m,c,a}time */
+		if (opt & OPT_full_time) { /* --full-time */
+			/* coreutils 8.4 ls --full-time prints:
 			 * 2009-07-13 17:49:27.000000000 +0200
+			 * we don't show fractional seconds.
 			 */
-			column += printf("%.24s ", filetime);
-		} else { /* LIST_DATE_TIME */
-			/* G.current_time_t ~== time(NULL) */
-			time_t age = G.current_time_t - *ttime;
+			char buf[sizeof("YYYY-mm-dd HH:MM:SS TIMEZONE")];
+			strftime(buf, sizeof(buf), "%Y-%m-%d %H:%M:%S %z",
+					localtime(&dn->dn_time));
+			column += printf("%s ", buf);
+		} else { /* ordinary time format */
+			/* G.current_time_t is ~== time(NULL) */
+			char *filetime = ctime(&dn->dn_time);
+			/* filetime's format: "Wed Jun 30 21:49:08 1993\n" */
+			time_t age = G.current_time_t - dn->dn_time;
 			if (age < 3600L * 24 * 365 / 2 && age > -15 * 60) {
 				/* less than 6 months old */
 				/* "mmm dd hh:mm " */
@@ -663,14 +577,8 @@ static NOINLINE unsigned display_single(
 			}
 			column += 13;
 		}
-	}
 #endif
-#if ENABLE_SELINUX
-	if (G.all_fmt & LIST_CONTEXT) {
-		column += printf("%-32s ", dn->sid ? dn->sid : "unknown");
-		freecon(dn->sid);
 	}
-#endif
 
 #if ENABLE_FEATURE_LS_COLOR
 	if (G_show_color) {
@@ -689,7 +597,9 @@ static NOINLINE unsigned display_single(
 	if (lpath) {
 		printf(" -> ");
 #if ENABLE_FEATURE_LS_FILETYPES || ENABLE_FEATURE_LS_COLOR
-		if ((G.all_fmt & LIST_FILETYPE) || G_show_color) {
+		if ((opt & (OPT_F|OPT_p))
+		 || G_show_color
+		) {
 			mode_t mode = dn->dn_mode_stat;
 			if (!mode)
 				if (stat(dn->fullname, &statbuf) == 0)
@@ -711,7 +621,7 @@ static NOINLINE unsigned display_single(
 		}
 	}
 #if ENABLE_FEATURE_LS_FILETYPES
-	if (G.all_fmt & LIST_FILETYPE) {
+	if (opt & (OPT_F|OPT_p)) {
 		if (append) {
 			putchar(append);
 			column++;
@@ -727,9 +637,9 @@ static void display_files(struct dnode *
 	unsigned i, ncols, nrows, row, nc;
 	unsigned column;
 	unsigned nexttab;
-	unsigned column_width = 0; /* used only by STYLE_COLUMNAR */
+	unsigned column_width = 0; /* used only by coulmnal output */
 
-	if (G.all_fmt & STYLE_LONG) { /* STYLE_LONG or STYLE_SINGLE */
+	if (option_mask32 & (OPT_l|OPT_1)) {
 		ncols = 1;
 	} else {
 		/* find the longest file name, use that as the column width */
@@ -738,10 +648,11 @@ static void display_files(struct dnode *
 			if (column_width < len)
 				column_width = len;
 		}
-		column_width += 2 +
-			IF_SELINUX( ((G.all_fmt & LIST_CONTEXT) ? 33 : 0) + )
-				((G.all_fmt & LIST_INO) ? 8 : 0) +
-				((G.all_fmt & LIST_BLOCKS) ? 5 : 0);
+		column_width += 2
+			+ ((option_mask32 & OPT_Z) ? 33 : 0) /* context width */
+			+ ((option_mask32 & OPT_i) ? 8 : 0) /* inode# width */
+			+ ((option_mask32 & OPT_s) ? 5 : 0) /* "alloc block" width */
+		;
 		ncols = (unsigned)G_terminal_width / column_width;
 	}
 
@@ -759,7 +670,7 @@ static void display_files(struct dnode *
 	for (row = 0; row < nrows; row++) {
 		for (nc = 0; nc < ncols; nc++) {
 			/* reach into the array based on the column and row */
-			if (G.all_fmt & DISP_ROWS)
+			if (option_mask32 & OPT_x)
 				i = (row * ncols) + nc;	/* display across row */
 			else
 				i = (nc * nrows) + row;	/* display by column */
@@ -792,7 +703,7 @@ static struct dnode *my_stat(const char
 
 	if ((option_mask32 & OPT_L) || force_follow) {
 #if ENABLE_SELINUX
-		if (is_selinux_enabled())  {
+		if (option_mask32 & OPT_Z) {
 			getfilecon(fullname, &cur->sid);
 		}
 #endif
@@ -805,7 +716,7 @@ static struct dnode *my_stat(const char
 		cur->dn_mode_stat = statbuf.st_mode;
 	} else {
 #if ENABLE_SELINUX
-		if (is_selinux_enabled()) {
+		if (option_mask32 & OPT_Z) {
 			lgetfilecon(fullname, &cur->sid);
 		}
 #endif
@@ -822,9 +733,11 @@ static struct dnode *my_stat(const char
 	cur->dn_mode   = statbuf.st_mode  ;
 	cur->dn_size   = statbuf.st_size  ;
 #if ENABLE_FEATURE_LS_TIMESTAMPS || ENABLE_FEATURE_LS_SORTFILES
-	cur->dn_atime  = statbuf.st_atime ;
-	cur->dn_mtime  = statbuf.st_mtime ;
-	cur->dn_ctime  = statbuf.st_ctime ;
+	cur->dn_time   = statbuf.st_mtime ;
+	if (option_mask32 & OPT_u)
+		cur->dn_time = statbuf.st_atime;
+	if (option_mask32 & OPT_c)
+		cur->dn_time = statbuf.st_ctime;
 #endif
 	cur->dn_ino    = statbuf.st_ino   ;
 	cur->dn_blocks = statbuf.st_blocks;
@@ -938,33 +851,30 @@ static int sortcmp(const void *a, const
 {
 	struct dnode *d1 = *(struct dnode **)a;
 	struct dnode *d2 = *(struct dnode **)b;
-	unsigned sort_opts = G.all_fmt & SORT_MASK;
+	unsigned opt = option_mask32;
 	off_t dif;
 
-	dif = 0; /* assume SORT_NAME */
+	dif = 0; /* assume sort by name */
 	// TODO: use pre-initialized function pointer
 	// instead of branch forest
-	if (sort_opts == SORT_SIZE) {
+	if (opt & OPT_dirs_first) {
+		dif = S_ISDIR(d2->dn_mode) - S_ISDIR(d1->dn_mode);
+		if (dif != 0)
+			goto maybe_invert_and_ret;
+	}
+
+	if (opt & OPT_S) { /* sort by size */
 		dif = (d2->dn_size - d1->dn_size);
 	} else
-	if (sort_opts == SORT_ATIME) {
-		dif = (d2->dn_atime - d1->dn_atime);
-	} else
-	if (sort_opts == SORT_CTIME) {
-		dif = (d2->dn_ctime - d1->dn_ctime);
-	} else
-	if (sort_opts == SORT_MTIME) {
-		dif = (d2->dn_mtime - d1->dn_mtime);
-	} else
-	if (sort_opts == SORT_DIR) {
-		dif = S_ISDIR(d2->dn_mode) - S_ISDIR(d1->dn_mode);
+	if (opt & OPT_t) { /* sort by time */
+		dif = (d2->dn_time - d1->dn_time);
 	} else
 #if defined(HAVE_STRVERSCMP) && HAVE_STRVERSCMP == 1
-	if (sort_opts == SORT_VERSION) {
+	if (opt & OPT_v) { /* sort by version */
 		dif = strverscmp(d1->name, d2->name);
 	} else
 #endif
-	if (sort_opts == SORT_EXT) {
+	if (opt & OPT_X) { /* sort by extension */
 		dif = strcmp(strchrnul(d1->name, '.'), strchrnul(d2->name, '.'));
 	}
 	if (dif == 0) {
@@ -973,18 +883,17 @@ static int sortcmp(const void *a, const
 			dif = strcoll(d1->name, d2->name);
 		else
 			dif = strcmp(d1->name, d2->name);
-	}
-
-	/* Make dif fit into an int */
-	if (sizeof(dif) > sizeof(int)) {
-		enum { BITS_TO_SHIFT = 8 * (sizeof(dif) - sizeof(int)) };
-		/* shift leaving only "int" worth of bits */
-		if (dif != 0) {
+	} else {
+		/* Make dif fit into an int */
+		if (sizeof(dif) > sizeof(int)) {
+			enum { BITS_TO_SHIFT = 8 * (sizeof(dif) - sizeof(int)) };
+			/* shift leaving only "int" worth of bits */
+			/* (this requires dif != 0, and here it is nonzero) */
 			dif = 1 | (int)((uoff_t)dif >> BITS_TO_SHIFT);
 		}
 	}
-
-	return (G.all_fmt & SORT_REVERSE) ? -(int)dif : (int)dif;
+ maybe_invert_and_ret:
+	return (opt & OPT_r) ? -(int)dif : (int)dif;
 }
 
 static void dnsort(struct dnode **dn, int size)
@@ -1023,13 +932,13 @@ static struct dnode **scan_one_dir(const
 
 		/* are we going to list the file- it may be . or .. or a hidden file */
 		if (entry->d_name[0] == '.') {
-			if ((!entry->d_name[1] || (entry->d_name[1] == '.' && !entry->d_name[2]))
-			 && !(G.all_fmt & DISP_DOT)
+			if (!(option_mask32 & (OPT_a|OPT_A)))
+				continue; /* skip all dotfiles if no -a/-A */
+			if (!(option_mask32 & OPT_a)
+			 && (!entry->d_name[1] || (entry->d_name[1] == '.' && !entry->d_name[2]))
 			) {
-				continue;
+				continue; /* if only -A, skip . and .. but show other dotfiles */
 			}
-			if (!(G.all_fmt & DISP_HIDDEN))
-				continue;
 		}
 		fullname = concat_path_file(path, entry->d_name);
 		cur = my_stat(fullname, bb_basename(fullname), 0);
@@ -1097,7 +1006,7 @@ static void scan_and_display_dirs_recur(
 	struct dnode **subdnp;
 
 	for (; *dn; dn++) {
-		if (G.all_fmt & (DISP_DIRNAME | DISP_RECURSIVE)) {
+		if (G.show_dirname || (option_mask32 & OPT_R)) {
 			if (!first)
 				bb_putchar('\n');
 			first = 0;
@@ -1105,15 +1014,16 @@ static void scan_and_display_dirs_recur(
 		}
 		subdnp = scan_one_dir((*dn)->fullname, &nfiles);
 #if ENABLE_DESKTOP
-		if ((G.all_fmt & STYLE_MASK) == STYLE_LONG || (G.all_fmt & LIST_BLOCKS))
+		if (option_mask32 & (OPT_s|OPT_l)) {
 			printf("total %"OFF_FMT"u\n", calculate_blocks(subdnp));
+		}
 #endif
 		if (nfiles > 0) {
 			/* list all files at this level */
 			sort_and_display_files(subdnp, nfiles);
 
 			if (ENABLE_FEATURE_LS_RECURSIVE
-			 && (G.all_fmt & DISP_RECURSIVE)
+			 && (option_mask32 & OPT_R)
 			) {
 				struct dnode **dnd;
 				unsigned dndirs;
@@ -1135,7 +1045,7 @@ static void scan_and_display_dirs_recur(
 
 
 int ls_main(int argc UNUSED_PARAM, char **argv)
-{
+{	/*      ^^^^^^^^^^^^^^^^^ note: if FTPD, argc can be wrong, see ftpd.c */
 	struct dnode **dnd;
 	struct dnode **dnf;
 	struct dnode **dnp;
@@ -1157,23 +1067,25 @@ int ls_main(int argc UNUSED_PARAM, char
 	 * 'auto', 'tty', 'if-tty'
 	 * (and substrings: "--color=alwa" work too)
 	 */
-	static const char ls_longopts[] ALIGN1 =
-		"color\0" Optional_argument "\xff"; /* no short equivalent */
 	static const char color_str[] ALIGN1 =
 		"always\0""yes\0""force\0"
 		"auto\0""tty\0""if-tty\0";
 	/* need to initialize since --color has _an optional_ argument */
 	const char *color_opt = color_str; /* "always" */
 #endif
+#if ENABLE_LONG_OPTS
+	static const char ls_longopts[] ALIGN1 =
+		"full-time\0" No_argument "\xff"
+		"group-directories-first\0" No_argument "\xfe"
+		"color\0" Optional_argument "\xfd"
+	;
+#endif
 
 	INIT_G();
 
 	init_unicode();
 
-	if (ENABLE_FEATURE_LS_SORTFILES)
-		G.all_fmt = SORT_NAME;
-
-#if ENABLE_FEATURE_AUTOWIDTH
+#if ENABLE_FEATURE_LS_WIDTH
 	/* obtain the terminal width */
 	G_terminal_width = get_terminal_width(STDIN_FILENO);
 	/* go one less... */
@@ -1181,10 +1093,12 @@ int ls_main(int argc UNUSED_PARAM, char
 #endif
 
 	/* process options */
-	IF_FEATURE_LS_COLOR(applet_long_options = ls_longopts;)
+	IF_LONG_OPTS(applet_long_options = ls_longopts;)
 	opt_complementary =
-		/* -e implies -l */
-		IF_FEATURE_LS_TIMESTAMPS("el")
+		/* -n and -g imply -l */
+		"nl:gl"
+		/* --full-time implies -l */
+		IF_FEATURE_LS_TIMESTAMPS(IF_LONG_OPTS(":\xff""l"))
 		/* http://pubs.opengroup.org/onlinepubs/9699919799/utilities/ls.html:
 		 * in some pairs of opts, only last one takes effect:
 		 */
@@ -1196,25 +1110,28 @@ int ls_main(int argc UNUSED_PARAM, char
 		":x-1:1-x" /* bylines/oneline (not in SuS, but in GNU coreutils 8.4) */
 		IF_FEATURE_LS_TIMESTAMPS(":c-u:u-c") /* mtime/atime */
 		/* -w NUM: */
-		IF_FEATURE_AUTOWIDTH(":w+");
+		IF_FEATURE_LS_WIDTH(":w+");
 	opt = getopt32(argv, ls_options
-		IF_FEATURE_AUTOWIDTH(, NULL, &G_terminal_width)
+		IF_FEATURE_LS_WIDTH(, /*-T*/ NULL, /*-w*/ &G_terminal_width)
 		IF_FEATURE_LS_COLOR(, &color_opt)
 	);
-	for (i = 0; opt_flags[i] != (1U << 31); i++) {
-		if (opt & (1 << i)) {
-			uint32_t flags = opt_flags[i];
-
-			if (flags & STYLE_MASK)
-				G.all_fmt &= ~STYLE_MASK;
-			if (flags & SORT_MASK)
-				G.all_fmt &= ~SORT_MASK;
-			if (flags & TIME_MASK)
-				G.all_fmt &= ~TIME_MASK;
+#if 0 /* option bits debug */
+	bb_error_msg("opt:0x%08x l:%x H:%x color:%x dirs:%x", opt, OPT_l, OPT_H, OPT_color, OPT_dirs_first);
+	if (opt & OPT_c         ) bb_error_msg("-c");
+	if (opt & OPT_l         ) bb_error_msg("-l");
+	if (opt & OPT_H         ) bb_error_msg("-H");
+	if (opt & OPT_color     ) bb_error_msg("--color");
+	if (opt & OPT_dirs_first) bb_error_msg("--group-directories-first");
+	if (opt & OPT_full_time ) bb_error_msg("--full-time");
+	exit(0);
+#endif
 
-			G.all_fmt |= flags;
-		}
+#if ENABLE_SELINUX
+	if (opt & OPT_Z) {
+		if (!is_selinux_enabled())
+			option_mask32 &= ~OPT_Z;
 	}
+#endif
 
 #if ENABLE_FEATURE_LS_COLOR
 	/* set G_show_color = 1/0 */
@@ -1242,27 +1159,35 @@ int ls_main(int argc UNUSED_PARAM, char
 #endif
 
 	/* sort out which command line options take precedence */
-	if (ENABLE_FEATURE_LS_RECURSIVE && (G.all_fmt & DISP_NOLIST))
-		G.all_fmt &= ~DISP_RECURSIVE;	/* no recurse if listing only dir */
-	if (ENABLE_FEATURE_LS_TIMESTAMPS && ENABLE_FEATURE_LS_SORTFILES) {
-		if (G.all_fmt & TIME_CHANGE)
-			G.all_fmt = (G.all_fmt & ~SORT_MASK) | SORT_CTIME;
-		if (G.all_fmt & TIME_ACCESS)
-			G.all_fmt = (G.all_fmt & ~SORT_MASK) | SORT_ATIME;
+	if (ENABLE_FEATURE_LS_RECURSIVE && (opt & OPT_d))
+		option_mask32 &= ~OPT_R;	/* no recurse if listing only dir */
+	if (!(opt & OPT_l)) { /* not -l? */
+		if (ENABLE_FEATURE_LS_TIMESTAMPS && ENABLE_FEATURE_LS_SORTFILES) {
+			/* when to sort by time? -t[cu] sorts by time even with -l */
+			/* (this is achieved by opt_flags[] element for -t) */
+			/* without -l, bare -c or -u enable sort too */
+			/* (with -l, bare -c or -u just select which time to show) */
+			if (opt & (OPT_c|OPT_u)) {
+				option_mask32 |= OPT_t;
+			}
+		}
 	}
-	if ((G.all_fmt & STYLE_MASK) != STYLE_LONG) /* not -l? */
-		G.all_fmt &= ~(LIST_ID_NUMERIC|LIST_ID_NAME|LIST_FULLTIME);
 
 	/* choose a display format if one was not already specified by an option */
-	if (!(G.all_fmt & STYLE_MASK))
-		G.all_fmt |= (isatty(STDOUT_FILENO) ? STYLE_COLUMNAR : STYLE_SINGLE);
+	if (!(option_mask32 & (OPT_l|OPT_1|OPT_x|OPT_C)))
+		option_mask32 |= (isatty(STDOUT_FILENO) ? OPT_C : OPT_1);
+
+	if (ENABLE_FTPD && applet_name[0] == 'f') {
+		/* ftpd secret backdoor. dirs first are much nicer */
+		option_mask32 |= OPT_dirs_first;
+	}
 
 	argv += optind;
 	if (!argv[0])
 		*--argv = (char*)".";
 
 	if (argv[1])
-		G.all_fmt |= DISP_DIRNAME; /* 2 or more items? label directories */
+		G.show_dirname = 1; /* 2 or more items? label directories */
 
 	/* stuff the command line file names into a dnode array */
 	dn = NULL;
@@ -1270,10 +1195,7 @@ int ls_main(int argc UNUSED_PARAM, char
 	do {
 		cur = my_stat(*argv, *argv,
 			/* follow links on command line unless -l, -s or -F: */
-			!((G.all_fmt & STYLE_MASK) == STYLE_LONG
-			  || (G.all_fmt & LIST_BLOCKS)
-			  || (option_mask32 & OPT_F)
-			)
+			!(option_mask32 & (OPT_l|OPT_s|OPT_F))
 			/* ... or if -H: */
 			|| (option_mask32 & OPT_H)
 			/* ... or if -L, but my_stat always follows links if -L */
@@ -1302,7 +1224,7 @@ int ls_main(int argc UNUSED_PARAM, char
 			break;
 	}
 
-	if (G.all_fmt & DISP_NOLIST) {
+	if (option_mask32 & OPT_d) {
 		sort_and_display_files(dnp, nfiles);
 	} else {
 		dnd = splitdnarray(dnp, SPLIT_DIR);
diff -urpN busybox-1.26.2/coreutils/md5_sha1_sum.c busybox-1.27.0/coreutils/md5_sha1_sum.c
--- busybox-1.26.2/coreutils/md5_sha1_sum.c	2016-09-27 18:53:50.000000000 +0200
+++ busybox-1.27.0/coreutils/md5_sha1_sum.c	2017-01-24 18:44:48.000000000 +0100
@@ -45,7 +45,6 @@
 //config:	help
 //config:	  Enabling the -c options allows files to be checked
 //config:	  against pre-calculated hash values.
-//config:
 //config:	  -s and -w are useful options when verifying checksums.
 
 //applet:IF_MD5SUM(APPLET_NOEXEC(md5sum, md5_sha1_sum, BB_DIR_USR_BIN, BB_SUID_DROP, md5sum))
@@ -167,7 +166,7 @@ static uint8_t *hash_file(const char *fi
 	} context;
 	uint8_t *hash_value;
 	void FAST_FUNC (*update)(void*, const void*, size_t);
-	void FAST_FUNC (*final)(void*, void*);
+	unsigned FAST_FUNC (*final)(void*, void*);
 	char hash_algo;
 
 	src_fd = open_or_warn_stdin(filename);
diff -urpN busybox-1.26.2/coreutils/mkdir.c busybox-1.27.0/coreutils/mkdir.c
--- busybox-1.26.2/coreutils/mkdir.c	2016-12-10 18:46:36.000000000 +0100
+++ busybox-1.27.0/coreutils/mkdir.c	2017-01-10 16:31:40.000000000 +0100
@@ -23,8 +23,6 @@
 //config:	bool "Enable long options"
 //config:	default y
 //config:	depends on MKDIR && LONG_OPTS
-//config:	help
-//config:	  Support long options for the mkdir applet.
 
 //applet:IF_MKDIR(APPLET_NOFORK(mkdir, mkdir, BB_DIR_BIN, BB_SUID_DROP, mkdir))
 
diff -urpN busybox-1.26.2/coreutils/mktemp.c busybox-1.27.0/coreutils/mktemp.c
--- busybox-1.26.2/coreutils/mktemp.c	1970-01-01 01:00:00.000000000 +0100
+++ busybox-1.27.0/coreutils/mktemp.c	2017-07-01 22:51:12.000000000 +0200
@@ -0,0 +1,122 @@
+/* vi: set sw=4 ts=4: */
+/*
+ * Mini mktemp implementation for busybox
+ *
+ *
+ * Copyright (C) 2000 by Daniel Jacobowitz
+ * Written by Daniel Jacobowitz <dan@debian.org>
+ *
+ * Licensed under GPLv2 or later, see file LICENSE in this source tree.
+ */
+
+/* Coreutils 6.12 man page says:
+ *        mktemp [OPTION]... [TEMPLATE]
+ * Create a temporary file or directory, safely, and print its name. If
+ * TEMPLATE is not specified, use tmp.XXXXXXXXXX.
+ * -d, --directory
+ *        create a directory, not a file
+ * -q, --quiet
+ *        suppress diagnostics about file/dir-creation failure
+ * -u, --dry-run
+ *        do not create anything; merely print a name (unsafe)
+ * --tmpdir[=DIR]
+ *        interpret TEMPLATE relative to DIR. If DIR is not specified,
+ *        use  $TMPDIR if set, else /tmp.  With this option, TEMPLATE must
+ *        not be an absolute name. Unlike with -t, TEMPLATE may contain
+ *        slashes, but even here, mktemp still creates only the final com-
+ *        ponent.
+ * -p DIR use DIR as a prefix; implies -t [deprecated]
+ * -t     interpret TEMPLATE as a single file name component, relative  to
+ *        a  directory:  $TMPDIR, if set; else the directory specified via
+ *        -p; else /tmp [deprecated]
+ */
+//config:config MKTEMP
+//config:	bool "mktemp"
+//config:	default y
+//config:	help
+//config:	  mktemp is used to create unique temporary files
+
+//applet:IF_MKTEMP(APPLET(mktemp, BB_DIR_BIN, BB_SUID_DROP))
+
+//kbuild:lib-$(CONFIG_MKTEMP) += mktemp.o
+
+//usage:#define mktemp_trivial_usage
+//usage:       "[-dt] [-p DIR] [TEMPLATE]"
+//usage:#define mktemp_full_usage "\n\n"
+//usage:       "Create a temporary file with name based on TEMPLATE and print its name.\n"
+//usage:       "TEMPLATE must end with XXXXXX (e.g. [/dir/]nameXXXXXX).\n"
+//usage:       "Without TEMPLATE, -t tmp.XXXXXX is assumed.\n"
+//usage:     "\n	-d	Make directory, not file"
+//usage:     "\n	-q	Fail silently on errors"
+//usage:     "\n	-t	Prepend base directory name to TEMPLATE"
+//usage:     "\n	-p DIR	Use DIR as a base directory (implies -t)"
+//usage:     "\n	-u	Do not create anything; print a name"
+//usage:     "\n"
+//usage:     "\nBase directory is: -p DIR, else $TMPDIR, else /tmp"
+//usage:
+//usage:#define mktemp_example_usage
+//usage:       "$ mktemp /tmp/temp.XXXXXX\n"
+//usage:       "/tmp/temp.mWiLjM\n"
+//usage:       "$ ls -la /tmp/temp.mWiLjM\n"
+//usage:       "-rw-------    1 andersen andersen        0 Apr 25 17:10 /tmp/temp.mWiLjM\n"
+
+#include "libbb.h"
+
+int mktemp_main(int argc, char **argv) MAIN_EXTERNALLY_VISIBLE;
+int mktemp_main(int argc UNUSED_PARAM, char **argv)
+{
+	const char *path;
+	char *chp;
+	unsigned opts;
+	enum {
+		OPT_d = 1 << 0,
+		OPT_q = 1 << 1,
+		OPT_t = 1 << 2,
+		OPT_p = 1 << 3,
+		OPT_u = 1 << 4,
+	};
+
+	path = getenv("TMPDIR");
+	if (!path || path[0] == '\0')
+		path = "/tmp";
+
+	opt_complementary = "?1"; /* 1 argument max */
+	opts = getopt32(argv, "dqtp:u", &path);
+
+	chp = argv[optind];
+	if (!chp) {
+		/* GNU coreutils 8.4:
+		 * bare "mktemp" -> "mktemp -t tmp.XXXXXX"
+		 */
+		chp = xstrdup("tmp.XXXXXX");
+		opts |= OPT_t;
+	}
+#if 0
+	/* Don't allow directory separator in template */
+	if ((opts & OPT_t) && bb_basename(chp) != chp) {
+		errno = EINVAL;
+		goto error;
+	}
+#endif
+	if (opts & (OPT_t|OPT_p))
+		chp = concat_path_file(path, chp);
+
+	if (opts & OPT_u) {
+		chp = mktemp(chp);
+		if (chp[0] == '\0')
+			goto error;
+	} else if (opts & OPT_d) {
+		if (mkdtemp(chp) == NULL)
+			goto error;
+	} else {
+		if (mkstemp(chp) < 0)
+			goto error;
+	}
+	puts(chp);
+	return EXIT_SUCCESS;
+ error:
+	if (opts & OPT_q)
+		return EXIT_FAILURE;
+	/* don't use chp as it gets mangled in case of error */
+	bb_perror_nomsg_and_die();
+}
diff -urpN busybox-1.26.2/coreutils/mv.c busybox-1.27.0/coreutils/mv.c
--- busybox-1.26.2/coreutils/mv.c	2016-12-10 18:46:36.000000000 +0100
+++ busybox-1.27.0/coreutils/mv.c	2017-01-10 16:31:40.000000000 +0100
@@ -21,8 +21,6 @@
 //config:	bool "Enable long options"
 //config:	default y
 //config:	depends on MV && LONG_OPTS
-//config:	help
-//config:	  Support long options for the mv applet.
 
 //applet:IF_MV(APPLET(mv, BB_DIR_BIN, BB_SUID_DROP))
 
diff -urpN busybox-1.26.2/coreutils/nl.c busybox-1.27.0/coreutils/nl.c
--- busybox-1.26.2/coreutils/nl.c	1970-01-01 01:00:00.000000000 +0100
+++ busybox-1.27.0/coreutils/nl.c	2017-07-01 22:51:12.000000000 +0200
@@ -0,0 +1,101 @@
+/* vi: set sw=4 ts=4: */
+/*
+ * Copyright (C) 2017 Denys Vlasenko <vda.linux@googlemail.com>
+ *
+ * Licensed under GPLv2, see file LICENSE in this source tree.
+ */
+//config:config NL
+//config:	bool "nl"
+//config:	default y
+//config:	help
+//config:	  nl is used to number lines of files.
+
+//applet:IF_NL(APPLET(nl, BB_DIR_USR_BIN, BB_SUID_DROP))
+
+//kbuild:lib-$(CONFIG_NL) += nl.o
+
+//usage:#define nl_trivial_usage
+//usage:       "[OPTIONS] [FILE]..."
+//usage:#define nl_full_usage "\n\n"
+//usage:       "Write FILEs to standard output with line numbers added\n"
+//usage:     "\n	-b STYLE	Which lines to number - a: all, t: nonempty, n: none"
+//^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^TODO: support "pBRE": number only lines thatmatch regexp BRE"
+////usage:     "\n	-f STYLE	footer lines"
+////usage:     "\n	-h STYLE	header lines"
+////usage:     "\n	-d CC		use CC for separating logical pages"
+//usage:     "\n	-i N		Line number increment"
+////usage:     "\n	-l NUMBER	group of NUMBER empty lines counted as one"
+////usage:     "\n	-n FORMAT	lneft justified, no leading zeros; rn or rz"
+////usage:     "\n	-p 		do not reset line numbers at logical pages (huh?)"
+//usage:     "\n	-s STRING	Use STRING as line number separator"
+//usage:     "\n	-v N		Start from N"
+//usage:     "\n	-w N		Width of line numbers"
+
+/* By default, selects -v1 -i1 -l1 -sTAB -w6 -nrn -hn -bt -fn */
+
+#include "libbb.h"
+
+void FAST_FUNC print_numbered_lines(struct number_state *ns, const char *filename)
+{
+	FILE *fp = fopen_or_warn_stdin(filename);
+	unsigned N = ns->start;
+	char *line;
+
+	while ((line = xmalloc_fgetline(fp)) != NULL) {
+		if (ns->all
+		 || (ns->nonempty && line[0])
+		) {
+			printf("%*u%s%s\n", ns->width, N, ns->sep, line);
+			N += ns->inc;
+		} else if (ns->empty_str)
+			fputs(ns->empty_str, stdout);
+		free(line);
+	}
+
+	fclose(fp);
+}
+
+int nl_main(int argc, char **argv) MAIN_EXTERNALLY_VISIBLE;
+int nl_main(int argc UNUSED_PARAM, char **argv)
+{
+	struct number_state ns;
+	const char *opt_b = "t";
+	enum {
+		OPT_p = (1 << 0),
+	};
+#if ENABLE_LONG_OPTS
+	static const char nl_longopts[] ALIGN1 =
+		"body-numbering\0"	Required_argument "b"
+	//	"footer-numbering\0"	Required_argument "f" - not implemented yet
+	//	"header-numbering\0"	Required_argument "h" - not implemented yet
+	//	"section-delimiter\0"	Required_argument "d" - not implemented yet
+		"line-increment\0"	Required_argument "i"
+	//	"join-blank-lines\0"	Required_argument "l" - not implemented yet
+	//	"number-format\0"	Required_argument "n" - not implemented yet
+		"no-renumber\0"		No_argument       "p" // no-op so far
+		"number-separator\0"	Required_argument "s"
+		"starting-line-number\0"Required_argument "v"
+		"number-width\0"	Required_argument "w"
+	;
+
+	applet_long_options = nl_longopts;
+#endif
+	ns.width = 6;
+	ns.start = 1;
+	ns.inc = 1;
+	ns.sep = "\t";
+	getopt32(argv, "pw:+s:v:+i:+b:", &ns.width, &ns.sep, &ns.start, &ns.inc, &opt_b);
+	ns.all = (opt_b[0] == 'a');
+	ns.nonempty = (opt_b[0] == 't');
+	ns.empty_str = xasprintf("%*s\n", ns.width + (int)strlen(ns.sep), "");
+
+	argv += optind;
+	if (!*argv)
+		*--argv = (char*)"-";
+
+	do {
+		print_numbered_lines(&ns, *argv);
+	} while (*++argv);
+
+	fflush_stdout_and_exit(EXIT_SUCCESS);
+}
diff -urpN busybox-1.26.2/coreutils/nproc.c busybox-1.27.0/coreutils/nproc.c
--- busybox-1.26.2/coreutils/nproc.c	1970-01-01 01:00:00.000000000 +0100
+++ busybox-1.27.0/coreutils/nproc.c	2017-07-01 22:51:12.000000000 +0200
@@ -0,0 +1,51 @@
+/*
+ * Copyright (C) 2017 Denys Vlasenko <vda.linux@googlemail.com>
+ *
+ * Licensed under GPLv2, see LICENSE in this source tree
+ */
+//config:config NPROC
+//config:	bool "nproc"
+//config:	default y
+//config:	help
+//config:	  Print number of CPUs
+
+//applet:IF_NPROC(APPLET(nproc, BB_DIR_USR_BIN, BB_SUID_DROP))
+
+//kbuild:lib-$(CONFIG_NPROC) += nproc.o
+
+//usage:#define nproc_trivial_usage
+//usage:	""
+//TODO: "[--all] [--ignore=N]"
+//usage:#define nproc_full_usage "\n\n"
+//usage:	"Print number of CPUs"
+
+#include <sched.h>
+#include "libbb.h"
+
+int nproc_main(int argc, char **argv) MAIN_EXTERNALLY_VISIBLE;
+int nproc_main(int argc UNUSED_PARAM, char **argv UNUSED_PARAM)
+{
+	unsigned long mask[1024];
+	unsigned i, count = 0;
+
+	//applet_long_options = ...;
+	//getopt32(argv, "");
+
+	//if --all, count /sys/devices/system/cpu/cpuN dirs, else:
+
+	if (sched_getaffinity(0, sizeof(mask), (void*)mask) == 0) {
+		for (i = 0; i < ARRAY_SIZE(mask); i++) {
+			unsigned long m = mask[i];
+			while (m) {
+				if (m & 1)
+					count++;
+				m >>= 1;
+			}
+		}
+	}
+	if (count == 0)
+		count++;
+	printf("%u\n", count);
+
+	return 0;
+}
diff -urpN busybox-1.26.2/coreutils/paste.c busybox-1.27.0/coreutils/paste.c
--- busybox-1.26.2/coreutils/paste.c	1970-01-01 01:00:00.000000000 +0100
+++ busybox-1.27.0/coreutils/paste.c	2017-04-05 18:27:36.000000000 +0200
@@ -0,0 +1,140 @@
+/* vi: set sw=4 ts=4: */
+/*
+ * paste.c - implementation of the posix paste command
+ *
+ * Written by Maxime Coste <mawww@kakoune.org>
+ *
+ * Licensed under GPLv2 or later, see file LICENSE in this source tree.
+ */
+//config:config PASTE
+//config:	bool "paste"
+//config:	default y
+//config:	help
+//config:	  paste is used to paste lines of different files together
+//config:	  and write the result to stdout
+
+//applet:IF_PASTE(APPLET_NOEXEC(paste, paste, BB_DIR_USR_BIN, BB_SUID_DROP, paste))
+
+//kbuild:lib-$(CONFIG_PASTE) += paste.o
+
+//usage:#define paste_trivial_usage
+//usage:       "[OPTIONS] [FILE]..."
+//usage:#define paste_full_usage "\n\n"
+//usage:       "Paste lines from each input file, separated with tab\n"
+//usage:     "\n	-d LIST	Use delimiters from LIST, not tab"
+//usage:     "\n	-s      Serial: one file at a time"
+//usage:
+//usage:#define paste_example_usage
+//usage:       "# write out directory in four columns\n"
+//usage:       "$ ls | paste - - - -\n"
+//usage:       "# combine pairs of lines from a file into single lines\n"
+//usage:       "$ paste -s -d '\\t\\n' file\n"
+
+#include "libbb.h"
+
+static void paste_files(FILE** files, int file_cnt, char* delims, int del_cnt)
+{
+	char *line;
+	char delim;
+	int active_files = file_cnt;
+	int i;
+
+	while (active_files > 0) {
+		int del_idx = 0;
+
+		for (i = 0; i < file_cnt; ++i) {
+			if (files[i] == NULL)
+				continue;
+
+			line = xmalloc_fgetline(files[i]);
+			if (!line) {
+				fclose_if_not_stdin(files[i]);
+				files[i] = NULL;
+				--active_files;
+				continue;
+			}
+			fputs(line, stdout);
+			free(line);
+			delim = '\n';
+			if (i != file_cnt - 1) {
+				delim = delims[del_idx++];
+				if (del_idx == del_cnt)
+					del_idx = 0;
+			}
+			if (delim != '\0')
+				fputc(delim, stdout);
+		}
+	}
+}
+
+static void paste_files_separate(FILE** files, char* delims, int del_cnt)
+{
+	char *line, *next_line;
+	char delim;
+	int i;
+
+	for (i = 0; files[i]; ++i) {
+		int del_idx = 0;
+
+		line = NULL;
+		while ((next_line = xmalloc_fgetline(files[i])) != NULL) {
+			if (line) {
+				fputs(line, stdout);
+				free(line);
+				delim = delims[del_idx++];
+				if (del_idx == del_cnt)
+					del_idx = 0;
+				if (delim != '\0')
+					fputc(delim, stdout);
+			}
+			line = next_line;
+		}
+		if (line) {
+			/* coreutils adds \n even if this is a final line
+			 * of the last file and it was not \n-terminated.
+			 */
+			printf("%s\n", line);
+			free(line);
+		}
+		fclose_if_not_stdin(files[i]);
+	}
+}
+
+#define PASTE_OPT_DELIMITERS (1 << 0)
+#define PASTE_OPT_SEPARATE   (1 << 1)
+
+int paste_main(int argc, char **argv) MAIN_EXTERNALLY_VISIBLE;
+int paste_main(int argc UNUSED_PARAM, char **argv)
+{
+	char *delims = (char*)"\t";
+	int del_cnt = 1;
+	unsigned opt;
+	int i;
+
+	opt = getopt32(argv, "d:s", &delims);
+	argv += optind;
+
+	if (opt & PASTE_OPT_DELIMITERS) {
+		if (!delims[0])
+			bb_error_msg_and_die("-d '' is not supported");
+		/* unknown mappings are not changed: "\z" -> '\\' 'z' */
+		/* trailing backslash, if any, is preserved */
+		del_cnt = strcpy_and_process_escape_sequences(delims, delims) - delims;
+		/* note: handle NUL properly (do not stop at it!): try -d'\t\0\t' */
+	}
+
+	if (!argv[0])
+		(--argv)[0] = (char*) "-";
+	for (i = 0; argv[i]; ++i) {
+		argv[i] = (void*) fopen_or_warn_stdin(argv[i]);
+		if (!argv[i])
+			xfunc_die();
+	}
+
+	if (opt & PASTE_OPT_SEPARATE)
+		paste_files_separate((FILE**)argv, delims, del_cnt);
+	else
+		paste_files((FILE**)argv, i, delims, del_cnt);
+
+	fflush_stdout_and_exit(0);
+}
diff -urpN busybox-1.26.2/coreutils/printf.c busybox-1.27.0/coreutils/printf.c
--- busybox-1.26.2/coreutils/printf.c	2016-12-10 18:46:36.000000000 +0100
+++ busybox-1.27.0/coreutils/printf.c	2017-01-10 16:31:40.000000000 +0100
@@ -49,6 +49,9 @@
 
 //kbuild:lib-$(CONFIG_PRINTF) += printf.o
 
+//kbuild:lib-$(CONFIG_ASH_PRINTF)  += printf.o
+//kbuild:lib-$(CONFIG_HUSH_PRINTF) += printf.o
+
 //usage:#define printf_trivial_usage
 //usage:       "FORMAT [ARG]..."
 //usage:#define printf_full_usage "\n\n"
@@ -417,7 +420,7 @@ int printf_main(int argc UNUSED_PARAM, c
 	if (argv[1] && argv[1][0] == '-' && argv[1][1] == '-' && !argv[1][2])
 		argv++;
 	if (!argv[1]) {
-		if (ENABLE_ASH_BUILTIN_PRINTF
+		if (ENABLE_ASH_PRINTF
 		 && applet_name[0] != 'p'
 		) {
 			bb_error_msg("usage: printf FORMAT [ARGUMENT...]");
diff -urpN busybox-1.26.2/coreutils/shred.c busybox-1.27.0/coreutils/shred.c
--- busybox-1.26.2/coreutils/shred.c	1970-01-01 01:00:00.000000000 +0100
+++ busybox-1.27.0/coreutils/shred.c	2017-07-01 22:51:12.000000000 +0200
@@ -0,0 +1,106 @@
+/* vi: set sw=4 ts=4: */
+/*
+ * Copyright (C) 2017 Denys Vlasenko <vda.linux@googlemail.com>
+ *
+ * Licensed under GPLv2, see file LICENSE in this source tree.
+ */
+//config:config SHRED
+//config:	bool "shred"
+//config:	default y
+//config:	help
+//config:	  Overwrite a file to hide its contents, and optionally delete it
+
+//applet:IF_SHRED(APPLET(shred, BB_DIR_USR_BIN, BB_SUID_DROP))
+
+//kbuild:lib-$(CONFIG_SHRED) += shred.o
+
+//usage:#define shred_trivial_usage
+//usage:       "FILE..."
+//usage:#define shred_full_usage "\n\n"
+//usage:       "Overwrite/delete FILEs\n"
+//usage:     "\n	-f	Chmod to ensure writability"
+//usage:     "\n	-n N	Overwrite N times (default 3)"
+//usage:     "\n	-z	Final overwrite with zeros"
+//usage:     "\n	-u	Remove file"
+//-x and -v are accepted but have no effect
+
+/* shred (GNU coreutils) 8.25:
+-f, --force		change permissions to allow writing if necessary
+-u			truncate and remove file after overwriting
+-z, --zero		add a final overwrite with zeros to hide shredding
+-n, --iterations=N	overwrite N times instead of the default (3)
+-v, --verbose		show progress
+-x, --exact		do not round file sizes up to the next full block; this is the default for non-regular files
+--random-source=FILE	get random bytes from FILE
+-s, --size=N		shred this many bytes (suffixes like K, M, G accepted)
+--remove[=HOW]		like -u but give control on HOW to delete;  See below
+*/
+
+#include "libbb.h"
+
+int shred_main(int argc, char **argv) MAIN_EXTERNALLY_VISIBLE;
+int shred_main(int argc UNUSED_PARAM, char **argv)
+{
+	int rand_fd = rand_fd; /* for compiler */
+	int zero_fd;
+	unsigned num_iter = 3;
+	unsigned opt;
+	enum {
+		OPT_f = (1 << 0),
+		OPT_u = (1 << 1),
+		OPT_z = (1 << 2),
+		OPT_n = (1 << 3),
+		OPT_v = (1 << 4),
+		OPT_x = (1 << 5),
+	};
+
+	opt = getopt32(argv, "fuzn:+vx", &num_iter);
+	argv += optind;
+
+	zero_fd = xopen("/dev/zero", O_RDONLY);
+	if (num_iter != 0)
+		rand_fd = xopen("/dev/urandom", O_RDONLY);
+
+	if (!*argv)
+		bb_show_usage();
+
+	for (;;) {
+		struct stat sb;
+		const char *fname;
+		unsigned i;
+		int fd;
+
+		fname = *argv++;
+		if (!fname)
+			break;
+		fd = -1;
+		if (opt & OPT_f) {
+			fd = open(fname, O_WRONLY);
+			if (fd < 0)
+				chmod(fname, 0666);
+		}
+		if (fd < 0)
+			fd = xopen(fname, O_WRONLY);
+
+		if (fstat(fd, &sb) == 0 && sb.st_size > 0) {
+			off_t size = sb.st_size;
+
+			for (i = 0; i < num_iter; i++) {
+				bb_copyfd_size(rand_fd, fd, size);
+				fdatasync(fd);
+				xlseek(fd, 0, SEEK_SET);
+			}
+			if (opt & OPT_z) {
+				bb_copyfd_size(zero_fd, fd, size);
+				fdatasync(fd);
+			}
+			if (opt & OPT_u) {
+				ftruncate(fd, 0);
+				xunlink(fname);
+			}
+			xclose(fd);
+		}
+	}
+
+	return EXIT_SUCCESS;
+}
diff -urpN busybox-1.26.2/coreutils/split.c busybox-1.27.0/coreutils/split.c
--- busybox-1.26.2/coreutils/split.c	2016-12-10 18:46:36.000000000 +0100
+++ busybox-1.27.0/coreutils/split.c	2017-01-10 16:31:40.000000000 +0100
@@ -9,7 +9,7 @@
 //config:	bool "split"
 //config:	default y
 //config:	help
-//config:	  split a file into pieces.
+//config:	  Split a file into pieces.
 //config:
 //config:config FEATURE_SPLIT_FANCY
 //config:	bool "Fancy extensions"
diff -urpN busybox-1.26.2/coreutils/tail.c busybox-1.27.0/coreutils/tail.c
--- busybox-1.26.2/coreutils/tail.c	2016-12-10 18:46:36.000000000 +0100
+++ busybox-1.27.0/coreutils/tail.c	2017-01-10 16:31:40.000000000 +0100
@@ -26,13 +26,12 @@
 //config:	  from files.
 //config:
 //config:config FEATURE_FANCY_TAIL
-//config:	bool "Enable extra tail options (-q, -s, -v, and -F)"
+//config:	bool "Enable -q, -s, -v, and -F options"
 //config:	default y
 //config:	depends on TAIL
 //config:	help
-//config:	  The options (-q, -s, -v and -F) are provided by GNU tail, but
-//config:	  are not specific in the SUSv3 standard.
-//config:
+//config:	  These options are provided by GNU tail, but
+//config:	  are not specific in the SUSv3 standard:
 //config:	    -q      Never output headers giving file names
 //config:	    -s SEC  Wait SEC seconds between reads with -f
 //config:	    -v      Always output headers giving file names
diff -urpN busybox-1.26.2/coreutils/test.c busybox-1.27.0/coreutils/test.c
--- busybox-1.26.2/coreutils/test.c	2017-01-01 13:01:05.000000000 +0100
+++ busybox-1.27.0/coreutils/test.c	2017-01-10 16:31:40.000000000 +0100
@@ -42,21 +42,20 @@
 //config:config FEATURE_TEST_64
 //config:	bool "Extend test to 64 bit"
 //config:	default y
-//config:	depends on TEST || TEST1 || TEST2 || ASH_BUILTIN_TEST || HUSH
+//config:	depends on TEST || TEST1 || TEST2 || ASH_TEST || HUSH_TEST
 //config:	help
 //config:	  Enable 64-bit support in test.
 
 //applet:IF_TEST(APPLET_NOFORK(test, test, BB_DIR_USR_BIN, BB_SUID_DROP, test))
-//applet:IF_TEST1(APPLET_NOFORK([,  test, BB_DIR_USR_BIN, BB_SUID_DROP, test))
-//applet:IF_TEST2(APPLET_NOFORK([[, test, BB_DIR_USR_BIN, BB_SUID_DROP, test))
+//applet:IF_TEST1(APPLET_NOFORK([,   test, BB_DIR_USR_BIN, BB_SUID_DROP, test))
+//applet:IF_TEST2(APPLET_NOFORK([[,  test, BB_DIR_USR_BIN, BB_SUID_DROP, test))
 
-//kbuild:lib-$(CONFIG_TEST) += test.o test_ptr_hack.o
+//kbuild:lib-$(CONFIG_TEST)  += test.o test_ptr_hack.o
 //kbuild:lib-$(CONFIG_TEST1) += test.o test_ptr_hack.o
 //kbuild:lib-$(CONFIG_TEST2) += test.o test_ptr_hack.o
-//kbuild:lib-$(CONFIG_ASH_BUILTIN_TEST) += test.o test_ptr_hack.o
-//kbuild:lib-$(CONFIG_HUSH) += test.o test_ptr_hack.o
-//kbuild:lib-$(CONFIG_SH_IS_HUSH) += test.o test_ptr_hack.o
-//kbuild:lib-$(CONFIG_BASH_IS_HUSH) += test.o test_ptr_hack.o
+
+//kbuild:lib-$(CONFIG_ASH_TEST)  += test.o test_ptr_hack.o
+//kbuild:lib-$(CONFIG_HUSH_TEST) += test.o test_ptr_hack.o
 
 /* "test --help" is special-cased to ignore --help */
 //usage:#define test_trivial_usage NOUSAGE_STR
@@ -843,7 +842,7 @@ int test_main(int argc, char **argv)
 	const char *arg0;
 
 	arg0 = bb_basename(argv[0]);
-	if ((ENABLE_TEST1 || ENABLE_TEST2 || ENABLE_ASH_BUILTIN_TEST || ENABLE_HUSH)
+	if ((ENABLE_TEST1 || ENABLE_TEST2 || ENABLE_ASH_TEST || ENABLE_HUSH_TEST)
 	 && (arg0[0] == '[')
 	) {
 		--argc;
diff -urpN busybox-1.26.2/coreutils/timeout.c busybox-1.27.0/coreutils/timeout.c
--- busybox-1.26.2/coreutils/timeout.c	1970-01-01 01:00:00.000000000 +0100
+++ busybox-1.27.0/coreutils/timeout.c	2017-07-01 22:51:12.000000000 +0200
@@ -0,0 +1,127 @@
+/* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
+ * COPYING NOTES
+ *
+ * timeout.c -- a timeout handler for shell commands
+ *
+ * Copyright (C) 2005-6, Roberto A. Foglietta <me@roberto.foglietta.name>
+ *
+ *   This program is free software; you can redistribute it and/or modify
+ *   it under the terms of the GNU General Public License as published by
+ *   the Free Software Foundation; version 2 of the License.
+ *
+ *   This program is distributed in the hope that it will be useful,
+ *   but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ *   GNU General Public License for more details.
+ *
+ *   You should have received a copy of the GNU General Public License
+ *   along with this program; if not, write to the Free Software
+ *   Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307, USA.
+ */
+/* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
+ * REVISION NOTES:
+ * released 17-11-2005 by Roberto A. Foglietta
+ * talarm   04-12-2005 by Roberto A. Foglietta
+ * modified 05-12-2005 by Roberto A. Foglietta
+ * sizerdct 06-12-2005 by Roberto A. Foglietta
+ * splitszf 12-05-2006 by Roberto A. Foglietta
+ * rewrite  14-11-2008 vda
+ */
+//config:config TIMEOUT
+//config:	bool "timeout"
+//config:	default y
+//config:	help
+//config:	  Runs a program and watches it. If it does not terminate in
+//config:	  specified number of seconds, it is sent a signal.
+
+//applet:IF_TIMEOUT(APPLET(timeout, BB_DIR_USR_BIN, BB_SUID_DROP))
+
+//kbuild:lib-$(CONFIG_TIMEOUT) += timeout.o
+
+//usage:#define timeout_trivial_usage
+//usage:       "[-t SECS] [-s SIG] PROG ARGS"
+//usage:#define timeout_full_usage "\n\n"
+//usage:       "Runs PROG. Sends SIG to it if it is not gone in SECS seconds.\n"
+//usage:       "Defaults: SECS: 10, SIG: TERM."
+
+#include "libbb.h"
+
+int timeout_main(int argc, char **argv) MAIN_EXTERNALLY_VISIBLE;
+int timeout_main(int argc UNUSED_PARAM, char **argv)
+{
+	int signo;
+	int status;
+	int parent = 0;
+	int timeout = 10;
+	pid_t pid;
+#if !BB_MMU
+	char *sv1, *sv2;
+#endif
+	const char *opt_s = "TERM";
+
+	/* -p option is not documented, it is needed to support NOMMU. */
+
+	/* -t SECONDS; -p PARENT_PID */
+	/* '+': stop at first non-option */
+	getopt32(argv, "+s:t:+" USE_FOR_NOMMU("p:+"), &opt_s, &timeout, &parent);
+	/*argv += optind; - no, wait for bb_daemonize_or_rexec! */
+	signo = get_signum(opt_s);
+	if (signo < 0)
+		bb_error_msg_and_die("unknown signal '%s'", opt_s);
+
+	/* We want to create a grandchild which will watch
+	 * and kill the grandparent. Other methods:
+	 * making parent watch child disrupts parent<->child link
+	 * (example: "tcpsvd 0.0.0.0 1234 timeout service_prog" -
+	 * it's better if service_prog is a child of tcpsvd!),
+	 * making child watch parent results in programs having
+	 * unexpected children. */
+
+	if (parent) /* we were re-execed, already grandchild */
+		goto grandchild;
+	if (!argv[optind]) /* no PROG? */
+		bb_show_usage();
+
+#if !BB_MMU
+	sv1 = argv[optind];
+	sv2 = argv[optind + 1];
+#endif
+	pid = xvfork();
+	if (pid == 0) {
+		/* Child: spawn grandchild and exit */
+		parent = getppid();
+#if !BB_MMU
+		argv[optind] = xasprintf("-p%u", parent);
+		argv[optind + 1] = NULL;
+#endif
+		/* NB: exits with nonzero on error: */
+		bb_daemonize_or_rexec(0, argv);
+		/* Here we are grandchild. Sleep, then kill grandparent */
+ grandchild:
+		/* Just sleep(HUGE_NUM); kill(parent) may kill wrong process! */
+		while (1) {
+			sleep(1);
+			if (--timeout <= 0)
+				break;
+			if (kill(parent, 0)) {
+				/* process is gone */
+				return EXIT_SUCCESS;
+			}
+		}
+		kill(parent, signo);
+		return EXIT_SUCCESS;
+	}
+
+	/* Parent */
+	wait(&status); /* wait for child to die */
+	/* Did intermediate [v]fork or exec fail? */
+	if (!WIFEXITED(status) || WEXITSTATUS(status) != 0)
+		return EXIT_FAILURE;
+	/* Ok, exec a program as requested */
+	argv += optind;
+#if !BB_MMU
+	argv[0] = sv1;
+	argv[1] = sv2;
+#endif
+	BB_EXECVP_or_die(argv);
+}
diff -urpN busybox-1.26.2/coreutils/uniq.c busybox-1.27.0/coreutils/uniq.c
--- busybox-1.26.2/coreutils/uniq.c	2016-12-10 18:46:36.000000000 +0100
+++ busybox-1.27.0/coreutils/uniq.c	2017-04-06 00:30:51.000000000 +0200
@@ -26,6 +26,7 @@
 //usage:     "\n	-c	Prefix lines by the number of occurrences"
 //usage:     "\n	-d	Only print duplicate lines"
 //usage:     "\n	-u	Only print unique lines"
+//usage:     "\n	-i	Ignore case"
 //usage:     "\n	-f N	Skip first N fields"
 //usage:     "\n	-s N	Skip first N chars (after any skipped fields)"
 //usage:     "\n	-w N	Compare N characters in line"
@@ -54,12 +55,13 @@ int uniq_main(int argc UNUSED_PARAM, cha
 		OPT_f = 0x8,
 		OPT_s = 0x10,
 		OPT_w = 0x20,
+		OPT_i = 0x40,
 	};
 
 	skip_fields = skip_chars = 0;
 	max_chars = INT_MAX;
 
-	opt = getopt32(argv, "cduf:+s:+w:+", &skip_fields, &skip_chars, &max_chars);
+	opt = getopt32(argv, "cduf:+s:+w:+i", &skip_fields, &skip_chars, &max_chars);
 	argv += optind;
 
 	input_filename = argv[0];
@@ -106,7 +108,12 @@ int uniq_main(int argc UNUSED_PARAM, cha
 				++cur_compare;
 			}
 
-			if (!old_line || strncmp(old_compare, cur_compare, max_chars)) {
+			if (!old_line)
+				break;
+			if ((opt & OPT_i)
+				? strncasecmp(old_compare, cur_compare, max_chars)
+				: strncmp(old_compare, cur_compare, max_chars)
+			) {
 				break;
 			}
 
diff -urpN busybox-1.26.2/coreutils/wc.c busybox-1.27.0/coreutils/wc.c
--- busybox-1.26.2/coreutils/wc.c	2016-12-10 18:46:36.000000000 +0100
+++ busybox-1.27.0/coreutils/wc.c	2017-01-10 16:31:40.000000000 +0100
@@ -40,11 +40,11 @@
 //config:	  in specified files.
 //config:
 //config:config FEATURE_WC_LARGE
-//config:	bool "Support very large files in wc"
+//config:	bool "Support very large counts"
 //config:	default y
 //config:	depends on WC
 //config:	help
-//config:	  Use "unsigned long long" in wc for counter variables.
+//config:	  Use "unsigned long long" for counter variables.
 
 //applet:IF_WC(APPLET(wc, BB_DIR_USR_BIN, BB_SUID_DROP))
 
diff -urpN busybox-1.26.2/coreutils/who.c busybox-1.27.0/coreutils/who.c
--- busybox-1.26.2/coreutils/who.c	2016-12-10 18:46:36.000000000 +0100
+++ busybox-1.27.0/coreutils/who.c	2017-07-01 22:51:12.000000000 +0200
@@ -23,6 +23,14 @@
 //config:      help
 //config:        who is used to show who is logged on.
 //config:
+// procps-ng has this variation of "who":
+//config:config W
+//config:      bool "w"
+//config:      default y
+//config:      depends on FEATURE_UTMP
+//config:      help
+//config:        w is used to show who is logged on.
+//config:
 //config:config USERS
 //config:      bool "users"
 //config:      default y
@@ -30,11 +38,14 @@
 //config:      help
 //config:        Print users currently logged on.
 
+//                APPLET_ODDNAME:name   main location        suid_type     help
 //applet:IF_USERS(APPLET_ODDNAME(users, who, BB_DIR_USR_BIN, BB_SUID_DROP, users))
-//applet:IF_WHO(APPLET(who, BB_DIR_USR_BIN, BB_SUID_DROP))
+//applet:IF_W(    APPLET_ODDNAME(w,     who, BB_DIR_USR_BIN, BB_SUID_DROP, w))
+//applet:IF_WHO(  APPLET(        who,        BB_DIR_USR_BIN, BB_SUID_DROP))
 
 //kbuild:lib-$(CONFIG_USERS) += who.o
-//kbuild:lib-$(CONFIG_WHO) += who.o
+//kbuild:lib-$(CONFIG_W)     += who.o
+//kbuild:lib-$(CONFIG_WHO)   += who.o
 
 /* BB_AUDIT SUSv3 _NOT_ compliant -- missing options -b, -d, -l, -m, -p, -q, -r, -s, -t, -T, -u; Missing argument 'file'.  */
 
@@ -43,6 +54,31 @@
 //usage:#define users_full_usage "\n\n"
 //usage:       "Print the users currently logged on"
 
+//usage:#define w_trivial_usage
+//usage:       ""
+//usage:#define w_full_usage "\n\n"
+//usage:       "Show who is logged on"
+//
+// procps-ng 3.3.10:
+//           "\n	-h, --no-header"
+//           "\n	-u, --no-current"
+//	Ignores the username while figuring out the current process
+//	and cpu times.  To demonstrate this, do a "su" and do a "w" and a "w -u".
+//           "\n	-s, --short"
+//	Short format.  Don't print the login time, JCPU or PCPU times.
+//           "\n	-f, --from"
+//	Toggle printing the from (remote hostname) field.
+//	The default is for the from field to not be printed
+//           "\n	-i, --ip-addr"
+//	Display IP address instead of hostname for from field.
+//           "\n	-o, --old-style"
+//	Old style output. Prints blank space for idle times less than one minute.
+// Example output:
+//  17:28:00 up 4 days, 22:41,  4 users,  load average: 0.84, 0.97, 0.90
+// USER     TTY        LOGIN@   IDLE   JCPU   PCPU WHAT
+// root     tty1      Thu18    4days  4:33m  0.07s /bin/sh /etc/xdg/xfce4/xinitrc -- vt
+// root     pts/1     Mon13    3:24m  1:01   0.01s w
+
 //usage:#define who_trivial_usage
 //usage:       "[-a]"
 //usage:#define who_full_usage "\n\n"
@@ -73,14 +109,17 @@ static void idle_string(char *str6, time
 int who_main(int argc, char **argv) MAIN_EXTERNALLY_VISIBLE;
 int who_main(int argc UNUSED_PARAM, char **argv)
 {
+#define CNT_APPLET (ENABLE_USERS + ENABLE_W + ENABLE_WHO)
+	int do_users = (ENABLE_USERS && (CNT_APPLET == 1 || applet_name[0] == 'u'));
+	int do_w     = (ENABLE_W     && (CNT_APPLET == 1 || applet_name[1] == '\0'));
+	int do_who   = (ENABLE_WHO   && (CNT_APPLET == 1 || applet_name[1] == 'h'));
 	struct utmpx *ut;
 	unsigned opt;
-	int do_users = (ENABLE_USERS && (!ENABLE_WHO || applet_name[0] == 'u'));
 	const char *fmt = "%s";
 
 	opt_complementary = "=0";
-	opt = getopt32(argv, do_users ? "" : "aH");
-	if (opt & 2) // -H
+	opt = getopt32(argv, do_who ? "aH" : "");
+	if ((opt & 2) || do_w) /* -H or we are w */
 		puts("USER\t\tTTY\t\tIDLE\tTIME\t\t HOST");
 
 	setutxent();
@@ -114,6 +153,9 @@ int who_main(int argc UNUSED_PARAM, char
 						(int)sizeof(ut->ut_user), ut->ut_user,
 						(int)sizeof(ut->ut_line), ut->ut_line,
 						str6,
+// TODO: with LANG=en_US.UTF-8, who from coreutils 8.25 shows
+// TIME col as "2017-04-06 18:47" (the default format is "Apr  6 18:47").
+// The former format looks saner to me. Switch to it unconditionally?
 						ctime(&seconds) + 4,
 						(int)sizeof(ut->ut_host), ut->ut_host
 				);
diff -urpN busybox-1.26.2/debianutils/mktemp.c busybox-1.27.0/debianutils/mktemp.c
--- busybox-1.26.2/debianutils/mktemp.c	2016-09-27 18:53:50.000000000 +0200
+++ busybox-1.27.0/debianutils/mktemp.c	1970-01-01 01:00:00.000000000 +0100
@@ -1,122 +0,0 @@
-/* vi: set sw=4 ts=4: */
-/*
- * Mini mktemp implementation for busybox
- *
- *
- * Copyright (C) 2000 by Daniel Jacobowitz
- * Written by Daniel Jacobowitz <dan@debian.org>
- *
- * Licensed under GPLv2 or later, see file LICENSE in this source tree.
- */
-
-/* Coreutils 6.12 man page says:
- *        mktemp [OPTION]... [TEMPLATE]
- * Create a temporary file or directory, safely, and print its name. If
- * TEMPLATE is not specified, use tmp.XXXXXXXXXX.
- * -d, --directory
- *        create a directory, not a file
- * -q, --quiet
- *        suppress diagnostics about file/dir-creation failure
- * -u, --dry-run
- *        do not create anything; merely print a name (unsafe)
- * --tmpdir[=DIR]
- *        interpret TEMPLATE relative to DIR. If DIR is not specified,
- *        use  $TMPDIR if set, else /tmp.  With this option, TEMPLATE must
- *        not be an absolute name. Unlike with -t, TEMPLATE may contain
- *        slashes, but even here, mktemp still creates only the final com-
- *        ponent.
- * -p DIR use DIR as a prefix; implies -t [deprecated]
- * -t     interpret TEMPLATE as a single file name component, relative  to
- *        a  directory:  $TMPDIR, if set; else the directory specified via
- *        -p; else /tmp [deprecated]
- */
-//config:config MKTEMP
-//config:	bool "mktemp"
-//config:	default y
-//config:	help
-//config:	  mktemp is used to create unique temporary files
-
-//applet:IF_MKTEMP(APPLET(mktemp, BB_DIR_BIN, BB_SUID_DROP))
-
-//kbuild:lib-$(CONFIG_MKTEMP) += mktemp.o
-
-//usage:#define mktemp_trivial_usage
-//usage:       "[-dt] [-p DIR] [TEMPLATE]"
-//usage:#define mktemp_full_usage "\n\n"
-//usage:       "Create a temporary file with name based on TEMPLATE and print its name.\n"
-//usage:       "TEMPLATE must end with XXXXXX (e.g. [/dir/]nameXXXXXX).\n"
-//usage:       "Without TEMPLATE, -t tmp.XXXXXX is assumed.\n"
-//usage:     "\n	-d	Make directory, not file"
-//usage:     "\n	-q	Fail silently on errors"
-//usage:     "\n	-t	Prepend base directory name to TEMPLATE"
-//usage:     "\n	-p DIR	Use DIR as a base directory (implies -t)"
-//usage:     "\n	-u	Do not create anything; print a name"
-//usage:     "\n"
-//usage:     "\nBase directory is: -p DIR, else $TMPDIR, else /tmp"
-//usage:
-//usage:#define mktemp_example_usage
-//usage:       "$ mktemp /tmp/temp.XXXXXX\n"
-//usage:       "/tmp/temp.mWiLjM\n"
-//usage:       "$ ls -la /tmp/temp.mWiLjM\n"
-//usage:       "-rw-------    1 andersen andersen        0 Apr 25 17:10 /tmp/temp.mWiLjM\n"
-
-#include "libbb.h"
-
-int mktemp_main(int argc, char **argv) MAIN_EXTERNALLY_VISIBLE;
-int mktemp_main(int argc UNUSED_PARAM, char **argv)
-{
-	const char *path;
-	char *chp;
-	unsigned opts;
-	enum {
-		OPT_d = 1 << 0,
-		OPT_q = 1 << 1,
-		OPT_t = 1 << 2,
-		OPT_p = 1 << 3,
-		OPT_u = 1 << 4,
-	};
-
-	path = getenv("TMPDIR");
-	if (!path || path[0] == '\0')
-		path = "/tmp";
-
-	opt_complementary = "?1"; /* 1 argument max */
-	opts = getopt32(argv, "dqtp:u", &path);
-
-	chp = argv[optind];
-	if (!chp) {
-		/* GNU coreutils 8.4:
-		 * bare "mktemp" -> "mktemp -t tmp.XXXXXX"
-		 */
-		chp = xstrdup("tmp.XXXXXX");
-		opts |= OPT_t;
-	}
-#if 0
-	/* Don't allow directory separator in template */
-	if ((opts & OPT_t) && bb_basename(chp) != chp) {
-		errno = EINVAL;
-		goto error;
-	}
-#endif
-	if (opts & (OPT_t|OPT_p))
-		chp = concat_path_file(path, chp);
-
-	if (opts & OPT_u) {
-		chp = mktemp(chp);
-		if (chp[0] == '\0')
-			goto error;
-	} else if (opts & OPT_d) {
-		if (mkdtemp(chp) == NULL)
-			goto error;
-	} else {
-		if (mkstemp(chp) < 0)
-			goto error;
-	}
-	puts(chp);
-	return EXIT_SUCCESS;
- error:
-	if (opts & OPT_q)
-		return EXIT_FAILURE;
-	/* don't use chp as it gets mangled in case of error */
-	bb_perror_nomsg_and_die();
-}
diff -urpN busybox-1.26.2/debianutils/run_parts.c busybox-1.27.0/debianutils/run_parts.c
--- busybox-1.26.2/debianutils/run_parts.c	2016-09-27 18:53:50.000000000 +0200
+++ busybox-1.27.0/debianutils/run_parts.c	2017-01-10 16:31:40.000000000 +0100
@@ -41,8 +41,6 @@
 //config:	bool "Enable long options"
 //config:	default y
 //config:	depends on RUN_PARTS && LONG_OPTS
-//config:	help
-//config:	  Support long options for the run-parts applet.
 //config:
 //config:config FEATURE_RUN_PARTS_FANCY
 //config:	bool "Support additional arguments"
diff -urpN busybox-1.26.2/debianutils/start_stop_daemon.c busybox-1.27.0/debianutils/start_stop_daemon.c
--- busybox-1.26.2/debianutils/start_stop_daemon.c	2016-09-27 18:53:50.000000000 +0200
+++ busybox-1.27.0/debianutils/start_stop_daemon.c	2017-01-10 16:31:40.000000000 +0100
@@ -64,22 +64,19 @@ Misc options:
 //config:	  termination of system-level processes, usually the ones
 //config:	  started during the startup of the system.
 //config:
+//config:config FEATURE_START_STOP_DAEMON_LONG_OPTIONS
+//config:	bool "Enable long options"
+//config:	default y
+//config:	depends on START_STOP_DAEMON && LONG_OPTS
+//config:
 //config:config FEATURE_START_STOP_DAEMON_FANCY
 //config:	bool "Support additional arguments"
 //config:	default y
 //config:	depends on START_STOP_DAEMON
 //config:	help
-//config:	  Support additional arguments.
 //config:	  -o|--oknodo ignored since we exit with 0 anyway
 //config:	  -v|--verbose
 //config:	  -N|--nicelevel N
-//config:
-//config:config FEATURE_START_STOP_DAEMON_LONG_OPTIONS
-//config:	bool "Enable long options"
-//config:	default y
-//config:	depends on START_STOP_DAEMON && LONG_OPTS
-//config:	help
-//config:	  Support long options for the start-stop-daemon applet.
 
 //applet:IF_START_STOP_DAEMON(APPLET_ODDNAME(start-stop-daemon, start_stop_daemon, BB_DIR_SBIN, BB_SUID_DROP, start_stop_daemon))
 
diff -urpN busybox-1.26.2/docs/nofork_noexec.txt busybox-1.27.0/docs/nofork_noexec.txt
--- busybox-1.26.2/docs/nofork_noexec.txt	2016-09-27 18:53:50.000000000 +0200
+++ busybox-1.27.0/docs/nofork_noexec.txt	2017-01-30 21:57:30.000000000 +0100
@@ -33,6 +33,7 @@ roughly are:
 * do not expect shared global variables/buffers to be in their
   "initialized" state. Examples: xfunc_error_retval can be != 1,
   bb_common_bufsiz1 can be scribbled over, ...
+  (although usually xfunc_error_retval's state is not a problem).
 * do not expect that stdio wasn't used before. Calling set[v]buf()
   can be disastrous.
 * ...
@@ -81,18 +82,44 @@ are probably not worth the effort.
 Any NOFORK applet is also a NOEXEC applet.
 
 
+	Calling NOFORK applets
+
+API to call NOFORK applets is two functions:
+
+	run_nofork_applet(appno, argv)
+	spawn_and_wait(argv) // only if FEATURE_PREFER_APPLETS=y
+
+First one is directly used by shells if FEATURE_SH_NOFORK=y.
+Second one is used by many applets, but main users are xargs and find.
+It itself calls run_nofork_applet(), if argv[0] turned out to be a name
+of a NOFORK applet.
+
+run_nofork_applet() saves/inits/restores option parsing, xfunc_error_retval,
+applet_name. Thus, for example, caller does not need to worry about
+option_mask32 getting trashed.
+
+
+	Calling NOEXEC applets
+
+It's the same trusty spawn_and_wait(argv). If FEATURE_PREFER_APPLETS=y,
+it does NOEXEC trick. It resets xfunc_error_retval = 1 and
+logmode = LOGMODE_STDIO in the child.
+
+
 	Relevant CONFIG options
 
 FEATURE_PREFER_APPLETS
   BB_EXECVP(cmd, argv) will try to exec /proc/self/exe
-    if command's name matches some applet name
-  applet tables will contain NOFORK/NOEXEC bits
+  if command's name matches some applet name;
   spawn_and_wait(argv) will do NOFORK/NOEXEC tricks
 
-FEATURE_SH_STANDALONE (needs FEATURE_PREFER_APPLETS=y)
+//TODO: the above two things probably should have separate options?
+
+FEATURE_SH_STANDALONE
   shells will try to exec /proc/self/exe if command's name matches
-    some applet name
-  shells will do NOEXEC trick on NOEXEC applets
+  some applet name; shells will do NOEXEC trick on NOEXEC applets
+
+//TODO: split (same as for PREFER_APPLETS)
 
-FEATURE_SH_NOFORK (needs FEATURE_PREFER_APPLETS=y)
+FEATURE_SH_NOFORK
   shells will do NOFORK trick on NOFORK applets
diff -urpN busybox-1.26.2/docs/posix_conformance.txt busybox-1.27.0/docs/posix_conformance.txt
--- busybox-1.26.2/docs/posix_conformance.txt	2016-09-27 18:53:50.000000000 +0200
+++ busybox-1.27.0/docs/posix_conformance.txt	2017-04-05 18:27:36.000000000 +0200
@@ -22,7 +22,7 @@ POSIX Tools supported only as shell buil
 POSIX Tools not supported:
   asa, at, batch, bc, c99, command, compress, csplit, ex, fc, file,
   gencat, getconf, iconv, join, link, locale, localedef, lp, m4,
-  mailx, newgrp, nl, paste, pathchk, pax, pr, qalter, qdel, qhold, qmove,
+  mailx, newgrp, nl, pathchk, pax, pr, qalter, qdel, qhold, qmove,
   qmsg, qrerun, qrls, qselect, qsig, qstat, qsub, tabs, talk, tput,
   tsort, unlink, uucp, uustat, uux
 
@@ -469,6 +469,12 @@ od POSIX options
   -x              |  no    | no        |
 od Busybox specific options: None
 
+paste POSIX options
+ option           | exists | compliant | remarks
+  -d list         |  yes   | yes       |
+  -s              |  yes   | yes       |
+paste Busybox specific options: None
+
 patch POSIX options
  option           | exists | compliant | remarks
   -D define       |  no    | no        |
diff -urpN busybox-1.26.2/docs/sigint.htm busybox-1.27.0/docs/sigint.htm
--- busybox-1.26.2/docs/sigint.htm	2016-09-27 18:53:50.000000000 +0200
+++ busybox-1.27.0/docs/sigint.htm	2017-07-01 22:51:12.000000000 +0200
@@ -45,7 +45,7 @@ intention.
 
 </td></tr><tr><th valign=top align=left>Required knowledge: </th>
 <td valign=top align=left>You have to know what it means to catch SIGINT or SIGQUIT and how
-processes are waiting for other processes (childs) they spawned.
+processes are waiting for other processes (children) they spawned.
 
 
 </td></tr></table>
@@ -366,7 +366,7 @@ signal, it has to take care of communica
 itself.
 
 <p>Some programs don't do this. On SIGINT, they do cleanup and exit
-immediatly, but the calling shell isn't told about the non-normal exit
+immediately, but the calling shell isn't told about the non-normal exit
 and it will call the next program in the script.
 
 <p>As a result, the user hits SIGINT and while one program exits, the
@@ -446,7 +446,7 @@ handlers, so it is portable.
 <code>trap</code> command. Here, the same as for C programs apply.  If
 the intention of SIGINT is to end your program, you have to exit in a
 way that the calling programs "sees" that you have been killed.  If
-you don't catch SIGINT, this happend automatically, but of you catch
+you don't catch SIGINT, this happened automatically, but of you catch
 SIGINT, i.e. to do cleanup work, you have to end the program by
 killing yourself, not by calling exit.
 
@@ -466,7 +466,7 @@ files (which isn't really portable in C,
 bourne shell. Every language implementation that lets you catch SIGINT
 should also give you the option to reset the signal and kill yourself.
 
-<P>It is always desireable to exit the right way, even if you don't
+<P>It is always desirable to exit the right way, even if you don't
 expect your usual callers to depend on it, some unusual one will come
 along. This proper exit status will be needed for WCE and will not
 hurt when the calling shell uses IUE or WUE.
@@ -565,7 +565,7 @@ comments the scripts echo.
 <th>What happens when a shellscript called emacs, the user did not use
 <code>C-c</code> and the script has additional commands in it?</th>
 <th>What happens if a non-interactive child catches SIGINT?</th>
-<th>To behave properly, childs must do what?</th>
+<th>To behave properly, children must do what?</th>
 </tr>
 
 <tr valign=top align=left>
diff -urpN busybox-1.26.2/docs/style-guide.txt busybox-1.27.0/docs/style-guide.txt
--- busybox-1.26.2/docs/style-guide.txt	2016-09-27 18:53:50.000000000 +0200
+++ busybox-1.27.0/docs/style-guide.txt	2017-07-01 22:51:12.000000000 +0200
@@ -329,7 +329,7 @@ With "const int" compiler may fail to op
 a real storage in rodata for it! (Hopefully, newer gcc will get better
 at it...).  With "define", you have slight risk of polluting namespace
 (#define doesn't allow you to redefine the name in the inner scopes),
-and complex "define" are evaluated each time they uesd, not once
+and complex "define" are evaluated each time they used, not once
 at declarations like enums. Also, the preprocessor does _no_ type checking
 whatsoever, making it much more error prone.
 
diff -urpN busybox-1.26.2/e2fsprogs/fsck.c busybox-1.27.0/e2fsprogs/fsck.c
--- busybox-1.26.2/e2fsprogs/fsck.c	2016-12-10 18:46:36.000000000 +0100
+++ busybox-1.27.0/e2fsprogs/fsck.c	2017-01-30 21:57:30.000000000 +0100
@@ -1071,7 +1071,7 @@ int fsck_main(int argc UNUSED_PARAM, cha
 	new_args(); /* G.args[G.num_args - 1] is the last, NULL element */
 
 	if (!notitle)
-		puts("fsck (busybox "BB_VER", "BB_BT")");
+		puts("fsck (busybox "BB_VER")");
 
 	/* Even plain "fsck /dev/hda1" needs fstab to get fs type,
 	 * so we are scanning it anyway */
diff -urpN busybox-1.26.2/editors/Config.src busybox-1.27.0/editors/Config.src
--- busybox-1.26.2/editors/Config.src	2016-09-27 18:53:50.000000000 +0200
+++ busybox-1.27.0/editors/Config.src	2017-01-10 16:31:40.000000000 +0100
@@ -12,7 +12,7 @@ config FEATURE_ALLOW_EXEC
 	default y
 	depends on VI || AWK
 	help
-	  Enables vi and awk features which allows user to execute
+	  Enables vi and awk features which allow user to execute
 	  shell commands (using system() C call).
 
 endmenu
diff -urpN busybox-1.26.2/editors/diff.c busybox-1.27.0/editors/diff.c
--- busybox-1.26.2/editors/diff.c	2016-09-27 18:53:50.000000000 +0200
+++ busybox-1.27.0/editors/diff.c	2017-07-01 22:51:12.000000000 +0200
@@ -88,8 +88,6 @@
 //config:	bool "Enable long options"
 //config:	default y
 //config:	depends on DIFF && LONG_OPTS
-//config:	help
-//config:	  Enable use of long options.
 //config:
 //config:config FEATURE_DIFF_DIR
 //config:	bool "Enable directory support"
@@ -297,17 +295,6 @@ static int search(const int *c, int k, i
 	}
 }
 
-static unsigned isqrt(unsigned n)
-{
-	unsigned x = 1;
-	while (1) {
-		const unsigned y = x;
-		x = ((n / x) + x) >> 1;
-		if (x <= (y + 1) && x >= (y - 1))
-			return x;
-	}
-}
-
 static void stone(const int *a, int n, const int *b, int *J, int pref)
 {
 	const unsigned isq = isqrt(n);
@@ -728,9 +715,19 @@ static int diffreg(char *file[2])
 	fp[0] = stdin;
 	fp[1] = stdin;
 	for (i = 0; i < 2; i++) {
-		int fd = open_or_warn_stdin(file[i]);
-		if (fd == -1)
-			goto out;
+		int fd = STDIN_FILENO;
+		if (!LONE_DASH(file[i])) {
+			if (!(option_mask32 & FLAG(N))) {
+				fd = open_or_warn(file[i], O_RDONLY);
+				if (fd == -1)
+					goto out;
+			} else {
+				/* -N: if some file does not exist compare it like empty */
+				fd = open(file[i], O_RDONLY);
+				if (fd == -1)
+					fd = xopen("/dev/null", O_RDONLY);
+			}
+		}
 		/* Our diff implementation is using seek.
 		 * When we meet non-seekable file, we must make a temp copy.
 		 */
@@ -991,17 +988,23 @@ int diff_main(int argc UNUSED_PARAM, cha
 	argv += optind;
 	while (L_arg)
 		label[!!label[0]] = llist_pop(&L_arg);
+
+	/* Compat: "diff file name_which_doesnt_exist" exits with 2 */
 	xfunc_error_retval = 2;
 	for (i = 0; i < 2; i++) {
 		file[i] = argv[i];
-		/* Compat: "diff file name_which_doesnt_exist" exits with 2 */
 		if (LONE_DASH(file[i])) {
 			fstat(STDIN_FILENO, &stb[i]);
 			gotstdin++;
-		} else
+		} else if (option_mask32 & FLAG(N)) {
+			if (stat(file[i], &stb[i]))
+				xstat("/dev/null", &stb[i]);
+		} else {
 			xstat(file[i], &stb[i]);
+		}
 	}
 	xfunc_error_retval = 1;
+
 	if (gotstdin && (S_ISDIR(stb[0].st_mode) || S_ISDIR(stb[1].st_mode)))
 		bb_error_msg_and_die("can't compare stdin to a directory");
 
diff -urpN busybox-1.26.2/editors/sed.c busybox-1.27.0/editors/sed.c
--- busybox-1.26.2/editors/sed.c	2016-12-10 18:46:36.000000000 +0100
+++ busybox-1.27.0/editors/sed.c	2017-07-01 22:51:12.000000000 +0200
@@ -337,7 +337,7 @@ static int get_address(const char *my_st
 
 	if (isdigit(*my_str)) {
 		*linenum = strtol(my_str, (char**)&pos, 10);
-		/* endstr shouldnt ever equal NULL */
+		/* endstr shouldn't ever equal NULL */
 	} else if (*my_str == '$') {
 		*linenum = -1;
 		pos++;
@@ -444,7 +444,7 @@ static int parse_subst_cmd(sed_cmd_t *se
 			free(fname);
 			break;
 		}
-		/* Ignore case (gnu exension) */
+		/* Ignore case (gnu extension) */
 		case 'i':
 		case 'I':
 			cflags |= REG_ICASE;
@@ -587,7 +587,7 @@ static const char *parse_cmd_args(sed_cm
 		free(match);
 		free(replace);
 	}
-	/* if it wasnt a single-letter command that takes no arguments
+	/* if it wasn't a single-letter command that takes no arguments
 	 * then it must be an invalid command.
 	 */
 	else if (idx >= IDX_nul) { /* not d,D,g,G,h,H,l,n,N,p,P,q,x,=,{,} */
@@ -751,7 +751,7 @@ static void do_subst_w_backrefs(char *li
 				continue;
 			}
 			/* I _think_ it is impossible to get '\' to be
-			 * the last char in replace string. Thus we dont check
+			 * the last char in replace string. Thus we don't check
 			 * for replace[i] == NUL. (counterexample anyone?) */
 			/* if we find a backslash escaped character, print the character */
 			pipe_putc(replace[i]);
diff -urpN busybox-1.26.2/editors/vi.c busybox-1.27.0/editors/vi.c
--- busybox-1.26.2/editors/vi.c	2016-09-28 23:02:40.000000000 +0200
+++ busybox-1.27.0/editors/vi.c	2017-07-01 22:51:12.000000000 +0200
@@ -30,7 +30,7 @@
 //config:	  you may wish to use something else.
 //config:
 //config:config FEATURE_VI_MAX_LEN
-//config:	int "Maximum screen width in vi"
+//config:	int "Maximum screen width"
 //config:	range 256 16384
 //config:	default 4096
 //config:	depends on VI
@@ -39,7 +39,7 @@
 //config:	  Make it smaller than 4k only if you are very limited on memory.
 //config:
 //config:config FEATURE_VI_8BIT
-//config:	bool "Allow vi to display 8-bit chars (otherwise shows dots)"
+//config:	bool "Allow to display 8-bit chars (otherwise shows dots)"
 //config:	default n
 //config:	depends on VI
 //config:	help
@@ -53,7 +53,7 @@
 //config:	default y
 //config:	depends on VI
 //config:	help
-//config:	  Enable a limited set of colon commands for vi. This does not
+//config:	  Enable a limited set of colon commands. This does not
 //config:	  provide an "ex" mode.
 //config:
 //config:config FEATURE_VI_YANKMARK
@@ -61,16 +61,14 @@
 //config:	default y
 //config:	depends on VI
 //config:	help
-//config:	  This will enable you to use yank and put, as well as mark in
-//config:	  busybox vi.
+//config:	  This will enable you to use yank and put, as well as mark.
 //config:
 //config:config FEATURE_VI_SEARCH
 //config:	bool "Enable search and replace cmds"
 //config:	default y
 //config:	depends on VI
 //config:	help
-//config:	  Select this if you wish to be able to do search and replace in
-//config:	  busybox vi.
+//config:	  Select this if you wish to be able to do search and replace.
 //config:
 //config:config FEATURE_VI_REGEX_SEARCH
 //config:	bool "Enable regex in search and replace"
@@ -84,16 +82,15 @@
 //config:	default y
 //config:	depends on VI
 //config:	help
-//config:	  Selecting this option will make busybox vi signal aware. This will
-//config:	  make busybox vi support SIGWINCH to deal with Window Changes, catch
-//config:	  Ctrl-Z and Ctrl-C and alarms.
+//config:	  Selecting this option will make vi signal aware. This will support
+//config:	  SIGWINCH to deal with Window Changes, catch ^Z and ^C and alarms.
 //config:
 //config:config FEATURE_VI_DOT_CMD
 //config:	bool "Remember previous cmd and \".\" cmd"
 //config:	default y
 //config:	depends on VI
 //config:	help
-//config:	  Make busybox vi remember the last command and be able to repeat it.
+//config:	  Make vi remember the last command and be able to repeat it.
 //config:
 //config:config FEATURE_VI_READONLY
 //config:	bool "Enable -R option and \"view\" mode"
@@ -104,25 +101,23 @@
 //config:	  open a file in read-only mode.
 //config:
 //config:config FEATURE_VI_SETOPTS
-//config:	bool "Enable set-able options, ai ic showmatch"
+//config:	bool "Enable settable options, ai ic showmatch"
 //config:	default y
 //config:	depends on VI
 //config:	help
 //config:	  Enable the editor to set some (ai, ic, showmatch) options.
 //config:
 //config:config FEATURE_VI_SET
-//config:	bool "Support for :set"
+//config:	bool "Support :set"
 //config:	default y
 //config:	depends on VI
-//config:	help
-//config:	  Support for ":set".
 //config:
 //config:config FEATURE_VI_WIN_RESIZE
 //config:	bool "Handle window resize"
 //config:	default y
 //config:	depends on VI
 //config:	help
-//config:	  Make busybox vi behave nicely with terminals that get resized.
+//config:	  Behave nicely with terminals that get resized.
 //config:
 //config:config FEATURE_VI_ASK_TERMINAL
 //config:	bool "Use 'tell me cursor position' ESC sequence to measure window"
@@ -133,15 +128,16 @@
 //config:	  this option makes vi perform a last-ditch effort to find it:
 //config:	  position cursor to 999,999 and ask terminal to report real
 //config:	  cursor position using "ESC [ 6 n" escape sequence, then read stdin.
-//config:
 //config:	  This is not clean but helps a lot on serial lines and such.
+//config:
 //config:config FEATURE_VI_UNDO
-//config:	bool "Support undo command 'u'"
+//config:	bool "Support undo command \"u\""
 //config:	default y
 //config:	depends on VI
 //config:	help
 //config:	  Support the 'u' command to undo insertion, deletion, and replacement
 //config:	  of text.
+//config:
 //config:config FEATURE_VI_UNDO_QUEUE
 //config:	bool "Enable undo operation queuing"
 //config:	default y
@@ -152,6 +148,7 @@
 //config:	  reached, the contents of the queue are committed to the undo stack.
 //config:	  This increases the size of the undo code and allows some undo
 //config:	  operations (especially un-typing/backspacing) to be far more useful.
+//config:
 //config:config FEATURE_VI_UNDO_QUEUE_MAX
 //config:	int "Maximum undo character queue size"
 //config:	default 256
@@ -357,7 +354,7 @@ struct globals {
 #if ENABLE_FEATURE_VI_USE_SIGNALS
 	sigjmp_buf restart;     // catch_sig()
 #endif
-	struct termios term_orig, term_vi; // remember what the cooked mode was
+	struct termios term_orig; // remember what the cooked mode was
 #if ENABLE_FEATURE_VI_COLON
 	char *initial_cmds[3];  // currently 2 entries, NULL terminated
 #endif
@@ -465,7 +462,6 @@ struct globals {
 #define context_end    (G.context_end   )
 #define restart        (G.restart       )
 #define term_orig      (G.term_orig     )
-#define term_vi        (G.term_vi       )
 #define initial_cmds   (G.initial_cmds  )
 #define readbuffer     (G.readbuffer    )
 #define scr_out_buf    (G.scr_out_buf   )
@@ -719,14 +715,6 @@ static int init_text_buffer(char *fn)
 {
 	int rc;
 
-	flush_undo_data();
-	modified_count = 0;
-	last_modified_count = -1;
-#if ENABLE_FEATURE_VI_YANKMARK
-	/* init the marks */
-	memset(mark, 0, sizeof(mark));
-#endif
-
 	/* allocate/reallocate text buffer */
 	free(text);
 	text_size = 10240;
@@ -741,6 +729,14 @@ static int init_text_buffer(char *fn)
 		// file doesnt exist. Start empty buf with dummy line
 		char_insert(text, '\n', NO_UNDO);
 	}
+
+	flush_undo_data();
+	modified_count = 0;
+	last_modified_count = -1;
+#if ENABLE_FEATURE_VI_YANKMARK
+	/* init the marks */
+	memset(mark, 0, sizeof(mark));
+#endif
 	return rc;
 }
 
@@ -1038,7 +1034,9 @@ static void colon(char *buf)
 	 || strncmp(p, "wn", cnt) == 0
 	 || (p[0] == 'x' && !p[1])
 	) {
-		cnt = file_write(current_filename, text, end - 1);
+		if (modified_count != 0 || p[0] != 'x') {
+			cnt = file_write(current_filename, text, end - 1);
+		}
 		if (cnt < 0) {
 			if (cnt == -1)
 				status_line_bold("Write error: %s", strerror(errno));
@@ -1049,8 +1047,9 @@ static void colon(char *buf)
 				current_filename,
 				count_lines(text, end - 1), cnt
 			);
-			if (p[0] == 'x' || p[1] == 'q' || p[1] == 'n'
-			 || p[0] == 'X' || p[1] == 'Q' || p[1] == 'N'
+			if (p[0] == 'x'
+			 || p[1] == 'q' || p[1] == 'n'
+			 || p[1] == 'Q' || p[1] == 'N'
 			) {
 				editing = 0;
 			}
@@ -1461,7 +1460,7 @@ static void colon(char *buf)
 		}
 #endif /* FEATURE_VI_SEARCH */
 	} else if (strncmp(cmd, "version", i) == 0) {  // show software version
-		status_line(BB_VER " " BB_BT);
+		status_line(BB_VER);
 	} else if (strncmp(cmd, "write", i) == 0  // write text to file
 	        || strncmp(cmd, "wq", i) == 0
 	        || strncmp(cmd, "wn", i) == 0
@@ -1480,16 +1479,19 @@ static void colon(char *buf)
 			goto ret;
 		}
 #endif
-		// how many lines in text[]?
-		li = count_lines(q, r);
-		size = r - q + 1;
 		//if (useforce) {
 			// if "fn" is not write-able, chmod u+w
 			// sprintf(syscmd, "chmod u+w %s", fn);
 			// system(syscmd);
 			// forced = TRUE;
 		//}
-		l = file_write(fn, q, r);
+		if (modified_count != 0 || cmd[0] != 'x') {
+			size = r - q + 1;
+			l = file_write(fn, q, r);
+		} else {
+			size = 0;
+			l = 0;
+		}
 		//if (useforce && forced) {
 			// chmod u-w
 			// sprintf(syscmd, "chmod u-w %s", fn);
@@ -1500,17 +1502,20 @@ static void colon(char *buf)
 			if (l == -1)
 				status_line_bold_errno(fn);
 		} else {
+			// how many lines written
+			li = count_lines(q, q + l - 1);
 			status_line("'%s' %dL, %dC", fn, li, l);
-			if (q == text && r == end - 1 && l == size) {
-				modified_count = 0;
-				last_modified_count = -1;
-			}
-			if ((cmd[0] == 'x' || cmd[1] == 'q' || cmd[1] == 'n'
-			    || cmd[0] == 'X' || cmd[1] == 'Q' || cmd[1] == 'N'
-			    )
-			 && l == size
-			) {
-				editing = 0;
+			if (l == size) {
+				if (q == text && q + l == end) {
+					modified_count = 0;
+					last_modified_count = -1;
+				}
+				if (cmd[0] == 'x'
+				 || cmd[1] == 'q' || cmd[1] == 'n'
+				 || cmd[1] == 'Q' || cmd[1] == 'N'
+				) {
+					editing = 0;
+				}
 			}
 		}
 #if ENABLE_FEATURE_VI_YANKMARK
@@ -2734,15 +2739,9 @@ static char *swap_context(char *p) // go
 //----- Set terminal attributes --------------------------------
 static void rawmode(void)
 {
-	tcgetattr(0, &term_orig);
-	term_vi = term_orig;
-	term_vi.c_lflag &= (~ICANON & ~ECHO);	// leave ISIG on - allow intr's
-	term_vi.c_iflag &= (~IXON & ~ICRNL);
-	term_vi.c_oflag &= (~ONLCR);
-	term_vi.c_cc[VMIN] = 1;
-	term_vi.c_cc[VTIME] = 0;
-	erase_char = term_vi.c_cc[VERASE];
-	tcsetattr_stdin_TCSANOW(&term_vi);
+	// no TERMIOS_CLEAR_ISIG: leave ISIG on - allow signals
+	set_termios_to_raw(STDIN_FILENO, &term_orig, TERMIOS_RAW_CRNL);
+	erase_char = term_orig.c_cc[VERASE];
 }
 
 static void cookmode(void)
@@ -2817,8 +2816,15 @@ static int readit(void) // read (maybe c
 	int c;
 
 	fflush_all();
-	c = read_key(STDIN_FILENO, readbuffer, /*timeout off:*/ -2);
+
+	// Wait for input. TIMEOUT = -1 makes read_key wait even
+	// on nonblocking stdin.
+	// Note: read_key sets errno to 0 on success.
+ again:
+	c = read_key(STDIN_FILENO, readbuffer, /*timeout:*/ -1);
 	if (c == -1) { // EOF/error
+		if (errno == EAGAIN) // paranoia
+			goto again;
 		go_bottom_and_clear_to_eol();
 		cookmode(); // terminal to "cooked"
 		bb_error_msg_and_die("can't read user input");
diff -urpN busybox-1.26.2/examples/depmod busybox-1.27.0/examples/depmod
--- busybox-1.26.2/examples/depmod	2016-09-27 18:53:50.000000000 +0200
+++ busybox-1.27.0/examples/depmod	2017-01-25 01:56:57.000000000 +0100
@@ -7,7 +7,7 @@
 # Licensed under GPLv2, see file LICENSE in this source tree.
 #
 
-local BASE="${1:-/usr/lib/modules}"
+BASE="${1:-/usr/lib/modules}"
 
 find "$BASE" -name '*.ko.gz' | while read I ; do
 	N=`basename "$I" '.ko.gz'`
diff -urpN busybox-1.26.2/examples/udhcp/sample.bound busybox-1.27.0/examples/udhcp/sample.bound
--- busybox-1.26.2/examples/udhcp/sample.bound	2016-09-27 18:53:50.000000000 +0200
+++ busybox-1.27.0/examples/udhcp/sample.bound	2017-04-06 00:51:15.000000000 +0200
@@ -18,11 +18,18 @@ then
 	metric=0
 	for i in $router
 	do
+		if [ "$subnet" = "255.255.255.255" ]; then
+			# special case for /32 subnets:
+			# /32 instructs kernel to always use routing for all outgoing packets
+			# (they can never be sent to local subnet - there is no local subnet for /32).
+			# Used in datacenters, avoids the need for private ip-addresses between two hops.
+			/sbin/ip route add $i dev $interface
+		fi
 		/sbin/route add default gw $i dev $interface metric $((metric++))
 	done
 fi
 
-# Only replace resolv.conf is we have at least one DNS server
+# Only replace resolv.conf if we have at least one DNS server
 if [ -n "$dns" ]
 then
 	echo -n > $RESOLV_CONF
diff -urpN busybox-1.26.2/examples/udhcp/sample.renew busybox-1.27.0/examples/udhcp/sample.renew
--- busybox-1.26.2/examples/udhcp/sample.renew	2016-09-27 18:53:50.000000000 +0200
+++ busybox-1.27.0/examples/udhcp/sample.renew	2017-04-06 00:52:13.000000000 +0200
@@ -1,5 +1,5 @@
 #!/bin/sh
-# Sample udhcpc bound script
+# Sample udhcpc renew script
 
 RESOLV_CONF="/etc/udhcpc/resolv.conf"
 
@@ -18,11 +18,18 @@ then
 	metric=0
 	for i in $router
 	do
+		if [ "$subnet" = "255.255.255.255" ]; then
+			# special case for /32 subnets:
+			# /32 instructs kernel to always use routing for all outgoing packets
+			# (they can never be sent to local subnet - there is no local subnet for /32).
+			# Used in datacenters, avoids the need for private ip-addresses between two hops.
+			/sbin/ip route add $i dev $interface
+		fi
 		/sbin/route add default gw $i dev $interface metric $((metric++))
 	done
 fi
 
-# Only replace resolv.conf is we have at least one DNS server
+# Only replace resolv.conf if we have at least one DNS server
 if [ -n "$dns" ]
 then
 	echo -n > $RESOLV_CONF
diff -urpN busybox-1.26.2/examples/udhcp/simple.script busybox-1.27.0/examples/udhcp/simple.script
--- busybox-1.26.2/examples/udhcp/simple.script	2016-09-27 18:53:50.000000000 +0200
+++ busybox-1.27.0/examples/udhcp/simple.script	2017-04-06 00:51:38.000000000 +0200
@@ -29,8 +29,14 @@ case "$1" in
 			metric=0
 			for i in $router ; do
 				echo "Adding router $i"
-				route add default gw $i dev $interface metric $metric
-				: $(( metric += 1 ))
+				if [ "$subnet" = "255.255.255.255" ]; then
+	# special case for /32 subnets:
+	# /32 instructs kernel to always use routing for all outgoing packets
+	# (they can never be sent to local subnet - there is no local subnet for /32).
+	# Used in datacenters, avoids the need for private ip-addresses between two hops.
+					ip route add $i dev $interface
+				fi
+				route add default gw $i dev $interface metric $((metric++))
 			done
 		fi
 
diff -urpN busybox-1.26.2/examples/var_service/README_distro_proposal.txt busybox-1.27.0/examples/var_service/README_distro_proposal.txt
--- busybox-1.26.2/examples/var_service/README_distro_proposal.txt	2017-01-01 12:57:06.000000000 +0100
+++ busybox-1.27.0/examples/var_service/README_distro_proposal.txt	2017-01-03 12:28:15.000000000 +0100
@@ -48,7 +48,7 @@ ps tells me they did put X, dbus, NM and
   654 ?        00:00:00     runsv
   659 ?        00:00:00       udevd
 
-Here is a link to Vod Linux's wiki:
+Here is a link to Void Linux's wiki:
 
     https://wiki.voidlinux.eu/Runit
 
@@ -98,10 +98,10 @@ It is not required that a specific clone
 daemon: any long running background program. Common examples are sshd, getty,
 ntpd, dhcp client...
 
-service: same as "daemon"
+service: daemon controlled by a service monitor.
 
 service directory: a directory with an executable file (script) named "run"
-which (usually) execs daemon (possibly after some preparatory steps).
+which (usually) execs some daemon, possibly after some preparatory steps.
 It should start it not as a child or daemonized process, but by exec'ing it
 (inheriting the same PID and the place in the process tree).
 
@@ -116,7 +116,7 @@ whose directories disappeared.
 
 supervisor: a tool which monitors one service directory.
 It runs "run" script as its child. It restarts it if it dies.
-It can be instructed to start/top/signal its child.
+It can be instructed to start/stop/signal its child.
 In daemontools package, it is called "supervise". In runit, it is called
 "runsv". In s6, it is called "s6-supervise".
 
@@ -150,7 +150,9 @@ The less distros diverge, the easier use
 
 System-wide service dirs reside in a distro-specific location.
 The recommended location is /var/service. (However, since it is not
-a mandatory location, avoid depending on it in your run scripts).
+a mandatory location, avoid depending on it in your run scripts.
+Void Linux wanted to have it somewhere in /run/*, and they solved this
+by making /var/service a symlink).
 
 The install location for service dirs is /etc/rc:
 when e.g. ntpd daemon is installed, it creates the /etc/rc/ntpd
@@ -182,10 +184,14 @@ of bad things may happen. This may be wo
 heuristics in service monitor which give new service a few seconds
 of "grace time" to be fully populated; but this is not yet
 implemented in any of three packages.
+This also may be worked around by creating a .dotdir (a directory
+whose name starts with a dot), populating it, and then renaming;
+but packaging tools usually do not have an option to do this
+automatically - additional install scripting in packages will be needed.
 
 Daemons' output file descriptors are handled somewhat awkwardly
 by various daemontools implementations. For example, for runit tools,
-daemons' stdout goes to wherever runsdir's stdout was directied;
+daemons' stdout goes to wherever runsvdir's stdout was directed;
 stderr goes to runsvdir, which in turn "rotates" it on its command line
 (which is visible in ps output).
 
@@ -236,11 +242,11 @@ there is no guarantee in which order com
 If DIR has no slash and is not "." or "..", it is assumed to be
 relative to the system-wide service directory.
 
-The "svok DIR" tool exits 0 if service is running, and nonzero if not.
+[Currently, "svc" exists only in daemontools and in busybox.
+This proposal asks developers of other daemontools implementations
+to add "svc" command to their projects]
 
-The "svstat DIR1 DIR2..." prints one human-readable line for each directory,
-saying whether supervise is successfully running in that directory,
-and reporting the status information maintained by supervise.
+The "svok DIR" tool exits 0 if service is running, and nonzero if not.
 
 Other tools with different names and APIs may exist; however
 for portability scripts should use the above tools.
@@ -250,27 +256,28 @@ To this end, first create and populate a
 
 Then "activate" it by running ??????? - this copies (or symlinks,
 depending on the distro) its files to the "live" service directory,
-whereever it is located on this distro.
+wherever it is located on this distro.
 
 Removal of the service should be done as follows:
-svc -d DIR [DIR/log], then remove the service directory
-(this makes service monitor SIGTERM per-directory supervisors
-(if they exist in the implementation))
+svc -d DIR [DIR/log], then remove the service directory:
+this makes service monitor SIGTERM per-directory supervisors
+(if they exist in the implementation).
 
 
 	Implementation details
 
-Top-level service monitor program name is not standardized.
-[svscan, runsvdir, s6-svscan ...]
+Top-level service monitor program name is not standardized
+[svscan, runsvdir, s6-svscan ...] - it does not need to be,
+as far as daemon packagers are concerned.
 
 It may run one per-directory supervisor, or two supervisors
 (one for DIR/ and one for DIR/log/); for memory-constrained systems
 an implementation is possible which itself controls all services, without
 intermediate supervisors.
 [runsvdir runs one "runsv DIR" per DIR, runsv handles DIR/log/ if that exists]
-[svscan runs a pair of "superwise DIR" and "superwise DIR/log"]
+[svscan runs a pair of "supervise DIR" and "supervise DIR/log"]
 
-Directores are remembered by device+inode numbers, not names. Renaming a directory
+Directories are remembered by device+inode numbers, not names. Renaming a directory
 does not affect the running service (unless it is renamed to a .dotdir).
 
 Removal (or .dotdiring) of a directory sends SIGTERM to any running services.
diff -urpN busybox-1.26.2/examples/var_service/dhcp_if/dhcp_handler busybox-1.27.0/examples/var_service/dhcp_if/dhcp_handler
--- busybox-1.26.2/examples/var_service/dhcp_if/dhcp_handler	2016-09-27 18:53:50.000000000 +0200
+++ busybox-1.27.0/examples/var_service/dhcp_if/dhcp_handler	2017-07-01 22:51:12.000000000 +0200
@@ -21,7 +21,7 @@
 # ntpsrv=10.34.32.125 10.34.255.7
 #
 # renew: lease is renewed. Environment is similar to "bound".
-# The IP address does not change, however, the other DHCP paramaters,
+# The IP address does not change, however, the other DHCP parameters,
 # such as the default gateway, subnet mask, and dns server may change.
 #
 # nak: udhcpc received a NAK message.
diff -urpN busybox-1.26.2/findutils/find.c busybox-1.27.0/findutils/find.c
--- busybox-1.26.2/findutils/find.c	2016-12-10 18:46:36.000000000 +0100
+++ busybox-1.27.0/findutils/find.c	2017-07-01 22:51:12.000000000 +0200
@@ -89,8 +89,6 @@
 //config:	bool "Enable -perm: permissions matching"
 //config:	default y
 //config:	depends on FIND
-//config:	help
-//config:	  Enable searching based on file permissions.
 //config:
 //config:config FEATURE_FIND_TYPE
 //config:	bool "Enable -type: file type matching (file/dir/link/...)"
@@ -104,15 +102,11 @@
 //config:	bool "Enable -xdev: 'stay in filesystem'"
 //config:	default y
 //config:	depends on FIND
-//config:	help
-//config:	  This option allows find to restrict searches to a single filesystem.
 //config:
 //config:config FEATURE_FIND_MAXDEPTH
 //config:	bool "Enable -mindepth N and -maxdepth N"
 //config:	default y
 //config:	depends on FIND
-//config:	help
-//config:	  This option enables -mindepth N and -maxdepth N option.
 //config:
 //config:config FEATURE_FIND_NEWER
 //config:	bool "Enable -newer: compare file modification times"
@@ -126,8 +120,6 @@
 //config:	bool "Enable -inum: inode number matching"
 //config:	default y
 //config:	depends on FIND
-//config:	help
-//config:	  Support the 'find -inum' option for searching by inode number.
 //config:
 //config:config FEATURE_FIND_EXEC
 //config:	bool "Enable -exec: execute commands"
@@ -151,15 +143,11 @@
 //config:	bool "Enable -user: username/uid matching"
 //config:	default y
 //config:	depends on FIND
-//config:	help
-//config:	  Support the 'find -user' option for searching by username or uid.
 //config:
 //config:config FEATURE_FIND_GROUP
 //config:	bool "Enable -group: group/gid matching"
 //config:	default y
 //config:	depends on FIND
-//config:	help
-//config:	  Support the 'find -group' option for searching by group name or gid.
 //config:
 //config:config FEATURE_FIND_NOT
 //config:	bool "Enable the 'not' (!) operator"
@@ -188,15 +176,13 @@
 //config:	bool "Enable -size: file size matching"
 //config:	default y
 //config:	depends on FIND
-//config:	help
-//config:	  Support the 'find -size' option for searching by file size.
 //config:
 //config:config FEATURE_FIND_PRUNE
 //config:	bool "Enable -prune: exclude subdirectories"
 //config:	default y
 //config:	depends on FIND
 //config:	help
-//config:	  If the file is a directory, dont descend into it. Useful for
+//config:	  If the file is a directory, don't descend into it. Useful for
 //config:	  exclusion .svn and CVS directories.
 //config:
 //config:config FEATURE_FIND_DELETE
diff -urpN busybox-1.26.2/findutils/grep.c busybox-1.27.0/findutils/grep.c
--- busybox-1.26.2/findutils/grep.c	2016-12-10 18:46:36.000000000 +0100
+++ busybox-1.27.0/findutils/grep.c	2017-07-01 22:51:12.000000000 +0200
@@ -39,13 +39,14 @@
 //config:config FEATURE_GREP_CONTEXT
 //config:	bool "Enable before and after context flags (-A, -B and -C)"
 //config:	default y
-//config:	depends on GREP || EGREP
+//config:	depends on GREP || EGREP || FGREP
 //config:	help
 //config:	  Print the specified number of leading (-B) and/or trailing (-A)
 //config:	  context surrounding our matching lines.
 //config:	  Print the specified number of context lines (-C).
 
 //applet:IF_GREP(APPLET(grep, BB_DIR_BIN, BB_SUID_DROP))
+//                APPLET_ODDNAME:name   main  location    suid_type     help
 //applet:IF_EGREP(APPLET_ODDNAME(egrep, grep, BB_DIR_BIN, BB_SUID_DROP, egrep))
 //applet:IF_FGREP(APPLET_ODDNAME(fgrep, grep, BB_DIR_BIN, BB_SUID_DROP, fgrep))
 
@@ -514,7 +515,7 @@ static int grep_file(FILE *file)
 				if (option_mask32 & OPT_o) {
 					if (FGREP_FLAG) {
 						/* -Fo just prints the pattern
-						 * (unless -v: -Fov doesnt print anything at all) */
+						 * (unless -v: -Fov doesn't print anything at all) */
 						if (found)
 							print_line(gl->pattern, strlen(gl->pattern), linenum, ':');
 					} else while (1) {
@@ -822,7 +823,7 @@ int grep_main(int argc UNUSED_PARAM, cha
  grep_done: ;
 	} while (*argv && *++argv);
 
-	/* destroy all the elments in the pattern list */
+	/* destroy all the elements in the pattern list */
 	if (ENABLE_FEATURE_CLEAN_UP) {
 		while (pattern_head) {
 			llist_t *pattern_head_ptr = pattern_head;
diff -urpN busybox-1.26.2/include/libbb.h busybox-1.27.0/include/libbb.h
--- busybox-1.26.2/include/libbb.h	2016-12-22 14:10:40.000000000 +0100
+++ busybox-1.27.0/include/libbb.h	2017-07-01 22:51:12.000000000 +0200
@@ -342,6 +342,8 @@ extern int *const bb_errno;
 uint64_t bb_bswap_64(uint64_t x) FAST_FUNC;
 #endif
 
+unsigned long FAST_FUNC isqrt(unsigned long long N);
+
 unsigned long long monotonic_ns(void) FAST_FUNC;
 unsigned long long monotonic_us(void) FAST_FUNC;
 unsigned long long monotonic_ms(void) FAST_FUNC;
@@ -355,6 +357,27 @@ extern char *skip_dev_pfx(const char *tt
 
 extern char *strrstr(const char *haystack, const char *needle) FAST_FUNC;
 
+/* dmalloc will redefine these to it's own implementation. It is safe
+ * to have the prototypes here unconditionally.  */
+void *malloc_or_warn(size_t size) FAST_FUNC RETURNS_MALLOC;
+void *xmalloc(size_t size) FAST_FUNC RETURNS_MALLOC;
+void *xzalloc(size_t size) FAST_FUNC RETURNS_MALLOC;
+void *xrealloc(void *old, size_t size) FAST_FUNC;
+/* After v = xrealloc_vector(v, SHIFT, idx) it's ok to use
+ * at least v[idx] and v[idx+1], for all idx values.
+ * SHIFT specifies how many new elements are added (1:2, 2:4, ..., 8:256...)
+ * when all elements are used up. New elements are zeroed out.
+ * xrealloc_vector(v, SHIFT, idx) *MUST* be called with consecutive IDXs -
+ * skipping an index is a bad bug - it may miss a realloc!
+ */
+#define xrealloc_vector(vector, shift, idx) \
+	xrealloc_vector_helper((vector), (sizeof((vector)[0]) << 8) + (shift), (idx))
+void* xrealloc_vector_helper(void *vector, unsigned sizeof_and_shift, int idx) FAST_FUNC;
+char *xstrdup(const char *s) FAST_FUNC RETURNS_MALLOC;
+char *xstrndup(const char *s, int n) FAST_FUNC RETURNS_MALLOC;
+void *xmemdup(const void *s, int n) FAST_FUNC RETURNS_MALLOC;
+
+
 //TODO: supply a pointer to char[11] buffer (avoid statics)?
 extern const char *bb_mode_string(mode_t mode) FAST_FUNC;
 extern int is_directory(const char *name, int followLinks) FAST_FUNC;
@@ -693,6 +716,56 @@ struct hostent *xgethostbyname(const cha
 // + inet_common.c has additional IPv4-only stuff
 
 
+#define TLS_MAX_MAC_SIZE 32
+#define TLS_MAX_KEY_SIZE 32
+struct tls_handshake_data; /* opaque */
+typedef struct tls_state {
+	int ofd;
+	int ifd;
+
+	unsigned min_encrypted_len_on_read;
+	uint16_t cipher_id;
+	uint8_t  encrypt_on_write;
+	unsigned MAC_size;
+	unsigned key_size;
+
+	uint8_t *outbuf;
+	int     outbuf_size;
+
+	int     inbuf_size;
+	int     ofs_to_buffered;
+	int     buffered_size;
+	uint8_t *inbuf;
+
+	struct tls_handshake_data *hsd;
+
+	// RFC 5246
+	// sequence number
+	//   Each connection state contains a sequence number, which is
+	//   maintained separately for read and write states.  The sequence
+	//   number MUST be set to zero whenever a connection state is made the
+	//   active state.  Sequence numbers are of type uint64 and may not
+	//   exceed 2^64-1.
+	/*uint64_t read_seq64_be;*/
+	uint64_t write_seq64_be;
+
+	uint8_t *client_write_key;
+	uint8_t *server_write_key;
+	uint8_t client_write_MAC_key[TLS_MAX_MAC_SIZE];
+	uint8_t server_write_MAC_k__[TLS_MAX_MAC_SIZE];
+	uint8_t client_write_k__[TLS_MAX_KEY_SIZE];
+	uint8_t server_write_k__[TLS_MAX_KEY_SIZE];
+} tls_state_t;
+
+static inline tls_state_t *new_tls_state(void)
+{
+	tls_state_t *tls = xzalloc(sizeof(*tls));
+	return tls;
+}
+void tls_handshake(tls_state_t *tls, const char *sni) FAST_FUNC;
+void tls_run_copy_loop(tls_state_t *tls) FAST_FUNC;
+
+
 void socket_want_pktinfo(int fd) FAST_FUNC;
 ssize_t send_to_from(int fd, void *buf, size_t len, int flags,
 		const struct sockaddr *to,
@@ -705,9 +778,6 @@ ssize_t recv_from_to(int fd, void *buf,
 
 uint16_t inet_cksum(uint16_t *addr, int len) FAST_FUNC;
 
-char *xstrdup(const char *s) FAST_FUNC RETURNS_MALLOC;
-char *xstrndup(const char *s, int n) FAST_FUNC RETURNS_MALLOC;
-void *xmemdup(const void *s, int n) FAST_FUNC RETURNS_MALLOC;
 void overlapping_strcpy(char *dst, const char *src) FAST_FUNC;
 char *safe_strncpy(char *dst, const char *src, size_t size) FAST_FUNC;
 char *strncpy_IFNAMSIZ(char *dst, const char *src) FAST_FUNC;
@@ -753,24 +823,6 @@ enum {
 };
 void visible(unsigned ch, char *buf, int flags) FAST_FUNC;
 
-/* dmalloc will redefine these to it's own implementation. It is safe
- * to have the prototypes here unconditionally.  */
-void *malloc_or_warn(size_t size) FAST_FUNC RETURNS_MALLOC;
-void *xmalloc(size_t size) FAST_FUNC RETURNS_MALLOC;
-void *xzalloc(size_t size) FAST_FUNC RETURNS_MALLOC;
-void *xrealloc(void *old, size_t size) FAST_FUNC;
-/* After v = xrealloc_vector(v, SHIFT, idx) it's ok to use
- * at least v[idx] and v[idx+1], for all idx values.
- * SHIFT specifies how many new elements are added (1:2, 2:4, ..., 8:256...)
- * when all elements are used up. New elements are zeroed out.
- * xrealloc_vector(v, SHIFT, idx) *MUST* be called with consecutive IDXs -
- * skipping an index is a bad bug - it may miss a realloc!
- */
-#define xrealloc_vector(vector, shift, idx) \
-	xrealloc_vector_helper((vector), (sizeof((vector)[0]) << 8) + (shift), (idx))
-void* xrealloc_vector_helper(void *vector, unsigned sizeof_and_shift, int idx) FAST_FUNC;
-
-
 extern ssize_t safe_read(int fd, void *buf, size_t count) FAST_FUNC;
 extern ssize_t nonblock_immune_read(int fd, void *buf, size_t count) FAST_FUNC;
 // NB: will return short read on error, not -1,
@@ -1043,10 +1095,19 @@ pid_t wait_any_nohang(int *wstat) FAST_F
  */
 int wait4pid(pid_t pid) FAST_FUNC;
 int wait_for_exitstatus(pid_t pid) FAST_FUNC;
+/************************************************************************/
+/* spawn_and_wait/run_nofork_applet/run_applet_no_and_exit need to work */
+/* carefully together to reinit some global state while not disturbing  */
+/* other. Be careful if you change them. Consult docs/nofork_noexec.txt */
+/************************************************************************/
 /* Same as wait4pid(spawn(argv)), but with NOFORK/NOEXEC if configured: */
 int spawn_and_wait(char **argv) FAST_FUNC;
 /* Does NOT check that applet is NOFORK, just blindly runs it */
 int run_nofork_applet(int applet_no, char **argv) FAST_FUNC;
+#ifndef BUILD_INDIVIDUAL
+extern int find_applet_by_name(const char *name) FAST_FUNC;
+extern void run_applet_no_and_exit(int a, char **argv) NORETURN FAST_FUNC;
+#endif
 
 /* Helpers for daemonization.
  *
@@ -1115,6 +1176,26 @@ extern const char *applet_long_options;
 #endif
 extern uint32_t option_mask32;
 extern uint32_t getopt32(char **argv, const char *applet_opts, ...) FAST_FUNC;
+/* BSD-derived getopt() functions require that optind be set to 1 in
+ * order to reset getopt() state.  This used to be generally accepted
+ * way of resetting getopt().  However, glibc's getopt()
+ * has additional getopt() state beyond optind (specifically, glibc
+ * extensions such as '+' and '-' at the start of the string), and requires
+ * that optind be set to zero to reset its state.  BSD-derived versions
+ * of getopt() misbehaved if optind is set to 0 in order to reset getopt(),
+ * and glibc's getopt() used to coredump if optind is set 1 in order
+ * to reset getopt().
+ * Then BSD introduced additional variable "optreset" which should be
+ * set to 1 in order to reset getopt().  Sigh.  Standards, anyone?
+ *
+ * By ~2008, OpenBSD 3.4 was changed to survive glibc-like optind = 0
+ * (to interpret it as if optreset was set).
+ */
+#ifdef __GLIBC__
+#define GETOPT_RESET() (optind = 0)
+#else /* BSD style */
+#define GETOPT_RESET() (optind = 1)
+#endif
 
 
 /* Having next pointer as a first member allows easy creation
@@ -1186,7 +1267,7 @@ extern void bb_logenv_override(void) FAS
 
 
 /* Applets which are useful from another applets */
-int bb_cat(char** argv);
+int bb_cat(char** argv) FAST_FUNC;
 /* If shell needs them, they exist even if not enabled as applets */
 int echo_main(int argc, char** argv) IF_ECHO(MAIN_EXTERNALLY_VISIBLE);
 int printf_main(int argc, char **argv) IF_PRINTF(MAIN_EXTERNALLY_VISIBLE);
@@ -1212,6 +1293,16 @@ int bunzip2_main(int argc, char **argv)
 void bb_displayroutes(int noresolve, int netstatfmt) FAST_FUNC;
 #endif
 
+struct number_state {
+	unsigned width;
+	unsigned start;
+	unsigned inc;
+	const char *sep;
+	const char *empty_str;
+	smallint all, nonempty;
+};
+void print_numbered_lines(struct number_state *ns, const char *filename) FAST_FUNC;
+
 
 /* Networking */
 /* This structure defines protocol families and their handlers. */
@@ -1253,13 +1344,8 @@ const struct hwtype *get_hwtype(const ch
 const struct hwtype *get_hwntype(int type) FAST_FUNC;
 
 
-#ifndef BUILD_INDIVIDUAL
-extern int find_applet_by_name(const char *name) FAST_FUNC;
-extern void run_applet_no_and_exit(int a, char **argv) NORETURN FAST_FUNC;
-#endif
-
+extern int fstype_matches(const char *fstype, const char *comma_list) FAST_FUNC;
 #ifdef HAVE_MNTENT_H
-extern int match_fstype(const struct mntent *mt, const char *fstypes) FAST_FUNC;
 extern struct mntent *find_mount_point(const char *name, int subdir_too) FAST_FUNC;
 #endif
 extern void erase_mtab(const char * name) FAST_FUNC;
@@ -1275,10 +1361,15 @@ extern int get_linux_version_code(void)
 
 extern char *query_loop(const char *device) FAST_FUNC;
 extern int del_loop(const char *device) FAST_FUNC;
-/* If *devname is not NULL, use that name, otherwise try to find free one,
+/*
+ * If *devname is not NULL, use that name, otherwise try to find free one,
  * malloc and return it in *devname.
- * return value: 1: read-only loopdev was setup, 0: rw, < 0: error */
-extern int set_loop(char **devname, const char *file, unsigned long long offset, int ro) FAST_FUNC;
+ * return value is the opened fd to the loop device, or < on error
+ */
+extern int set_loop(char **devname, const char *file, unsigned long long offset, unsigned flags) FAST_FUNC;
+/* These constants match linux/loop.h (without BB_ prefix): */
+#define BB_LO_FLAGS_READ_ONLY 1
+#define BB_LO_FLAGS_AUTOCLEAR 4
 
 /* Like bb_ask below, but asks on stdin with no timeout.  */
 char *bb_ask_stdin(const char * prompt) FAST_FUNC;
@@ -1390,6 +1481,12 @@ extern void selinux_or_die(void) FAST_FU
 #define SETUP_ENV_NO_CHDIR  (1 << 4)
 void setup_environment(const char *shell, int flags, const struct passwd *pw) FAST_FUNC;
 void nuke_str(char *str) FAST_FUNC;
+#if ENABLE_FEATURE_SECURETTY && !ENABLE_PAM
+int is_tty_secure(const char *short_tty) FAST_FUNC;
+#else
+static ALWAYS_INLINE int is_tty_secure(const char *short_tty UNUSED_PARAM) { return 1; }
+#endif
+#define CHECKPASS_PW_HAS_EMPTY_PASSWORD 2
 int check_password(const struct passwd *pw, const char *plaintext) FAST_FUNC;
 int ask_and_check_password_extended(const struct passwd *pw, int timeout, const char *prompt) FAST_FUNC;
 int ask_and_check_password(const struct passwd *pw) FAST_FUNC;
@@ -1438,6 +1535,10 @@ int get_terminal_width_height(int fd, un
 int get_terminal_width(int fd) FAST_FUNC;
 
 int tcsetattr_stdin_TCSANOW(const struct termios *tp) FAST_FUNC;
+#define TERMIOS_CLEAR_ISIG (1 << 0)
+#define TERMIOS_RAW_CRNL   (1 << 1)
+#define TERMIOS_RAW_INPUT  (1 << 2)
+int set_termios_to_raw(int fd, struct termios *oldterm, int flags) FAST_FUNC;
 
 /* NB: "unsigned request" is crucial! "int request" will break some arches! */
 int ioctl_or_perror(int fd, unsigned request, void *argp, const char *fmt,...) __attribute__ ((format (printf, 4, 5))) FAST_FUNC;
@@ -1749,19 +1850,23 @@ typedef struct sha3_ctx_t {
 } sha3_ctx_t;
 void md5_begin(md5_ctx_t *ctx) FAST_FUNC;
 void md5_hash(md5_ctx_t *ctx, const void *buffer, size_t len) FAST_FUNC;
-void md5_end(md5_ctx_t *ctx, void *resbuf) FAST_FUNC;
+unsigned md5_end(md5_ctx_t *ctx, void *resbuf) FAST_FUNC;
 void sha1_begin(sha1_ctx_t *ctx) FAST_FUNC;
 #define sha1_hash md5_hash
-void sha1_end(sha1_ctx_t *ctx, void *resbuf) FAST_FUNC;
+unsigned sha1_end(sha1_ctx_t *ctx, void *resbuf) FAST_FUNC;
 void sha256_begin(sha256_ctx_t *ctx) FAST_FUNC;
 #define sha256_hash md5_hash
 #define sha256_end  sha1_end
 void sha512_begin(sha512_ctx_t *ctx) FAST_FUNC;
 void sha512_hash(sha512_ctx_t *ctx, const void *buffer, size_t len) FAST_FUNC;
-void sha512_end(sha512_ctx_t *ctx, void *resbuf) FAST_FUNC;
+unsigned sha512_end(sha512_ctx_t *ctx, void *resbuf) FAST_FUNC;
 void sha3_begin(sha3_ctx_t *ctx) FAST_FUNC;
 void sha3_hash(sha3_ctx_t *ctx, const void *buffer, size_t len) FAST_FUNC;
-void sha3_end(sha3_ctx_t *ctx, void *resbuf) FAST_FUNC;
+unsigned sha3_end(sha3_ctx_t *ctx, void *resbuf) FAST_FUNC;
+/* TLS benefits from knowing that sha1 and sha256 share these. Give them "agnostic" names too */
+typedef struct md5_ctx_t md5sha_ctx_t;
+#define md5sha_hash md5_hash
+#define sha_end sha1_end
 
 extern uint32_t *global_crc32_table;
 uint32_t *crc32_filltable(uint32_t *tbl256, int endian) FAST_FUNC;
diff -urpN busybox-1.26.2/include/platform.h busybox-1.27.0/include/platform.h
--- busybox-1.26.2/include/platform.h	2016-09-27 18:53:50.000000000 +0200
+++ busybox-1.27.0/include/platform.h	2017-01-10 16:31:40.000000000 +0100
@@ -108,13 +108,18 @@
  * and/or smaller by using modified ABI. It is usually only needed
  * on non-static, busybox internal functions. Recent versions of gcc
  * optimize statics automatically. FAST_FUNC on static is required
- * only if you need to match a function pointer's type */
-#if __GNUC_PREREQ(3,0) && defined(i386) /* || defined(__x86_64__)? */
+ * only if you need to match a function pointer's type.
+ * FAST_FUNC may not work well with -flto so allow user to disable this.
+ * (-DFAST_FUNC= )
+ */
+#ifndef FAST_FUNC
+# if __GNUC_PREREQ(3,0) && defined(i386)
 /* stdcall makes callee to pop arguments from stack, not caller */
-# define FAST_FUNC __attribute__((regparm(3),stdcall))
+#  define FAST_FUNC __attribute__((regparm(3),stdcall))
 /* #elif ... - add your favorite arch today! */
-#else
-# define FAST_FUNC
+# else
+#  define FAST_FUNC
+# endif
 #endif
 
 /* Make all declarations hidden (-fvisibility flag only affects definitions) */
diff -urpN busybox-1.26.2/include/usage.src.h busybox-1.27.0/include/usage.src.h
--- busybox-1.26.2/include/usage.src.h	2016-09-27 18:53:50.000000000 +0200
+++ busybox-1.27.0/include/usage.src.h	2017-01-23 01:09:41.000000000 +0100
@@ -14,6 +14,14 @@
 
 #define NOUSAGE_STR "\b"
 
+#if !ENABLE_USE_BB_CRYPT || ENABLE_USE_BB_CRYPT_SHA
+# define CRYPT_METHODS_HELP_STR "des,md5,sha256/512" \
+	" (default "CONFIG_FEATURE_DEFAULT_PASSWD_ALGO")"
+#else
+# define CRYPT_METHODS_HELP_STR "des,md5" \
+	" (default "CONFIG_FEATURE_DEFAULT_PASSWD_ALGO")"
+#endif
+
 INSERT
 
 #define busybox_notes_usage \
diff -urpN busybox-1.26.2/init/halt.c busybox-1.27.0/init/halt.c
--- busybox-1.26.2/init/halt.c	2016-12-10 18:46:36.000000000 +0100
+++ busybox-1.27.0/init/halt.c	2017-01-30 21:57:30.000000000 +0100
@@ -46,8 +46,9 @@
 //config:	  locating telinit executable.
 
 //applet:IF_HALT(APPLET(halt, BB_DIR_SBIN, BB_SUID_DROP))
+//                   APPLET_ODDNAME:name      main  location     suid_type     help
 //applet:IF_POWEROFF(APPLET_ODDNAME(poweroff, halt, BB_DIR_SBIN, BB_SUID_DROP, poweroff))
-//applet:IF_REBOOT(APPLET_ODDNAME(reboot, halt, BB_DIR_SBIN, BB_SUID_DROP, reboot))
+//applet:IF_REBOOT(  APPLET_ODDNAME(reboot,   halt, BB_DIR_SBIN, BB_SUID_DROP, reboot))
 
 //kbuild:lib-$(CONFIG_HALT) += halt.o
 //kbuild:lib-$(CONFIG_POWEROFF) += halt.o
diff -urpN busybox-1.26.2/init/init.c busybox-1.27.0/init/init.c
--- busybox-1.26.2/init/init.c	2017-01-01 13:01:04.000000000 +0100
+++ busybox-1.27.0/init/init.c	2017-07-01 22:51:12.000000000 +0200
@@ -17,7 +17,7 @@
 //config:	  init is the first program run when the system boots.
 //config:
 //config:config LINUXRC
-//config:	bool "Support running init from within an initrd (not initramfs)"
+//config:	bool "linuxrc: support running init from initrd (not initramfs)"
 //config:	default y
 //config:	select FEATURE_SYSLOG
 //config:	help
@@ -73,13 +73,15 @@
 //config:	bool "Enable init to write to syslog"
 //config:	default y
 //config:	depends on INIT || LINUXRC
+//config:	help
+//config:	  If selected, some init messages are sent to syslog.
+//config:	  Otherwise, they are sent to VT #5 if linux virtual tty is detected
+//config:	  (if not, no separate logging is done).
 //config:
-//config:config FEATURE_EXTRA_QUIET
-//config:	bool "Be _extra_ quiet on boot"
+//config:config FEATURE_INIT_QUIET
+//config:	bool "Be quiet on boot (no 'init started:' message)"
 //config:	default y
 //config:	depends on INIT || LINUXRC
-//config:	help
-//config:	  Prevent init from logging some messages to the console during boot.
 //config:
 //config:config FEATURE_INIT_COREDUMPS
 //config:	bool "Support dumping core for child processes (debugging only)"
@@ -104,13 +106,13 @@
 //config:	  sets TERM to "vt102" if one is found.
 //config:
 //config:config FEATURE_INIT_MODIFY_CMDLINE
-//config:	bool "Modify the command-line to \"init\""
+//config:	bool "Clear init's command line"
 //config:	default y
 //config:	depends on INIT || LINUXRC
 //config:	help
 //config:	  When launched as PID 1 and after parsing its arguments, init
 //config:	  wipes all the arguments but argv[0] and rewrites argv[0] to
-//config:	  contain only "init", so that its command-line appears solely as
+//config:	  contain only "init", so that its command line appears solely as
 //config:	  "init" in tools such as ps.
 //config:	  If this option is set to Y, init will keep its original behavior,
 //config:	  otherwise, all the arguments including argv[0] will be preserved,
@@ -214,7 +216,9 @@ struct init_action {
 
 static struct init_action *init_action_list = NULL;
 
+#if !ENABLE_FEATURE_INIT_SYSLOG
 static const char *log_console = VC_5;
+#endif
 
 enum {
 	L_LOG = 0x1,
@@ -253,17 +257,16 @@ static void message(int where, const cha
 	msg[l++] = '\n';
 	msg[l] = '\0';
 #else
-	{
-		static int log_fd = -1;
-
-		msg[l++] = '\n';
-		msg[l] = '\0';
+	msg[l++] = '\n';
+	msg[l] = '\0';
+	if (where & L_LOG) {
 		/* Take full control of the log tty, and never close it.
 		 * It's mine, all mine!  Muhahahaha! */
+		static int log_fd = -1;
+
 		if (log_fd < 0) {
-			if (!log_console) {
-				log_fd = STDERR_FILENO;
-			} else {
+			log_fd = STDERR_FILENO;
+			if (log_console) {
 				log_fd = device_open(log_console, O_WRONLY | O_NONBLOCK | O_NOCTTY);
 				if (log_fd < 0) {
 					bb_error_msg("can't log to %s", log_console);
@@ -273,11 +276,9 @@ static void message(int where, const cha
 				}
 			}
 		}
-		if (where & L_LOG) {
-			full_write(log_fd, msg, l);
-			if (log_fd == STDERR_FILENO)
-				return; /* don't print dup messages */
-		}
+		full_write(log_fd, msg, l);
+		if (log_fd == STDERR_FILENO)
+			return; /* don't print dup messages */
 	}
 #endif
 
@@ -327,8 +328,9 @@ static void console_init(void)
 		 * if TERM is set to linux (the default) */
 		if (!s || strcmp(s, "linux") == 0)
 			putenv((char*)"TERM=vt102");
-		if (!ENABLE_FEATURE_INIT_SYSLOG)
-			log_console = NULL;
+# if !ENABLE_FEATURE_INIT_SYSLOG
+		log_console = NULL;
+# endif
 	} else
 #endif
 	if (!s)
@@ -543,8 +545,8 @@ static pid_t run(const struct init_actio
 	}
 
 	/* Log the process name and args */
-	message(L_LOG, "starting pid %d, tty '%s': '%s'",
-			getpid(), a->terminal, a->command);
+	message(L_LOG, "starting pid %u, tty '%s': '%s'",
+			(int)getpid(), a->terminal, a->command);
 
 	/* Now run it.  The new program will take over this PID,
 	 * so nothing further in init.c should be run. */
@@ -759,7 +761,7 @@ static void run_shutdown_and_kill_proces
 
 	/* Send signals to every process _except_ pid 1 */
 	kill(-1, SIGTERM);
-	message(L_CONSOLE | L_LOG, "Sent SIG%s to all processes", "TERM");
+	message(L_CONSOLE, "Sent SIG%s to all processes", "TERM");
 	sync();
 	sleep(1);
 
@@ -1098,7 +1100,7 @@ int init_main(int argc UNUSED_PARAM, cha
 	if (argv[1])
 		xsetenv("RUNLEVEL", argv[1]);
 
-#if !ENABLE_FEATURE_EXTRA_QUIET
+#if !ENABLE_FEATURE_INIT_QUIET
 	/* Hello world */
 	message(L_CONSOLE | L_LOG, "init started: %s", bb_banner);
 #endif
diff -urpN busybox-1.26.2/init/mesg.c busybox-1.27.0/init/mesg.c
--- busybox-1.26.2/init/mesg.c	2016-09-27 18:53:50.000000000 +0200
+++ busybox-1.27.0/init/mesg.c	1970-01-01 01:00:00.000000000 +0100
@@ -1,76 +0,0 @@
-/* vi: set sw=4 ts=4: */
-/*
- * mesg implementation for busybox
- *
- * Copyright (c) 2002 Manuel Novoa III  <mjn3@codepoet.org>
- *
- * Licensed under GPLv2 or later, see file LICENSE in this source tree.
- */
-
-//config:config MESG
-//config:	bool "mesg"
-//config:	default y
-//config:	help
-//config:	  Mesg controls access to your terminal by others. It is typically
-//config:	  used to allow or disallow other users to write to your terminal
-//config:
-//config:config FEATURE_MESG_ENABLE_ONLY_GROUP
-//config:	bool "Enable writing to tty only by group, not by everybody"
-//config:	default y
-//config:	depends on MESG
-//config:	help
-//config:	  Usually, ttys are owned by group "tty", and "write" tool is
-//config:	  setgid to this group. This way, "mesg y" only needs to enable
-//config:	  "write by owning group" bit in tty mode.
-//config:
-//config:	  If you set this option to N, "mesg y" will enable writing
-//config:	  by anybody at all. This is not recommended.
-
-//applet:IF_MESG(APPLET(mesg, BB_DIR_USR_BIN, BB_SUID_DROP))
-
-//kbuild:lib-$(CONFIG_MESG) += mesg.o
-
-//usage:#define mesg_trivial_usage
-//usage:       "[y|n]"
-//usage:#define mesg_full_usage "\n\n"
-//usage:       "Control write access to your terminal\n"
-//usage:       "	y	Allow write access to your terminal\n"
-//usage:       "	n	Disallow write access to your terminal"
-
-#include "libbb.h"
-
-#if ENABLE_FEATURE_MESG_ENABLE_ONLY_GROUP
-#define S_IWGRP_OR_S_IWOTH  S_IWGRP
-#else
-#define S_IWGRP_OR_S_IWOTH  (S_IWGRP | S_IWOTH)
-#endif
-
-int mesg_main(int argc, char **argv) MAIN_EXTERNALLY_VISIBLE;
-int mesg_main(int argc UNUSED_PARAM, char **argv)
-{
-	struct stat sb;
-	mode_t m;
-	char c = 0;
-
-	argv++;
-
-	if (argv[0]
-	 && (argv[1] || ((c = argv[0][0]) != 'y' && c != 'n'))
-	) {
-		bb_show_usage();
-	}
-
-	if (!isatty(STDIN_FILENO))
-		bb_error_msg_and_die("not a tty");
-
-	xfstat(STDIN_FILENO, &sb, "stderr");
-	if (c == 0) {
-		puts((sb.st_mode & (S_IWGRP|S_IWOTH)) ? "is y" : "is n");
-		return EXIT_SUCCESS;
-	}
-	m = (c == 'y') ? sb.st_mode | S_IWGRP_OR_S_IWOTH
-	               : sb.st_mode & ~(S_IWGRP|S_IWOTH);
-	if (fchmod(STDIN_FILENO, m) != 0)
-		bb_perror_nomsg_and_die();
-	return EXIT_SUCCESS;
-}
diff -urpN busybox-1.26.2/libbb/Config.src busybox-1.27.0/libbb/Config.src
--- busybox-1.26.2/libbb/Config.src	2017-01-01 13:01:04.000000000 +0100
+++ busybox-1.27.0/libbb/Config.src	2017-01-10 16:31:40.000000000 +0100
@@ -70,24 +70,13 @@ config FEATURE_FAST_TOP
 	  but code size is slightly bigger.
 
 config FEATURE_ETC_NETWORKS
-	bool "Support for /etc/networks"
+	bool "Support /etc/networks"
 	default n
 	help
 	  Enable support for network names in /etc/networks. This is
 	  a rarely used feature which allows you to use names
 	  instead of IP/mask pairs in route command.
 
-config FEATURE_USE_TERMIOS
-	bool "Use termios to manipulate the screen"
-	default y
-	depends on MORE || TOP || POWERTOP
-	help
-	  This option allows utilities such as 'more' and 'top' to determine
-	  the size of the screen. If you leave this disabled, your utilities
-	  that display things on the screen will be especially primitive and
-	  will be unable to determine the current screen size, and will be
-	  unable to move the cursor.
-
 config FEATURE_EDITING
 	bool "Command line editing"
 	default y
@@ -147,15 +136,11 @@ config FEATURE_TAB_COMPLETION
 	bool "Tab completion"
 	default y
 	depends on FEATURE_EDITING
-	help
-	  Enable tab completion.
 
 config FEATURE_USERNAME_COMPLETION
 	bool "Username completion"
 	default y
 	depends on FEATURE_TAB_COMPLETION
-	help
-	  Enable username completion.
 
 config FEATURE_EDITING_FANCY_PROMPT
 	bool "Fancy shell prompts"
diff -urpN busybox-1.26.2/libbb/Kbuild.src busybox-1.27.0/libbb/Kbuild.src
--- busybox-1.26.2/libbb/Kbuild.src	2017-01-01 13:01:04.000000000 +0100
+++ busybox-1.27.0/libbb/Kbuild.src	2017-07-01 22:51:12.000000000 +0200
@@ -83,6 +83,7 @@ lib-y += safe_gethostname.o
 lib-y += safe_poll.o
 lib-y += safe_strncpy.o
 lib-y += safe_write.o
+lib-y += securetty.o
 lib-y += setup_environment.o
 lib-y += signals.o
 lib-y += simplify_path.o
diff -urpN busybox-1.26.2/libbb/appletlib.c busybox-1.27.0/libbb/appletlib.c
--- busybox-1.26.2/libbb/appletlib.c	2017-01-01 13:01:04.000000000 +0100
+++ busybox-1.27.0/libbb/appletlib.c	2017-01-15 00:18:53.000000000 +0100
@@ -52,6 +52,32 @@
 
 #include "usage_compressed.h"
 
+
+/* "Do not compress usage text if uncompressed text is small
+ *  and we don't include bunzip2 code for other reasons"
+ *
+ * Useful for mass one-applet rebuild (bunzip2 code is ~2.7k).
+ *
+ * Unlike BUNZIP2, if FEATURE_SEAMLESS_BZ2 is on, bunzip2 code is built but
+ * still may be unused if none of the selected applets calls open_zipped()
+ * or its friends; we test for (FEATURE_SEAMLESS_BZ2 && <APPLET>) instead.
+ * For example, only if TAR and FEATURE_SEAMLESS_BZ2 are both selected,
+ * then bunzip2 code will be linked in anyway, and disabling help compression
+ * would be not optimal:
+ */
+#if UNPACKED_USAGE_LENGTH < 4*1024 \
+ && !(ENABLE_FEATURE_SEAMLESS_BZ2 && ENABLE_TAR) \
+ && !(ENABLE_FEATURE_SEAMLESS_BZ2 && ENABLE_MODPROBE) \
+ && !(ENABLE_FEATURE_SEAMLESS_BZ2 && ENABLE_INSMOD) \
+ && !(ENABLE_FEATURE_SEAMLESS_BZ2 && ENABLE_DEPMOD) \
+ && !(ENABLE_FEATURE_SEAMLESS_BZ2 && ENABLE_MAN) \
+ && !ENABLE_BUNZIP2 \
+ && !ENABLE_BZCAT
+# undef  ENABLE_FEATURE_COMPRESS_USAGE
+# define ENABLE_FEATURE_COMPRESS_USAGE 0
+#endif
+
+
 #if ENABLE_SHOW_USAGE && !ENABLE_FEATURE_COMPRESS_USAGE
 static const char usage_messages[] ALIGN1 = UNPACKED_USAGE;
 #else
@@ -554,6 +580,7 @@ static inline void parse_config_file(voi
 
 
 # if ENABLE_FEATURE_SUID && NUM_APPLETS > 0
+#  if ENABLE_FEATURE_SUID_CONFIG
 /* check if u is member of group g */
 static int ingroup(uid_t u, gid_t g)
 {
@@ -568,6 +595,7 @@ static int ingroup(uid_t u, gid_t g)
 	}
 	return 0;
 }
+#  endif
 
 static void check_suid(int applet_no)
 {
@@ -720,11 +748,7 @@ static int busybox_main(char **argv)
 		int col;
 		unsigned output_width;
  help:
-		output_width = 80;
-		if (ENABLE_FEATURE_AUTOWIDTH) {
-			/* Obtain the terminal width */
-			output_width = get_terminal_width(2);
-		}
+		output_width = get_terminal_width(2);
 
 		dup2(1, 2);
 		full_write2_str(bb_banner); /* reuse const string */
diff -urpN busybox-1.26.2/libbb/bb_cat.c busybox-1.27.0/libbb/bb_cat.c
--- busybox-1.26.2/libbb/bb_cat.c	1970-01-01 01:00:00.000000000 +0100
+++ busybox-1.27.0/libbb/bb_cat.c	2017-07-01 22:51:12.000000000 +0200
@@ -0,0 +1,33 @@
+/* vi: set sw=4 ts=4: */
+/*
+ * Copyright (C) 2003  Manuel Novoa III  <mjn3@codepoet.org>
+ *
+ * Licensed under GPLv2, see file LICENSE in this source tree.
+ */
+//kbuild:lib-y += bb_cat.o
+
+#include "libbb.h"
+
+int FAST_FUNC bb_cat(char **argv)
+{
+	int fd;
+	int retval = EXIT_SUCCESS;
+
+	if (!*argv)
+		argv = (char**) &bb_argv_dash;
+
+	do {
+		fd = open_or_warn_stdin(*argv);
+		if (fd >= 0) {
+			/* This is not a xfunc - never exits */
+			off_t r = bb_copyfd_eof(fd, STDOUT_FILENO);
+			if (fd != STDIN_FILENO)
+				close(fd);
+			if (r >= 0)
+				continue;
+		}
+		retval = EXIT_FAILURE;
+	} while (*++argv);
+
+	return retval;
+}
diff -urpN busybox-1.26.2/libbb/correct_password.c busybox-1.27.0/libbb/correct_password.c
--- busybox-1.26.2/libbb/correct_password.c	2016-09-27 18:53:50.000000000 +0200
+++ busybox-1.27.0/libbb/correct_password.c	2017-07-01 22:51:12.000000000 +0200
@@ -63,7 +63,7 @@ static const char *get_passwd(const stru
 }
 
 /*
- * Return 1 if PW has an empty password.
+ * Return CHECKPASS_PW_HAS_EMPTY_PASSWORD if PW has an empty password.
  * Return 1 if the user gives the correct password for entry PW,
  * 0 if not.
  * NULL pw means "just fake it for login with bad username"
@@ -77,7 +77,7 @@ int FAST_FUNC check_password(const struc
 
 	pw_pass = get_passwd(pw, buffer);
 	if (!pw_pass[0]) { /* empty password field? */
-		return 1;
+		return CHECKPASS_PW_HAS_EMPTY_PASSWORD;
 	}
 
 	encrypted = pw_encrypt(plaintext, /*salt:*/ pw_pass, 1);
@@ -88,7 +88,7 @@ int FAST_FUNC check_password(const struc
 
 
 /* Ask the user for a password.
- * Return 1 without asking if PW has an empty password.
+ * Return CHECKPASS_PW_HAS_EMPTY_PASSWORD without asking if PW has an empty password.
  * Return -1 on EOF, error while reading input, or timeout.
  * Return 1 if the user gives the correct password for entry PW,
  * 0 if not.
@@ -105,7 +105,7 @@ int FAST_FUNC ask_and_check_password_ext
 
 	pw_pass = get_passwd(pw, buffer);
 	if (!pw_pass[0]) /* empty password field? */
-		return 1;
+		return CHECKPASS_PW_HAS_EMPTY_PASSWORD;
 
 	plaintext = bb_ask(STDIN_FILENO, timeout, prompt);
 	if (!plaintext) {
diff -urpN busybox-1.26.2/libbb/crc32.c busybox-1.27.0/libbb/crc32.c
--- busybox-1.26.2/libbb/crc32.c	2016-09-27 18:53:50.000000000 +0200
+++ busybox-1.27.0/libbb/crc32.c	2017-02-06 21:57:41.000000000 +0100
@@ -24,7 +24,7 @@ uint32_t* FAST_FUNC crc32_filltable(uint
 {
 	uint32_t polynomial = endian ? 0x04c11db7 : 0xedb88320;
 	uint32_t c;
-	int i, j;
+	unsigned i, j;
 
 	if (!crc_table)
 		crc_table = xmalloc(256 * sizeof(uint32_t));
diff -urpN busybox-1.26.2/libbb/dump.c busybox-1.27.0/libbb/dump.c
--- busybox-1.26.2/libbb/dump.c	2016-09-27 18:53:50.000000000 +0200
+++ busybox-1.27.0/libbb/dump.c	2017-01-30 21:57:30.000000000 +0100
@@ -14,12 +14,12 @@
 #include "libbb.h"
 #include "dump.h"
 
-static const char index_str[] ALIGN1 = ".#-+ 0123456789";
+static const char dot_flags_width_chars[] ALIGN1 = ".#-+ 0123456789";
 
 static const char size_conv_str[] ALIGN1 =
 "\x1\x4\x4\x4\x4\x4\x4\x8\x8\x8\x8\010cdiouxXeEfgG";
 
-static const char lcc[] ALIGN1 = "diouxX";
+static const char int_convs[] ALIGN1 = "diouxX";
 
 
 typedef struct priv_dumper_t {
@@ -71,7 +71,7 @@ static NOINLINE int bb_dump_size(FS *fs)
 			 * skip any special chars -- save precision in
 			 * case it's a %s format.
 			 */
-			while (strchr(index_str + 1, *++fmt))
+			while (strchr(dot_flags_width_chars + 1, *++fmt))
 				continue;
 			if (*fmt == '.' && isdigit(*++fmt)) {
 				prec = atoi(fmt);
@@ -82,14 +82,15 @@ static NOINLINE int bb_dump_size(FS *fs)
 			if (!p) {
 				if (*fmt == 's') {
 					bcnt += prec;
-				} else if (*fmt == '_') {
+				}
+				if (*fmt == '_') {
 					++fmt;
 					if ((*fmt == 'c') || (*fmt == 'p') || (*fmt == 'u')) {
 						bcnt += 1;
 					}
 				}
 			} else {
-				bcnt += size_conv_str[p - (size_conv_str + 12)];
+				bcnt += p[-12];
 			}
 		}
 		cur_size += bcnt * fu->reps;
@@ -99,32 +100,30 @@ static NOINLINE int bb_dump_size(FS *fs)
 
 static NOINLINE void rewrite(priv_dumper_t *dumper, FS *fs)
 {
-	enum { NOTOKAY, USEBCNT, USEPREC } sokay;
 	FU *fu;
-	PR *pr;
-	char *p1, *p2, *p3;
-	char savech, *fmtp;
-	const char *byte_count_str;
-	int nconv, prec = 0;
 
 	for (fu = fs->nextfu; fu; fu = fu->nextfu) {
+		PR *pr;
+		char *p1, *p2, *p3;
+		char *fmtp;
+		int nconv = 0;
 		/*
 		 * break each format unit into print units; each
 		 * conversion character gets its own.
 		 */
-		for (nconv = 0, fmtp = fu->fmt; *fmtp; ) {
-			/* NOSTRICT */
-			/* DBU:[dvae@cray.com] zalloc so that forward ptrs start out NULL*/
-			pr = xzalloc(sizeof(PR));
+		for (fmtp = fu->fmt; *fmtp; ) {
+			unsigned len;
+			const char *prec;
+			const char *byte_count_str;
+
+			/* DBU:[dvae@cray.com] zalloc so that forward ptrs start out NULL */
+			pr = xzalloc(sizeof(*pr));
 			if (!fu->nextpr)
 				fu->nextpr = pr;
 
 			/* skip preceding text and up to the next % sign */
-			for (p1 = fmtp; *p1 && *p1 != '%'; ++p1)
-				continue;
-
-			/* only text in the string */
-			if (!*p1) {
+			p1 = strchr(fmtp, '%');
+			if (!p1) { /* only text in the string */
 				pr->fmt = fmtp;
 				pr->flags = F_TEXT;
 				break;
@@ -134,22 +133,20 @@ static NOINLINE void rewrite(priv_dumper
 			 * get precision for %s -- if have a byte count, don't
 			 * need it.
 			 */
+			prec = NULL;
 			if (fu->bcnt) {
-				sokay = USEBCNT;
 				/* skip to conversion character */
-				for (++p1; strchr(index_str, *p1); ++p1)
+				while (strchr(dot_flags_width_chars, *++p1))
 					continue;
 			} else {
 				/* skip any special chars, field width */
-				while (strchr(index_str + 1, *++p1))
+				while (strchr(dot_flags_width_chars + 1, *++p1))
 					continue;
 				if (*p1 == '.' && isdigit(*++p1)) {
-					sokay = USEPREC;
-					prec = atoi(p1);
+					prec = p1;
 					while (isdigit(*++p1))
 						continue;
-				} else
-					sokay = NOTOKAY;
+				}
 			}
 
 			p2 = p1 + 1; /* set end pointer */
@@ -165,74 +162,72 @@ static NOINLINE void rewrite(priv_dumper
 				byte_count_str = "\001";
  DO_BYTE_COUNT:
 				if (fu->bcnt) {
-					do {
-						if (fu->bcnt == *byte_count_str) {
+					for (;;) {
+						if (fu->bcnt == *byte_count_str)
 							break;
-						}
-					} while (*++byte_count_str);
+						if (*++byte_count_str == 0)
+							bb_error_msg_and_die("bad byte count for conversion character %s", p1);
+					}
 				}
 				/* Unlike the original, output the remainder of the format string. */
-				if (!*byte_count_str) {
-					bb_error_msg_and_die("bad byte count for conversion character %s", p1);
-				}
 				pr->bcnt = *byte_count_str;
-			} else if (*p1 == 'l') {
+			} else
+			if (*p1 == 'l') { /* %ld etc */
+				const char *e;
+
 				++p2;
 				++p1;
  DO_INT_CONV:
-				{
-					const char *e;
-					e = strchr(lcc, *p1);
-					if (!e) {
-						goto DO_BAD_CONV_CHAR;
-					}
-					pr->flags = F_INT;
-					if (e > lcc + 1) {
-						pr->flags = F_UINT;
-					}
-					byte_count_str = "\004\002\001";
-					goto DO_BYTE_COUNT;
-				}
-				/* NOTREACHED */
-			} else if (strchr(lcc, *p1)) {
+				e = strchr(int_convs, *p1); /* "diouxX"? */
+				if (!e)
+					goto DO_BAD_CONV_CHAR;
+				pr->flags = F_INT;
+				if (e > int_convs + 1) /* not d or i? */
+					pr->flags = F_UINT;
+				byte_count_str = "\004\002\001";
+				goto DO_BYTE_COUNT;
+			} else
+			if (strchr(int_convs, *p1)) { /* %d etc */
 				goto DO_INT_CONV;
-			} else if (strchr("eEfgG", *p1)) {
+			} else
+			if (strchr("eEfgG", *p1)) { /* floating point */
 				pr->flags = F_DBL;
 				byte_count_str = "\010\004";
 				goto DO_BYTE_COUNT;
-			} else if (*p1 == 's') {
+			} else
+			if (*p1 == 's') {
 				pr->flags = F_STR;
-				if (sokay == USEBCNT) {
-					pr->bcnt = fu->bcnt;
-				} else if (sokay == USEPREC) {
-					pr->bcnt = prec;
-				} else {   /* NOTOKAY */
-					bb_error_msg_and_die("%%s requires a precision or a byte count");
+				pr->bcnt = fu->bcnt;
+				if (fu->bcnt == 0) {
+					if (!prec)
+						bb_error_msg_and_die("%%s needs precision or byte count");
+					pr->bcnt = atoi(prec);
 				}
-			} else if (*p1 == '_') {
-				++p2;
+			} else
+			if (*p1 == '_') {
+				p2++;  /* move past a in "%_a" */
 				switch (p1[1]) {
-				case 'A':
+				case 'A':	/* %_A[dox]: print address and the end */
 					dumper->endfu = fu;
 					fu->flags |= F_IGNORE;
 					/* FALLTHROUGH */
-				case 'a':
+				case 'a':	/* %_a[dox]: current address */
 					pr->flags = F_ADDRESS;
-					++p2;
+					p2++;  /* move past x in "%_ax" */
 					if ((p1[2] != 'd') && (p1[2] != 'o') && (p1[2] != 'x')) {
 						goto DO_BAD_CONV_CHAR;
 					}
 					*p1 = p1[2];
 					break;
-				case 'c':
+				case 'c':	/* %_c: chars, \ooo, \n \r \t etc */
 					pr->flags = F_C;
 					/* *p1 = 'c';   set in conv_c */
 					goto DO_BYTE_COUNT_1;
-				case 'p':
+				case 'p':	/* %_p: chars, dots for nonprintable */
 					pr->flags = F_P;
 					*p1 = 'c';
 					goto DO_BYTE_COUNT_1;
-				case 'u':
+				case 'u':	/* %_p: chars, 'nul', 'esc' etc for nonprintable */
 					pr->flags = F_U;
 					/* *p1 = 'c';   set in conv_u */
 					goto DO_BYTE_COUNT_1;
@@ -248,13 +243,8 @@ static NOINLINE void rewrite(priv_dumper
 			 * copy to PR format string, set conversion character
 			 * pointer, update original.
 			 */
-			savech = *p2;
-			p1[1] = '\0';
-			pr->fmt = xstrdup(fmtp);
-			*p2 = savech;
-			//Too early! xrealloc can move pr->fmt!
-			//pr->cchar = pr->fmt + (p1 - fmtp);
-
+			len = (p1 - fmtp) + 1;
+			pr->fmt = xstrndup(fmtp, len);
 			/* DBU:[dave@cray.com] w/o this, trailing fmt text, space is lost.
 			 * Skip subsequent text and up to the next % sign and tack the
 			 * additional text onto fmt: eg. if fmt is "%x is a HEX number",
@@ -262,16 +252,17 @@ static NOINLINE void rewrite(priv_dumper
 			 */
 			for (p3 = p2; *p3 && *p3 != '%'; p3++)
 				continue;
-			if (p3 > p2) {
-				savech = *p3;
-				*p3 = '\0';
-				pr->fmt = xrealloc(pr->fmt, strlen(pr->fmt) + (p3-p2) + 1);
-				strcat(pr->fmt, p2);
-				*p3 = savech;
-				p2 = p3;
+			if ((p3 - p2) != 0) {
+				char *d;
+				pr->fmt = d = xrealloc(pr->fmt, len + (p3 - p2) + 1);
+				d += len;
+				do {
+					*d++ = *p2++;
+				} while (p2 != p3);
+				*d = '\0';
+				/* now p2 = p3 */
 			}
-
-			pr->cchar = pr->fmt + (p1 - fmtp);
+			pr->cchar = pr->fmt + len - 1; /* must be after realloc! */
 			fmtp = p2;
 
 			/* only one conversion character if byte count */
@@ -283,7 +274,7 @@ static NOINLINE void rewrite(priv_dumper
 		 * if format unit byte count not specified, figure it out
 		 * so can adjust rep count later.
 		 */
-		if (!fu->bcnt)
+		if (fu->bcnt == 0)
 			for (pr = fu->nextpr; pr; pr = pr->nextpr)
 				fu->bcnt += pr->bcnt;
 	}
@@ -305,16 +296,18 @@ static NOINLINE void rewrite(priv_dumper
 			fu->reps += (dumper->blocksize - fs->bcnt) / fu->bcnt;
 		}
 		if (fu->reps > 1 && fu->nextpr) {
+			PR *pr;
+			char *p1, *p2;
+
 			for (pr = fu->nextpr;; pr = pr->nextpr)
 				if (!pr->nextpr)
 					break;
-			for (p1 = pr->fmt, p2 = NULL; *p1; ++p1)
+			p2 = NULL;
+			for (p1 = pr->fmt; *p1; ++p1)
 				p2 = isspace(*p1) ? p1 : NULL;
 			if (p2)
 				pr->nospace = p2;
 		}
-		if (!fu->nextfu)
-			break;
 	}
 }
 
@@ -358,6 +351,7 @@ static NOINLINE int next(priv_dumper_t *
 			if (dumper->next__done)
 				return 0; /* no next file */
 			dumper->next__done = 1;
+//why stat of stdin is specially prohibited?
 			statok = 0;
 		}
 		if (dumper->pub.dump_skip)
@@ -762,6 +756,11 @@ void FAST_FUNC bb_dump_add(dumper_t* pub
 			if (!isspace(*p)) {
 				bb_error_msg_and_die("bad format {%s}", fmt);
 			}
+// Above check prohibits formats such as '/1"%02x"' - it requires space after 1.
+// Other than this, formats can be pretty much jammed together:
+// "%07_ax:"8/2 "%04x|""\n"
+// but this space is required. The check *can* be removed, but
+// keeping it to stay compat with util-linux hexdump.
 			tfu->bcnt = atoi(savep);
 			/* skip trailing white space */
 			p = skip_whitespace(p + 1);
diff -urpN busybox-1.26.2/libbb/getopt32.c busybox-1.27.0/libbb/getopt32.c
--- busybox-1.26.2/libbb/getopt32.c	2016-09-27 18:53:50.000000000 +0200
+++ busybox-1.27.0/libbb/getopt32.c	2017-07-01 22:51:12.000000000 +0200
@@ -128,7 +128,7 @@ const char *opt_complementary
  "abc"  If groups of two or more chars are specified, the first char
         is the main option and the other chars are secondary options.
         Their flags will be turned on if the main option is found even
-        if they are not specifed on the command line.  For example:
+        if they are not specified on the command line.  For example:
 
         opt_complementary = "abc";
         flags = getopt32(argv, "abcd")
@@ -404,7 +404,7 @@ getopt32(char **argv, const char *applet
 		if (c >= 32)
 			break;
 		on_off->opt_char = *s;
-		on_off->switch_on = (1 << c);
+		on_off->switch_on = (1U << c);
 		if (*++s == ':') {
 			on_off->optarg = va_arg(p, void **);
 			if (s[1] == '+' || s[1] == '*') {
@@ -454,7 +454,7 @@ getopt32(char **argv, const char *applet
 			if (c >= 32)
 				break;
 			on_off->opt_char = l_o->val;
-			on_off->switch_on = (1 << c);
+			on_off->switch_on = (1U << c);
 			if (l_o->has_arg != no_argument)
 				on_off->optarg = va_arg(p, void **);
 			c++;
@@ -576,13 +576,7 @@ getopt32(char **argv, const char *applet
 	 * run_nofork_applet() does this, but we might end up here
 	 * also via gunzip_main() -> gzip_main(). Play safe.
 	 */
-#ifdef __GLIBC__
-	optind = 0;
-#else /* BSD style */
-	optind = 1;
-	/* optreset = 1; */
-#endif
-	/* optarg = NULL; opterr = 0; optopt = 0; - do we need this?? */
+	GETOPT_RESET();
 
 	/* Note: just "getopt() <= 0" will not work well for
 	 * "fake" short options, like this one:
diff -urpN busybox-1.26.2/libbb/hash_md5_sha.c busybox-1.27.0/libbb/hash_md5_sha.c
--- busybox-1.26.2/libbb/hash_md5_sha.c	2016-09-27 18:53:50.000000000 +0200
+++ busybox-1.27.0/libbb/hash_md5_sha.c	2017-01-24 18:44:48.000000000 +0100
@@ -9,6 +9,8 @@
 
 #include "libbb.h"
 
+#define NEED_SHA512 (ENABLE_SHA512SUM || ENABLE_USE_BB_CRYPT_SHA)
+
 /* gcc 4.2.1 optimizes rotr64 better with inline than with macro
  * (for rotX32, there is no difference). Why? My guess is that
  * macro requires clever common subexpression elimination heuristics
@@ -456,7 +458,7 @@ void FAST_FUNC md5_hash(md5_ctx_t *ctx,
  * endian byte order, so that a byte-wise output yields to the wanted
  * ASCII representation of the message digest.
  */
-void FAST_FUNC md5_end(md5_ctx_t *ctx, void *resbuf)
+unsigned FAST_FUNC md5_end(md5_ctx_t *ctx, void *resbuf)
 {
 	/* MD5 stores total in LE, need to swap on BE arches: */
 	common64_end(ctx, /*swap_needed:*/ BB_BIG_ENDIAN);
@@ -470,6 +472,7 @@ void FAST_FUNC md5_end(md5_ctx_t *ctx, v
 	}
 
 	memcpy(resbuf, ctx->hash, sizeof(ctx->hash[0]) * 4);
+	return sizeof(ctx->hash[0]) * 4;
 }
 
 
@@ -564,48 +567,59 @@ static void FAST_FUNC sha1_process_block
  * are the most significant half of first 64 elements
  * of the same array.
  */
-static const uint64_t sha_K[80] = {
-	0x428a2f98d728ae22ULL, 0x7137449123ef65cdULL,
-	0xb5c0fbcfec4d3b2fULL, 0xe9b5dba58189dbbcULL,
-	0x3956c25bf348b538ULL, 0x59f111f1b605d019ULL,
-	0x923f82a4af194f9bULL, 0xab1c5ed5da6d8118ULL,
-	0xd807aa98a3030242ULL, 0x12835b0145706fbeULL,
-	0x243185be4ee4b28cULL, 0x550c7dc3d5ffb4e2ULL,
-	0x72be5d74f27b896fULL, 0x80deb1fe3b1696b1ULL,
-	0x9bdc06a725c71235ULL, 0xc19bf174cf692694ULL,
-	0xe49b69c19ef14ad2ULL, 0xefbe4786384f25e3ULL,
-	0x0fc19dc68b8cd5b5ULL, 0x240ca1cc77ac9c65ULL,
-	0x2de92c6f592b0275ULL, 0x4a7484aa6ea6e483ULL,
-	0x5cb0a9dcbd41fbd4ULL, 0x76f988da831153b5ULL,
-	0x983e5152ee66dfabULL, 0xa831c66d2db43210ULL,
-	0xb00327c898fb213fULL, 0xbf597fc7beef0ee4ULL,
-	0xc6e00bf33da88fc2ULL, 0xd5a79147930aa725ULL,
-	0x06ca6351e003826fULL, 0x142929670a0e6e70ULL,
-	0x27b70a8546d22ffcULL, 0x2e1b21385c26c926ULL,
-	0x4d2c6dfc5ac42aedULL, 0x53380d139d95b3dfULL,
-	0x650a73548baf63deULL, 0x766a0abb3c77b2a8ULL,
-	0x81c2c92e47edaee6ULL, 0x92722c851482353bULL,
-	0xa2bfe8a14cf10364ULL, 0xa81a664bbc423001ULL,
-	0xc24b8b70d0f89791ULL, 0xc76c51a30654be30ULL,
-	0xd192e819d6ef5218ULL, 0xd69906245565a910ULL,
-	0xf40e35855771202aULL, 0x106aa07032bbd1b8ULL,
-	0x19a4c116b8d2d0c8ULL, 0x1e376c085141ab53ULL,
-	0x2748774cdf8eeb99ULL, 0x34b0bcb5e19b48a8ULL,
-	0x391c0cb3c5c95a63ULL, 0x4ed8aa4ae3418acbULL,
-	0x5b9cca4f7763e373ULL, 0x682e6ff3d6b2b8a3ULL,
-	0x748f82ee5defb2fcULL, 0x78a5636f43172f60ULL,
-	0x84c87814a1f0ab72ULL, 0x8cc702081a6439ecULL,
-	0x90befffa23631e28ULL, 0xa4506cebde82bde9ULL,
-	0xbef9a3f7b2c67915ULL, 0xc67178f2e372532bULL,
-	0xca273eceea26619cULL, 0xd186b8c721c0c207ULL, /* [64]+ are used for sha512 only */
-	0xeada7dd6cde0eb1eULL, 0xf57d4f7fee6ed178ULL,
-	0x06f067aa72176fbaULL, 0x0a637dc5a2c898a6ULL,
-	0x113f9804bef90daeULL, 0x1b710b35131c471bULL,
-	0x28db77f523047d84ULL, 0x32caab7b40c72493ULL,
-	0x3c9ebe0a15c9bebcULL, 0x431d67c49c100d4cULL,
-	0x4cc5d4becb3e42b6ULL, 0x597f299cfc657e2aULL,
-	0x5fcb6fab3ad6faecULL, 0x6c44198c4a475817ULL
+#undef K
+#if NEED_SHA512
+typedef uint64_t sha_K_int;
+# define K(v) v
+#else
+typedef uint32_t sha_K_int;
+# define K(v) (uint32_t)(v >> 32)
+#endif
+static const sha_K_int sha_K[] = {
+	K(0x428a2f98d728ae22ULL), K(0x7137449123ef65cdULL),
+	K(0xb5c0fbcfec4d3b2fULL), K(0xe9b5dba58189dbbcULL),
+	K(0x3956c25bf348b538ULL), K(0x59f111f1b605d019ULL),
+	K(0x923f82a4af194f9bULL), K(0xab1c5ed5da6d8118ULL),
+	K(0xd807aa98a3030242ULL), K(0x12835b0145706fbeULL),
+	K(0x243185be4ee4b28cULL), K(0x550c7dc3d5ffb4e2ULL),
+	K(0x72be5d74f27b896fULL), K(0x80deb1fe3b1696b1ULL),
+	K(0x9bdc06a725c71235ULL), K(0xc19bf174cf692694ULL),
+	K(0xe49b69c19ef14ad2ULL), K(0xefbe4786384f25e3ULL),
+	K(0x0fc19dc68b8cd5b5ULL), K(0x240ca1cc77ac9c65ULL),
+	K(0x2de92c6f592b0275ULL), K(0x4a7484aa6ea6e483ULL),
+	K(0x5cb0a9dcbd41fbd4ULL), K(0x76f988da831153b5ULL),
+	K(0x983e5152ee66dfabULL), K(0xa831c66d2db43210ULL),
+	K(0xb00327c898fb213fULL), K(0xbf597fc7beef0ee4ULL),
+	K(0xc6e00bf33da88fc2ULL), K(0xd5a79147930aa725ULL),
+	K(0x06ca6351e003826fULL), K(0x142929670a0e6e70ULL),
+	K(0x27b70a8546d22ffcULL), K(0x2e1b21385c26c926ULL),
+	K(0x4d2c6dfc5ac42aedULL), K(0x53380d139d95b3dfULL),
+	K(0x650a73548baf63deULL), K(0x766a0abb3c77b2a8ULL),
+	K(0x81c2c92e47edaee6ULL), K(0x92722c851482353bULL),
+	K(0xa2bfe8a14cf10364ULL), K(0xa81a664bbc423001ULL),
+	K(0xc24b8b70d0f89791ULL), K(0xc76c51a30654be30ULL),
+	K(0xd192e819d6ef5218ULL), K(0xd69906245565a910ULL),
+	K(0xf40e35855771202aULL), K(0x106aa07032bbd1b8ULL),
+	K(0x19a4c116b8d2d0c8ULL), K(0x1e376c085141ab53ULL),
+	K(0x2748774cdf8eeb99ULL), K(0x34b0bcb5e19b48a8ULL),
+	K(0x391c0cb3c5c95a63ULL), K(0x4ed8aa4ae3418acbULL),
+	K(0x5b9cca4f7763e373ULL), K(0x682e6ff3d6b2b8a3ULL),
+	K(0x748f82ee5defb2fcULL), K(0x78a5636f43172f60ULL),
+	K(0x84c87814a1f0ab72ULL), K(0x8cc702081a6439ecULL),
+	K(0x90befffa23631e28ULL), K(0xa4506cebde82bde9ULL),
+	K(0xbef9a3f7b2c67915ULL), K(0xc67178f2e372532bULL),
+#if NEED_SHA512  /* [64]+ are used for sha512 only */
+	K(0xca273eceea26619cULL), K(0xd186b8c721c0c207ULL),
+	K(0xeada7dd6cde0eb1eULL), K(0xf57d4f7fee6ed178ULL),
+	K(0x06f067aa72176fbaULL), K(0x0a637dc5a2c898a6ULL),
+	K(0x113f9804bef90daeULL), K(0x1b710b35131c471bULL),
+	K(0x28db77f523047d84ULL), K(0x32caab7b40c72493ULL),
+	K(0x3c9ebe0a15c9bebcULL), K(0x431d67c49c100d4cULL),
+	K(0x4cc5d4becb3e42b6ULL), K(0x597f299cfc657e2aULL),
+	K(0x5fcb6fab3ad6faecULL), K(0x6c44198c4a475817ULL),
+#endif
 };
+#undef K
 
 #undef Ch
 #undef Maj
@@ -649,7 +663,7 @@ static void FAST_FUNC sha256_process_blo
 		 * (I hope compiler is clever enough to just fetch
 		 * upper half)
 		 */
-		uint32_t K_t = sha_K[t] >> 32;
+		uint32_t K_t = NEED_SHA512 ? (sha_K[t] >> 32) : sha_K[t];
 		uint32_t T1 = h + S1(e) + Ch(e, f, g) + K_t + W[t];
 		uint32_t T2 = S0(a) + Maj(a, b, c);
 		h = g;
@@ -679,6 +693,7 @@ static void FAST_FUNC sha256_process_blo
 	ctx->hash[7] += h;
 }
 
+#if NEED_SHA512
 static void FAST_FUNC sha512_process_block128(sha512_ctx_t *ctx)
 {
 	unsigned t;
@@ -740,7 +755,7 @@ static void FAST_FUNC sha512_process_blo
 	ctx->hash[6] += g;
 	ctx->hash[7] += h;
 }
-
+#endif /* NEED_SHA512 */
 
 void FAST_FUNC sha1_begin(sha1_ctx_t *ctx)
 {
@@ -765,6 +780,7 @@ static const uint32_t init256[] = {
 	0x1f83d9ab,
 	0x5be0cd19,
 };
+#if NEED_SHA512
 static const uint32_t init512_lo[] = {
 	0,
 	0,
@@ -777,6 +793,7 @@ static const uint32_t init512_lo[] = {
 	0xfb41bd6b,
 	0x137e2179,
 };
+#endif /* NEED_SHA512 */
 
 /* Initialize structure containing state of computation.
    (FIPS 180-2:5.3.2)  */
@@ -787,6 +804,7 @@ void FAST_FUNC sha256_begin(sha256_ctx_t
 	ctx->process_block = sha256_process_block64;
 }
 
+#if NEED_SHA512
 /* Initialize structure containing state of computation.
    (FIPS 180-2:5.3.3)  */
 void FAST_FUNC sha512_begin(sha512_ctx_t *ctx)
@@ -810,7 +828,7 @@ void FAST_FUNC sha512_hash(sha512_ctx_t
 	ctx->total64[0] += len;
 	if (ctx->total64[0] < len)
 		ctx->total64[1]++;
-#if 0
+# if 0
 	remaining = 128 - bufpos;
 
 	/* Hash whole blocks */
@@ -825,7 +843,7 @@ void FAST_FUNC sha512_hash(sha512_ctx_t
 
 	/* Save last, partial blosk */
 	memcpy(ctx->wbuffer + bufpos, buffer, len);
-#else
+# else
 	while (1) {
 		remaining = 128 - bufpos;
 		if (remaining > len)
@@ -843,11 +861,12 @@ void FAST_FUNC sha512_hash(sha512_ctx_t
 		sha512_process_block128(ctx);
 		/*bufpos = 0; - already is */
 	}
-#endif
+# endif
 }
+#endif /* NEED_SHA512 */
 
 /* Used also for sha256 */
-void FAST_FUNC sha1_end(sha1_ctx_t *ctx, void *resbuf)
+unsigned FAST_FUNC sha1_end(sha1_ctx_t *ctx, void *resbuf)
 {
 	unsigned hash_size;
 
@@ -861,10 +880,13 @@ void FAST_FUNC sha1_end(sha1_ctx_t *ctx,
 		for (i = 0; i < hash_size; ++i)
 			ctx->hash[i] = SWAP_BE32(ctx->hash[i]);
 	}
-	memcpy(resbuf, ctx->hash, sizeof(ctx->hash[0]) * hash_size);
+	hash_size *= sizeof(ctx->hash[0]);
+	memcpy(resbuf, ctx->hash, hash_size);
+	return hash_size;
 }
 
-void FAST_FUNC sha512_end(sha512_ctx_t *ctx, void *resbuf)
+#if NEED_SHA512
+unsigned FAST_FUNC sha512_end(sha512_ctx_t *ctx, void *resbuf)
 {
 	unsigned bufpos = ctx->total64[0] & 127;
 
@@ -896,7 +918,9 @@ void FAST_FUNC sha512_end(sha512_ctx_t *
 			ctx->hash[i] = SWAP_BE64(ctx->hash[i]);
 	}
 	memcpy(resbuf, ctx->hash, sizeof(ctx->hash));
+	return sizeof(ctx->hash);
 }
+#endif /* NEED_SHA512 */
 
 
 /*
@@ -1430,7 +1454,7 @@ void FAST_FUNC sha3_hash(sha3_ctx_t *ctx
 #endif
 }
 
-void FAST_FUNC sha3_end(sha3_ctx_t *ctx, void *resbuf)
+unsigned FAST_FUNC sha3_end(sha3_ctx_t *ctx, void *resbuf)
 {
 	/* Padding */
 	uint8_t *buf = (uint8_t*)ctx->state;
@@ -1455,4 +1479,5 @@ void FAST_FUNC sha3_end(sha3_ctx_t *ctx,
 
 	/* Output */
 	memcpy(resbuf, ctx->state, 64);
+	return 64;
 }
diff -urpN busybox-1.26.2/libbb/hash_md5prime.c busybox-1.27.0/libbb/hash_md5prime.c
--- busybox-1.26.2/libbb/hash_md5prime.c	2016-09-27 18:53:50.000000000 +0200
+++ busybox-1.27.0/libbb/hash_md5prime.c	2017-01-24 18:44:48.000000000 +0100
@@ -437,7 +437,7 @@ void FAST_FUNC md5_hash(const void *buff
  * MD5 finalization. Ends an MD5 message-digest operation,
  * writing the message digest.
  */
-void FAST_FUNC md5_end(void *digest, md5_ctx_t *context)
+unsigned FAST_FUNC md5_end(void *digest, md5_ctx_t *context)
 {
 	unsigned idx, padLen;
 	unsigned char bits[8];
@@ -457,4 +457,5 @@ void FAST_FUNC md5_end(void *digest, md5
 
 	/* Store state in digest */
 	memcpy32_cpu2le(digest, context->state, 16);
+	return 16;
 }
diff -urpN busybox-1.26.2/libbb/isqrt.c busybox-1.27.0/libbb/isqrt.c
--- busybox-1.26.2/libbb/isqrt.c	1970-01-01 01:00:00.000000000 +0100
+++ busybox-1.27.0/libbb/isqrt.c	2017-07-01 22:51:12.000000000 +0200
@@ -0,0 +1,60 @@
+/*
+ * Copyright (C) 2017 Denys Vlasenko <vda.linux@googlemail.com>
+ *
+ * Licensed under GPLv2, see file LICENSE in this source tree.
+ */
+
+//kbuild:lib-y += isqrt.o
+
+#ifndef ISQRT_TEST
+# include "libbb.h"
+#else
+/* gcc -DISQRT_TEST -Wall -O2 isqrt.c -oisqrt && ./isqrt $((RANDOM*RANDOM)) */
+# include <stdlib.h>
+# include <stdio.h>
+# include <time.h>
+# define FAST_FUNC /* nothing */
+#endif
+
+/* Returns such x that x+1 > sqrt(N) */
+unsigned long FAST_FUNC isqrt(unsigned long long N)
+{
+	unsigned long x;
+	unsigned shift;
+#define LL_WIDTH_BITS (unsigned)(sizeof(N)*8)
+
+	shift = LL_WIDTH_BITS - 2;
+	x = 0;
+	do {
+		x = (x << 1) + 1;
+		if ((unsigned long long)x * x > (N >> shift))
+			x--; /* whoops, that +1 was too much */
+		shift -= 2;
+	} while ((int)shift >= 0);
+	return x;
+}
+
+#ifdef ISQRT_TEST
+int main(int argc, char **argv)
+{
+	unsigned long long n = argv[1] ? strtoull(argv[1], NULL, 0) : time(NULL);
+	for (;;) {
+		unsigned long h;
+		n--;
+		h = isqrt(n);
+		if (!(n & 0xffff))
+			printf("isqrt(%llx)=%lx\n", n, h);
+		if ((unsigned long long)h * h > n) {
+			printf("BAD1: isqrt(%llx)=%lx\n", n, h);
+			return 1;
+		}
+		h++;
+		if ((unsigned long long)h * h != 0 /* this can overflow to 0 - not a bug */
+		 && (unsigned long long)h * h <= n)
+		{
+			printf("BAD2: isqrt(%llx)=%lx\n", n, h);
+			return 1;
+		}
+	}
+}
+#endif
diff -urpN busybox-1.26.2/libbb/lineedit.c busybox-1.27.0/libbb/lineedit.c
--- busybox-1.26.2/libbb/lineedit.c	2016-12-10 18:46:36.000000000 +0100
+++ busybox-1.27.0/libbb/lineedit.c	2017-01-15 00:18:53.000000000 +0100
@@ -2325,7 +2325,7 @@ int FAST_FUNC read_line_input(line_input
 	/* ~ECHO, ~ECHONL: turn off echoing, including newline echoing */
 	/* ~ISIG: turn off INTR (ctrl-C), QUIT, SUSP */
 	new_settings.c_lflag &= ~(ICANON | ECHO | ECHONL | ISIG);
-	/* reads would block only if < 1 char is available */
+	/* reads will block only if < 1 char is available */
 	new_settings.c_cc[VMIN] = 1;
 	/* no timeout (reads block forever) */
 	new_settings.c_cc[VTIME] = 0;
diff -urpN busybox-1.26.2/libbb/loop.c busybox-1.27.0/libbb/loop.c
--- busybox-1.26.2/libbb/loop.c	2016-09-27 18:53:50.000000000 +0200
+++ busybox-1.27.0/libbb/loop.c	2017-04-05 18:27:36.000000000 +0200
@@ -78,22 +78,24 @@ int FAST_FUNC del_loop(const char *devic
 	return rc;
 }
 
-/* Returns 0 if mounted RW, 1 if mounted read-only, <0 for error.
-   *device is loop device to use, or if *device==NULL finds a loop device to
-   mount it on and sets *device to a strdup of that loop device name.  This
-   search will re-use an existing loop device already bound to that
-   file/offset if it finds one.
+/* Returns opened fd to the loop device, <0 on error.
+ * *device is loop device to use, or if *device==NULL finds a loop device to
+ * mount it on and sets *device to a strdup of that loop device name.  This
+ * search will re-use an existing loop device already bound to that
+ * file/offset if it finds one.
  */
-int FAST_FUNC set_loop(char **device, const char *file, unsigned long long offset, int ro)
+int FAST_FUNC set_loop(char **device, const char *file, unsigned long long offset, unsigned flags)
 {
 	char dev[LOOP_NAMESIZE];
 	char *try;
 	bb_loop_info loopinfo;
 	struct stat statbuf;
-	int i, dfd, ffd, mode, rc = -1;
+	int i, dfd, ffd, mode, rc;
+
+	rc = dfd = -1;
 
 	/* Open the file.  Barf if this doesn't work.  */
-	mode = ro ? O_RDONLY : O_RDWR;
+	mode = (flags & BB_LO_FLAGS_READ_ONLY) ? O_RDONLY : O_RDWR;
  open_ffd:
 	ffd = open(file, mode);
 	if (ffd < 0) {
@@ -144,20 +146,35 @@ int FAST_FUNC set_loop(char **device, co
 
 		/* If device is free, claim it.  */
 		if (rc && errno == ENXIO) {
-			memset(&loopinfo, 0, sizeof(loopinfo));
-			safe_strncpy((char *)loopinfo.lo_file_name, file, LO_NAME_SIZE);
-			loopinfo.lo_offset = offset;
 			/* Associate free loop device with file.  */
 			if (ioctl(dfd, LOOP_SET_FD, ffd) == 0) {
-				if (ioctl(dfd, BB_LOOP_SET_STATUS, &loopinfo) == 0)
-					rc = 0;
-				else
+				memset(&loopinfo, 0, sizeof(loopinfo));
+				safe_strncpy((char *)loopinfo.lo_file_name, file, LO_NAME_SIZE);
+				loopinfo.lo_offset = offset;
+				/*
+				 * Used by mount to set LO_FLAGS_AUTOCLEAR.
+				 * LO_FLAGS_READ_ONLY is not set because RO is controlled by open type of the file.
+				 * Note that closing LO_FLAGS_AUTOCLEARed dfd before mount
+				 * is wrong (would free the loop device!)
+				 */
+				loopinfo.lo_flags = (flags & ~BB_LO_FLAGS_READ_ONLY);
+				rc = ioctl(dfd, BB_LOOP_SET_STATUS, &loopinfo);
+				if (rc != 0 && (loopinfo.lo_flags & BB_LO_FLAGS_AUTOCLEAR)) {
+					/* Old kernel, does not support LO_FLAGS_AUTOCLEAR? */
+					/* (this code path is not tested) */
+					loopinfo.lo_flags -= BB_LO_FLAGS_AUTOCLEAR;
+					rc = ioctl(dfd, BB_LOOP_SET_STATUS, &loopinfo);
+				}
+				if (rc != 0) {
 					ioctl(dfd, LOOP_CLR_FD, 0);
+				}
 			}
 		} else {
 			rc = -1;
 		}
-		close(dfd);
+		if (rc != 0) {
+			close(dfd);
+		}
  try_again:
 		if (*device) break;
 	}
@@ -165,7 +182,7 @@ int FAST_FUNC set_loop(char **device, co
 	if (rc == 0) {
 		if (!*device)
 			*device = xstrdup(dev);
-		return (mode == O_RDONLY); /* 1:ro, 0:rw */
+		return dfd;
 	}
 	return rc;
 }
diff -urpN busybox-1.26.2/libbb/match_fstype.c busybox-1.27.0/libbb/match_fstype.c
--- busybox-1.26.2/libbb/match_fstype.c	2016-09-27 18:53:50.000000000 +0200
+++ busybox-1.27.0/libbb/match_fstype.c	2017-01-30 21:57:30.000000000 +0100
@@ -12,34 +12,30 @@
 
 #include "libbb.h"
 
-#ifdef HAVE_MNTENT_H
-
-int FAST_FUNC match_fstype(const struct mntent *mt, const char *t_fstype)
+int FAST_FUNC fstype_matches(const char *fstype, const char *comma_list)
 {
 	int match = 1;
 
-	if (!t_fstype)
+	if (!comma_list)
 		return match;
 
-	if (t_fstype[0] == 'n' && t_fstype[1] == 'o') {
+	if (comma_list[0] == 'n' && comma_list[1] == 'o') {
 		match--;
-		t_fstype += 2;
+		comma_list += 2;
 	}
 
 	while (1) {
-		char *after_mnt_type = is_prefixed_with(t_fstype, mt->mnt_type);
+		char *after_mnt_type = is_prefixed_with(comma_list, fstype);
 		if (after_mnt_type
 		 && (*after_mnt_type == '\0' || *after_mnt_type == ',')
 		) {
 			return match;
 		}
-		t_fstype = strchr(t_fstype, ',');
-		if (!t_fstype)
+		comma_list = strchr(comma_list, ',');
+		if (!comma_list)
 			break;
-		t_fstype++;
+		comma_list++;
 	}
 
 	return !match;
 }
-
-#endif /* HAVE_MNTENT_H */
diff -urpN busybox-1.26.2/libbb/print_numbered_lines.c busybox-1.27.0/libbb/print_numbered_lines.c
--- busybox-1.26.2/libbb/print_numbered_lines.c	1970-01-01 01:00:00.000000000 +0100
+++ busybox-1.27.0/libbb/print_numbered_lines.c	2017-07-01 22:51:12.000000000 +0200
@@ -0,0 +1,29 @@
+/* vi: set sw=4 ts=4: */
+/*
+ * Copyright (C) 2017 Denys Vlasenko <vda.linux@googlemail.com>
+ *
+ * Licensed under GPLv2, see file LICENSE in this source tree.
+ */
+//kbuild:lib-y += print_numbered_lines.o
+
+#include "libbb.h"
+
+void FAST_FUNC print_numbered_lines(struct number_state *ns, const char *filename)
+{
+	FILE *fp = fopen_or_warn_stdin(filename);
+	unsigned N = ns->start;
+	char *line;
+
+	while ((line = xmalloc_fgetline(fp)) != NULL) {
+		if (ns->all
+		 || (ns->nonempty && line[0])
+		) {
+			printf("%*u%s%s\n", ns->width, N, ns->sep, line);
+			N += ns->inc;
+		} else if (ns->empty_str)
+			fputs(ns->empty_str, stdout);
+		free(line);
+	}
+
+	fclose(fp);
+}
diff -urpN busybox-1.26.2/libbb/procps.c busybox-1.27.0/libbb/procps.c
--- busybox-1.26.2/libbb/procps.c	2016-09-27 18:53:50.000000000 +0200
+++ busybox-1.27.0/libbb/procps.c	2017-02-04 20:10:03.000000000 +0100
@@ -370,6 +370,7 @@ procps_status_t* FAST_FUNC procps_scan(p
 			| PSSCAN_TTY | PSSCAN_NICE
 			| PSSCAN_CPU)
 		) {
+			int s_idx;
 			char *cp, *comm1;
 			int tty;
 #if !ENABLE_FEATURE_FAST_TOP
@@ -468,17 +469,20 @@ procps_status_t* FAST_FUNC procps_scan(p
 #if ENABLE_FEATURE_PS_ADDITIONAL_COLUMNS
 			sp->niceness = tasknice;
 #endif
-
-			if (sp->vsz == 0 && sp->state[0] != 'Z')
+			sp->state[1] = ' ';
+			sp->state[2] = ' ';
+			s_idx = 1;
+			if (sp->vsz == 0 && sp->state[0] != 'Z') {
+				/* not sure what the purpose of this flag */
 				sp->state[1] = 'W';
-			else
-				sp->state[1] = ' ';
-			if (tasknice < 0)
-				sp->state[2] = '<';
-			else if (tasknice) /* > 0 */
-				sp->state[2] = 'N';
-			else
-				sp->state[2] = ' ';
+				s_idx = 2;
+			}
+			if (tasknice != 0) {
+				if (tasknice < 0)
+					sp->state[s_idx] = '<';
+				else /* > 0 */
+					sp->state[s_idx] = 'N';
+			}
 		}
 
 #if ENABLE_FEATURE_TOPMEM
diff -urpN busybox-1.26.2/libbb/pw_encrypt.c busybox-1.27.0/libbb/pw_encrypt.c
--- busybox-1.26.2/libbb/pw_encrypt.c	2016-09-27 18:53:50.000000000 +0200
+++ busybox-1.27.0/libbb/pw_encrypt.c	2017-02-06 21:57:41.000000000 +0100
@@ -30,7 +30,7 @@ static int i64c(int i)
 int FAST_FUNC crypt_make_salt(char *p, int cnt /*, int x */)
 {
 	/* was: x += ... */
-	int x = getpid() + monotonic_us();
+	unsigned x = getpid() + monotonic_us();
 	do {
 		/* x = (x*1664525 + 1013904223) % 2^32 generator is lame
 		 * (low-order bit is not "random", etc...),
diff -urpN busybox-1.26.2/libbb/pw_encrypt_sha.c busybox-1.27.0/libbb/pw_encrypt_sha.c
--- busybox-1.26.2/libbb/pw_encrypt_sha.c	2016-09-27 18:53:50.000000000 +0200
+++ busybox-1.27.0/libbb/pw_encrypt_sha.c	2017-01-24 18:44:48.000000000 +0100
@@ -18,9 +18,10 @@ static char *
 NOINLINE
 sha_crypt(/*const*/ char *key_data, /*const*/ char *salt_data)
 {
+#undef sha_end
 	void (*sha_begin)(void *ctx) FAST_FUNC;
 	void (*sha_hash)(void *ctx, const void *buffer, size_t len) FAST_FUNC;
-	void (*sha_end)(void *ctx, void *resbuf) FAST_FUNC;
+	unsigned (*sha_end)(void *ctx, void *resbuf) FAST_FUNC;
 	int _32or64;
 
 	char *result, *resptr;
@@ -47,16 +48,17 @@ sha_crypt(/*const*/ char *key_data, /*co
 	unsigned cnt;
 	unsigned rounds;
 	char *cp;
-	char is_sha512;
 
 	/* Analyze salt, construct already known part of result */
 	cnt = strlen(salt_data) + 1 + 43 + 1;
-	is_sha512 = salt_data[1];
-	if (is_sha512 == '6')
+	_32or64 = 32;
+	if (salt_data[1] == '6') { /* sha512 */
+		_32or64 *= 2; /*64*/
 		cnt += 43;
+	}
 	result = resptr = xzalloc(cnt); /* will provide NUL terminator */
 	*resptr++ = '$';
-	*resptr++ = is_sha512;
+	*resptr++ = salt_data[1];
 	*resptr++ = '$';
 	rounds = ROUNDS_DEFAULT;
 	salt_data += 3;
@@ -93,12 +95,10 @@ sha_crypt(/*const*/ char *key_data, /*co
 	sha_begin = (void*)sha256_begin;
 	sha_hash = (void*)sha256_hash;
 	sha_end = (void*)sha256_end;
-	_32or64 = 32;
-	if (is_sha512 == '6') {
+	if (_32or64 != 32) {
 		sha_begin = (void*)sha512_begin;
 		sha_hash = (void*)sha512_hash;
 		sha_end = (void*)sha512_end;
-		_32or64 = 64;
 	}
 
 	/* Add KEY, SALT.  */
@@ -200,7 +200,7 @@ do { \
 	unsigned w = ((B2) << 16) | ((B1) << 8) | (B0); \
 	resptr = to64(resptr, w, N); \
 } while (0)
-	if (is_sha512 == '5') {
+	if (_32or64 == 32) { /* sha256 */
 		unsigned i = 0;
 		while (1) {
 			unsigned j = i + 10;
diff -urpN busybox-1.26.2/libbb/recursive_action.c busybox-1.27.0/libbb/recursive_action.c
--- busybox-1.26.2/libbb/recursive_action.c	2016-09-27 18:53:50.000000000 +0200
+++ busybox-1.27.0/libbb/recursive_action.c	2017-07-01 22:51:12.000000000 +0200
@@ -30,24 +30,37 @@ static int FAST_FUNC true_action(const c
 	return TRUE;
 }
 
-/* fileAction return value of 0 on any file in directory will make
- * recursive_action() return 0, but it doesn't stop directory traversal
+/* fileName is (l)stat'ed (depending on ACTION_FOLLOWLINKS[_L0]).
+ *
+ * If it is a file: fileAction in run on it, its return value is returned.
+ *
+ * In case we are in a recursive invocation (see below):
+ * normally, fileAction should return 1 (TRUE) to indicate that
+ * everything is okay and processing should continue.
+ * fileAction return value of 0 (FALSE) on any file in directory will make
+ * recursive_action() also return 0, but it doesn't stop directory traversal
  * (fileAction/dirAction will be called on each file).
  *
- * If !ACTION_RECURSE, dirAction is called on the directory and its
+ * [TODO: maybe introduce -1 to mean "stop traversal NOW and return"]
+ *
+ * If it is a directory:
+ *
+ * If !ACTION_RECURSE, dirAction is called and its
  * return value is returned from recursive_action(). No recursion.
  *
- * If ACTION_RECURSE, recursive_action() is called on each directory.
+ * If ACTION_RECURSE, directory is opened, and recursive_action() is called
+ * on each file/subdirectory.
  * If any one of these calls returns 0, current recursive_action() returns 0.
  *
+ * If !ACTION_DEPTHFIRST, dirAction is called before recurse.
+ * Return value of 0 (FALSE) is an error: prevents recursion,
+ * the warning is printed (unless ACTION_QUIET) and recursive_action() returns 0.
+ * Return value of 2 (SKIP) prevents recursion, instead recursive_action()
+ * returns 1 (TRUE, no error).
+ *
  * If ACTION_DEPTHFIRST, dirAction is called after recurse.
  * If it returns 0, the warning is printed and recursive_action() returns 0.
  *
- * If !ACTION_DEPTHFIRST, dirAction is called before we recurse.
- * Return value of 0 (FALSE) or 2 (SKIP) prevents recursion
- * into that directory, instead recursive_action() returns 0 (if FALSE)
- * or 1 (if SKIP)
- *
  * ACTION_FOLLOWLINKS mainly controls handling of links to dirs.
  * 0: lstat(statbuf). Calls fileAction on link name even if points to dir.
  * 1: stat(statbuf). Calls dirAction and optionally recurse on link to dir.
@@ -105,7 +118,7 @@ int FAST_FUNC recursive_action(const cha
 
 	if (!(flags & ACTION_DEPTHFIRST)) {
 		status = dirAction(fileName, &statbuf, userData, depth);
-		if (!status)
+		if (status == FALSE)
 			goto done_nak_warn;
 		if (status == SKIP)
 			return TRUE;
@@ -121,24 +134,23 @@ int FAST_FUNC recursive_action(const cha
 	status = TRUE;
 	while ((next = readdir(dir)) != NULL) {
 		char *nextFile;
+		int s;
 
 		nextFile = concat_subpath_file(fileName, next->d_name);
 		if (nextFile == NULL)
 			continue;
+
 		/* process every file (NB: ACTION_RECURSE is set in flags) */
-		if (!recursive_action(nextFile, flags, fileAction, dirAction,
-						userData, depth + 1))
+		s = recursive_action(nextFile, flags, fileAction, dirAction,
+						userData, depth + 1);
+		if (s == FALSE)
 			status = FALSE;
-//		s = recursive_action(nextFile, flags, fileAction, dirAction,
-//						userData, depth + 1);
 		free(nextFile);
-//#define RECURSE_RESULT_ABORT 3
+//#define RECURSE_RESULT_ABORT -1
 //		if (s == RECURSE_RESULT_ABORT) {
 //			closedir(dir);
 //			return s;
 //		}
-//		if (s == FALSE)
-//			status = FALSE;
 	}
 	closedir(dir);
 
diff -urpN busybox-1.26.2/libbb/securetty.c busybox-1.27.0/libbb/securetty.c
--- busybox-1.26.2/libbb/securetty.c	1970-01-01 01:00:00.000000000 +0100
+++ busybox-1.27.0/libbb/securetty.c	2017-07-01 22:51:12.000000000 +0200
@@ -0,0 +1,26 @@
+/* vi: set sw=4 ts=4: */
+/*
+ * /etc/securetty checking.
+ *
+ * Licensed under GPLv2, see file LICENSE in this source tree.
+ */
+#include "libbb.h"
+
+#if ENABLE_FEATURE_SECURETTY && !ENABLE_PAM
+int FAST_FUNC is_tty_secure(const char *short_tty)
+{
+	char *buf = (char*)"/etc/securetty"; /* any non-NULL is ok */
+	parser_t *parser = config_open2("/etc/securetty", fopen_for_read);
+	while (config_read(parser, &buf, 1, 1, "# \t", PARSE_NORMAL)) {
+		if (strcmp(buf, short_tty) == 0)
+			break;
+		buf = NULL;
+	}
+	config_close(parser);
+	/* buf != NULL here if config file was not found, empty
+	 * or line was found which equals short_tty.
+	 * In all these cases, we report "this tty is secure".
+	 */
+	return buf != NULL;
+}
+#endif
diff -urpN busybox-1.26.2/libbb/vfork_daemon_rexec.c busybox-1.27.0/libbb/vfork_daemon_rexec.c
--- busybox-1.26.2/libbb/vfork_daemon_rexec.c	2016-09-27 18:53:50.000000000 +0200
+++ busybox-1.27.0/libbb/vfork_daemon_rexec.c	2017-07-01 22:51:12.000000000 +0200
@@ -121,28 +121,8 @@ int FAST_FUNC run_nofork_applet(int appl
 
 	/* In case getopt() or getopt32() was already called:
 	 * reset the libc getopt() function, which keeps internal state.
-	 *
-	 * BSD-derived getopt() functions require that optind be set to 1 in
-	 * order to reset getopt() state.  This used to be generally accepted
-	 * way of resetting getopt().  However, glibc's getopt()
-	 * has additional getopt() state beyond optind, and requires that
-	 * optind be set to zero to reset its state.  So the unfortunate state of
-	 * affairs is that BSD-derived versions of getopt() misbehave if
-	 * optind is set to 0 in order to reset getopt(), and glibc's getopt()
-	 * will core dump if optind is set 1 in order to reset getopt().
-	 *
-	 * More modern versions of BSD require that optreset be set to 1 in
-	 * order to reset getopt().  Sigh.  Standards, anyone?
 	 */
-#ifdef __GLIBC__
-	optind = 0;
-#else /* BSD style */
-	optind = 1;
-	/* optreset = 1; */
-#endif
-	/* optarg = NULL; opterr = 1; optopt = 63; - do we need this too? */
-	/* (values above are what they initialized to in glibc and uclibc) */
-	/* option_mask32 = 0; - not needed, no applet depends on it being 0 */
+	GETOPT_RESET();
 
 	argc = 1;
 	while (argv[argc])
@@ -167,11 +147,7 @@ int FAST_FUNC run_nofork_applet(int appl
 	restore_nofork_data(&old);
 
 	/* Other globals can be simply reset to defaults */
-#ifdef __GLIBC__
-	optind = 0;
-#else /* BSD style */
-	optind = 1;
-#endif
+	GETOPT_RESET();
 
 	return rc & 0xff; /* don't confuse people with "exitcodes" >255 */
 }
@@ -183,26 +159,28 @@ int FAST_FUNC spawn_and_wait(char **argv
 #if ENABLE_FEATURE_PREFER_APPLETS
 	int a = find_applet_by_name(argv[0]);
 
-	if (a >= 0 && (APPLET_IS_NOFORK(a)
-# if BB_MMU
-			|| APPLET_IS_NOEXEC(a) /* NOEXEC trick needs fork() */
-# endif
-	)) {
-# if BB_MMU
+	if (a >= 0) {
 		if (APPLET_IS_NOFORK(a))
-# endif
-		{
 			return run_nofork_applet(a, argv);
+# if BB_MMU /* NOEXEC needs fork(), thus this is done only on MMU machines: */
+		if (APPLET_IS_NOEXEC(a)) {
+			fflush_all();
+			rc = fork();
+			if (rc) /* parent or error */
+				return wait4pid(rc);
+
+			/* child */
+			/* reset some state and run without execing */
+
+			/* msg_eol = "\n"; - no caller needs this reinited yet */
+			logmode = LOGMODE_STDIO;
+			/* die_func = NULL; - needed if the caller is a shell,
+			 * init, or a NOFORK applet. But none of those call us
+			 * as of yet (and that should probably always stay true).
+			 */
+			/* xfunc_error_retval and applet_name are init by: */
+			run_applet_no_and_exit(a, argv);
 		}
-# if BB_MMU
-		/* MMU only */
-		/* a->noexec is true */
-		rc = fork();
-		if (rc) /* parent or error */
-			return wait4pid(rc);
-		/* child */
-		xfunc_error_retval = EXIT_FAILURE;
-		run_applet_no_and_exit(a, argv);
 # endif
 	}
 #endif /* FEATURE_PREFER_APPLETS */
diff -urpN busybox-1.26.2/libbb/xfuncs.c busybox-1.27.0/libbb/xfuncs.c
--- busybox-1.26.2/libbb/xfuncs.c	2016-12-10 18:46:36.000000000 +0100
+++ busybox-1.27.0/libbb/xfuncs.c	2017-01-15 00:18:53.000000000 +0100
@@ -311,6 +311,43 @@ int FAST_FUNC tcsetattr_stdin_TCSANOW(co
 	return tcsetattr(STDIN_FILENO, TCSANOW, tp);
 }
 
+int FAST_FUNC set_termios_to_raw(int fd, struct termios *oldterm, int flags)
+{
+//TODO: lineedit, microcom and less might be adapted to use this too:
+// grep for "tcsetattr"
+
+	struct termios newterm;
+
+	tcgetattr(fd, oldterm);
+	newterm = *oldterm;
+
+	/* Turn off buffered input (ICANON)
+	 * Turn off echoing (ECHO)
+	 * and separate echoing of newline (ECHONL, normally off anyway)
+	 */
+	newterm.c_lflag &= ~(ICANON | ECHO | ECHONL);
+	if (flags & TERMIOS_CLEAR_ISIG) {
+		/* dont recognize INT/QUIT/SUSP chars */
+		newterm.c_lflag &= ~ISIG;
+	}
+	/* reads will block only if < 1 char is available */
+	newterm.c_cc[VMIN] = 1;
+	/* no timeout (reads block forever) */
+	newterm.c_cc[VTIME] = 0;
+	if (flags & TERMIOS_RAW_CRNL) {
+		/* dont convert CR to NL on input */
+		newterm.c_iflag &= ~(IXON | ICRNL);
+		/* dont convert NL to CR on output */
+		newterm.c_oflag &= ~(ONLCR);
+	}
+	if (flags & TERMIOS_RAW_INPUT) {
+		/* dont convert anything on input */
+		newterm.c_iflag &= ~(BRKINT|INLCR|ICRNL|IXON|IXOFF|IUCLC|IXANY|IMAXBEL);
+	}
+
+	return tcsetattr(fd, TCSANOW, &newterm);
+}
+
 pid_t FAST_FUNC safe_waitpid(pid_t pid, int *wstat, int options)
 {
 	pid_t r;
diff -urpN busybox-1.26.2/libpwdgrp/pwd_grp.c busybox-1.27.0/libpwdgrp/pwd_grp.c
--- busybox-1.26.2/libpwdgrp/pwd_grp.c	2016-09-27 18:53:50.000000000 +0200
+++ busybox-1.27.0/libpwdgrp/pwd_grp.c	2017-07-01 22:51:12.000000000 +0200
@@ -14,7 +14,7 @@
  *    exit using the atexit function to make valgrind happy.
  * 2) the passwd/group files:
  *      a) must contain the expected number of fields (as per count of field
- *         delimeters ":") or we will complain with a error message.
+ *         delimiters ":") or we will complain with a error message.
  *      b) leading and trailing whitespace in fields is stripped.
  *      c) some fields are not allowed to be empty (e.g. username, uid/gid),
  *         and in this case NULL is returned and errno is set to EINVAL.
@@ -149,7 +149,7 @@ static struct statics *get_S(void)
 /* Internal functions */
 
 /* Divide the passwd/group/shadow record in fields
- * by substituting the given delimeter
+ * by substituting the given delimiter
  * e.g. ':' or ',' with '\0'.
  * Returns the number of fields found.
  * Strips leading and trailing whitespace in fields.
diff -urpN busybox-1.26.2/loginutils/Config.src busybox-1.27.0/loginutils/Config.src
--- busybox-1.26.2/loginutils/Config.src	2016-09-27 18:53:50.000000000 +0200
+++ busybox-1.27.0/loginutils/Config.src	2017-01-10 16:31:40.000000000 +0100
@@ -6,7 +6,7 @@
 menu "Login/Password Management Utilities"
 
 config FEATURE_SHADOWPASSWDS
-	bool "Support for shadow passwords"
+	bool "Support shadow passwords"
 	default y
 	help
 	  Build support for shadow password in /etc/shadow. This file is only
diff -urpN busybox-1.26.2/loginutils/add-remove-shell.c busybox-1.27.0/loginutils/add-remove-shell.c
--- busybox-1.26.2/loginutils/add-remove-shell.c	2016-09-27 18:53:50.000000000 +0200
+++ busybox-1.27.0/loginutils/add-remove-shell.c	2017-07-01 22:51:12.000000000 +0200
@@ -19,6 +19,7 @@
 //config:       help
 //config:         Remove shells from /etc/shells.
 
+//                       APPLET_ODDNAME:name          main              location         suid_type     help
 //applet:IF_ADD_SHELL(   APPLET_ODDNAME(add-shell   , add_remove_shell, BB_DIR_USR_SBIN, BB_SUID_DROP, add_shell   ))
 //applet:IF_REMOVE_SHELL(APPLET_ODDNAME(remove-shell, add_remove_shell, BB_DIR_USR_SBIN, BB_SUID_DROP, remove_shell))
 
@@ -42,10 +43,7 @@
 #define REMOVE_SHELL (ENABLE_REMOVE_SHELL && (!ENABLE_ADD_SHELL || applet_name[0] == 'r'))
 #define ADD_SHELL    (ENABLE_ADD_SHELL && (!ENABLE_REMOVE_SHELL || applet_name[0] == 'a'))
 
-/* NB: we use the _address_, not the value, of this string
- * as a "special value of pointer" in the code.
- */
-static const char dont_add[] ALIGN1 = "\n";
+#define dont_add ((char*)(uintptr_t)1)
 
 int add_remove_shell_main(int argc, char **argv) MAIN_EXTERNALLY_VISIBLE;
 int add_remove_shell_main(int argc UNUSED_PARAM, char **argv)
@@ -53,6 +51,9 @@ int add_remove_shell_main(int argc UNUSE
 	FILE *orig_fp;
 	char *orig_fn;
 	char *new_fn;
+	struct stat sb;
+
+	sb.st_mode = 0666;
 
 	argv++;
 
@@ -60,6 +61,8 @@ int add_remove_shell_main(int argc UNUSE
 	if (!orig_fn)
 		return EXIT_FAILURE;
 	orig_fp = fopen_for_read(orig_fn);
+	if (orig_fp)
+		xfstat(fileno(orig_fp), &sb, orig_fn);
 
 	new_fn = xasprintf("%s.tmp", orig_fn);
 	/*
@@ -70,13 +73,9 @@ int add_remove_shell_main(int argc UNUSE
 	 * after which it should revert to O_TRUNC.
 	 * For now, I settle for O_TRUNC instead.
 	 */
-	xmove_fd(xopen(new_fn, O_WRONLY | O_CREAT | O_TRUNC), STDOUT_FILENO);
-
-	/* TODO:
-	struct stat sb;
-	xfstat(fileno(orig_fp), &sb);
+	xmove_fd(xopen3(new_fn, O_WRONLY | O_CREAT | O_TRUNC, sb.st_mode), STDOUT_FILENO);
+	/* TODO?
 	xfchown(STDOUT_FILENO, sb.st_uid, sb.st_gid);
-	xfchmod(STDOUT_FILENO, sb.st_mode);
 	*/
 
 	if (orig_fp) {
@@ -94,7 +93,7 @@ int add_remove_shell_main(int argc UNUSE
 					}
 					/* we are add-shell */
 					/* mark this name as "do not add" */
-					*cpp = (char*)dont_add;
+					*cpp = dont_add;
 				}
 				cpp++;
 			}
diff -urpN busybox-1.26.2/loginutils/addgroup.c busybox-1.27.0/loginutils/addgroup.c
--- busybox-1.26.2/loginutils/addgroup.c	2016-12-10 18:46:36.000000000 +0100
+++ busybox-1.27.0/loginutils/addgroup.c	2017-01-10 16:31:40.000000000 +0100
@@ -19,15 +19,13 @@
 //config:	bool "Enable long options"
 //config:	default y
 //config:	depends on ADDGROUP && LONG_OPTS
-//config:	help
-//config:	  Support long options for the addgroup applet.
 //config:
 //config:config FEATURE_ADDUSER_TO_GROUP
-//config:	bool "Support for adding users to groups"
+//config:	bool "Support adding users to groups"
 //config:	default y
 //config:	depends on ADDGROUP
 //config:	help
-//config:	  If  called  with two non-option arguments,
+//config:	  If called with two non-option arguments,
 //config:	  addgroup will add an existing user to an
 //config:	  existing group.
 
diff -urpN busybox-1.26.2/loginutils/adduser.c busybox-1.27.0/loginutils/adduser.c
--- busybox-1.26.2/loginutils/adduser.c	2016-09-27 18:53:50.000000000 +0200
+++ busybox-1.27.0/loginutils/adduser.c	2017-01-30 21:57:30.000000000 +0100
@@ -17,8 +17,6 @@
 //config:	bool "Enable long options"
 //config:	default y
 //config:	depends on ADDUSER && LONG_OPTS
-//config:	help
-//config:	  Support long options for the adduser applet.
 //config:
 //config:config FEATURE_CHECK_NAMES
 //config:	bool "Enable sanity check on user/group names in adduser and addgroup"
@@ -66,7 +64,7 @@
 //usage:     "\n	-h DIR		Home directory"
 //usage:     "\n	-g GECOS	GECOS field"
 //usage:     "\n	-s SHELL	Login shell"
-//usage:     "\n	-G GRP		Add user to existing group"
+//usage:     "\n	-G GRP		Group"
 //usage:     "\n	-S		Create a system user"
 //usage:     "\n	-D		Don't assign a password"
 //usage:     "\n	-H		Don't create home directory"
diff -urpN busybox-1.26.2/loginutils/chpasswd.c busybox-1.27.0/loginutils/chpasswd.c
--- busybox-1.26.2/loginutils/chpasswd.c	2016-09-27 18:53:50.000000000 +0200
+++ busybox-1.27.0/loginutils/chpasswd.c	2017-01-23 01:09:41.000000000 +0100
@@ -13,9 +13,9 @@
 //config:	  and uses this information to update a group of existing users.
 //config:
 //config:config FEATURE_DEFAULT_PASSWD_ALGO
-//config:	string "Default password encryption method (passwd -a, cryptpw -m parameter)"
+//config:	string "Default encryption method (passwd -a, cryptpw -m, chpasswd -c ALG)"
 //config:	default "des"
-//config:	depends on PASSWD || CRYPTPW
+//config:	depends on PASSWD || CRYPTPW || CHPASSWD
 //config:	help
 //config:	  Possible choices are "d[es]", "m[d5]", "s[ha256]" or "sha512".
 
@@ -29,13 +29,13 @@
 //usage:       "Read user:password from stdin and update /etc/passwd\n"
 //usage:	IF_LONG_OPTS(
 //usage:     "\n	-e,--encrypted		Supplied passwords are in encrypted form"
-//usage:     "\n	-m,--md5		Use MD5 encryption instead of DES"
-//usage:     "\n	-c,--crypt-method	Use the specified method to encrypt the passwords"
+//usage:     "\n	-m,--md5		Eencrypt using md5, not des"
+//usage:     "\n	-c,--crypt-method ALG	"CRYPT_METHODS_HELP_STR
 //usage:	)
 //usage:	IF_NOT_LONG_OPTS(
 //usage:     "\n	-e	Supplied passwords are in encrypted form"
-//usage:     "\n	-m	Use MD5 encryption instead of DES"
-//usage:     "\n	-c	Use the specified method to encrypt the passwords"
+//usage:     "\n	-m	Eencrypt using md5, not des"
+//usage:     "\n	-c ALG	"CRYPT_METHODS_HELP_STR
 //usage:	)
 
 #include "libbb.h"
diff -urpN busybox-1.26.2/loginutils/cryptpw.c busybox-1.27.0/loginutils/cryptpw.c
--- busybox-1.26.2/loginutils/cryptpw.c	2016-09-27 18:53:50.000000000 +0200
+++ busybox-1.27.0/loginutils/cryptpw.c	2017-07-01 22:51:12.000000000 +0200
@@ -35,17 +35,17 @@
 //usage:       "[OPTIONS] [PASSWORD] [SALT]"
 /* We do support -s, we just don't mention it */
 //usage:#define cryptpw_full_usage "\n\n"
-//usage:       "Crypt PASSWORD using crypt(3)\n"
+//usage:       "Print crypt(3) hashed PASSWORD\n"
 //usage:	IF_LONG_OPTS(
-//usage:     "\n	-P,--password-fd=N	Read password from fd N"
+//usage:     "\n	-P,--password-fd N	Read password from fd N"
 /* //usage:  "\n	-s,--stdin		Use stdin; like -P0" */
-//usage:     "\n	-m,--method=TYPE	Encryption method"
-//usage:     "\n	-S,--salt=SALT"
+//usage:     "\n	-m,--method TYPE	"CRYPT_METHODS_HELP_STR
+//usage:     "\n	-S,--salt SALT"
 //usage:	)
 //usage:	IF_NOT_LONG_OPTS(
 //usage:     "\n	-P N	Read password from fd N"
 /* //usage:  "\n	-s	Use stdin; like -P0" */
-//usage:     "\n	-m TYPE	Encryption method TYPE"
+//usage:     "\n	-m TYPE	"CRYPT_METHODS_HELP_STR
 //usage:     "\n	-S SALT"
 //usage:	)
 
@@ -64,7 +64,7 @@ OPTIONS
     $1$.
 -R, --rounds=NUMBER
     Use NUMBER rounds. This argument is ignored if the method
-    choosen does not support variable rounds. For the OpenBSD Blowfish
+    chosen does not support variable rounds. For the OpenBSD Blowfish
     method this is the logarithm of the number of rounds.
 -m, --method=TYPE
     Compute the password using the TYPE method. If TYPE is 'help'
@@ -92,7 +92,8 @@ to cryptpw. -a option (alias for -m) cam
 int cryptpw_main(int argc, char **argv) MAIN_EXTERNALLY_VISIBLE;
 int cryptpw_main(int argc UNUSED_PARAM, char **argv)
 {
-	char salt[MAX_PW_SALT_LEN];
+	/* Supports: cryptpw -m sha256 PASS 'rounds=999999999$SALT' */
+	char salt[MAX_PW_SALT_LEN + sizeof("rounds=999999999$")];
 	char *salt_ptr;
 	char *password;
 	const char *opt_m, *opt_S;
@@ -122,6 +123,7 @@ int cryptpw_main(int argc UNUSED_PARAM,
 
 	salt_ptr = crypt_make_pw_salt(salt, opt_m);
 	if (opt_S)
+		/* put user's data after the "$N$" prefix */
 		safe_strncpy(salt_ptr, opt_S, sizeof(salt) - (sizeof("$N$")-1));
 
 	xmove_fd(fd, STDIN_FILENO);
diff -urpN busybox-1.26.2/loginutils/deluser.c busybox-1.27.0/loginutils/deluser.c
--- busybox-1.26.2/loginutils/deluser.c	2016-09-27 18:53:50.000000000 +0200
+++ busybox-1.27.0/loginutils/deluser.c	2017-01-10 16:31:40.000000000 +0100
@@ -21,7 +21,7 @@
 //config:	  Utility for deleting a group account.
 //config:
 //config:config FEATURE_DEL_USER_FROM_GROUP
-//config:	bool "Support for removing users from groups"
+//config:	bool "Support removing users from groups"
 //config:	default y
 //config:	depends on DELGROUP
 //config:	help
diff -urpN busybox-1.26.2/loginutils/getty.c busybox-1.27.0/loginutils/getty.c
--- busybox-1.26.2/loginutils/getty.c	2016-09-27 18:53:50.000000000 +0200
+++ busybox-1.27.0/loginutils/getty.c	2017-01-15 00:18:53.000000000 +0100
@@ -316,7 +316,7 @@ static void init_tty_attrs(int speed)
 	/* non-raw output; add CR to each NL */
 	G.tty_attrs.c_oflag = OPOST | ONLCR;
 
-	/* reads would block only if < 1 char is available */
+	/* reads will block only if < 1 char is available */
 	G.tty_attrs.c_cc[VMIN] = 1;
 	/* no timeout (reads block forever) */
 	G.tty_attrs.c_cc[VTIME] = 0;
diff -urpN busybox-1.26.2/loginutils/login.c busybox-1.27.0/loginutils/login.c
--- busybox-1.26.2/loginutils/login.c	2017-01-01 13:01:04.000000000 +0100
+++ busybox-1.27.0/loginutils/login.c	2017-07-01 22:51:12.000000000 +0200
@@ -24,7 +24,7 @@
 //config:	  will not be cleaned up.
 //config:
 //config:config LOGIN_SCRIPTS
-//config:	bool "Support for login scripts"
+//config:	bool "Support login scripts"
 //config:	depends on LOGIN
 //config:	default y
 //config:	help
@@ -32,7 +32,7 @@
 //config:	  just prior to switching from root to logged-in user.
 //config:
 //config:config FEATURE_NOLOGIN
-//config:	bool "Support for /etc/nologin"
+//config:	bool "Support /etc/nologin"
 //config:	default y
 //config:	depends on LOGIN
 //config:	help
@@ -40,7 +40,7 @@
 //config:	  If it exists, non-root logins are prohibited.
 //config:
 //config:config FEATURE_SECURETTY
-//config:	bool "Support for /etc/securetty"
+//config:	bool "Support /etc/securetty"
 //config:	default y
 //config:	depends on LOGIN
 //config:	help
@@ -175,25 +175,6 @@ static void die_if_nologin(void)
 # define die_if_nologin() ((void)0)
 #endif
 
-#if ENABLE_FEATURE_SECURETTY && !ENABLE_PAM
-static int check_securetty(const char *short_tty)
-{
-	char *buf = (char*)"/etc/securetty"; /* any non-NULL is ok */
-	parser_t *parser = config_open2("/etc/securetty", fopen_for_read);
-	while (config_read(parser, &buf, 1, 1, "# \t", PARSE_NORMAL)) {
-		if (strcmp(buf, short_tty) == 0)
-			break;
-		buf = NULL;
-	}
-	config_close(parser);
-	/* buf != NULL here if config file was not found, empty
-	 * or line was found which equals short_tty */
-	return buf != NULL;
-}
-#else
-static ALWAYS_INLINE int check_securetty(const char *short_tty UNUSED_PARAM) { return 1; }
-#endif
-
 #if ENABLE_SELINUX
 static void initselinux(char *username, char *full_tty,
 						security_context_t *user_sid)
@@ -505,7 +486,7 @@ int login_main(int argc UNUSED_PARAM, ch
 		if (opt & LOGIN_OPT_f)
 			break; /* -f USER: success without asking passwd */
 
-		if (pw->pw_uid == 0 && !check_securetty(short_tty))
+		if (pw->pw_uid == 0 && !is_tty_secure(short_tty))
 			goto auth_failed;
 
 		/* Don't check the password if password entry is empty (!) */
diff -urpN busybox-1.26.2/loginutils/passwd.c busybox-1.27.0/loginutils/passwd.c
--- busybox-1.26.2/loginutils/passwd.c	2016-09-27 18:53:50.000000000 +0200
+++ busybox-1.27.0/loginutils/passwd.c	2017-01-23 01:09:41.000000000 +0100
@@ -32,7 +32,7 @@
 //usage:#define passwd_full_usage "\n\n"
 //usage:       "Change USER's password (default: current user)"
 //usage:     "\n"
-//usage:     "\n	-a ALG	Encryption method"
+//usage:     "\n	-a ALG	"CRYPT_METHODS_HELP_STR
 //usage:     "\n	-d	Set password to ''"
 //usage:     "\n	-l	Lock (disable) account"
 //usage:     "\n	-u	Unlock (enable) account"
diff -urpN busybox-1.26.2/loginutils/su.c busybox-1.27.0/loginutils/su.c
--- busybox-1.26.2/loginutils/su.c	2016-12-10 18:46:36.000000000 +0100
+++ busybox-1.27.0/loginutils/su.c	2017-07-01 22:51:12.000000000 +0200
@@ -11,19 +11,23 @@
 //config:	help
 //config:	  su is used to become another user during a login session.
 //config:	  Invoked without a username, su defaults to becoming the super user.
-//config:
-//config:	  Note that Busybox binary must be setuid root for this applet to
+//config:	  Note that busybox binary must be setuid root for this applet to
 //config:	  work properly.
 //config:
 //config:config FEATURE_SU_SYSLOG
-//config:	bool "Enable su to write to syslog"
+//config:	bool "Log to syslog all attempts to use su"
 //config:	default y
 //config:	depends on SU
 //config:
 //config:config FEATURE_SU_CHECKS_SHELLS
-//config:	bool "Enable su to check user's shell to be listed in /etc/shells"
-//config:	depends on SU
+//config:	bool "If user's shell is not in /etc/shells, disallow -s PROG"
 //config:	default y
+//config:	depends on SU
+//config:
+//config:config FEATURE_SU_BLANK_PW_NEEDS_SECURE_TTY
+//config:	bool "Allow blank passwords only on TTYs in /etc/securetty"
+//config:	default n
+//config:	depends on SU
 
 //applet:/* Needs to be run by root or be suid root - needs to change uid and gid: */
 //applet:IF_SU(APPLET(su, BB_DIR_BIN, BB_SUID_REQUIRE))
@@ -80,6 +84,7 @@ int su_main(int argc UNUSED_PARAM, char
 	char user_buf[64];
 #endif
 	const char *old_user;
+	int r;
 
 	/* Note: we don't use "'+': stop at first non-option" idiom here.
 	 * For su, "SCRIPT ARGS" or "-c CMD ARGS" do not stop option parsing:
@@ -100,6 +105,11 @@ int su_main(int argc UNUSED_PARAM, char
 		argv++;
 	}
 
+	tty = xmalloc_ttyname(STDIN_FILENO);
+	if (!tty)
+		tty = "none";
+	tty = skip_dev_pfx(tty);
+
 	if (ENABLE_FEATURE_SU_SYSLOG) {
 		/* The utmp entry (via getlogin) is probably the best way to
 		 * identify the user, especially if someone su's from a su-shell.
@@ -113,20 +123,26 @@ int su_main(int argc UNUSED_PARAM, char
 			pw = getpwuid(cur_uid);
 			old_user = pw ? xstrdup(pw->pw_name) : "";
 		}
-		tty = xmalloc_ttyname(2);
-		if (!tty) {
-			tty = "none";
-		}
 		openlog(applet_name, 0, LOG_AUTH);
 	}
 
 	pw = xgetpwnam(opt_username);
 
-	if (cur_uid == 0 || ask_and_check_password(pw) > 0) {
+	r = 1;
+	if (cur_uid != 0)
+		r = ask_and_check_password(pw);
+	if (r > 0) {
+		if (ENABLE_FEATURE_SU_BLANK_PW_NEEDS_SECURE_TTY
+		 && r == CHECKPASS_PW_HAS_EMPTY_PASSWORD
+		 && !is_tty_secure(tty)
+		) {
+			goto fail;
+		}
 		if (ENABLE_FEATURE_SU_SYSLOG)
 			syslog(LOG_NOTICE, "%c %s %s:%s",
 				'+', tty, old_user, opt_username);
 	} else {
+ fail:
 		if (ENABLE_FEATURE_SU_SYSLOG)
 			syslog(LOG_NOTICE, "%c %s %s:%s",
 				'-', tty, old_user, opt_username);
diff -urpN busybox-1.26.2/loginutils/vlock.c busybox-1.27.0/loginutils/vlock.c
--- busybox-1.26.2/loginutils/vlock.c	2016-09-27 18:53:50.000000000 +0200
+++ busybox-1.27.0/loginutils/vlock.c	2017-01-15 00:18:53.000000000 +0100
@@ -105,12 +105,12 @@ int vlock_main(int argc UNUSED_PARAM, ch
 	ioctl(STDIN_FILENO, VT_SETMODE, &vtm);
 #endif
 
+//TODO: use set_termios_to_raw()
 	tcgetattr(STDIN_FILENO, &oterm);
 	term = oterm;
-	term.c_iflag &= ~BRKINT;
-	term.c_iflag |= IGNBRK;
-	term.c_lflag &= ~ISIG;
-	term.c_lflag &= ~(ECHO | ECHOCTL);
+	term.c_iflag |= IGNBRK; /* ignore serial break (why? VTs don't have breaks, right?) */
+	term.c_iflag &= ~BRKINT; /* redundant? "dont translate break to SIGINT" */
+	term.c_lflag &= ~(ISIG | ECHO | ECHOCTL); /* ignore ^C ^Z, echo off */
 	tcsetattr_stdin_TCSANOW(&term);
 
 	while (1) {
diff -urpN busybox-1.26.2/mailutils/sendmail.c busybox-1.27.0/mailutils/sendmail.c
--- busybox-1.26.2/mailutils/sendmail.c	2016-12-10 18:46:36.000000000 +0100
+++ busybox-1.27.0/mailutils/sendmail.c	2017-04-05 18:27:36.000000000 +0200
@@ -150,7 +150,7 @@ static char *sane_address(char *str)
 	trim(str);
 	s = str;
 	while (*s) {
-		if (!isalnum(*s) && !strchr("_-.@", *s)) {
+		if (!isalnum(*s) && !strchr("+_-.@", *s)) {
 			bb_error_msg("bad address '%s'", str);
 			/* returning "": */
 			str[0] = '\0';
diff -urpN busybox-1.26.2/make_single_applets.sh busybox-1.27.0/make_single_applets.sh
--- busybox-1.26.2/make_single_applets.sh	2017-01-01 13:01:05.000000000 +0100
+++ busybox-1.27.0/make_single_applets.sh	2017-01-16 17:32:02.000000000 +0100
@@ -28,9 +28,14 @@ for app in $apps; do
 done
 #echo "$allno" >.config_allno
 
+trap 'test -f .config.SV && mv .config.SV .config && touch .config' EXIT
+
+
 # Turn on each applet individually and build single-applet executable
+# (give config names on command line to build only those)
+test $# = 0 && set -- $apps
 fail=0
-for app in $apps; do
+for app; do
 	# Only if it was indeed originally enabled...
 	{ echo "$cfg" | grep -q "^CONFIG_${app}=y\$"; } || continue
 
@@ -54,16 +59,20 @@ for app in $apps; do
 		mv .config busybox_config_${app}
 	elif ! make $makeopts >>busybox_make_${app}.log 2>&1; then
 		: $((fail++))
+		grep -i -e error: -e warning: busybox_make_${app}.log
 		echo "Build error for ${app}"
 		mv .config busybox_config_${app}
 	elif ! grep -q '^#define NUM_APPLETS 1$' include/NUM_APPLETS.h; then
+		grep -i -e error: -e warning: busybox_make_${app}.log
 		mv busybox busybox_${app}
 		: $((fail++))
 		echo "NUM_APPLETS != 1 for ${app}: `cat include/NUM_APPLETS.h`"
 		mv .config busybox_config_${app}
 	else
+		grep -i -e error: -e warning: busybox_make_${app}.log \
+		|| rm busybox_make_${app}.log
 		mv busybox busybox_${app}
-		rm busybox_make_${app}.log
+		#mv .config busybox_config_${app}
 	fi
 	mv .config.SV .config
 	#exit
diff -urpN busybox-1.26.2/miscutils/chat.c busybox-1.27.0/miscutils/chat.c
--- busybox-1.26.2/miscutils/chat.c	2016-12-10 18:46:36.000000000 +0100
+++ busybox-1.27.0/miscutils/chat.c	2017-01-15 00:18:53.000000000 +0100
@@ -213,6 +213,7 @@ int chat_main(int argc UNUSED_PARAM, cha
 		, signal_handler);
 
 #if ENABLE_FEATURE_CHAT_TTY_HIFI
+//TODO: use set_termios_to_raw()
 	tcgetattr(STDIN_FILENO, &tio);
 	tio0 = tio;
 	cfmakeraw(&tio);
diff -urpN busybox-1.26.2/miscutils/chrt.c busybox-1.27.0/miscutils/chrt.c
--- busybox-1.26.2/miscutils/chrt.c	2016-12-10 18:46:36.000000000 +0100
+++ busybox-1.27.0/miscutils/chrt.c	1970-01-01 01:00:00.000000000 +0100
@@ -1,149 +0,0 @@
-/* vi: set sw=4 ts=4: */
-/*
- * chrt - manipulate real-time attributes of a process
- * Copyright (c) 2006-2007 Bernhard Reutner-Fischer
- *
- * Licensed under GPLv2 or later, see file LICENSE in this source tree.
- */
-//config:config CHRT
-//config:	bool "chrt"
-//config:	default y
-//config:	help
-//config:	  manipulate real-time attributes of a process.
-//config:	  This requires sched_{g,s}etparam support in your libc.
-
-//applet:IF_CHRT(APPLET(chrt, BB_DIR_USR_BIN, BB_SUID_DROP))
-
-//kbuild:lib-$(CONFIG_CHRT) += chrt.o
-
-//usage:#define chrt_trivial_usage
-//usage:       "[-prfom] [PRIO] [PID | PROG ARGS]"
-//usage:#define chrt_full_usage "\n\n"
-//usage:       "Change scheduling priority and class for a process\n"
-//usage:     "\n	-p	Operate on PID"
-//usage:     "\n	-r	Set SCHED_RR class"
-//usage:     "\n	-f	Set SCHED_FIFO class"
-//usage:     "\n	-o	Set SCHED_OTHER class"
-//usage:     "\n	-m	Show min/max priorities"
-//usage:
-//usage:#define chrt_example_usage
-//usage:       "$ chrt -r 4 sleep 900; x=$!\n"
-//usage:       "$ chrt -f -p 3 $x\n"
-//usage:       "You need CAP_SYS_NICE privileges to set scheduling attributes of a process"
-
-#include <sched.h>
-#include "libbb.h"
-
-static const struct {
-	int policy;
-	char name[sizeof("SCHED_OTHER")];
-} policies[] = {
-	{SCHED_OTHER, "SCHED_OTHER"},
-	{SCHED_FIFO, "SCHED_FIFO"},
-	{SCHED_RR, "SCHED_RR"}
-};
-
-//TODO: add
-// -b, SCHED_BATCH
-// -i, SCHED_IDLE
-
-static void show_min_max(int pol)
-{
-	const char *fmt = "%s min/max priority\t: %u/%u\n";
-	int max, min;
-
-	max = sched_get_priority_max(pol);
-	min = sched_get_priority_min(pol);
-	if ((max|min) < 0)
-		fmt = "%s not supported\n";
-	printf(fmt, policies[pol].name, min, max);
-}
-
-#define OPT_m (1<<0)
-#define OPT_p (1<<1)
-#define OPT_r (1<<2)
-#define OPT_f (1<<3)
-#define OPT_o (1<<4)
-
-int chrt_main(int argc, char **argv) MAIN_EXTERNALLY_VISIBLE;
-int chrt_main(int argc UNUSED_PARAM, char **argv)
-{
-	pid_t pid = 0;
-	unsigned opt;
-	struct sched_param sp;
-	char *pid_str;
-	char *priority = priority; /* for compiler */
-	const char *current_new;
-	int policy = SCHED_RR;
-
-	/* only one policy accepted */
-	opt_complementary = "r--fo:f--ro:o--rf";
-	opt = getopt32(argv, "+mprfo");
-	if (opt & OPT_m) { /* print min/max and exit */
-		show_min_max(SCHED_FIFO);
-		show_min_max(SCHED_RR);
-		show_min_max(SCHED_OTHER);
-		fflush_stdout_and_exit(EXIT_SUCCESS);
-	}
-	if (opt & OPT_r)
-		policy = SCHED_RR;
-	if (opt & OPT_f)
-		policy = SCHED_FIFO;
-	if (opt & OPT_o)
-		policy = SCHED_OTHER;
-
-	argv += optind;
-	if (!argv[0])
-		bb_show_usage();
-	if (opt & OPT_p) {
-		pid_str = *argv++;
-		if (*argv) { /* "-p <priority> <pid> [...]" */
-			priority = pid_str;
-			pid_str = *argv;
-		}
-		/* else "-p <pid>", and *argv == NULL */
-		pid = xatoul_range(pid_str, 1, ((unsigned)(pid_t)ULONG_MAX) >> 1);
-	} else {
-		priority = *argv++;
-		if (!*argv)
-			bb_show_usage();
-	}
-
-	current_new = "current\0new";
-	if (opt & OPT_p) {
-		int pol;
- print_rt_info:
-		pol = sched_getscheduler(pid);
-		if (pol < 0)
-			bb_perror_msg_and_die("can't %cet pid %d's policy", 'g', (int)pid);
-		printf("pid %d's %s scheduling policy: %s\n",
-				pid, current_new, policies[pol].name);
-		if (sched_getparam(pid, &sp))
-			bb_perror_msg_and_die("can't get pid %d's attributes", (int)pid);
-		printf("pid %d's %s scheduling priority: %d\n",
-				(int)pid, current_new, sp.sched_priority);
-		if (!*argv) {
-			/* Either it was just "-p <pid>",
-			 * or it was "-p <priority> <pid>" and we came here
-			 * for the second time (see goto below) */
-			return EXIT_SUCCESS;
-		}
-		*argv = NULL;
-		current_new += 8;
-	}
-
-	/* from the manpage of sched_getscheduler:
-	[...] sched_priority can have a value in the range 0 to 99.
-	[...] SCHED_OTHER or SCHED_BATCH must be assigned static priority 0.
-	[...] SCHED_FIFO or SCHED_RR can have static priority in 1..99 range.
-	*/
-	sp.sched_priority = xstrtou_range(priority, 0, policy != SCHED_OTHER ? 1 : 0, 99);
-
-	if (sched_setscheduler(pid, policy, &sp) < 0)
-		bb_perror_msg_and_die("can't %cet pid %d's policy", 's', (int)pid);
-
-	if (!argv[0]) /* "-p <priority> <pid> [...]" */
-		goto print_rt_info;
-
-	BB_EXECVP_or_die(argv);
-}
diff -urpN busybox-1.26.2/miscutils/conspy.c busybox-1.27.0/miscutils/conspy.c
--- busybox-1.26.2/miscutils/conspy.c	2016-12-10 18:46:36.000000000 +0100
+++ busybox-1.27.0/miscutils/conspy.c	2017-01-15 00:18:53.000000000 +0100
@@ -363,7 +363,6 @@ int conspy_main(int argc, char **argv) M
 int conspy_main(int argc UNUSED_PARAM, char **argv)
 {
 	char tty_name[sizeof(DEV_TTY "NN")];
-	struct termios termbuf;
 	unsigned opts;
 	unsigned ttynum;
 	int poll_timeout_ms;
@@ -414,16 +413,14 @@ int conspy_main(int argc UNUSED_PARAM, c
 
 	bb_signals(BB_FATAL_SIGS, cleanup);
 
-	// All characters must be passed through to us unaltered
 	G.kbd_fd = xopen(CURRENT_TTY, O_RDONLY);
-	tcgetattr(G.kbd_fd, &G.term_orig);
-	termbuf = G.term_orig;
-	termbuf.c_iflag &= ~(BRKINT|INLCR|ICRNL|IXON|IXOFF|IUCLC|IXANY|IMAXBEL);
-	//termbuf.c_oflag &= ~(OPOST); - no, we still want \n -> \r\n
-	termbuf.c_lflag &= ~(ISIG|ICANON|ECHO);
-	termbuf.c_cc[VMIN] = 1;
-	termbuf.c_cc[VTIME] = 0;
-	tcsetattr(G.kbd_fd, TCSANOW, &termbuf);
+
+	// All characters must be passed through to us unaltered
+	set_termios_to_raw(G.kbd_fd, &G.term_orig, 0
+		| TERMIOS_CLEAR_ISIG // no signals on ^C ^Z etc
+		| TERMIOS_RAW_INPUT  // turn off all input conversions
+	);
+	//Note: termios.c_oflag &= ~(OPOST); - no, we still want \n -> \r\n
 
 	poll_timeout_ms = 250;
 	while (1) {
diff -urpN busybox-1.26.2/miscutils/crond.c busybox-1.27.0/miscutils/crond.c
--- busybox-1.26.2/miscutils/crond.c	2016-09-27 18:53:50.000000000 +0200
+++ busybox-1.27.0/miscutils/crond.c	2017-01-23 01:09:41.000000000 +0100
@@ -52,7 +52,7 @@
 //usage:       "	-f	Foreground"
 //usage:     "\n	-b	Background (default)"
 //usage:     "\n	-S	Log to syslog (default)"
-//usage:     "\n	-l N	Set log level. Most verbose:0, default:8"
+//usage:     "\n	-l N	Set log level. Most verbose 0, default 8"
 //usage:	IF_FEATURE_CROND_D(
 //usage:     "\n	-d N	Set log level, log to stderr"
 //usage:	)
diff -urpN busybox-1.26.2/miscutils/devfsd.c busybox-1.27.0/miscutils/devfsd.c
--- busybox-1.26.2/miscutils/devfsd.c	2016-12-10 18:46:36.000000000 +0100
+++ busybox-1.27.0/miscutils/devfsd.c	2017-01-10 16:31:40.000000000 +0100
@@ -82,7 +82,7 @@
 //config:	  the external modutils.
 //config:
 //config:config DEVFSD_FG_NP
-//config:	bool "Enables the -fg and -np options"
+//config:	bool "Enable the -fg and -np options"
 //config:	default y
 //config:	depends on DEVFSD
 //config:	help
diff -urpN busybox-1.26.2/miscutils/eject.c busybox-1.27.0/miscutils/eject.c
--- busybox-1.26.2/miscutils/eject.c	2016-12-10 18:46:36.000000000 +0100
+++ busybox-1.27.0/miscutils/eject.c	1970-01-01 01:00:00.000000000 +0100
@@ -1,152 +0,0 @@
-/* vi: set sw=4 ts=4: */
-/*
- * eject implementation for busybox
- *
- * Copyright (C) 2004  Peter Willis <psyphreak@phreaker.net>
- * Copyright (C) 2005  Tito Ragusa <farmatito@tiscali.it>
- *
- * Licensed under GPLv2 or later, see file LICENSE in this source tree.
- */
-
-/*
- * This is a simple hack of eject based on something Erik posted in #uclibc.
- * Most of the dirty work blatantly ripped off from cat.c =)
- */
-//config:config EJECT
-//config:	bool "eject"
-//config:	default y
-//config:	select PLATFORM_LINUX
-//config:	help
-//config:	  Used to eject cdroms. (defaults to /dev/cdrom)
-//config:
-//config:config FEATURE_EJECT_SCSI
-//config:	bool "SCSI support"
-//config:	default y
-//config:	depends on EJECT
-//config:	help
-//config:	  Add the -s option to eject, this allows to eject SCSI-Devices and
-//config:	  usb-storage devices.
-
-//applet:IF_EJECT(APPLET(eject, BB_DIR_USR_BIN, BB_SUID_DROP))
-
-//kbuild:lib-$(CONFIG_EJECT) += eject.o
-
-//usage:#define eject_trivial_usage
-//usage:       "[-t] [-T] [DEVICE]"
-//usage:#define eject_full_usage "\n\n"
-//usage:       "Eject DEVICE or default /dev/cdrom\n"
-//usage:	IF_FEATURE_EJECT_SCSI(
-//usage:     "\n	-s	SCSI device"
-//usage:	)
-//usage:     "\n	-t	Close tray"
-//usage:     "\n	-T	Open/close tray (toggle)"
-
-#include <sys/mount.h>
-#include "libbb.h"
-#if ENABLE_FEATURE_EJECT_SCSI
-/* Must be after libbb.h: they need size_t */
-# include "fix_u32.h"
-# include <scsi/sg.h>
-# include <scsi/scsi.h>
-#endif
-
-#define dev_fd 3
-
-/* Code taken from the original eject (http://eject.sourceforge.net/),
- * refactored it a bit for busybox (ne-bb@nicoerfurth.de) */
-
-#if ENABLE_FEATURE_EJECT_SCSI
-static void eject_scsi(const char *dev)
-{
-	static const char sg_commands[3][6] ALIGN1 = {
-		{ ALLOW_MEDIUM_REMOVAL, 0, 0, 0, 0, 0 },
-		{ START_STOP, 0, 0, 0, 1, 0 },
-		{ START_STOP, 0, 0, 0, 2, 0 }
-	};
-
-	unsigned i;
-	unsigned char sense_buffer[32];
-	unsigned char inqBuff[2];
-	sg_io_hdr_t io_hdr;
-
-	if ((ioctl(dev_fd, SG_GET_VERSION_NUM, &i) < 0) || (i < 30000))
-		bb_error_msg_and_die("not a sg device or old sg driver");
-
-	memset(&io_hdr, 0, sizeof(sg_io_hdr_t));
-	io_hdr.interface_id = 'S';
-	io_hdr.cmd_len = 6;
-	io_hdr.mx_sb_len = sizeof(sense_buffer);
-	io_hdr.dxfer_direction = SG_DXFER_NONE;
-	/* io_hdr.dxfer_len = 0; */
-	io_hdr.dxferp = inqBuff;
-	io_hdr.sbp = sense_buffer;
-	io_hdr.timeout = 2000;
-
-	for (i = 0; i < 3; i++) {
-		io_hdr.cmdp = (void *)sg_commands[i];
-		ioctl_or_perror_and_die(dev_fd, SG_IO, (void *)&io_hdr, "%s", dev);
-	}
-
-	/* force kernel to reread partition table when new disc is inserted */
-	ioctl(dev_fd, BLKRRPART);
-}
-#else
-# define eject_scsi(dev) ((void)0)
-#endif
-
-/* various defines swiped from linux/cdrom.h */
-#define CDROMCLOSETRAY            0x5319  /* pendant of CDROMEJECT  */
-#define CDROMEJECT                0x5309  /* Ejects the cdrom media */
-#define CDROM_DRIVE_STATUS        0x5326  /* Get tray position, etc. */
-/* drive status possibilities returned by CDROM_DRIVE_STATUS ioctl */
-#define CDS_TRAY_OPEN        2
-
-#define FLAG_CLOSE  1
-#define FLAG_SMART  2
-#define FLAG_SCSI   4
-
-static void eject_cdrom(unsigned flags, const char *dev)
-{
-	int cmd = CDROMEJECT;
-
-	if (flags & FLAG_CLOSE
-	 || ((flags & FLAG_SMART) && ioctl(dev_fd, CDROM_DRIVE_STATUS) == CDS_TRAY_OPEN)
-	) {
-		cmd = CDROMCLOSETRAY;
-	}
-
-	ioctl_or_perror_and_die(dev_fd, cmd, NULL, "%s", dev);
-}
-
-int eject_main(int argc, char **argv) MAIN_EXTERNALLY_VISIBLE;
-int eject_main(int argc UNUSED_PARAM, char **argv)
-{
-	unsigned flags;
-	const char *device;
-
-	opt_complementary = "?1:t--T:T--t";
-	flags = getopt32(argv, "tT" IF_FEATURE_EJECT_SCSI("s"));
-	device = argv[optind] ? argv[optind] : "/dev/cdrom";
-
-	/* We used to do "umount <device>" here, but it was buggy
-	   if something was mounted OVER cdrom and
-	   if cdrom is mounted many times.
-
-	   This works equally well (or better):
-	   #!/bin/sh
-	   umount /dev/cdrom
-	   eject /dev/cdrom
-	*/
-
-	xmove_fd(xopen_nonblocking(device), dev_fd);
-
-	if (ENABLE_FEATURE_EJECT_SCSI && (flags & FLAG_SCSI))
-		eject_scsi(device);
-	else
-		eject_cdrom(flags, device);
-
-	if (ENABLE_FEATURE_CLEAN_UP)
-		close(dev_fd);
-
-	return EXIT_SUCCESS;
-}
diff -urpN busybox-1.26.2/miscutils/flash_lock_unlock.c busybox-1.27.0/miscutils/flash_lock_unlock.c
--- busybox-1.26.2/miscutils/flash_lock_unlock.c	2016-12-10 18:46:36.000000000 +0100
+++ busybox-1.27.0/miscutils/flash_lock_unlock.c	2017-01-30 21:57:30.000000000 +0100
@@ -17,7 +17,8 @@
 //config:	  The flash_unlock binary from mtd-utils as of git head 5ec0c10d0. This
 //config:	  utility unlocks part or all of the flash device.
 
-//applet:IF_FLASH_LOCK(APPLET_ODDNAME(flash_lock, flash_lock_unlock, BB_DIR_USR_SBIN, BB_SUID_DROP, flash_lock))
+//                       APPLET_ODDNAME:name          main               location         suid_type     help
+//applet:IF_FLASH_LOCK(  APPLET_ODDNAME(flash_lock,   flash_lock_unlock, BB_DIR_USR_SBIN, BB_SUID_DROP, flash_lock))
 //applet:IF_FLASH_UNLOCK(APPLET_ODDNAME(flash_unlock, flash_lock_unlock, BB_DIR_USR_SBIN, BB_SUID_DROP, flash_unlock))
 
 //kbuild:lib-$(CONFIG_FLASH_LOCK) += flash_lock_unlock.o
diff -urpN busybox-1.26.2/miscutils/hdparm.c busybox-1.27.0/miscutils/hdparm.c
--- busybox-1.26.2/miscutils/hdparm.c	2016-12-10 18:46:36.000000000 +0100
+++ busybox-1.27.0/miscutils/hdparm.c	2017-01-10 16:31:40.000000000 +0100
@@ -25,7 +25,7 @@
 //config:	default y
 //config:	depends on HDPARM
 //config:	help
-//config:	  Enables the -I and -i options to obtain detailed information
+//config:	  Enable the -I and -i options to obtain detailed information
 //config:	  directly from drives about their capabilities and supported ATA
 //config:	  feature set. If no device name is specified, hdparm will read
 //config:	  identify data from stdin. Enabling this option will add about 16k...
@@ -35,7 +35,7 @@
 //config:	default y
 //config:	depends on HDPARM
 //config:	help
-//config:	  Enables the 'hdparm -R' option to register an IDE interface.
+//config:	  Enable the 'hdparm -R' option to register an IDE interface.
 //config:	  This is dangerous stuff, so you should probably say N.
 //config:
 //config:config FEATURE_HDPARM_HDIO_UNREGISTER_HWIF
@@ -43,7 +43,7 @@
 //config:	default y
 //config:	depends on HDPARM
 //config:	help
-//config:	  Enables the 'hdparm -U' option to un-register an IDE interface.
+//config:	  Enable the 'hdparm -U' option to un-register an IDE interface.
 //config:	  This is dangerous stuff, so you should probably say N.
 //config:
 //config:config FEATURE_HDPARM_HDIO_DRIVE_RESET
@@ -51,7 +51,7 @@
 //config:	default y
 //config:	depends on HDPARM
 //config:	help
-//config:	  Enables the 'hdparm -w' option to perform a device reset.
+//config:	  Enable the 'hdparm -w' option to perform a device reset.
 //config:	  This is dangerous stuff, so you should probably say N.
 //config:
 //config:config FEATURE_HDPARM_HDIO_TRISTATE_HWIF
@@ -59,7 +59,7 @@
 //config:	default y
 //config:	depends on HDPARM
 //config:	help
-//config:	  Enables the 'hdparm -x' option to tristate device for hotswap,
+//config:	  Enable the 'hdparm -x' option to tristate device for hotswap,
 //config:	  and the '-b' option to get/set bus state. This is dangerous
 //config:	  stuff, so you should probably say N.
 //config:
@@ -68,7 +68,7 @@
 //config:	default y
 //config:	depends on HDPARM
 //config:	help
-//config:	  Enables the 'hdparm -d' option to get/set using_dma flag.
+//config:	  Enable the 'hdparm -d' option to get/set using_dma flag.
 
 //applet:IF_HDPARM(APPLET(hdparm, BB_DIR_SBIN, BB_SUID_DROP))
 
diff -urpN busybox-1.26.2/miscutils/inotifyd.c busybox-1.27.0/miscutils/inotifyd.c
--- busybox-1.26.2/miscutils/inotifyd.c	2016-12-10 18:46:36.000000000 +0100
+++ busybox-1.27.0/miscutils/inotifyd.c	2017-07-01 22:51:12.000000000 +0200
@@ -12,7 +12,7 @@
  * Use as follows:
  * # inotifyd /user/space/agent dir/or/file/being/watched[:mask] ...
  *
- * When a filesystem event matching the specified mask is occured on specified file (or directory)
+ * When a filesystem event matching the specified mask is occurred on specified file (or directory)
  * a userspace agent is spawned and given the following parameters:
  * $1. actual event(s)
  * $2. file (or directory) name
diff -urpN busybox-1.26.2/miscutils/ionice.c busybox-1.27.0/miscutils/ionice.c
--- busybox-1.26.2/miscutils/ionice.c	2016-12-10 18:46:36.000000000 +0100
+++ busybox-1.27.0/miscutils/ionice.c	1970-01-01 01:00:00.000000000 +0100
@@ -1,115 +0,0 @@
-/* vi: set sw=4 ts=4: */
-/*
- * ionice implementation for busybox based on linux-utils-ng 2.14
- *
- * Copyright (C) 2008 by  <u173034@informatik.uni-oldenburg.de>
- *
- * Licensed under GPLv2 or later, see file LICENSE in this source tree.
- */
-//config:config IONICE
-//config:	bool "ionice"
-//config:	default y
-//config:	select PLATFORM_LINUX
-//config:	help
-//config:	  Set/set program io scheduling class and priority
-//config:	  Requires kernel >= 2.6.13
-
-//applet:IF_IONICE(APPLET(ionice, BB_DIR_BIN, BB_SUID_DROP))
-
-//kbuild:lib-$(CONFIG_IONICE) += ionice.o
-
-//usage:#define ionice_trivial_usage
-//usage:	"[-c 1-3] [-n 0-7] [-p PID] [PROG]"
-//usage:#define ionice_full_usage "\n\n"
-//usage:       "Change I/O priority and class\n"
-//usage:     "\n	-c	Class. 1:realtime 2:best-effort 3:idle"
-//usage:     "\n	-n	Priority"
-
-#include <sys/syscall.h>
-#include <asm/unistd.h>
-#include "libbb.h"
-
-static int ioprio_set(int which, int who, int ioprio)
-{
-	return syscall(SYS_ioprio_set, which, who, ioprio);
-}
-
-static int ioprio_get(int which, int who)
-{
-	return syscall(SYS_ioprio_get, which, who);
-}
-
-enum {
-	IOPRIO_WHO_PROCESS = 1,
-	IOPRIO_WHO_PGRP,
-	IOPRIO_WHO_USER
-};
-
-enum {
-	IOPRIO_CLASS_NONE,
-	IOPRIO_CLASS_RT,
-	IOPRIO_CLASS_BE,
-	IOPRIO_CLASS_IDLE
-};
-
-static const char to_prio[] ALIGN1 = "none\0realtime\0best-effort\0idle";
-
-#define IOPRIO_CLASS_SHIFT      13
-
-int ionice_main(int argc, char **argv) MAIN_EXTERNALLY_VISIBLE;
-int ionice_main(int argc UNUSED_PARAM, char **argv)
-{
-	/* Defaults */
-	int ioclass = 0;
-	int pri = 0;
-	int pid = 0; /* affect own porcess */
-	int opt;
-	enum {
-		OPT_n = 1,
-		OPT_c = 2,
-		OPT_p = 4,
-	};
-
-	/* Numeric params */
-	/* '+': stop at first non-option */
-	opt = getopt32(argv, "+n:+c:+p:+", &pri, &ioclass, &pid);
-	argv += optind;
-
-	if (opt & OPT_c) {
-		if (ioclass > 3)
-			bb_error_msg_and_die("bad class %d", ioclass);
-// Do we need this (compat?)?
-//		if (ioclass == IOPRIO_CLASS_NONE)
-//			ioclass = IOPRIO_CLASS_BE;
-//		if (ioclass == IOPRIO_CLASS_IDLE) {
-//			//if (opt & OPT_n)
-//			//	bb_error_msg("ignoring priority for idle class");
-//			pri = 7;
-//		}
-	}
-
-	if (!(opt & (OPT_n|OPT_c))) {
-		if (!(opt & OPT_p) && *argv)
-			pid = xatoi_positive(*argv);
-
-		pri = ioprio_get(IOPRIO_WHO_PROCESS, pid);
-		if (pri == -1)
-			bb_perror_msg_and_die("ioprio_%cet", 'g');
-
-		ioclass = (pri >> IOPRIO_CLASS_SHIFT) & 0x3;
-		pri &= 0xff;
-		printf((ioclass == IOPRIO_CLASS_IDLE) ? "%s\n" : "%s: prio %d\n",
-				nth_string(to_prio, ioclass), pri);
-	} else {
-//printf("pri=%d class=%d val=%x\n",
-//pri, ioclass, pri | (ioclass << IOPRIO_CLASS_SHIFT));
-		pri |= (ioclass << IOPRIO_CLASS_SHIFT);
-		if (ioprio_set(IOPRIO_WHO_PROCESS, pid, pri) == -1)
-			bb_perror_msg_and_die("ioprio_%cet", 's');
-		if (argv[0]) {
-			BB_EXECVP_or_die(argv);
-		}
-	}
-
-	return EXIT_SUCCESS;
-}
diff -urpN busybox-1.26.2/miscutils/last.c busybox-1.27.0/miscutils/last.c
--- busybox-1.26.2/miscutils/last.c	2016-12-10 18:46:36.000000000 +0100
+++ busybox-1.27.0/miscutils/last.c	1970-01-01 01:00:00.000000000 +0100
@@ -1,166 +0,0 @@
-/* vi: set sw=4 ts=4: */
-/*
- * last implementation for busybox
- *
- * Copyright (C) 2003-2004 by Erik Andersen <andersen@codepoet.org>
- *
- * Licensed under GPLv2, see file LICENSE in this source tree.
- */
-//config:config LAST
-//config:	bool "last"
-//config:	default y
-//config:	depends on FEATURE_WTMP
-//config:	help
-//config:	  'last' displays a list of the last users that logged into the system.
-//config:
-//config:config FEATURE_LAST_FANCY
-//config:	bool "Turn on output of extra information"
-//config:	default y
-//config:	depends on LAST
-//config:	help
-//config:	  'last' displays detailed information about the last users that
-//config:	  logged into the system (mimics sysvinit last). +900 bytes.
-
-//applet:IF_LAST(APPLET(last, BB_DIR_USR_BIN, BB_SUID_DROP))
-
-//kbuild:ifeq ($(CONFIG_FEATURE_LAST_FANCY),y)
-//kbuild:lib-$(CONFIG_FEATURE_LAST_FANCY) += last_fancy.o
-//kbuild:else
-//kbuild:lib-$(CONFIG_LAST) += last.o
-//kbuild:endif
-
-//usage:#define last_trivial_usage
-//usage:       ""IF_FEATURE_LAST_FANCY("[-HW] [-f FILE]")
-//usage:#define last_full_usage "\n\n"
-//usage:       "Show listing of the last users that logged into the system"
-//usage:	IF_FEATURE_LAST_FANCY( "\n"
-/* //usage:  "\n	-H	Show header line" */
-//usage:     "\n	-W	Display with no host column truncation"
-//usage:     "\n	-f FILE Read from FILE instead of /var/log/wtmp"
-//usage:	)
-
-#include "libbb.h"
-
-/* NB: ut_name and ut_user are the same field, use only one name (ut_user)
- * to reduce confusion */
-
-#ifndef SHUTDOWN_TIME
-#  define SHUTDOWN_TIME 254
-#endif
-
-/* Grr... utmp char[] members do not have to be nul-terminated.
- * Do what we can while still keeping this reasonably small.
- * Note: We are assuming the ut_id[] size is fixed at 4. */
-
-#if defined UT_LINESIZE \
-	&& ((UT_LINESIZE != 32) || (UT_NAMESIZE != 32) || (UT_HOSTSIZE != 256))
-#error struct utmpx member char[] size(s) have changed!
-#elif defined __UT_LINESIZE \
-	&& ((__UT_LINESIZE != 32) || (__UT_NAMESIZE != 32) || (__UT_HOSTSIZE != 256))
-/* __UT_NAMESIZE was checked with 64 above, but glibc-2.11 definitely uses 32! */
-#error struct utmpx member char[] size(s) have changed!
-#endif
-
-#if EMPTY != 0 || RUN_LVL != 1 || BOOT_TIME != 2 || NEW_TIME != 3 || \
-	OLD_TIME != 4
-#error Values for the ut_type field of struct utmpx changed
-#endif
-
-int last_main(int argc, char **argv) MAIN_EXTERNALLY_VISIBLE;
-int last_main(int argc UNUSED_PARAM, char **argv UNUSED_PARAM)
-{
-	struct utmpx ut;
-	int n, file = STDIN_FILENO;
-	time_t t_tmp;
-	off_t pos;
-	static const char _ut_usr[] ALIGN1 =
-			"runlevel\0" "reboot\0" "shutdown\0";
-	static const char _ut_lin[] ALIGN1 =
-			"~\0" "{\0" "|\0" /* "LOGIN\0" "date\0" */;
-	enum {
-		TYPE_RUN_LVL = RUN_LVL,         /* 1 */
-		TYPE_BOOT_TIME = BOOT_TIME,     /* 2 */
-		TYPE_SHUTDOWN_TIME = SHUTDOWN_TIME
-	};
-	enum {
-		_TILDE = EMPTY, /* 0 */
-		TYPE_NEW_TIME,  /* NEW_TIME, 3 */
-		TYPE_OLD_TIME   /* OLD_TIME, 4 */
-	};
-
-	if (argv[1]) {
-		bb_show_usage();
-	}
-	file = xopen(bb_path_wtmp_file, O_RDONLY);
-
-	printf("%-10s %-14s %-18s %-12.12s %s\n",
-		"USER", "TTY", "HOST", "LOGIN", "TIME");
-	/* yikes. We reverse over the file and that is a not too elegant way */
-	pos = xlseek(file, 0, SEEK_END);
-	pos = lseek(file, pos - sizeof(ut), SEEK_SET);
-	while ((n = full_read(file, &ut, sizeof(ut))) > 0) {
-		if (n != sizeof(ut)) {
-			bb_perror_msg_and_die("short read");
-		}
-		n = index_in_strings(_ut_lin, ut.ut_line);
-		if (n == _TILDE) { /* '~' */
-#if 1
-/* do we really need to be cautious here? */
-			n = index_in_strings(_ut_usr, ut.ut_user);
-			if (++n > 0)
-				ut.ut_type = n != 3 ? n : SHUTDOWN_TIME;
-#else
-			if (is_prefixed_with(ut.ut_user, "shutdown"))
-				ut.ut_type = SHUTDOWN_TIME;
-			else if (is_prefixed_with(ut.ut_user, "reboot"))
-				ut.ut_type = BOOT_TIME;
-			else if (is_prefixed_with(ut.ut_user, "runlevel"))
-				ut.ut_type = RUN_LVL;
-#endif
-		} else {
-			if (ut.ut_user[0] == '\0' || strcmp(ut.ut_user, "LOGIN") == 0) {
-				/* Don't bother.  This means we can't find how long
-				 * someone was logged in for.  Oh well. */
-				goto next;
-			}
-			if (ut.ut_type != DEAD_PROCESS
-			 && ut.ut_user[0]
-			 && ut.ut_line[0]
-			) {
-				ut.ut_type = USER_PROCESS;
-			}
-			if (strcmp(ut.ut_user, "date") == 0) {
-				if (n == TYPE_OLD_TIME) { /* '|' */
-					ut.ut_type = OLD_TIME;
-				}
-				if (n == TYPE_NEW_TIME) { /* '{' */
-					ut.ut_type = NEW_TIME;
-				}
-			}
-		}
-
-		if (ut.ut_type != USER_PROCESS) {
-			switch (ut.ut_type) {
-				case OLD_TIME:
-				case NEW_TIME:
-				case RUN_LVL:
-				case SHUTDOWN_TIME:
-					goto next;
-				case BOOT_TIME:
-					strcpy(ut.ut_line, "system boot");
-			}
-		}
-		/* manpages say ut_tv.tv_sec *is* time_t,
-		 * but some systems have it wrong */
-		t_tmp = (time_t)ut.ut_tv.tv_sec;
-		printf("%-10s %-14s %-18s %-12.12s\n",
-			ut.ut_user, ut.ut_line, ut.ut_host, ctime(&t_tmp) + 4);
- next:
-		pos -= sizeof(ut);
-		if (pos <= 0)
-			break; /* done. */
-		xlseek(file, pos, SEEK_SET);
-	}
-
-	fflush_stdout_and_exit(EXIT_SUCCESS);
-}
diff -urpN busybox-1.26.2/miscutils/last_fancy.c busybox-1.27.0/miscutils/last_fancy.c
--- busybox-1.26.2/miscutils/last_fancy.c	2016-09-27 18:53:50.000000000 +0200
+++ busybox-1.27.0/miscutils/last_fancy.c	1970-01-01 01:00:00.000000000 +0100
@@ -1,300 +0,0 @@
-/* vi: set sw=4 ts=4: */
-/*
- * (sysvinit like) last implementation
- *
- * Copyright (C) 2008 by Patricia Muscalu <patricia.muscalu@axis.com>
- *
- * Licensed under GPLv2 or later, see file LICENSE in this source tree.
- */
-
-#include "libbb.h"
-
-/* NB: ut_name and ut_user are the same field, use only one name (ut_user)
- * to reduce confusion */
-
-#ifndef SHUTDOWN_TIME
-#  define SHUTDOWN_TIME 254
-#endif
-
-#define HEADER_FORMAT     "%-8.8s %-12.12s %-*.*s %-16.16s %-7.7s %s\n"
-#define HEADER_LINE       "USER", "TTY", \
-	INET_ADDRSTRLEN, INET_ADDRSTRLEN, "HOST", "LOGIN", "  TIME", ""
-#define HEADER_LINE_WIDE  "USER", "TTY", \
-	INET6_ADDRSTRLEN, INET6_ADDRSTRLEN, "HOST", "LOGIN", "  TIME", ""
-
-#if !defined __UT_LINESIZE && defined UT_LINESIZE
-# define __UT_LINESIZE UT_LINESIZE
-#endif
-
-enum {
-	NORMAL,
-	LOGGED,
-	DOWN,
-	REBOOT,
-	CRASH,
-	GONE
-};
-
-enum {
-	LAST_OPT_W = (1 << 0),  /* -W wide            */
-	LAST_OPT_f = (1 << 1),  /* -f input file      */
-	LAST_OPT_H = (1 << 2),  /* -H header          */
-};
-
-#define show_wide (option_mask32 & LAST_OPT_W)
-
-static void show_entry(struct utmpx *ut, int state, time_t dur_secs)
-{
-	unsigned days, hours, mins;
-	char duration[sizeof("(%u+02:02)") + sizeof(int)*3];
-	char login_time[17];
-	char logout_time[8];
-	const char *logout_str;
-	const char *duration_str;
-	time_t tmp;
-
-	/* manpages say ut_tv.tv_sec *is* time_t,
-	 * but some systems have it wrong */
-	tmp = ut->ut_tv.tv_sec;
-	safe_strncpy(login_time, ctime(&tmp), 17);
-	tmp = dur_secs;
-	snprintf(logout_time, 8, "- %s", ctime(&tmp) + 11);
-
-	dur_secs = MAX(dur_secs - (time_t)ut->ut_tv.tv_sec, (time_t)0);
-	/* unsigned int is easier to divide than time_t (which may be signed long) */
-	mins = dur_secs / 60;
-	days = mins / (24*60);
-	mins = mins % (24*60);
-	hours = mins / 60;
-	mins = mins % 60;
-
-//	if (days) {
-		sprintf(duration, "(%u+%02u:%02u)", days, hours, mins);
-//	} else {
-//		sprintf(duration, " (%02u:%02u)", hours, mins);
-//	}
-
-	logout_str = logout_time;
-	duration_str = duration;
-	switch (state) {
-	case NORMAL:
-		break;
-	case LOGGED:
-		logout_str = "  still";
-		duration_str = "logged in";
-		break;
-	case DOWN:
-		logout_str = "- down ";
-		break;
-	case REBOOT:
-		break;
-	case CRASH:
-		logout_str = "- crash";
-		break;
-	case GONE:
-		logout_str = "   gone";
-		duration_str = "- no logout";
-		break;
-	}
-
-	printf(HEADER_FORMAT,
-		ut->ut_user,
-		ut->ut_line,
-		show_wide ? INET6_ADDRSTRLEN : INET_ADDRSTRLEN,
-		show_wide ? INET6_ADDRSTRLEN : INET_ADDRSTRLEN,
-		ut->ut_host,
-		login_time,
-		logout_str,
-		duration_str);
-}
-
-static int get_ut_type(struct utmpx *ut)
-{
-	if (ut->ut_line[0] == '~') {
-		if (strcmp(ut->ut_user, "shutdown") == 0) {
-			return SHUTDOWN_TIME;
-		}
-		if (strcmp(ut->ut_user, "reboot") == 0) {
-			return BOOT_TIME;
-		}
-		if (strcmp(ut->ut_user, "runlevel") == 0) {
-			return RUN_LVL;
-		}
-		return ut->ut_type;
-	}
-
-	if (ut->ut_user[0] == 0) {
-		return DEAD_PROCESS;
-	}
-
-	if ((ut->ut_type != DEAD_PROCESS)
-	 && (strcmp(ut->ut_user, "LOGIN") != 0)
-	 && ut->ut_user[0]
-	 && ut->ut_line[0]
-	) {
-		ut->ut_type = USER_PROCESS;
-	}
-
-	if (strcmp(ut->ut_user, "date") == 0) {
-		if (ut->ut_line[0] == '|') {
-			return OLD_TIME;
-		}
-		if (ut->ut_line[0] == '{') {
-			return NEW_TIME;
-		}
-	}
-	return ut->ut_type;
-}
-
-static int is_runlevel_shutdown(struct utmpx *ut)
-{
-	if (((ut->ut_pid & 255) == '0') || ((ut->ut_pid & 255) == '6')) {
-		return 1;
-	}
-
-	return 0;
-}
-
-int last_main(int argc, char **argv) MAIN_EXTERNALLY_VISIBLE;
-int last_main(int argc UNUSED_PARAM, char **argv)
-{
-	struct utmpx ut;
-	const char *filename = _PATH_WTMP;
-	llist_t *zlist;
-	off_t pos;
-	time_t start_time;
-	time_t boot_time;
-	time_t down_time;
-	int file;
-	smallint going_down;
-	smallint boot_down;
-
-	/*opt =*/ getopt32(argv, "Wf:" /* "H" */, &filename);
-#ifdef BUT_UTIL_LINUX_LAST_HAS_NO_SUCH_OPT
-	if (opt & LAST_OPT_H) {
-		/* Print header line */
-		if (opt & LAST_OPT_W) {
-			printf(HEADER_FORMAT, HEADER_LINE_WIDE);
-		} else {
-			printf(HEADER_FORMAT, HEADER_LINE);
-		}
-	}
-#endif
-
-	file = xopen(filename, O_RDONLY);
-	{
-		/* in case the file is empty... */
-		struct stat st;
-		fstat(file, &st);
-		start_time = st.st_ctime;
-	}
-
-	time(&down_time);
-	going_down = 0;
-	boot_down = NORMAL; /* 0 */
-	zlist = NULL;
-	boot_time = 0;
-	/* get file size, rounding down to last full record */
-	pos = xlseek(file, 0, SEEK_END) / sizeof(ut) * sizeof(ut);
-	for (;;) {
-		pos -= (off_t)sizeof(ut);
-		if (pos < 0) {
-			/* Beyond the beginning of the file boundary =>
-			 * the whole file has been read. */
-			break;
-		}
-		xlseek(file, pos, SEEK_SET);
-		xread(file, &ut, sizeof(ut));
-		/* rewritten by each record, eventially will have
-		 * first record's ut_tv.tv_sec: */
-		start_time = ut.ut_tv.tv_sec;
-
-		switch (get_ut_type(&ut)) {
-		case SHUTDOWN_TIME:
-			down_time = ut.ut_tv.tv_sec;
-			boot_down = DOWN;
-			going_down = 1;
-			break;
-		case RUN_LVL:
-			if (is_runlevel_shutdown(&ut)) {
-				down_time = ut.ut_tv.tv_sec;
-				going_down = 1;
-				boot_down = DOWN;
-			}
-			break;
-		case BOOT_TIME:
-			strcpy(ut.ut_line, "system boot");
-			show_entry(&ut, REBOOT, down_time);
-			boot_down = CRASH;
-			going_down = 1;
-			break;
-		case DEAD_PROCESS:
-			if (!ut.ut_line[0]) {
-				break;
-			}
-			/* add_entry */
-			llist_add_to(&zlist, xmemdup(&ut, sizeof(ut)));
-			break;
-		case USER_PROCESS: {
-			int show;
-
-			if (!ut.ut_line[0]) {
-				break;
-			}
-			/* find_entry */
-			show = 1;
-			{
-				llist_t *el, *next;
-				for (el = zlist; el; el = next) {
-					struct utmpx *up = (struct utmpx *)el->data;
-					next = el->link;
-					if (strncmp(up->ut_line, ut.ut_line, __UT_LINESIZE) == 0) {
-						if (show) {
-							show_entry(&ut, NORMAL, up->ut_tv.tv_sec);
-							show = 0;
-						}
-						llist_unlink(&zlist, el);
-						free(el->data);
-						free(el);
-					}
-				}
-			}
-
-			if (show) {
-				int state = boot_down;
-
-				if (boot_time == 0) {
-					state = LOGGED;
-					/* Check if the process is alive */
-					if ((ut.ut_pid > 0)
-					 && (kill(ut.ut_pid, 0) != 0)
-					 && (errno == ESRCH)) {
-						state = GONE;
-					}
-				}
-				show_entry(&ut, state, boot_time);
-			}
-			/* add_entry */
-			llist_add_to(&zlist, xmemdup(&ut, sizeof(ut)));
-			break;
-		}
-		}
-
-		if (going_down) {
-			boot_time = ut.ut_tv.tv_sec;
-			llist_free(zlist, free);
-			zlist = NULL;
-			going_down = 0;
-		}
-	}
-
-	if (ENABLE_FEATURE_CLEAN_UP) {
-		llist_free(zlist, free);
-	}
-
-	printf("\nwtmp begins %s", ctime(&start_time));
-
-	if (ENABLE_FEATURE_CLEAN_UP)
-		close(file);
-	fflush_stdout_and_exit(EXIT_SUCCESS);
-}
diff -urpN busybox-1.26.2/miscutils/less.c busybox-1.27.0/miscutils/less.c
--- busybox-1.26.2/miscutils/less.c	2016-12-10 18:46:36.000000000 +0100
+++ busybox-1.27.0/miscutils/less.c	2017-07-01 22:51:12.000000000 +0200
@@ -87,7 +87,6 @@
 //config:	  this option makes less perform a last-ditch effort to find it:
 //config:	  position cursor to 999,999 and ask terminal to report real
 //config:	  cursor position using "ESC [ 6 n" escape sequence, then read stdin.
-//config:
 //config:	  This is not clean but helps a lot on serial lines and such.
 //config:
 //config:config FEATURE_LESS_DASHCMD
@@ -99,11 +98,9 @@
 //config:	  less itself ('-' keyboard command).
 //config:
 //config:config FEATURE_LESS_LINENUMS
-//config:	bool "Enable dynamic switching of line numbers"
+//config:	bool "Enable -N (dynamic switching of line numbers)"
 //config:	default y
 //config:	depends on FEATURE_LESS_DASHCMD
-//config:	help
-//config:	  Enables "-N" command.
 
 //applet:IF_LESS(APPLET(less, BB_DIR_USR_BIN, BB_SUID_DROP))
 
@@ -270,7 +267,7 @@ struct globals {
 /* flines[] are lines read from stdin, each in malloc'ed buffer.
  * Line numbers are stored as uint32_t prepended to each line.
  * Pointer is adjusted so that flines[i] points directly past
- * line number. Accesor: */
+ * line number. Accessor: */
 #define MEMPTR(p) ((char*)(p) - 4)
 #define LINENO(p) (*(uint32_t*)((p) - 4))
 
diff -urpN busybox-1.26.2/miscutils/lsscsi.c busybox-1.27.0/miscutils/lsscsi.c
--- busybox-1.26.2/miscutils/lsscsi.c	1970-01-01 01:00:00.000000000 +0100
+++ busybox-1.27.0/miscutils/lsscsi.c	2017-07-01 22:51:12.000000000 +0200
@@ -0,0 +1,123 @@
+/* vi: set sw=4 ts=4: */
+/*
+ * lsscsi implementation for busybox
+ *
+ * Copyright (C) 2017 Markus Gothe <nietzsche@lysator.liu.se>
+ *
+ * Licensed under GPLv2 or later, see file LICENSE in this source tree.
+ */
+//config:config LSSCSI
+//config:	bool "lsscsi"
+//config:	default y
+//config:	#select PLATFORM_LINUX
+//config:	help
+//config:	  lsscsi is a utility for displaying information about SCSI buses in the
+//config:	  system and devices connected to them.
+//config:
+//config:	  This version uses sysfs (/sys/bus/scsi/devices) only.
+
+//applet:IF_LSSCSI(APPLET(lsscsi, BB_DIR_USR_BIN, BB_SUID_DROP))
+
+//kbuild:lib-$(CONFIG_LSSCSI) += lsscsi.o
+
+//usage:#define lsscsi_trivial_usage NOUSAGE_STR
+//usage:#define lsscsi_full_usage ""
+
+#include "libbb.h"
+
+static char *get_line(const char *filename, char *buf, unsigned *bufsize_p)
+{
+	unsigned bufsize = *bufsize_p;
+	ssize_t sz;
+
+	if ((int)(bufsize - 2) <= 0)
+		return buf;
+
+	sz = open_read_close(filename, buf, bufsize - 2);
+	if (sz < 0)
+		sz = 0;
+	buf[sz] = '\0';
+	trim(buf);
+
+	sz = strlen(buf) + 1;
+	bufsize -= sz;
+	buf += sz;
+	buf[0] = '\0';
+
+	*bufsize_p = bufsize;
+	return buf;
+}
+
+int lsscsi_main(int argc, char **argv) MAIN_EXTERNALLY_VISIBLE;
+int lsscsi_main(int argc UNUSED_PARAM, char **argv UNUSED_PARAM)
+{
+	struct dirent *de;
+	DIR *dir;
+
+	xchdir("/sys/bus/scsi/devices");
+
+	dir = xopendir(".");
+	while ((de = readdir(dir)) != NULL) {
+		char buf[256];
+		char *ptr;
+		unsigned bufsize;
+		const char *vendor;
+		const char *type_str;
+		const char *type_name;
+		const char *model;
+		const char *rev;
+		unsigned type;
+
+		if (!isdigit(de->d_name[0]))
+			continue;
+		if (!strchr(de->d_name, ':'))
+			continue;
+		if (chdir(de->d_name) != 0)
+			continue;
+
+		bufsize = sizeof(buf);
+		vendor = buf;
+		ptr = get_line("vendor", buf, &bufsize);
+		type_str = ptr;
+		ptr = get_line("type", ptr, &bufsize);
+		model = ptr;
+		ptr = get_line("model", ptr, &bufsize);
+		rev = ptr;
+		ptr = get_line("rev", ptr, &bufsize);
+
+		printf("[%s]\t", de->d_name);
+
+#define scsi_device_types \
+	"disk\0"    "tape\0"    "printer\0" "process\0" \
+	"worm\0"    "\0"        "scanner\0" "optical\0" \
+	"mediumx\0" "comms\0"   "\0"        "\0"        \
+	"storage\0" "enclosu\0" "sim dsk\0" "opti rd\0" \
+	"bridge\0"  "osd\0"     "adi\0"     "\0"        \
+	"\0"        "\0"        "\0"        "\0"        \
+	"\0"        "\0"        "\0"        "\0"        \
+	"\0"        "\0"        "wlun\0"    "no dev"
+		type = bb_strtou(type_str, NULL, 10);
+		if (errno
+		 || type >= 0x20
+		 || (type_name = nth_string(scsi_device_types, type))[0] == '\0'
+		) {
+			printf("(%s)\t", type_str);
+		} else {
+			printf("%s\t", type_name);
+		}
+
+		printf("%s\t""%s\t""%s\n",
+			vendor,
+			model,
+			rev
+		);
+		/* TODO: also output device column, e.g. "/dev/sdX" */
+
+		xchdir("..");
+	}
+
+	if (ENABLE_FEATURE_CLEAN_UP)
+		closedir(dir);
+
+	return EXIT_SUCCESS;
+}
diff -urpN busybox-1.26.2/miscutils/microcom.c busybox-1.27.0/miscutils/microcom.c
--- busybox-1.26.2/miscutils/microcom.c	2016-12-10 18:46:36.000000000 +0100
+++ busybox-1.27.0/miscutils/microcom.c	2017-01-15 00:18:53.000000000 +0100
@@ -33,6 +33,7 @@
 // set raw tty mode
 static void xget1(int fd, struct termios *t, struct termios *oldt)
 {
+//TODO: use set_termios_to_raw()
 	tcgetattr(fd, oldt);
 	*t = *oldt;
 	cfmakeraw(t);
diff -urpN busybox-1.26.2/miscutils/mountpoint.c busybox-1.27.0/miscutils/mountpoint.c
--- busybox-1.26.2/miscutils/mountpoint.c	2016-12-10 18:46:36.000000000 +0100
+++ busybox-1.27.0/miscutils/mountpoint.c	1970-01-01 01:00:00.000000000 +0100
@@ -1,105 +0,0 @@
-/* vi: set sw=4 ts=4: */
-/*
- * mountpoint implementation for busybox
- *
- * Copyright (C) 2005 Bernhard Reutner-Fischer
- *
- * Licensed under GPLv2 or later, see file LICENSE in this source tree.
- *
- * Based on sysvinit's mountpoint
- */
-//config:config MOUNTPOINT
-//config:	bool "mountpoint"
-//config:	default y
-//config:	help
-//config:	  mountpoint checks if the directory is a mountpoint.
-
-//applet:IF_MOUNTPOINT(APPLET(mountpoint, BB_DIR_BIN, BB_SUID_DROP))
-
-//kbuild:lib-$(CONFIG_MOUNTPOINT) += mountpoint.o
-
-//usage:#define mountpoint_trivial_usage
-//usage:       "[-q] <[-dn] DIR | -x DEVICE>"
-//usage:#define mountpoint_full_usage "\n\n"
-//usage:       "Check if the directory is a mountpoint\n"
-//usage:     "\n	-q	Quiet"
-//usage:     "\n	-d	Print major/minor device number of the filesystem"
-//usage:     "\n	-n	Print device name of the filesystem"
-//usage:     "\n	-x	Print major/minor device number of the blockdevice"
-//usage:
-//usage:#define mountpoint_example_usage
-//usage:       "$ mountpoint /proc\n"
-//usage:       "/proc is not a mountpoint\n"
-//usage:       "$ mountpoint /sys\n"
-//usage:       "/sys is a mountpoint\n"
-
-#include "libbb.h"
-
-int mountpoint_main(int argc, char **argv) MAIN_EXTERNALLY_VISIBLE;
-int mountpoint_main(int argc UNUSED_PARAM, char **argv)
-{
-	struct stat st;
-	const char *msg;
-	char *arg;
-	int rc, opt;
-
-	opt_complementary = "=1"; /* must have one argument */
-	opt = getopt32(argv, "qdxn");
-#define OPT_q (1)
-#define OPT_d (2)
-#define OPT_x (4)
-#define OPT_n (8)
-	arg = argv[optind];
-	msg = "%s";
-
-	rc = (opt & OPT_x) ? stat(arg, &st) : lstat(arg, &st);
-	if (rc != 0)
-		goto err;
-
-	if (opt & OPT_x) {
-		if (S_ISBLK(st.st_mode)) {
-			printf("%u:%u\n", major(st.st_rdev),
-						minor(st.st_rdev));
-			return EXIT_SUCCESS;
-		}
-		errno = 0; /* make perror_msg work as error_msg */
-		msg = "%s: not a block device";
-		goto err;
-	}
-
-	errno = ENOTDIR;
-	if (S_ISDIR(st.st_mode)) {
-		dev_t st_dev = st.st_dev;
-		ino_t st_ino = st.st_ino;
-		char *p = xasprintf("%s/..", arg);
-
-		if (stat(p, &st) == 0) {
-			//int is_mnt = (st_dev != st.st_dev) || (st_dev == st.st_dev && st_ino == st.st_ino);
-			int is_not_mnt = (st_dev == st.st_dev) && (st_ino != st.st_ino);
-
-			if (opt & OPT_d)
-				printf("%u:%u\n", major(st_dev), minor(st_dev));
-			if (opt & OPT_n) {
-				const char *d = find_block_device(arg);
-				/* name is undefined, but device is mounted -> anonymous superblock! */
-				/* happens with btrfs */
-				if (!d) {
-					d = "UNKNOWN";
-					/* TODO: iterate /proc/mounts, or /proc/self/mountinfo
-					 * to find out the device name */
-				}
-				printf("%s %s\n", d, arg);
-			}
-			if (!(opt & (OPT_q | OPT_d | OPT_n)))
-				printf("%s is %sa mountpoint\n", arg, is_not_mnt ? "not " : "");
-			return is_not_mnt;
-		}
-		arg = p;
-		/* else: stat had set errno, just fall through */
-	}
-
- err:
-	if (!(opt & OPT_q))
-		bb_perror_msg(msg, arg);
-	return EXIT_FAILURE;
-}
diff -urpN busybox-1.26.2/miscutils/nandwrite.c busybox-1.27.0/miscutils/nandwrite.c
--- busybox-1.26.2/miscutils/nandwrite.c	2016-09-27 18:53:50.000000000 +0200
+++ busybox-1.27.0/miscutils/nandwrite.c	2017-01-23 01:09:41.000000000 +0100
@@ -37,7 +37,7 @@
 //usage:     "\n	-s ADDR	Start address"
 
 //usage:#define nanddump_trivial_usage
-//usage:	"[-no]" IF_LONG_OPTS(" [--bb=padbad|skipbad]") " [-s ADDR] [-l LEN] [-f FILE] MTD_DEVICE"
+//usage:	"[-no]" IF_LONG_OPTS(" [--bb padbad|skipbad]") " [-s ADDR] [-l LEN] [-f FILE] MTD_DEVICE"
 //usage:#define nanddump_full_usage "\n\n"
 //usage:	"Dump MTD_DEVICE\n"
 //usage:     "\n	-n	Read without ecc"
@@ -46,7 +46,7 @@
 //usage:     "\n	-l LEN	Length"
 //usage:     "\n	-f FILE	Dump to file ('-' for stdout)"
 //usage:     IF_LONG_OPTS(
-//usage:     "\n	--bb=METHOD:"
+//usage:     "\n	--bb METHOD"
 //usage:     "\n		skipbad: skip bad blocks"
 //usage:     "\n		padbad: substitute bad blocks by 0xff (default)"
 //usage:     )
diff -urpN busybox-1.26.2/miscutils/partprobe.c busybox-1.27.0/miscutils/partprobe.c
--- busybox-1.26.2/miscutils/partprobe.c	1970-01-01 01:00:00.000000000 +0100
+++ busybox-1.27.0/miscutils/partprobe.c	2017-07-01 22:51:12.000000000 +0200
@@ -0,0 +1,56 @@
+/* vi: set sw=4 ts=4: */
+/*
+ * Copyright (C) 2017 Denys Vlasenko <vda.linux@googlemail.com>
+ *
+ * Licensed under GPLv2, see file LICENSE in this source tree.
+ */
+//config:config PARTPROBE
+//config:	bool "partprobe"
+//config:	default y
+//config:	select PLATFORM_LINUX
+//config:	help
+//config:	  Ask kernel to rescan partition table.
+
+//applet:IF_PARTPROBE(APPLET(partprobe, BB_DIR_USR_SBIN, BB_SUID_DROP))
+
+//kbuild:lib-$(CONFIG_PARTPROBE) += partprobe.o
+
+#include <linux/fs.h>
+#include "libbb.h"
+#ifndef BLKRRPART
+# define BLKRRPART _IO(0x12,95)
+#endif
+
+//usage:#define partprobe_trivial_usage
+//usage:	"DEVICE..."
+//usage:#define partprobe_full_usage "\n\n"
+//usage:	"Ask kernel to rescan partition table"
+//
+// partprobe (GNU parted) 3.2:
+// -d, --dry-run	Don't update the kernel
+// -s, --summary	Show a summary of devices and their partitions
+
+int partprobe_main(int argc, char **argv) MAIN_EXTERNALLY_VISIBLE;
+int partprobe_main(int argc UNUSED_PARAM, char **argv)
+{
+	getopt32(argv, "");
+	argv += optind;
+
+	/* "partprobe" with no arguments just does nothing */
+
+	while (*argv) {
+		int fd = xopen(*argv, O_RDONLY);
+		/*
+		 * Newer versions of parted scan partition tables themselves and
+		 * use BLKPG ioctl (BLKPG_DEL_PARTITION / BLKPG_ADD_PARTITION)
+		 * since this way kernel does not need to know
+		 * partition table formats.
+		 * We use good old BLKRRPART:
+		 */
+		ioctl_or_perror_and_die(fd, BLKRRPART, NULL, "%s", *argv);
+		close(fd);
+		argv++;
+	}
+
+	return EXIT_SUCCESS;
+}
diff -urpN busybox-1.26.2/miscutils/rx.c busybox-1.27.0/miscutils/rx.c
--- busybox-1.26.2/miscutils/rx.c	2016-12-10 18:46:36.000000000 +0100
+++ busybox-1.27.0/miscutils/rx.c	2017-02-06 21:57:41.000000000 +0100
@@ -94,7 +94,7 @@ static int receive(/*int read_fd, */int
 		int blockBegin;
 		int blockNo, blockNoOnesCompl;
 		int cksum_or_crc;
-		int expected;
+		unsigned expected;
 		int i, j;
 
 		blockBegin = read_byte(timeout);
@@ -263,6 +263,7 @@ int rx_main(int argc UNUSED_PARAM, char
 
 	termios_err = tcgetattr(read_fd, &tty);
 	if (termios_err == 0) {
+//TODO: use set_termios_to_raw()
 		orig_tty = tty;
 		cfmakeraw(&tty);
 		tcsetattr(read_fd, TCSAFLUSH, &tty);
diff -urpN busybox-1.26.2/miscutils/setsid.c busybox-1.27.0/miscutils/setsid.c
--- busybox-1.26.2/miscutils/setsid.c	2016-12-10 18:46:36.000000000 +0100
+++ busybox-1.27.0/miscutils/setsid.c	1970-01-01 01:00:00.000000000 +0100
@@ -1,82 +0,0 @@
-/* vi: set sw=4 ts=4: */
-/*
- * setsid.c -- execute a command in a new session
- * Rick Sladkey <jrs@world.std.com>
- * In the public domain.
- *
- * 1999-02-22 Arkadiusz Mickiewicz <misiek@pld.ORG.PL>
- * - added Native Language Support
- *
- * 2001-01-18 John Fremlin <vii@penguinpowered.com>
- * - fork in case we are process group leader
- *
- * 2004-11-12 Paul Fox
- * - busyboxed
- */
-//config:config SETSID
-//config:	bool "setsid"
-//config:	default y
-//config:	help
-//config:	  setsid runs a program in a new session
-
-//applet:IF_SETSID(APPLET(setsid, BB_DIR_USR_BIN, BB_SUID_DROP))
-
-//kbuild:lib-$(CONFIG_SETSID) += setsid.o
-
-//usage:#define setsid_trivial_usage
-//usage:       "[-c] PROG ARGS"
-//usage:#define setsid_full_usage "\n\n"
-//usage:       "Run PROG in a new session. PROG will have no controlling terminal\n"
-//usage:       "and will not be affected by keyboard signals (^C etc).\n"
-//usage:     "\n	-c	Set controlling terminal to stdin"
-
-#include "libbb.h"
-
-int setsid_main(int argc, char **argv) MAIN_EXTERNALLY_VISIBLE;
-int setsid_main(int argc UNUSED_PARAM, char **argv)
-{
-	unsigned opt;
-
-	opt_complementary = "-1"; /* at least one arg */
-	opt = getopt32(argv, "+c"); /* +: stop on first non-opt */
-	argv += optind;
-
-	/* setsid() is allowed only when we are not a process group leader.
-	 * Otherwise our PID serves as PGID of some existing process group
-	 * and cannot be used as PGID of a new process group.
-	 *
-	 * Example: setsid() below fails when run alone in interactive shell:
-	 *  $ setsid PROG
-	 * because shell's child (setsid) is put in a new process group.
-	 * But doesn't fail if shell is not interactive
-	 * (and therefore doesn't create process groups for pipes),
-	 * or if setsid is not the first process in the process group:
-	 *  $ true | setsid PROG
-	 * or if setsid is executed in backquotes (`setsid PROG`)...
-	 */
-	if (setsid() < 0) {
-		pid_t pid = fork_or_rexec(argv);
-		if (pid != 0) {
-			/* parent */
-			/* TODO:
-			 * we can waitpid(pid, &status, 0) and then even
-			 * emulate exitcode, making the behavior consistent
-			 * in both forked and non forked cases.
-			 * However, the code is larger and upstream
-			 * does not do such trick.
-			 */
-			return EXIT_SUCCESS;
-		}
-
-		/* child */
-		/* now there should be no error: */
-		setsid();
-	}
-
-	if (opt) {
-		/* -c: set (with stealing) controlling tty */
-		ioctl(0, TIOCSCTTY, 1);
-	}
-
-	BB_EXECVP_or_die(argv);
-}
diff -urpN busybox-1.26.2/miscutils/taskset.c busybox-1.27.0/miscutils/taskset.c
--- busybox-1.26.2/miscutils/taskset.c	2016-09-27 18:53:50.000000000 +0200
+++ busybox-1.27.0/miscutils/taskset.c	1970-01-01 01:00:00.000000000 +0100
@@ -1,222 +0,0 @@
-/* vi: set sw=4 ts=4: */
-/*
- * taskset - retrieve or set a processes' CPU affinity
- * Copyright (c) 2006 Bernhard Reutner-Fischer
- *
- * Licensed under GPLv2 or later, see file LICENSE in this source tree.
- */
-
-//config:config TASKSET
-//config:	bool "taskset"
-//config:	default n  # doesn't build on some non-x86 targets (m68k)
-//config:	help
-//config:	  Retrieve or set a processes's CPU affinity.
-//config:	  This requires sched_{g,s}etaffinity support in your libc.
-//config:
-//config:config FEATURE_TASKSET_FANCY
-//config:	bool "Fancy output"
-//config:	default y
-//config:	depends on TASKSET
-//config:	help
-//config:	  Add code for fancy output. This merely silences a compiler-warning
-//config:	  and adds about 135 Bytes. May be needed for machines with alot
-//config:	  of CPUs.
-
-//applet:IF_TASKSET(APPLET(taskset, BB_DIR_USR_BIN, BB_SUID_DROP))
-//kbuild:lib-$(CONFIG_TASKSET) += taskset.o
-
-//usage:#define taskset_trivial_usage
-//usage:       "[-p] [MASK] [PID | PROG ARGS]"
-//usage:#define taskset_full_usage "\n\n"
-//usage:       "Set or get CPU affinity\n"
-//usage:     "\n	-p	Operate on an existing PID"
-//usage:
-//usage:#define taskset_example_usage
-//usage:       "$ taskset 0x7 ./dgemm_test&\n"
-//usage:       "$ taskset -p 0x1 $!\n"
-//usage:       "pid 4790's current affinity mask: 7\n"
-//usage:       "pid 4790's new affinity mask: 1\n"
-//usage:       "$ taskset 0x7 /bin/sh -c './taskset -p 0x1 $$'\n"
-//usage:       "pid 6671's current affinity mask: 1\n"
-//usage:       "pid 6671's new affinity mask: 1\n"
-//usage:       "$ taskset -p 1\n"
-//usage:       "pid 1's current affinity mask: 3\n"
-/*
- Not yet implemented:
- * -a/--all-tasks (affect all threads)
- * -c/--cpu-list  (specify CPUs via "1,3,5-7")
- */
-
-#include <sched.h>
-#include "libbb.h"
-
-#if ENABLE_FEATURE_TASKSET_FANCY
-#define TASKSET_PRINTF_MASK "%s"
-/* craft a string from the mask */
-static char *from_cpuset(cpu_set_t *mask)
-{
-	int i;
-	char *ret = NULL;
-	char *str = xzalloc((CPU_SETSIZE / 4) + 1); /* we will leak it */
-
-	for (i = CPU_SETSIZE - 4; i >= 0; i -= 4) {
-		int val = 0;
-		int off;
-		for (off = 0; off <= 3; ++off)
-			if (CPU_ISSET(i + off, mask))
-				val |= 1 << off;
-		if (!ret && val)
-			ret = str;
-		*str++ = bb_hexdigits_upcase[val] | 0x20;
-	}
-	return ret;
-}
-#else
-#define TASKSET_PRINTF_MASK "%llx"
-static unsigned long long from_cpuset(cpu_set_t *mask)
-{
-	BUILD_BUG_ON(CPU_SETSIZE < 8*sizeof(int));
-
-	/* Take the least significant bits. Assume cpu_set_t is
-	 * implemented as an array of unsigned long or unsigned
-	 * int.
-	 */
-	if (CPU_SETSIZE < 8*sizeof(long))
-		return *(unsigned*)mask;
-	if (CPU_SETSIZE < 8*sizeof(long long))
-		return *(unsigned long*)mask;
-# if BB_BIG_ENDIAN
-	if (sizeof(long long) > sizeof(long)) {
-		/* We can put two long in the long long, but they have to
-		 * be swapped: the least significant word comes first in the
-		 * array */
-		unsigned long *p = (void*)mask;
-		return p[0] + ((unsigned long long)p[1] << (8*sizeof(long)));
-	}
-# endif
-	return *(unsigned long long*)mask;
-}
-#endif
-
-
-int taskset_main(int argc, char **argv) MAIN_EXTERNALLY_VISIBLE;
-int taskset_main(int argc UNUSED_PARAM, char **argv)
-{
-	cpu_set_t mask;
-	pid_t pid = 0;
-	unsigned opt_p;
-	const char *current_new;
-	char *pid_str;
-	char *aff = aff; /* for compiler */
-
-	/* NB: we mimic util-linux's taskset: -p does not take
-	 * an argument, i.e., "-pN" is NOT valid, only "-p N"!
-	 * Indeed, util-linux-2.13-pre7 uses:
-	 * getopt_long(argc, argv, "+pchV", ...), not "...p:..." */
-
-	opt_complementary = "-1"; /* at least 1 arg */
-	opt_p = getopt32(argv, "+p");
-	argv += optind;
-
-	if (opt_p) {
-		pid_str = *argv++;
-		if (*argv) { /* "-p <aff> <pid> ...rest.is.ignored..." */
-			aff = pid_str;
-			pid_str = *argv; /* NB: *argv != NULL in this case */
-		}
-		/* else it was just "-p <pid>", and *argv == NULL */
-		pid = xatoul_range(pid_str, 1, ((unsigned)(pid_t)ULONG_MAX) >> 1);
-	} else {
-		aff = *argv++; /* <aff> <cmd...> */
-		if (!*argv)
-			bb_show_usage();
-	}
-
-	current_new = "current\0new";
-	if (opt_p) {
- print_aff:
-		if (sched_getaffinity(pid, sizeof(mask), &mask) < 0)
-			bb_perror_msg_and_die("can't %cet pid %d's affinity", 'g', pid);
-		printf("pid %d's %s affinity mask: "TASKSET_PRINTF_MASK"\n",
-				pid, current_new, from_cpuset(&mask));
-		if (!*argv) {
-			/* Either it was just "-p <pid>",
-			 * or it was "-p <aff> <pid>" and we came here
-			 * for the second time (see goto below) */
-			return EXIT_SUCCESS;
-		}
-		*argv = NULL;
-		current_new += 8; /* "new" */
-	}
-
-	/* Affinity was specified, translate it into cpu_set_t */
-	CPU_ZERO(&mask);
-	if (!ENABLE_FEATURE_TASKSET_FANCY) {
-		unsigned i;
-		unsigned long long m;
-
-		/* Do not allow zero mask: */
-		m = xstrtoull_range(aff, 0, 1, ULLONG_MAX);
-		i = 0;
-		do {
-			if (m & 1)
-				CPU_SET(i, &mask);
-			i++;
-			m >>= 1;
-		} while (m != 0);
-	} else {
-		unsigned i;
-		char *last_byte;
-		char *bin;
-		uint8_t bit_in_byte;
-
-		/* Cheap way to get "long enough" buffer */
-		bin = xstrdup(aff);
-
-		if (aff[0] != '0' || (aff[1]|0x20) != 'x') {
-/* TODO: decimal/octal masks are still limited to 2^64 */
-			unsigned long long m = xstrtoull_range(aff, 0, 1, ULLONG_MAX);
-			bin += strlen(bin);
-			last_byte = bin - 1;
-			while (m) {
-				*--bin = m & 0xff;
-				m >>= 8;
-			}
-		} else {
-			/* aff is "0x.....", we accept very long masks in this form */
-			last_byte = hex2bin(bin, aff + 2, INT_MAX);
-			if (!last_byte) {
- bad_aff:
-				bb_error_msg_and_die("bad affinity '%s'", aff);
-			}
-			last_byte--; /* now points to the last byte */
-		}
-
-		i = 0;
-		bit_in_byte = 1;
-		while (last_byte >= bin) {
-			if (bit_in_byte & *last_byte) {
-				if (i >= CPU_SETSIZE)
-					goto bad_aff;
-				CPU_SET(i, &mask);
-				//bb_error_msg("bit %d set", i);
-			}
-			i++;
-			/* bit_in_byte is uint8_t! & 0xff is implied */
-			bit_in_byte = (bit_in_byte << 1);
-			if (!bit_in_byte) {
-				bit_in_byte = 1;
-				last_byte--;
-			}
-		}
-	}
-
-	/* Set pid's or our own (pid==0) affinity */
-	if (sched_setaffinity(pid, sizeof(mask), &mask))
-		bb_perror_msg_and_die("can't %cet pid %d's affinity", 's', pid);
-
-	if (!argv[0]) /* "-p <aff> <pid> [...ignored...]" */
-		goto print_aff; /* print new affinity and exit */
-
-	BB_EXECVP_or_die(argv);
-}
diff -urpN busybox-1.26.2/miscutils/time.c busybox-1.27.0/miscutils/time.c
--- busybox-1.26.2/miscutils/time.c	2016-12-10 18:46:36.000000000 +0100
+++ busybox-1.27.0/miscutils/time.c	2017-07-01 22:51:12.000000000 +0200
@@ -21,10 +21,14 @@
 //kbuild:lib-$(CONFIG_TIME) += time.o
 
 //usage:#define time_trivial_usage
-//usage:       "[-v] PROG ARGS"
+//usage:       "[-vpa] [-o FILE] PROG ARGS"
 //usage:#define time_full_usage "\n\n"
 //usage:       "Run PROG, display resource usage when it exits\n"
 //usage:     "\n	-v	Verbose"
+//usage:     "\n	-p	POSIX output format"
+//usage:     "\n	-f FMT	Custom format"
+//usage:     "\n	-o FILE	Write result to FILE"
+//usage:     "\n	-a	Append (else overwrite)"
 
 #include "libbb.h"
 #include <sys/resource.h> /* getrusage */
@@ -397,7 +401,7 @@ static void run_command(char *const *cmd
 	}
 
 	/* Have signals kill the child but not self (if possible).  */
-//TODO: just block all sigs? and reenable them in the very end in main?
+//TODO: just block all sigs? and re-enable them in the very end in main?
 	interrupt_signal = signal(SIGINT, SIG_IGN);
 	quit_signal = signal(SIGQUIT, SIG_IGN);
 
@@ -412,29 +416,50 @@ int time_main(int argc, char **argv) MAI
 int time_main(int argc UNUSED_PARAM, char **argv)
 {
 	resource_t res;
-	const char *output_format = default_format;
+	/* $TIME has lowest prio (-v,-p,-f FMT overrride it) */
+	const char *output_format = getenv("TIME") ? : default_format;
+	char *output_filename;
+	int output_fd;
 	int opt;
+	int ex;
+	enum {
+		OPT_v = (1 << 0),
+		OPT_p = (1 << 1),
+		OPT_a = (1 << 2),
+		OPT_o = (1 << 3),
+		OPT_f = (1 << 4),
+	};
 
 	opt_complementary = "-1"; /* at least one arg */
 	/* "+": stop on first non-option */
-	opt = getopt32(argv, "+vp");
+	opt = getopt32(argv, "+vpao:f:", &output_filename, &output_format);
 	argv += optind;
-	if (opt & 1)
+	if (opt & OPT_v)
 		output_format = long_format;
-	if (opt & 2)
+	if (opt & OPT_p)
 		output_format = posix_format;
+	output_fd = STDERR_FILENO;
+	if (opt & OPT_o) {
+		output_fd = xopen(output_filename,
+			(opt & OPT_a) /* append? */
+			? (O_CREAT | O_WRONLY | O_CLOEXEC | O_APPEND)
+			: (O_CREAT | O_WRONLY | O_CLOEXEC | O_TRUNC)
+		);
+	}
 
 	run_command(argv, &res);
 
 	/* Cheat. printf's are shorter :) */
-	xdup2(STDERR_FILENO, STDOUT_FILENO);
+	xdup2(output_fd, STDOUT_FILENO);
 	summarize(output_format, argv, &res);
 
+	ex = WEXITSTATUS(res.waitstatus);
+	/* Impossible: we do not use WUNTRACED flag in wait()...
 	if (WIFSTOPPED(res.waitstatus))
-		return WSTOPSIG(res.waitstatus);
+		ex = WSTOPSIG(res.waitstatus);
+	*/
 	if (WIFSIGNALED(res.waitstatus))
-		return WTERMSIG(res.waitstatus);
-	if (WIFEXITED(res.waitstatus))
-		return WEXITSTATUS(res.waitstatus);
-	fflush_stdout_and_exit(EXIT_SUCCESS);
+		ex = WTERMSIG(res.waitstatus);
+
+	fflush_stdout_and_exit(ex);
 }
diff -urpN busybox-1.26.2/miscutils/timeout.c busybox-1.27.0/miscutils/timeout.c
--- busybox-1.26.2/miscutils/timeout.c	2016-12-10 18:46:36.000000000 +0100
+++ busybox-1.27.0/miscutils/timeout.c	1970-01-01 01:00:00.000000000 +0100
@@ -1,127 +0,0 @@
-/* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
- * COPYING NOTES
- *
- * timeout.c -- a timeout handler for shell commands
- *
- * Copyright (C) 2005-6, Roberto A. Foglietta <me@roberto.foglietta.name>
- *
- *   This program is free software; you can redistribute it and/or modify
- *   it under the terms of the GNU General Public License as published by
- *   the Free Software Foundation; version 2 of the License.
- *
- *   This program is distributed in the hope that it will be useful,
- *   but WITHOUT ANY WARRANTY; without even the implied warranty of
- *   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- *   GNU General Public License for more details.
- *
- *   You should have received a copy of the GNU General Public License
- *   along with this program; if not, write to the Free Software
- *   Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307, USA.
- */
-/* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
- * REVISION NOTES:
- * released 17-11-2005 by Roberto A. Foglietta
- * talarm   04-12-2005 by Roberto A. Foglietta
- * modified 05-12-2005 by Roberto A. Foglietta
- * sizerdct 06-12-2005 by Roberto A. Foglietta
- * splitszf 12-05-2006 by Roberto A. Foglietta
- * rewrite  14-11-2008 vda
- */
-//config:config TIMEOUT
-//config:	bool "timeout"
-//config:	default y
-//config:	help
-//config:	  Runs a program and watches it. If it does not terminate in
-//config:	  specified number of seconds, it is sent a signal.
-
-//applet:IF_TIMEOUT(APPLET(timeout, BB_DIR_USR_BIN, BB_SUID_DROP))
-
-//kbuild:lib-$(CONFIG_TIMEOUT) += timeout.o
-
-//usage:#define timeout_trivial_usage
-//usage:       "[-t SECS] [-s SIG] PROG ARGS"
-//usage:#define timeout_full_usage "\n\n"
-//usage:       "Runs PROG. Sends SIG to it if it is not gone in SECS seconds.\n"
-//usage:       "Defaults: SECS: 10, SIG: TERM."
-
-#include "libbb.h"
-
-int timeout_main(int argc, char **argv) MAIN_EXTERNALLY_VISIBLE;
-int timeout_main(int argc UNUSED_PARAM, char **argv)
-{
-	int signo;
-	int status;
-	int parent = 0;
-	int timeout = 10;
-	pid_t pid;
-#if !BB_MMU
-	char *sv1, *sv2;
-#endif
-	const char *opt_s = "TERM";
-
-	/* -p option is not documented, it is needed to support NOMMU. */
-
-	/* -t SECONDS; -p PARENT_PID */
-	/* '+': stop at first non-option */
-	getopt32(argv, "+s:t:+" USE_FOR_NOMMU("p:+"), &opt_s, &timeout, &parent);
-	/*argv += optind; - no, wait for bb_daemonize_or_rexec! */
-	signo = get_signum(opt_s);
-	if (signo < 0)
-		bb_error_msg_and_die("unknown signal '%s'", opt_s);
-
-	/* We want to create a grandchild which will watch
-	 * and kill the grandparent. Other methods:
-	 * making parent watch child disrupts parent<->child link
-	 * (example: "tcpsvd 0.0.0.0 1234 timeout service_prog" -
-	 * it's better if service_prog is a child of tcpsvd!),
-	 * making child watch parent results in programs having
-	 * unexpected children. */
-
-	if (parent) /* we were re-execed, already grandchild */
-		goto grandchild;
-	if (!argv[optind]) /* no PROG? */
-		bb_show_usage();
-
-#if !BB_MMU
-	sv1 = argv[optind];
-	sv2 = argv[optind + 1];
-#endif
-	pid = xvfork();
-	if (pid == 0) {
-		/* Child: spawn grandchild and exit */
-		parent = getppid();
-#if !BB_MMU
-		argv[optind] = xasprintf("-p%u", parent);
-		argv[optind + 1] = NULL;
-#endif
-		/* NB: exits with nonzero on error: */
-		bb_daemonize_or_rexec(0, argv);
-		/* Here we are grandchild. Sleep, then kill grandparent */
- grandchild:
-		/* Just sleep(HUGE_NUM); kill(parent) may kill wrong process! */
-		while (1) {
-			sleep(1);
-			if (--timeout <= 0)
-				break;
-			if (kill(parent, 0)) {
-				/* process is gone */
-				return EXIT_SUCCESS;
-			}
-		}
-		kill(parent, signo);
-		return EXIT_SUCCESS;
-	}
-
-	/* Parent */
-	wait(&status); /* wait for child to die */
-	/* Did intermediate [v]fork or exec fail? */
-	if (!WIFEXITED(status) || WEXITSTATUS(status) != 0)
-		return EXIT_FAILURE;
-	/* Ok, exec a program as requested */
-	argv += optind;
-#if !BB_MMU
-	argv[0] = sv1;
-	argv[1] = sv2;
-#endif
-	BB_EXECVP_or_die(argv);
-}
diff -urpN busybox-1.26.2/miscutils/ubi_tools.c busybox-1.27.0/miscutils/ubi_tools.c
--- busybox-1.26.2/miscutils/ubi_tools.c	2016-09-27 18:53:50.000000000 +0200
+++ busybox-1.27.0/miscutils/ubi_tools.c	2017-01-30 21:57:30.000000000 +0100
@@ -45,11 +45,12 @@
 //config:	help
 //config:	  Update a UBI volume.
 
-//applet:IF_UBIATTACH(APPLET_ODDNAME(ubiattach, ubi_tools, BB_DIR_USR_SBIN, BB_SUID_DROP, ubiattach))
-//applet:IF_UBIDETACH(APPLET_ODDNAME(ubidetach, ubi_tools, BB_DIR_USR_SBIN, BB_SUID_DROP, ubidetach))
-//applet:IF_UBIMKVOL(APPLET_ODDNAME(ubimkvol, ubi_tools, BB_DIR_USR_SBIN, BB_SUID_DROP, ubimkvol))
-//applet:IF_UBIRMVOL(APPLET_ODDNAME(ubirmvol, ubi_tools, BB_DIR_USR_SBIN, BB_SUID_DROP, ubirmvol))
-//applet:IF_UBIRSVOL(APPLET_ODDNAME(ubirsvol, ubi_tools, BB_DIR_USR_SBIN, BB_SUID_DROP, ubirsvol))
+//                       APPLET_ODDNAME:name       main       location         suid_type     help
+//applet:IF_UBIATTACH(   APPLET_ODDNAME(ubiattach, ubi_tools, BB_DIR_USR_SBIN, BB_SUID_DROP, ubiattach))
+//applet:IF_UBIDETACH(   APPLET_ODDNAME(ubidetach, ubi_tools, BB_DIR_USR_SBIN, BB_SUID_DROP, ubidetach))
+//applet:IF_UBIMKVOL(    APPLET_ODDNAME(ubimkvol,  ubi_tools, BB_DIR_USR_SBIN, BB_SUID_DROP, ubimkvol))
+//applet:IF_UBIRMVOL(    APPLET_ODDNAME(ubirmvol,  ubi_tools, BB_DIR_USR_SBIN, BB_SUID_DROP, ubirmvol))
+//applet:IF_UBIRSVOL(    APPLET_ODDNAME(ubirsvol,  ubi_tools, BB_DIR_USR_SBIN, BB_SUID_DROP, ubirsvol))
 //applet:IF_UBIUPDATEVOL(APPLET_ODDNAME(ubiupdatevol, ubi_tools, BB_DIR_USR_SBIN, BB_SUID_DROP, ubiupdatevol))
 
 //kbuild:lib-$(CONFIG_UBIATTACH) += ubi_tools.o
diff -urpN busybox-1.26.2/miscutils/wall.c busybox-1.27.0/miscutils/wall.c
--- busybox-1.26.2/miscutils/wall.c	2016-09-27 18:53:50.000000000 +0200
+++ busybox-1.27.0/miscutils/wall.c	1970-01-01 01:00:00.000000000 +0100
@@ -1,63 +0,0 @@
-/* vi: set sw=4 ts=4: */
-/*
- * wall - write a message to all logged-in users
- * Copyright (c) 2009 Bernhard Reutner-Fischer
- *
- * Licensed under GPLv2 or later, see file LICENSE in this source tree.
- */
-
-//config:config WALL
-//config:	bool "wall"
-//config:	default y
-//config:	depends on FEATURE_UTMP
-//config:	help
-//config:	  Write a message to all users that are logged in.
-
-/* Needs to be run by root or be suid root - needs to write to /dev/TTY: */
-//applet:IF_WALL(APPLET(wall, BB_DIR_USR_BIN, BB_SUID_REQUIRE))
-
-//kbuild:lib-$(CONFIG_WALL) += wall.o
-
-//usage:#define wall_trivial_usage
-//usage:	"[FILE]"
-//usage:#define wall_full_usage "\n\n"
-//usage:	"Write content of FILE or stdin to all logged-in users"
-//usage:
-//usage:#define wall_sample_usage
-//usage:	"echo foo | wall\n"
-//usage:	"wall ./mymessage"
-
-#include "libbb.h"
-
-int wall_main(int argc, char **argv) MAIN_EXTERNALLY_VISIBLE;
-int wall_main(int argc UNUSED_PARAM, char **argv)
-{
-	struct utmpx *ut;
-	char *msg;
-	int fd;
-
-	fd = STDIN_FILENO;
-	if (argv[1]) {
-		/* The applet is setuid.
-		 * Access to the file must be under user's uid/gid.
-		 */
-		fd = xopen_as_uid_gid(argv[1], O_RDONLY, getuid(), getgid());
-	}
-	msg = xmalloc_read(fd, NULL);
-	if (ENABLE_FEATURE_CLEAN_UP && argv[1])
-		close(fd);
-	setutxent();
-	while ((ut = getutxent()) != NULL) {
-		char *line;
-		if (ut->ut_type != USER_PROCESS)
-			continue;
-		line = concat_path_file("/dev", ut->ut_line);
-		xopen_xwrite_close(line, msg);
-		free(line);
-	}
-	if (ENABLE_FEATURE_CLEAN_UP) {
-		endutxent();
-		free(msg);
-	}
-	return EXIT_SUCCESS;
-}
diff -urpN busybox-1.26.2/modutils/Config.src busybox-1.27.0/modutils/Config.src
--- busybox-1.26.2/modutils/Config.src	2017-01-01 13:01:04.000000000 +0100
+++ busybox-1.27.0/modutils/Config.src	2017-07-01 22:51:12.000000000 +0200
@@ -8,9 +8,11 @@ menu "Linux Module Utilities"
 config MODPROBE_SMALL
 	bool "Simplified modutils"
 	default y
-	select PLATFORM_LINUX
 	help
-	  Simplified modutils.
+	  Build smaller (~1.5 kbytes), simplified module tools.
+
+	  This option by itself does not enable any applets -
+	  you need to select applets individually below.
 
 	  With this option modprobe does not require modules.dep file
 	  and does not use /etc/modules.conf file.
@@ -31,47 +33,38 @@ config MODPROBE_SMALL
 	  Additional module parameters can be stored in
 	  /etc/modules/$module_name files.
 
-	  Apart from modprobe, other utilities are also provided:
-	  - insmod is an alias to modprobe
-	  - rmmod is an alias to modprobe -r
-	  - depmod generates modules.dep.bb
-
 INSERT
 
 comment "Options common to multiple modutils"
 
+config FEATURE_CMDLINE_MODULE_OPTIONS
+	bool "Accept module options on modprobe command line"
+	default y
+	depends on INSMOD || MODPROBE
+	help
+	  Allow insmod and modprobe take module options from the applets'
+	  command line.
+
+config FEATURE_MODPROBE_SMALL_CHECK_ALREADY_LOADED
+	bool "Skip loading of already loaded modules"
+	default y
+	depends on MODPROBE_SMALL && (DEPMOD || INSMOD || MODPROBE)
+	help
+	  Check if the module is already loaded.
+
 config FEATURE_2_4_MODULES
 	bool "Support version 2.2/2.4 Linux kernels"
 	default n
-	depends on INSMOD || RMMOD || LSMOD
-	select PLATFORM_LINUX
+	depends on (INSMOD || LSMOD || MODPROBE || RMMOD) && !MODPROBE_SMALL
 	help
 	  Support module loading for 2.2.x and 2.4.x Linux kernels.
 	  This increases size considerably. Say N unless you plan
 	  to run ancient kernels.
 
-config FEATURE_INSMOD_TRY_MMAP
-	bool "Try to load module from a mmap'ed area"
-	default n
-	depends on INSMOD || MODPROBE_SMALL
-	select PLATFORM_LINUX
-	help
-	  This option causes module loading code to try to mmap
-	  module first. If it does not work (for example,
-	  it does not work for compressed modules), module will be read
-	  (and unpacked if needed) into a memory block allocated by malloc.
-
-	  The only case when mmap works but malloc does not is when
-	  you are trying to load a big module on a very memory-constrained
-	  machine. Malloc will momentarily need 2x as much memory as mmap.
-
-	  Choosing N saves about 250 bytes of code (on 32-bit x86).
-
 config FEATURE_INSMOD_VERSION_CHECKING
 	bool "Enable module version checking"
 	default n
 	depends on FEATURE_2_4_MODULES && (INSMOD || MODPROBE)
-	select PLATFORM_LINUX
 	help
 	  Support checking of versions for modules. This is used to
 	  ensure that the kernel and module are made for each other.
@@ -80,10 +73,9 @@ config FEATURE_INSMOD_KSYMOOPS_SYMBOLS
 	bool "Add module symbols to kernel symbol table"
 	default n
 	depends on FEATURE_2_4_MODULES && (INSMOD || MODPROBE)
-	select PLATFORM_LINUX
 	help
 	  By adding module symbols to the kernel symbol table, Oops messages
-	  occuring within kernel modules can be properly debugged. By enabling
+	  occurring within kernel modules can be properly debugged. By enabling
 	  this feature, module symbols will always be added to the kernel symbol
 	  table for proper debugging support. If you are not interested in
 	  Oops messages from kernel modules, say N.
@@ -92,7 +84,6 @@ config FEATURE_INSMOD_LOADINKMEM
 	bool "In kernel memory optimization (uClinux only)"
 	default n
 	depends on FEATURE_2_4_MODULES && (INSMOD || MODPROBE)
-	select PLATFORM_LINUX
 	help
 	  This is a special uClinux only memory optimization that lets insmod
 	  load the specified kernel module directly into kernel space, reducing
@@ -103,7 +94,6 @@ config FEATURE_INSMOD_LOAD_MAP
 	bool "Enable insmod load map (-m) option"
 	default n
 	depends on FEATURE_2_4_MODULES && INSMOD
-	select PLATFORM_LINUX
 	help
 	  Enabling this, one would be able to get a load map
 	  output on stdout. This makes kernel module debugging
@@ -114,8 +104,7 @@ config FEATURE_INSMOD_LOAD_MAP
 config FEATURE_INSMOD_LOAD_MAP_FULL
 	bool "Symbols in load map"
 	default y
-	depends on FEATURE_INSMOD_LOAD_MAP && !MODPROBE_SMALL
-	select PLATFORM_LINUX
+	depends on FEATURE_INSMOD_LOAD_MAP
 	help
 	  Without this option, -m will only output section
 	  load map. With this option, -m will also output
@@ -125,18 +114,32 @@ config FEATURE_CHECK_TAINTED_MODULE
 	bool "Support tainted module checking with new kernels"
 	default y
 	depends on (LSMOD || FEATURE_2_4_MODULES) && !MODPROBE_SMALL
-	select PLATFORM_LINUX
 	help
 	  Support checking for tainted modules. These are usually binary
 	  only modules that will make the linux-kernel list ignore your
 	  support request.
 	  This option is required to support GPLONLY modules.
 
+config FEATURE_INSMOD_TRY_MMAP
+	bool "Try to load module from a mmap'ed area"
+	default n
+	depends on (INSMOD || MODPROBE) && !MODPROBE_SMALL
+	help
+	  This option causes module loading code to try to mmap
+	  module first. If it does not work (for example,
+	  it does not work for compressed modules), module will be read
+	  (and unpacked if needed) into a memory block allocated by malloc.
+
+	  The only case when mmap works but malloc does not is when
+	  you are trying to load a big module on a very memory-constrained
+	  machine. Malloc will momentarily need 2x as much memory as mmap.
+
+	  Choosing N saves about 250 bytes of code (on 32-bit x86).
+
 config FEATURE_MODUTILS_ALIAS
-	bool "Support for module.aliases file"
+	bool "Support module.aliases file"
 	default y
-	depends on DEPMOD || MODPROBE
-	select PLATFORM_LINUX
+	depends on (DEPMOD || MODPROBE) && !MODPROBE_SMALL
 	help
 	  Generate and parse modules.alias containing aliases for bus
 	  identifiers:
@@ -150,10 +153,9 @@ config FEATURE_MODUTILS_ALIAS
 	  Say Y if unsure.
 
 config FEATURE_MODUTILS_SYMBOLS
-	bool "Support for module.symbols file"
+	bool "Support module.symbols file"
 	default y
-	depends on DEPMOD || MODPROBE
-	select PLATFORM_LINUX
+	depends on (DEPMOD || MODPROBE) && !MODPROBE_SMALL
 	help
 	  Generate and parse modules.symbols containing aliases for
 	  symbol_request() kernel calls, such as:
@@ -164,7 +166,7 @@ config FEATURE_MODUTILS_SYMBOLS
 config DEFAULT_MODULES_DIR
 	string "Default directory containing modules"
 	default "/lib/modules"
-	depends on DEPMOD || MODPROBE || MODPROBE_SMALL || MODINFO
+	depends on DEPMOD || MODPROBE || MODINFO
 	help
 	  Directory that contains kernel modules.
 	  Defaults to "/lib/modules"
@@ -172,9 +174,13 @@ config DEFAULT_MODULES_DIR
 config DEFAULT_DEPMOD_FILE
 	string "Default name of modules.dep"
 	default "modules.dep"
-	depends on DEPMOD || MODPROBE || MODPROBE_SMALL || MODINFO
+	depends on DEPMOD || MODPROBE || MODINFO
 	help
 	  Filename that contains kernel modules dependencies.
-	  Defaults to "modules.dep"
+	  Defaults to "modules.dep".
+	  If you configured the "simplified modutils" (MODPROBE_SMALL), a
+	  ".bb" suffix will be added after this name. Do not specify ".bb"
+	  here unless you intend your depmod or modprobe to work on
+	  "modules.dep.bb.bb" or such.
 
 endmenu
diff -urpN busybox-1.26.2/modutils/insmod.c busybox-1.27.0/modutils/insmod.c
--- busybox-1.26.2/modutils/insmod.c	2017-01-01 13:01:05.000000000 +0100
+++ busybox-1.27.0/modutils/insmod.c	2017-02-01 15:54:54.000000000 +0100
@@ -27,9 +27,9 @@
 
 //usage:#if !ENABLE_MODPROBE_SMALL
 //usage:#define insmod_trivial_usage
-//usage:	IF_FEATURE_2_4_MODULES("[OPTIONS] MODULE ")
-//usage:	IF_NOT_FEATURE_2_4_MODULES("FILE ")
-//usage:	"[SYMBOL=VALUE]..."
+//usage:	IF_FEATURE_2_4_MODULES("[OPTIONS] MODULE")
+//usage:	IF_NOT_FEATURE_2_4_MODULES("FILE")
+//usage:	IF_FEATURE_CMDLINE_MODULE_OPTIONS(" [SYMBOL=VALUE]...")
 //usage:#define insmod_full_usage "\n\n"
 //usage:       "Load kernel module"
 //usage:	IF_FEATURE_2_4_MODULES( "\n"
diff -urpN busybox-1.26.2/modutils/lsmod.c busybox-1.27.0/modutils/lsmod.c
--- busybox-1.26.2/modutils/lsmod.c	2017-01-01 13:01:04.000000000 +0100
+++ busybox-1.27.0/modutils/lsmod.c	2017-02-01 15:54:54.000000000 +0100
@@ -18,7 +18,6 @@
 //config:	bool "Pretty output"
 //config:	default y
 //config:	depends on LSMOD && !MODPROBE_SMALL
-//config:	select PLATFORM_LINUX
 //config:	help
 //config:	  This option makes output format of lsmod adjusted to
 //config:	  the format of module-init-tools for Linux kernel 2.6.
@@ -34,7 +33,7 @@
 //usage:#define lsmod_trivial_usage
 //usage:       ""
 //usage:#define lsmod_full_usage "\n\n"
-//usage:       "List the currently loaded kernel modules"
+//usage:       "List loaded kernel modules"
 //usage:#endif
 
 #include "libbb.h"
diff -urpN busybox-1.26.2/modutils/modinfo.c busybox-1.27.0/modutils/modinfo.c
--- busybox-1.26.2/modutils/modinfo.c	2016-09-27 18:53:50.000000000 +0200
+++ busybox-1.27.0/modutils/modinfo.c	2017-07-01 22:51:12.000000000 +0200
@@ -104,7 +104,7 @@ static void modinfo(const char *path, co
 			char *after_pattern;
 
 			ptr = memchr(ptr, *pattern, len - (ptr - (char*)the_module));
-			if (ptr == NULL) /* no occurance left, done */
+			if (ptr == NULL) /* no occurrence left, done */
 				break;
 			after_pattern = is_prefixed_with(ptr, pattern);
 			if (after_pattern && *after_pattern == '=') {
diff -urpN busybox-1.26.2/modutils/modprobe-small.c busybox-1.27.0/modutils/modprobe-small.c
--- busybox-1.26.2/modutils/modprobe-small.c	2017-01-10 16:55:51.000000000 +0100
+++ busybox-1.27.0/modutils/modprobe-small.c	2017-07-01 22:51:12.000000000 +0200
@@ -8,28 +8,15 @@
  * Licensed under GPLv2, see file LICENSE in this source tree.
  */
 
-/* config MODPROBE_SMALL is defined in Config.src to ensure better "make config" order */
-
-//config:config FEATURE_MODPROBE_SMALL_OPTIONS_ON_CMDLINE
-//config:	bool "Accept module options on modprobe command line"
-//config:	default y
-//config:	depends on MODPROBE_SMALL
-//config:	select PLATFORM_LINUX
-//config:	help
-//config:	  Allow insmod and modprobe take module options from command line.
-//config:
-//config:config FEATURE_MODPROBE_SMALL_CHECK_ALREADY_LOADED
-//config:	bool "Skip loading of already loaded modules"
-//config:	default y
-//config:	depends on MODPROBE_SMALL
-//config:	help
-//config:	  Check if the module is already loaded.
+/* modprobe-small configs are defined in Config.src to ensure better
+ * "make config" order */
 
+//applet:IF_LSMOD(   IF_MODPROBE_SMALL(APPLET(lsmod,    BB_DIR_SBIN, BB_SUID_DROP)))
 //applet:IF_MODPROBE(IF_MODPROBE_SMALL(APPLET(modprobe, BB_DIR_SBIN, BB_SUID_DROP)))
+//                                   APPLET_ODDNAME:name    main      location     suid_type     help
 //applet:IF_DEPMOD(IF_MODPROBE_SMALL(APPLET_ODDNAME(depmod, modprobe, BB_DIR_SBIN, BB_SUID_DROP, depmod)))
 //applet:IF_INSMOD(IF_MODPROBE_SMALL(APPLET_ODDNAME(insmod, modprobe, BB_DIR_SBIN, BB_SUID_DROP, insmod)))
-//applet:IF_LSMOD(IF_MODPROBE_SMALL(APPLET_ODDNAME(lsmod, modprobe, BB_DIR_SBIN, BB_SUID_DROP, lsmod)))
-//applet:IF_RMMOD(IF_MODPROBE_SMALL(APPLET_ODDNAME(rmmod, modprobe, BB_DIR_SBIN, BB_SUID_DROP, rmmod)))
+//applet:IF_RMMOD( IF_MODPROBE_SMALL(APPLET_ODDNAME(rmmod,  modprobe, BB_DIR_SBIN, BB_SUID_DROP, rmmod)))
 
 //kbuild:lib-$(CONFIG_MODPROBE_SMALL) += modprobe-small.o
 
@@ -59,7 +46,40 @@
 
 #define DEPFILE_BB CONFIG_DEFAULT_DEPMOD_FILE".bb"
 
+//usage:#if ENABLE_MODPROBE_SMALL
+
+//usage:#define lsmod_trivial_usage
+//usage:       ""
+//usage:#define lsmod_full_usage "\n\n"
+//usage:       "List loaded kernel modules"
+
+//usage:#endif
+
+#if ENABLE_LSMOD
+int lsmod_main(int argc, char **argv) MAIN_EXTERNALLY_VISIBLE;
+int lsmod_main(int argc UNUSED_PARAM, char **argv UNUSED_PARAM)
+{
+	xprint_and_close_file(xfopen_for_read("/proc/modules"));
+	return EXIT_SUCCESS;
+}
+#endif
+
+/* Num of applets that use modprobe_main() entry point. */
+/* lsmod is not here. */
+#define MOD_APPLET_CNT (ENABLE_MODPROBE + ENABLE_DEPMOD + ENABLE_INSMOD + ENABLE_RMMOD)
+
+/* Do not bother if MODPROBE_SMALL=y but no applets selected. */
+/* The rest of the file is in this if block. */
+#if MOD_APPLET_CNT > 0
+
+#define ONLY_APPLET (MOD_APPLET_CNT == 1)
+#define is_modprobe (ENABLE_MODPROBE && (ONLY_APPLET || applet_name[0] == 'm'))
+#define is_depmod   (ENABLE_DEPMOD   && (ONLY_APPLET || applet_name[0] == 'd'))
+#define is_insmod   (ENABLE_INSMOD   && (ONLY_APPLET || applet_name[0] == 'i'))
+#define is_rmmod    (ENABLE_RMMOD    && (ONLY_APPLET || applet_name[0] == 'r'))
+
 enum {
+	DEPMOD_OPT_n = (1 << 0), /* dry-run, print to stdout */
 	OPT_q = (1 << 0), /* be quiet */
 	OPT_r = (1 << 1), /* module removal instead of loading */
 };
@@ -149,7 +169,7 @@ static char* find_keyword(char *ptr, siz
 
 		/* search for the first char in word */
 		ptr = memchr(ptr, word[0], len);
-		if (ptr == NULL) /* no occurance left, done */
+		if (ptr == NULL) /* no occurrence left, done */
 			break;
 		after_word = is_prefixed_with(ptr, word);
 		if (after_word)
@@ -361,6 +381,8 @@ static FAST_FUNC int fileAction(const ch
 {
 	int cur;
 	const char *fname;
+	bool is_remove = (ENABLE_RMMOD && ONLY_APPLET)
+		|| ((ENABLE_RMMOD || ENABLE_MODPROBE) && (option_mask32 & OPT_r));
 
 	pathname += 2; /* skip "./" */
 	fname = bb_get_last_path_component_nostrip(pathname);
@@ -385,11 +407,11 @@ static FAST_FUNC int fileAction(const ch
 	if (parse_module(&modinfo[cur], pathname) != 0)
 		return TRUE; /* failed to open/read it, no point in trying loading */
 
-	if (!(option_mask32 & OPT_r)) {
+	if (!is_remove) {
 		if (load_module(pathname, module_load_options) == 0) {
 			/* Load was successful, there is nothing else to do.
 			 * This can happen ONLY for "top-level" module load,
-			 * not a dep, because deps dont do dirscan. */
+			 * not a dep, because deps don't do dirscan. */
 			exit(EXIT_SUCCESS);
 		}
 	}
@@ -456,7 +478,7 @@ static int start_dep_bb_writeout(void)
 	int fd;
 
 	/* depmod -n: write result to stdout */
-	if (applet_name[0] == 'd' && (option_mask32 & 1))
+	if (is_depmod && (option_mask32 & DEPMOD_OPT_n))
 		return STDOUT_FILENO;
 
 	fd = open(DEPFILE_BB".new", O_WRONLY | O_CREAT | O_TRUNC | O_EXCL, 0644);
@@ -656,7 +678,7 @@ static int rmmod(const char *filename)
  * NB: also called by depmod with bogus name "/",
  * just in order to force modprobe.dep.bb creation.
 */
-#if !ENABLE_FEATURE_MODPROBE_SMALL_OPTIONS_ON_CMDLINE
+#if !ENABLE_FEATURE_CMDLINE_MODULE_OPTIONS
 #define process_module(a,b) process_module(a)
 #define cmdline_options ""
 #endif
@@ -666,7 +688,8 @@ static int process_module(char *name, co
 	module_info **infovec;
 	module_info *info;
 	int infoidx;
-	int is_remove = (option_mask32 & OPT_r) != 0;
+	bool is_remove = (ENABLE_RMMOD && ONLY_APPLET)
+		|| ((ENABLE_RMMOD || ENABLE_MODPROBE) && (option_mask32 & OPT_r));
 	int exitcode = EXIT_SUCCESS;
 
 	dbg1_error_msg("process_module('%s','%s')", name, cmdline_options);
@@ -675,9 +698,8 @@ static int process_module(char *name, co
 
 	dbg1_error_msg("already_loaded:%d is_remove:%d", already_loaded(name), is_remove);
 
-	if (applet_name[0] == 'r') {
-		/* rmmod.
-		 * Does not remove dependencies, no need to scan, just remove.
+	if (is_rmmod) {
+		/* Does not remove dependencies, no need to scan, just remove.
 		 * (compat note: this allows and strips .ko suffix)
 		 */
 		rmmod(name);
@@ -701,7 +723,7 @@ static int process_module(char *name, co
 		options = xmalloc_open_read_close(opt_filename, NULL);
 		if (options)
 			replace(options, '\n', ' ');
-#if ENABLE_FEATURE_MODPROBE_SMALL_OPTIONS_ON_CMDLINE
+#if ENABLE_FEATURE_CMDLINE_MODULE_OPTIONS
 		if (cmdline_options) {
 			/* NB: cmdline_options always have one leading ' '
 			 * (see main()), we remove it here */
@@ -743,9 +765,12 @@ static int process_module(char *name, co
 
 	if (!infovec) {
 		/* both dirscan and find_alias found nothing */
-		if (!is_remove && applet_name[0] != 'd') /* it wasn't rmmod or depmod */
+		if (!is_remove && !is_depmod) { /* it wasn't rmmod or depmod */
 			bb_error_msg("module '%s' not found", name);
 //TODO: _and_die()? or should we continue (un)loading modules listed on cmdline?
+			/* "modprobe non-existing-module; echo $?" must print 1 */
+			exitcode = EXIT_FAILURE;
+		}
 		goto ret;
 	}
 
@@ -841,25 +866,28 @@ Usage: rmmod [-fhswvV] modulename ...
     should eventually fall to zero).
 
 # modprobe
-Usage: modprobe [-v] [-V] [-C config-file] [-n] [-i] [-q] [-b]
-    [-o <modname>] [ --dump-modversions ] <modname> [parameters...]
+Usage: modprobe [-v] [-V] [-C config-file] [-d <dirname> ] [-n] [-i] [-q]
+    [-b] [-o <modname>] [ --dump-modversions ] <modname> [parameters...]
 modprobe -r [-n] [-i] [-v] <modulename> ...
 modprobe -l -t <dirname> [ -a <modulename> ...]
 
 # depmod --help
-depmod 3.4 -- part of module-init-tools
-depmod -[aA] [-n -e -v -q -V -r -u]
+depmod 3.13 -- part of module-init-tools
+depmod -[aA] [-n -e -v -q -V -r -u -w -m]
       [-b basedirectory] [forced_version]
-depmod [-n -e -v -q -r -u] [-F kernelsyms] module1.ko module2.ko ...
+depmod [-n -e -v -q -r -u -w] [-F kernelsyms] module1.ko module2.ko ...
 If no arguments (except options) are given, "depmod -a" is assumed.
 depmod will output a dependency list suitable for the modprobe utility.
 Options:
     -a, --all           Probe all modules
     -A, --quick         Only does the work if there's a new module
-    -n, --show          Write the dependency file on stdout only
     -e, --errsyms       Report not supplied symbols
+    -m, --map           Create the legacy map files
+    -n, --show          Write the dependency file on stdout only
+    -P, --symbol-prefix Architecture symbol prefix
     -V, --version       Print the release version
     -v, --verbose       Enable verbose mode
+    -w, --warn          Warn on duplicates
     -h, --help          Print this usage message
 The following options are useful for people managing distributions:
     -b basedirectory
@@ -868,86 +896,61 @@ The following options are useful for peo
     -F kernelsyms
     --filesyms kernelsyms
                         Use the file instead of the current kernel symbols
+    -E Module.symvers
+    --symvers Module.symvers
+                        Use Module.symvers file to check symbol versions
 */
 
 //usage:#if ENABLE_MODPROBE_SMALL
 
-//usage:#define depmod_trivial_usage NOUSAGE_STR
-//usage:#define depmod_full_usage ""
-
-//usage:#define lsmod_trivial_usage
-//usage:       ""
-//usage:#define lsmod_full_usage "\n\n"
-//usage:       "List the currently loaded kernel modules"
+//usage:#define depmod_trivial_usage "[-n]"
+//usage:#define depmod_full_usage "\n\n"
+//usage:       "Generate modules.dep.bb"
+//usage:     "\n"
+//usage:     "\n	-n	Dry run: print file to stdout"
 
 //usage:#define insmod_trivial_usage
-//usage:	IF_FEATURE_2_4_MODULES("[OPTIONS] MODULE ")
-//usage:	IF_NOT_FEATURE_2_4_MODULES("FILE ")
-//usage:	"[SYMBOL=VALUE]..."
+//usage:	"FILE" IF_FEATURE_CMDLINE_MODULE_OPTIONS(" [SYMBOL=VALUE]...")
 //usage:#define insmod_full_usage "\n\n"
 //usage:       "Load kernel module"
-//usage:	IF_FEATURE_2_4_MODULES( "\n"
-//usage:     "\n	-f	Force module to load into the wrong kernel version"
-//usage:     "\n	-k	Make module autoclean-able"
-//usage:     "\n	-v	Verbose"
-//usage:     "\n	-q	Quiet"
-//usage:     "\n	-L	Lock: prevent simultaneous loads"
-//usage:	IF_FEATURE_INSMOD_LOAD_MAP(
-//usage:     "\n	-m	Output load map to stdout"
-//usage:	)
-//usage:     "\n	-x	Don't export externs"
-//usage:	)
 
 //usage:#define rmmod_trivial_usage
-//usage:       "[-wfa] [MODULE]..."
+//usage:       "MODULE..."
 //usage:#define rmmod_full_usage "\n\n"
-//usage:       "Unload kernel modules\n"
-//usage:     "\n	-w	Wait until the module is no longer used"
-//usage:     "\n	-f	Force unload"
-//usage:     "\n	-a	Remove all unused modules (recursively)"
-//usage:
-//usage:#define rmmod_example_usage
-//usage:       "$ rmmod tulip\n"
+//usage:       "Unload kernel modules"
 
 //usage:#define modprobe_trivial_usage
-//usage:	"[-qfwrsv] MODULE [SYMBOL=VALUE]..."
+//usage:	"[-rq] MODULE" IF_FEATURE_CMDLINE_MODULE_OPTIONS(" [SYMBOL=VALUE]...")
 //usage:#define modprobe_full_usage "\n\n"
-//usage:       "	-r	Remove MODULE (stacks) or do autoclean"
+//usage:       "	-r	Remove MODULE"
 //usage:     "\n	-q	Quiet"
-//usage:     "\n	-v	Verbose"
-//usage:     "\n	-f	Force"
-//usage:     "\n	-w	Wait for unload"
-//usage:     "\n	-s	Report via syslog instead of stderr"
 
 //usage:#endif
 
 int modprobe_main(int argc, char **argv) MAIN_EXTERNALLY_VISIBLE;
 int modprobe_main(int argc UNUSED_PARAM, char **argv)
 {
+#if ENABLE_MODPROBE || ENABLE_INSMOD || ENABLE_RMMOD
 	int exitcode;
+#endif
 	struct utsname uts;
-	char applet0 = applet_name[0];
-	IF_FEATURE_MODPROBE_SMALL_OPTIONS_ON_CMDLINE(char *options;)
-
-	/* are we lsmod? -> just dump /proc/modules */
-	if (ENABLE_LSMOD && 'l' == applet0) {
-		xprint_and_close_file(xfopen_for_read("/proc/modules"));
-		return EXIT_SUCCESS;
-	}
+	IF_FEATURE_CMDLINE_MODULE_OPTIONS(char *options = NULL;)
 
 	INIT_G();
 
 	/* Prevent ugly corner cases with no modules at all */
 	modinfo = xzalloc(sizeof(modinfo[0]));
 
-	if (!ENABLE_INSMOD || 'i' != applet0) { /* not insmod */
+	if ((MOD_APPLET_CNT == 2 && ENABLE_DEPMOD && ENABLE_MODPROBE)
+	 || is_depmod || is_modprobe
+	) {
 		/* Goto modules directory */
 		xchdir(CONFIG_DEFAULT_MODULES_DIR);
+		uname(&uts); /* never fails */
 	}
-	uname(&uts); /* never fails */
 
 	/* depmod? */
-	if (ENABLE_DEPMOD && 'd' == applet0) {
+	if (is_depmod) {
 		/* Supported:
 		 * -n: print result to stdout
 		 * -a: process all modules (default)
@@ -957,10 +960,12 @@ int modprobe_main(int argc UNUSED_PARAM,
 		 * -e: report any symbols which a module needs
 		 *  which are not supplied by other modules or the kernel
 		 * -F FILE: System.map (symbols for -e)
-		 * -q, -r, -u: noop?
+		 * -q, -r, -u: noop
 		 * Not supported:
 		 * -b BASEDIR: (TODO!) modules are in
 		 *  $BASEDIR/lib/modules/$VERSION
+		 * -m: create legacy "modules.*map" files (deprecated; in
+		 *  kmod's depmod, prints a warning message and continues)
 		 * -v: human readable deps to stdout
 		 * -V: version (don't want to support it - people may depend
 		 *  on it as an indicator of "standard" depmod)
@@ -978,28 +983,28 @@ int modprobe_main(int argc UNUSED_PARAM,
 		return !wrote_dep_bb_ok;
 	}
 
-	/* insmod, modprobe, rmmod require at least one argument */
+#if ENABLE_MODPROBE || ENABLE_INSMOD || ENABLE_RMMOD
+	/* modprobe, insmod, rmmod require at least one argument */
 	opt_complementary = "-1";
 	/* only -q (quiet) and -r (rmmod),
 	 * the rest are accepted and ignored (compat) */
 	getopt32(argv, "qrfsvwb");
 	argv += optind;
 
-	/* are we rmmod? -> simulate modprobe -r */
-	if (ENABLE_RMMOD && 'r' == applet0) {
-		option_mask32 |= OPT_r;
-	}
-
-	if (!ENABLE_INSMOD || 'i' != applet0) { /* not insmod */
+	if (is_modprobe) {
 		/* Goto $VERSION directory */
 		xchdir(uts.release);
 	}
 
-#if ENABLE_FEATURE_MODPROBE_SMALL_OPTIONS_ON_CMDLINE
+	/* are we rmmod? -> simulate modprobe -r, but don't bother the flag if
+	 * there're no other applets here */
+	if (is_rmmod) {
+		if (!ONLY_APPLET)
+			option_mask32 |= OPT_r;
+	} else if (!ENABLE_MODPROBE || !(option_mask32 & OPT_r)) {
+# if ENABLE_FEATURE_CMDLINE_MODULE_OPTIONS
 	/* If not rmmod/-r, parse possible module options given on command line.
 	 * insmod/modprobe takes one module name, the rest are parameters. */
-	options = NULL;
-	if (!(option_mask32 & OPT_r)) {
 		char **arg = argv;
 		while (*++arg) {
 			/* Enclose options in quotes */
@@ -1008,13 +1013,12 @@ int modprobe_main(int argc UNUSED_PARAM,
 			free(s);
 			*arg = NULL;
 		}
-	}
-#else
-	if (!(option_mask32 & OPT_r))
+# else
 		argv[1] = NULL;
-#endif
+# endif
+	}
 
-	if (ENABLE_INSMOD && 'i' == applet0) { /* insmod */
+	if (is_insmod) {
 		size_t len;
 		void *map;
 
@@ -1023,8 +1027,7 @@ int modprobe_main(int argc UNUSED_PARAM,
 		if (!map)
 			bb_perror_msg_and_die("can't read '%s'", *argv);
 		if (init_module(map, len,
-			IF_FEATURE_MODPROBE_SMALL_OPTIONS_ON_CMDLINE(options ? options : "")
-			IF_NOT_FEATURE_MODPROBE_SMALL_OPTIONS_ON_CMDLINE("")
+			(IF_FEATURE_CMDLINE_MODULE_OPTIONS(options ? options : ) "")
 			) != 0
 		) {
 			bb_error_msg_and_die("can't insert '%s': %s",
@@ -1034,7 +1037,7 @@ int modprobe_main(int argc UNUSED_PARAM,
 	}
 
 	/* Try to load modprobe.dep.bb */
-	if (!ENABLE_RMMOD || 'r' != applet0) { /* not rmmod */
+	if (!is_rmmod) {
 		load_dep_bb();
 	}
 
@@ -1046,7 +1049,10 @@ int modprobe_main(int argc UNUSED_PARAM,
 	} while (*++argv);
 
 	if (ENABLE_FEATURE_CLEAN_UP) {
-		IF_FEATURE_MODPROBE_SMALL_OPTIONS_ON_CMDLINE(free(options);)
+		IF_FEATURE_CMDLINE_MODULE_OPTIONS(free(options);)
 	}
 	return exitcode;
+#endif /* MODPROBE || INSMOD || RMMOD */
 }
+
+#endif /* MOD_APPLET_CNT > 0 */
diff -urpN busybox-1.26.2/modutils/modprobe.c busybox-1.27.0/modutils/modprobe.c
--- busybox-1.26.2/modutils/modprobe.c	2017-01-01 13:01:04.000000000 +0100
+++ busybox-1.27.0/modutils/modprobe.c	2017-07-01 22:51:12.000000000 +0200
@@ -19,7 +19,6 @@
 //config:	bool "Blacklist support"
 //config:	default y
 //config:	depends on MODPROBE && !MODPROBE_SMALL
-//config:	select PLATFORM_LINUX
 //config:	help
 //config:	  Say 'y' here to enable support for the 'blacklist' command in
 //config:	  modprobe.conf. This prevents the alias resolver to resolve
@@ -113,7 +112,7 @@
 //usage:
 //usage:#define modprobe_trivial_usage
 //usage:	"[-alrqvsD" IF_FEATURE_MODPROBE_BLACKLIST("b") "]"
-//usage:	" MODULE [SYMBOL=VALUE]..."
+//usage:	" MODULE" IF_FEATURE_CMDLINE_MODULE_OPTIONS(" [SYMBOL=VALUE]...")
 //usage:#define modprobe_full_usage "\n\n"
 //usage:       "	-a	Load multiple MODULEs"
 //usage:     "\n	-l	List (MODULE is a pattern)"
@@ -172,10 +171,13 @@ static const char modprobe_longopts[] AL
 /* "was seen in modules.dep": */
 #define MODULE_FLAG_FOUND_IN_MODDEP     0x0004
 #define MODULE_FLAG_BLACKLISTED         0x0008
+#define MODULE_FLAG_BUILTIN             0x0010
 
 struct globals {
 	llist_t *probes; /* MEs of module(s) requested on cmdline */
+#if ENABLE_FEATURE_CMDLINE_MODULE_OPTIONS
 	char *cmdline_mopts; /* module options from cmdline */
+#endif
 	int num_unresolved_deps;
 	/* bool. "Did we have 'symbol:FOO' requested on cmdline?" */
 	smallint need_symbols;
@@ -216,7 +218,7 @@ static void add_probe(const char *name)
 
 	m = get_or_add_modentry(name);
 	if (!(option_mask32 & (OPT_REMOVE | OPT_SHOW_DEPS))
-	 && (m->flags & MODULE_FLAG_LOADED)
+	 && (m->flags & (MODULE_FLAG_LOADED | MODULE_FLAG_BUILTIN))
 	) {
 		DBG("skipping %s, it is already loaded", name);
 		return;
@@ -250,6 +252,15 @@ static int FAST_FUNC config_file_action(
 	if (base[0] == '.')
 		goto error;
 
+	/* "man modprobe.d" from kmod version 22 suggests
+	 * that we shouldn't recurse into /etc/modprobe.d/dir/
+	 * _subdirectories_:
+	 */
+	if (depth > 1)
+		return SKIP; /* stop recursing */
+//TODO: instead, can use dirAction in recursive_action() to SKIP dirs
+//on depth == 1 level. But that's more code...
+
 	/* In dir recursion, skip files that do not end with a ".conf"
 	 * depth==0: read_config("modules.{symbols,alias}") must work,
 	 * "include FILE_NOT_ENDING_IN_CONF" must work too.
@@ -412,8 +423,10 @@ static int do_modprobe(struct module_ent
 
 	if (!(m->flags & MODULE_FLAG_FOUND_IN_MODDEP)) {
 		if (!(option_mask32 & INSMOD_OPT_SILENT))
-			bb_error_msg("module %s not found in modules.dep",
-				humanly_readable_name(m));
+			bb_error_msg((m->flags & MODULE_FLAG_BUILTIN) ?
+				     "module %s is builtin" :
+				     "module %s not found in modules.dep",
+				     humanly_readable_name(m));
 		return -ENOENT;
 	}
 	DBG("do_modprob'ing %s", m->modname);
@@ -459,8 +472,10 @@ static int do_modprobe(struct module_ent
 		options = m2->options;
 		m2->options = NULL;
 		options = parse_and_add_kcmdline_module_options(options, m2->modname);
+#if ENABLE_FEATURE_CMDLINE_MODULE_OPTIONS
 		if (m == m2)
 			options = gather_options_str(options, G.cmdline_mopts);
+#endif
 
 		if (option_mask32 & OPT_SHOW_DEPS) {
 			printf(options ? "insmod %s/%s/%s %s\n"
@@ -615,6 +630,11 @@ int modprobe_main(int argc UNUSED_PARAM,
 		while (config_read(parser, &s, 1, 1, "# \t", PARSE_NORMAL & ~PARSE_GREEDY))
 			get_or_add_modentry(s)->flags |= MODULE_FLAG_LOADED;
 		config_close(parser);
+
+		parser = config_open2("modules.builtin", fopen_for_read);
+		while (config_read(parser, &s, 1, 1, "# \t", PARSE_NORMAL))
+			get_or_add_modentry(s)->flags |= MODULE_FLAG_BUILTIN;
+		config_close(parser);
 	}
 
 	if (opt & (OPT_INSERT_ALL | OPT_REMOVE)) {
@@ -627,7 +647,9 @@ int modprobe_main(int argc UNUSED_PARAM,
 		/* First argument is module name, rest are parameters */
 		DBG("probing just module %s", *argv);
 		add_probe(argv[0]);
+#if ENABLE_FEATURE_CMDLINE_MODULE_OPTIONS
 		G.cmdline_mopts = parse_cmdline_module_options(argv, /*quote_spaces:*/ 1);
+#endif
 	}
 
 	/* Happens if all requested modules are already loaded */
diff -urpN busybox-1.26.2/modutils/modutils.c busybox-1.27.0/modutils/modutils.c
--- busybox-1.26.2/modutils/modutils.c	2017-01-10 16:55:51.000000000 +0100
+++ busybox-1.27.0/modutils/modutils.c	2017-07-01 22:51:12.000000000 +0200
@@ -75,12 +75,6 @@ void FAST_FUNC replace(char *s, char wha
 	}
 }
 
-char* FAST_FUNC replace_underscores(char *s)
-{
-	replace(s, '-', '_');
-	return s;
-}
-
 int FAST_FUNC string_to_llist(char *string, llist_t **llist, const char *delim)
 {
 	char *tok;
@@ -120,6 +114,7 @@ char* FAST_FUNC filename2modname(const c
 	return modname;
 }
 
+#if ENABLE_FEATURE_CMDLINE_MODULE_OPTIONS
 char* FAST_FUNC parse_cmdline_module_options(char **argv, int quote_spaces)
 {
 	char *options;
@@ -155,6 +150,7 @@ char* FAST_FUNC parse_cmdline_module_opt
 	/* if (optlen != 0) options[optlen-1] = '\0'; */
 	return options;
 }
+#endif
 
 #if ENABLE_FEATURE_INSMOD_TRY_MMAP
 void* FAST_FUNC try_to_mmap_module(const char *filename, size_t *image_size_p)
diff -urpN busybox-1.26.2/modutils/modutils.h busybox-1.27.0/modutils/modutils.h
--- busybox-1.26.2/modutils/modutils.h	2016-09-27 18:53:50.000000000 +0200
+++ busybox-1.27.0/modutils/modutils.h	2017-07-01 22:51:12.000000000 +0200
@@ -48,10 +48,13 @@ module_entry *moddb_get_or_create(module
 void moddb_free(module_db *db) FAST_FUNC;
 
 void replace(char *s, char what, char with) FAST_FUNC;
-char *replace_underscores(char *s) FAST_FUNC;
 int string_to_llist(char *string, llist_t **llist, const char *delim) FAST_FUNC;
 char *filename2modname(const char *filename, char *modname) FAST_FUNC;
+#if ENABLE_FEATURE_CMDLINE_MODULE_OPTIONS
 char *parse_cmdline_module_options(char **argv, int quote_spaces) FAST_FUNC;
+#else
+# define parse_cmdline_module_options(argv, quote_spaces) ""
+#endif
 
 /* insmod for 2.4 and modprobe's options (insmod 2.6 has no options at all): */
 #define INSMOD_OPTS \
diff -urpN busybox-1.26.2/networking/dnsd.c busybox-1.27.0/networking/dnsd.c
--- busybox-1.26.2/networking/dnsd.c	2016-12-10 18:46:36.000000000 +0100
+++ busybox-1.27.0/networking/dnsd.c	2017-07-01 22:51:12.000000000 +0200
@@ -360,7 +360,7 @@ RDATA   a variable length string of octe
 
 In order to reduce the size of messages, domain names coan be compressed.
 An entire domain name or a list of labels at the end of a domain name
-is replaced with a pointer to a prior occurance of the same name.
+is replaced with a pointer to a prior occurrence of the same name.
 
 The pointer takes the form of a two octet sequence:
     +--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+
diff -urpN busybox-1.26.2/networking/ftpd.c busybox-1.27.0/networking/ftpd.c
--- busybox-1.26.2/networking/ftpd.c	2016-12-10 18:46:36.000000000 +0100
+++ busybox-1.27.0/networking/ftpd.c	2017-01-30 21:57:30.000000000 +0100
@@ -15,7 +15,7 @@
 //config:	bool "ftpd"
 //config:	default y
 //config:	help
-//config:	  simple FTP daemon. You have to run it via inetd.
+//config:	  Simple FTP daemon. You have to run it via inetd.
 //config:
 //config:config FEATURE_FTPD_WRITE
 //config:	bool "Enable upload commands"
@@ -47,20 +47,26 @@
 //kbuild:lib-$(CONFIG_FTPD) += ftpd.o
 
 //usage:#define ftpd_trivial_usage
-//usage:       "[-wvS] [-t N] [-T N] [DIR]"
+//usage:       "[-wvS]"IF_FEATURE_FTPD_AUTHENTICATION(" [-a USER]")" [-t N] [-T N] [DIR]"
 //usage:#define ftpd_full_usage "\n\n"
-//usage:       "Anonymous FTP server\n"
-//usage:       "\n"
-//usage:       "ftpd should be used as an inetd service.\n"
-//usage:       "ftpd's line for inetd.conf:\n"
+//usage:	IF_NOT_FEATURE_FTPD_AUTHENTICATION(
+//usage:       "Anonymous FTP server. Accesses by clients occur under ftpd's UID.\n"
+//usage:	)
+//usage:	IF_FEATURE_FTPD_AUTHENTICATION(
+//usage:       "FTP server. "
+//usage:	)
+//usage:       "Chroots to DIR, if this fails (run by non-root), cds to it.\n"
+//usage:       "Should be used as inetd service, inetd.conf line:\n"
 //usage:       "	21 stream tcp nowait root ftpd ftpd /files/to/serve\n"
-//usage:       "It also can be ran from tcpsvd:\n"
+//usage:       "Can be run from tcpsvd:\n"
 //usage:       "	tcpsvd -vE 0.0.0.0 21 ftpd /files/to/serve\n"
 //usage:     "\n	-w	Allow upload"
+//usage:	IF_FEATURE_FTPD_AUTHENTICATION(
+//usage:     "\n	-a USER	Enable 'anonymous' login and map it to USER"
+//usage:	)
 //usage:     "\n	-v	Log errors to stderr. -vv: verbose log"
 //usage:     "\n	-S	Log errors to syslog. -SS: verbose log"
-//usage:     "\n	-t,-T	Idle and absolute timeouts"
-//usage:     "\n	DIR	Change root to this directory"
+//usage:     "\n	-t,-T N	Idle and absolute timeout"
 
 #include "libbb.h"
 #include "common_bufsiz.h"
@@ -695,7 +701,7 @@ popen_ls(const char *opt)
 		dup(STDOUT_FILENO); /* copy will become STDIN_FILENO */
 #if BB_MMU
 		/* memset(&G, 0, sizeof(G)); - ls_main does it */
-		exit(ls_main(ARRAY_SIZE(argv) - 1, (char**) argv));
+		exit(ls_main(/*argc_unused*/ 0, (char**) argv));
 #else
 		cur_fd = xopen(".", O_RDONLY | O_DIRECTORY);
 		/* On NOMMU, we want to execute a child - copy of ourself
@@ -1146,14 +1152,11 @@ enum {
 };
 
 int ftpd_main(int argc, char **argv) MAIN_EXTERNALLY_VISIBLE;
-#if !BB_MMU
-int ftpd_main(int argc, char **argv)
-#else
 int ftpd_main(int argc UNUSED_PARAM, char **argv)
-#endif
 {
 #if ENABLE_FEATURE_FTPD_AUTHENTICATION
 	struct passwd *pw = NULL;
+	char *anon_opt = NULL;
 #endif
 	unsigned abs_timeout;
 	unsigned verbose_S;
@@ -1166,16 +1169,21 @@ int ftpd_main(int argc UNUSED_PARAM, cha
 	G.timeout = 2 * 60;
 	opt_complementary = "vv:SS";
 #if BB_MMU
-	opts = getopt32(argv,    "vS" IF_FEATURE_FTPD_WRITE("w") "t:+T:+", &G.timeout, &abs_timeout, &G.verbose, &verbose_S);
+	opts = getopt32(argv,    "vS"
+		IF_FEATURE_FTPD_WRITE("w") "t:+T:+" IF_FEATURE_FTPD_AUTHENTICATION("a:"),
+		&G.timeout, &abs_timeout, IF_FEATURE_FTPD_AUTHENTICATION(&anon_opt,)
+		&G.verbose, &verbose_S);
 #else
-	opts = getopt32(argv, "l1AvS" IF_FEATURE_FTPD_WRITE("w") "t:+T:+", &G.timeout, &abs_timeout, &G.verbose, &verbose_S);
+	opts = getopt32(argv, "l1AvS"
+		IF_FEATURE_FTPD_WRITE("w") "t:+T:+" IF_FEATURE_FTPD_AUTHENTICATION("a:"),
+		&G.timeout, &abs_timeout, IF_FEATURE_FTPD_AUTHENTICATION(&anon_opt,)
+		&G.verbose, &verbose_S);
 	if (opts & (OPT_l|OPT_1)) {
 		/* Our secret backdoor to ls */
-/* TODO: pass --group-directories-first? would be nice, but ls doesn't do that yet */
 		if (fchdir(3) != 0)
 			_exit(127);
 		/* memset(&G, 0, sizeof(G)); - ls_main does it */
-		return ls_main(argc, argv);
+		return ls_main(/*argc_unused*/ 0, argv);
 	}
 #endif
 	if (G.verbose < verbose_S)
@@ -1234,7 +1242,12 @@ int ftpd_main(int argc UNUSED_PARAM, cha
 #if ENABLE_FEATURE_FTPD_AUTHENTICATION
 	while (1) {
 		uint32_t cmdval = cmdio_get_cmd_and_arg();
-			if (cmdval == const_USER) {
+		if (cmdval == const_USER) {
+			if (anon_opt && strcmp(G.ftp_arg, "anonymous") == 0) {
+				pw = getpwnam(anon_opt);
+				if (pw)
+					break; /* does not even ask for password */
+			}
 			pw = getpwnam(G.ftp_arg);
 			cmdio_write_raw(STR(FTP_GIVEPWORD)" Please specify password\r\n");
 		} else if (cmdval == const_PASS) {
diff -urpN busybox-1.26.2/networking/ftpgetput.c busybox-1.27.0/networking/ftpgetput.c
--- busybox-1.26.2/networking/ftpgetput.c	2016-12-10 18:46:36.000000000 +0100
+++ busybox-1.27.0/networking/ftpgetput.c	2017-01-10 16:31:40.000000000 +0100
@@ -28,8 +28,6 @@
 //config:	bool "Enable long options in ftpget/ftpput"
 //config:	default y
 //config:	depends on LONG_OPTS && (FTPGET || FTPPUT)
-//config:	help
-//config:	  Support long options for the ftpget/ftpput applet.
 
 //applet:IF_FTPGET(APPLET_ODDNAME(ftpget, ftpgetput, BB_DIR_USR_BIN, BB_SUID_DROP, ftpget))
 //applet:IF_FTPPUT(APPLET_ODDNAME(ftpput, ftpgetput, BB_DIR_USR_BIN, BB_SUID_DROP, ftpput))
diff -urpN busybox-1.26.2/networking/hostname.c busybox-1.27.0/networking/hostname.c
--- busybox-1.26.2/networking/hostname.c	2016-12-10 18:46:36.000000000 +0100
+++ busybox-1.27.0/networking/hostname.c	2017-01-30 21:57:30.000000000 +0100
@@ -22,6 +22,7 @@
 //config:	help
 //config:	  Alias to "hostname -d".
 
+//                        APPLET_ODDNAME:name           main      location    suid_type     help
 //applet:IF_DNSDOMAINNAME(APPLET_ODDNAME(dnsdomainname, hostname, BB_DIR_BIN, BB_SUID_DROP, dnsdomainname))
 //applet:IF_HOSTNAME(APPLET(hostname, BB_DIR_BIN, BB_SUID_DROP))
 
diff -urpN busybox-1.26.2/networking/httpd.c busybox-1.27.0/networking/httpd.c
--- busybox-1.26.2/networking/httpd.c	2016-12-10 18:46:36.000000000 +0100
+++ busybox-1.27.0/networking/httpd.c	2017-02-06 21:57:41.000000000 +0100
@@ -102,7 +102,7 @@
 //config:	bool "httpd"
 //config:	default y
 //config:	help
-//config:	  Serve web pages via an HTTP server.
+//config:	  HTTP server.
 //config:
 //config:config FEATURE_HTTPD_RANGES
 //config:	bool "Support 'Ranges:' header"
@@ -156,7 +156,7 @@
 //config:	  when specific URLs are requested.
 //config:
 //config:config FEATURE_HTTPD_CONFIG_WITH_SCRIPT_INTERPR
-//config:	bool "Support for running scripts through an interpreter"
+//config:	bool "Support running scripts through an interpreter"
 //config:	default y
 //config:	depends on FEATURE_HTTPD_CGI
 //config:	help
@@ -185,7 +185,7 @@
 //config:	  "&#60Hello&#32World&#62".
 //config:
 //config:config FEATURE_HTTPD_ERROR_PAGES
-//config:	bool "Support for custom error pages"
+//config:	bool "Support custom error pages"
 //config:	default y
 //config:	depends on HTTPD
 //config:	help
@@ -198,7 +198,7 @@
 //config:	  message.
 //config:
 //config:config FEATURE_HTTPD_PROXY
-//config:	bool "Support for reverse proxy"
+//config:	bool "Support reverse proxy"
 //config:	default y
 //config:	depends on HTTPD
 //config:	help
@@ -210,7 +210,7 @@
 //config:	  http://hostname[:port]/new/path/myfile.
 //config:
 //config:config FEATURE_HTTPD_GZIP
-//config:	bool "Support for GZIP content encoding"
+//config:	bool "Support GZIP content encoding"
 //config:	default y
 //config:	depends on HTTPD
 //config:	help
@@ -460,11 +460,6 @@ struct globals {
 #define ip_a_d            (G.ip_a_d           )
 #define g_realm           (G.g_realm          )
 #define remoteuser        (G.remoteuser       )
-#define referer           (G.referer          )
-#define user_agent        (G.user_agent       )
-#define host              (G.host             )
-#define http_accept       (G.http_accept      )
-#define http_accept_language (G.http_accept_language)
 #define file_size         (G.file_size        )
 #if ENABLE_FEATURE_HTTPD_RANGES
 #define range_start       (G.range_start      )
@@ -1152,7 +1147,7 @@ static void send_headers(int responseNum
 			"Last-Modified: %s\r\n"
 			"%s %"OFF_FMT"u\r\n",
 				date_str,
-				content_gzip ? "Transfer-length:" : "Content-length:",
+				content_gzip ? "Transfer-Length:" : "Content-Length:",
 				file_size
 		);
 	}
@@ -1529,11 +1524,11 @@ static void send_cgi_and_exit(
 #endif
 		}
 	}
-	setenv1("HTTP_USER_AGENT", user_agent);
-	if (http_accept)
-		setenv1("HTTP_ACCEPT", http_accept);
-	if (http_accept_language)
-		setenv1("HTTP_ACCEPT_LANGUAGE", http_accept_language);
+	setenv1("HTTP_USER_AGENT", G.user_agent);
+	if (G.http_accept)
+		setenv1("HTTP_ACCEPT", G.http_accept);
+	if (G.http_accept_language)
+		setenv1("HTTP_ACCEPT_LANGUAGE", G.http_accept_language);
 	if (post_len)
 		putenv(xasprintf("CONTENT_LENGTH=%d", post_len));
 	if (cookie)
@@ -1546,9 +1541,9 @@ static void send_cgi_and_exit(
 		putenv((char*)"AUTH_TYPE=Basic");
 	}
 #endif
-	if (referer)
-		setenv1("HTTP_REFERER", referer);
-	setenv1("HTTP_HOST", host); /* set to "" if NULL */
+	if (G.referer)
+		setenv1("HTTP_REFERER", G.referer);
+	setenv1("HTTP_HOST", G.host); /* set to "" if NULL */
 	/* setenv1("SERVER_NAME", safe_gethostname()); - don't do this,
 	 * just run "env SERVER_NAME=xyz httpd ..." instead */
 
@@ -2269,10 +2264,8 @@ static void handle_incoming_and_exit(con
 #if ENABLE_FEATURE_HTTPD_PROXY
 			/* We need 2 more bytes for yet another "\r\n" -
 			 * see near fdprintf(proxy_fd...) further below */
-			if (proxy_entry && (header_ptr - header_buf) < IOBUF_SIZE - 2) {
-				int len = strlen(iobuf);
-				if (len > IOBUF_SIZE - (header_ptr - header_buf) - 4)
-					len = IOBUF_SIZE - (header_ptr - header_buf) - 4;
+			if (proxy_entry && (header_ptr - header_buf) < IOBUF_SIZE - 4) {
+				int len = strnlen(iobuf, IOBUF_SIZE - (header_ptr - header_buf) - 4);
 				memcpy(header_ptr, iobuf, len);
 				header_ptr += len;
 				header_ptr[0] = '\r';
@@ -2283,14 +2276,14 @@ static void handle_incoming_and_exit(con
 
 #if ENABLE_FEATURE_HTTPD_CGI || ENABLE_FEATURE_HTTPD_PROXY
 			/* Try and do our best to parse more lines */
-			if ((STRNCASECMP(iobuf, "Content-length:") == 0)) {
+			if ((STRNCASECMP(iobuf, "Content-Length:") == 0)) {
 				/* extra read only for POST */
 				if (prequest != request_GET
 # if ENABLE_FEATURE_HTTPD_CGI
 				 && prequest != request_HEAD
 # endif
 				) {
-					tptr = skip_whitespace(iobuf + sizeof("Content-length:") - 1);
+					tptr = skip_whitespace(iobuf + sizeof("Content-Length:") - 1);
 					if (!tptr[0])
 						send_headers_and_exit(HTTP_BAD_REQUEST);
 					/* not using strtoul: it ignores leading minus! */
@@ -2303,19 +2296,26 @@ static void handle_incoming_and_exit(con
 #endif
 #if ENABLE_FEATURE_HTTPD_CGI
 			else if (STRNCASECMP(iobuf, "Cookie:") == 0) {
-				cookie = xstrdup(skip_whitespace(iobuf + sizeof("Cookie:")-1));
+				if (!cookie) /* in case they send millions of these, do not OOM */
+					cookie = xstrdup(skip_whitespace(iobuf + sizeof("Cookie:")-1));
 			} else if (STRNCASECMP(iobuf, "Content-Type:") == 0) {
-				content_type = xstrdup(skip_whitespace(iobuf + sizeof("Content-Type:")-1));
+				if (!content_type)
+					content_type = xstrdup(skip_whitespace(iobuf + sizeof("Content-Type:")-1));
 			} else if (STRNCASECMP(iobuf, "Referer:") == 0) {
-				referer = xstrdup(skip_whitespace(iobuf + sizeof("Referer:")-1));
+				if (!G.referer)
+					G.referer = xstrdup(skip_whitespace(iobuf + sizeof("Referer:")-1));
 			} else if (STRNCASECMP(iobuf, "User-Agent:") == 0) {
-				user_agent = xstrdup(skip_whitespace(iobuf + sizeof("User-Agent:")-1));
+				if (!G.user_agent)
+					G.user_agent = xstrdup(skip_whitespace(iobuf + sizeof("User-Agent:")-1));
 			} else if (STRNCASECMP(iobuf, "Host:") == 0) {
-				host = xstrdup(skip_whitespace(iobuf + sizeof("Host:")-1));
+				if (!G.host)
+					G.host = xstrdup(skip_whitespace(iobuf + sizeof("Host:")-1));
 			} else if (STRNCASECMP(iobuf, "Accept:") == 0) {
-				http_accept = xstrdup(skip_whitespace(iobuf + sizeof("Accept:")-1));
+				if (!G.http_accept)
+					G.http_accept = xstrdup(skip_whitespace(iobuf + sizeof("Accept:")-1));
 			} else if (STRNCASECMP(iobuf, "Accept-Language:") == 0) {
-				http_accept_language = xstrdup(skip_whitespace(iobuf + sizeof("Accept-Language:")-1));
+				if (!G.http_accept_language)
+					G.http_accept_language = xstrdup(skip_whitespace(iobuf + sizeof("Accept-Language:")-1));
 			}
 #endif
 #if ENABLE_FEATURE_HTTPD_BASIC_AUTH
@@ -2396,12 +2396,12 @@ static void handle_incoming_and_exit(con
 		int proxy_fd;
 		len_and_sockaddr *lsa;
 
-		proxy_fd = socket(AF_INET, SOCK_STREAM, 0);
-		if (proxy_fd < 0)
-			send_headers_and_exit(HTTP_INTERNAL_SERVER_ERROR);
 		lsa = host2sockaddr(proxy_entry->host_port, 80);
 		if (lsa == NULL)
 			send_headers_and_exit(HTTP_INTERNAL_SERVER_ERROR);
+		proxy_fd = socket(lsa->u.sa.sa_family, SOCK_STREAM, 0);
+		if (proxy_fd < 0)
+			send_headers_and_exit(HTTP_INTERNAL_SERVER_ERROR);
 		if (connect(proxy_fd, &lsa->u.sa, lsa->len) < 0)
 			send_headers_and_exit(HTTP_INTERNAL_SERVER_ERROR);
 		fdprintf(proxy_fd, "%s %s%s%s%s HTTP/%c.%c\r\n",
diff -urpN busybox-1.26.2/networking/httpd_helpers.sh busybox-1.27.0/networking/httpd_helpers.sh
--- busybox-1.26.2/networking/httpd_helpers.sh	1970-01-01 01:00:00.000000000 +0100
+++ busybox-1.27.0/networking/httpd_helpers.sh	2016-12-22 15:04:32.000000000 +0100
@@ -0,0 +1,24 @@
+#!/bin/sh
+
+PREFIX="i486-linux-uclibc-"
+OPTS="-static -static-libgcc \
+-D_LARGEFILE_SOURCE -D_LARGEFILE64_SOURCE -D_FILE_OFFSET_BITS=64 \
+-Wall -Wshadow -Wwrite-strings -Wundef -Wstrict-prototypes -Werror \
+-Wold-style-definition -Wdeclaration-after-statement -Wno-pointer-sign \
+-Wmissing-prototypes -Wmissing-declarations \
+-Os -fno-builtin-strlen -finline-limit=0 -fomit-frame-pointer \
+-ffunction-sections -fdata-sections -fno-guess-branch-probability \
+-funsigned-char \
+-falign-functions=1 -falign-jumps=1 -falign-labels=1 -falign-loops=1 \
+-march=i386 -mpreferred-stack-boundary=2 \
+-Wl,--warn-common -Wl,--sort-common -Wl,--gc-sections"
+
+${PREFIX}gcc \
+${OPTS} \
+-Wl,-Map -Wl,index.cgi.map \
+httpd_indexcgi.c -o index.cgi && strip index.cgi
+
+${PREFIX}gcc \
+${OPTS} \
+-Wl,-Map -Wl,httpd_ssi.map \
+httpd_ssi.c -o httpd_ssi && strip httpd_ssi
diff -urpN busybox-1.26.2/networking/httpd_post_upload.cgi busybox-1.27.0/networking/httpd_post_upload.cgi
--- busybox-1.26.2/networking/httpd_post_upload.cgi	1970-01-01 01:00:00.000000000 +0100
+++ busybox-1.27.0/networking/httpd_post_upload.cgi	2016-12-22 15:33:08.000000000 +0100
@@ -0,0 +1,59 @@
+#!/bin/sh
+
+# post_upload.htm example:
+# <html>
+# <body>
+# <form action=/cgi-bin/httpd_post_upload.cgi method=post enctype=multipart/form-data>
+# File to upload: <input type=file name=file1> <input type=submit>
+# </form>
+
+# POST upload format:
+# -----------------------------29995809218093749221856446032^M
+# Content-Disposition: form-data; name="file1"; filename="..."^M
+# Content-Type: application/octet-stream^M
+# ^M    <--------- headers end with empty line
+# file contents
+# file contents
+# file contents
+# ^M    <--------- extra empty line
+# -----------------------------29995809218093749221856446032--^M
+
+file=/tmp/$$-$RANDOM
+
+CR=`printf '\r'`
+
+# CGI output must start with at least empty line (or headers)
+printf '\r\n'
+
+IFS="$CR"
+read -r delim_line
+IFS=""
+
+while read -r line; do
+    test x"$line" = x"" && break
+    test x"$line" = x"$CR" && break
+done
+
+cat >"$file"
+
+# We need to delete the tail of "\r\ndelim_line--\r\n"
+tail_len=$((${#delim_line} + 6))
+
+# Get and check file size
+filesize=`stat -c"%s" "$file"`
+test "$filesize" -lt "$tail_len" && exit 1
+
+# Check that tail is correct
+dd if="$file" skip=$((filesize - tail_len)) bs=1 count=1000 >"$file.tail" 2>/dev/null
+printf "\r\n%s--\r\n" "$delim_line" >"$file.tail.expected"
+if ! diff -q "$file.tail" "$file.tail.expected" >/dev/null; then
+    printf "<html>\n<body>\nMalformed file upload"
+    exit 1
+fi
+rm "$file.tail"
+rm "$file.tail.expected"
+
+# Truncate the file
+dd of="$file" seek=$((filesize - tail_len)) bs=1 count=0 >/dev/null 2>/dev/null
+
+printf "<html>\n<body>\nFile upload has been accepted"
diff -urpN busybox-1.26.2/networking/httpd_post_upload.txt busybox-1.27.0/networking/httpd_post_upload.txt
--- busybox-1.26.2/networking/httpd_post_upload.txt	2017-01-01 12:57:06.000000000 +0100
+++ busybox-1.27.0/networking/httpd_post_upload.txt	1970-01-01 01:00:00.000000000 +0100
@@ -1,65 +0,0 @@
-POST upload example:
-
-post_upload.htm
-===============
-<html>
-<body>
-<form action=/cgi-bin/post_upload.cgi method=post enctype=multipart/form-data>
-File to upload: <input type=file name=file1> <input type=submit>
-</form>
-
-
-post_upload.cgi
-===============
-#!/bin/sh
-
-# POST upload format:
-# -----------------------------29995809218093749221856446032^M
-# Content-Disposition: form-data; name="file1"; filename="..."^M
-# Content-Type: application/octet-stream^M
-# ^M    <--------- headers end with empty line
-# file contents
-# file contents
-# file contents
-# ^M    <--------- extra empty line
-# -----------------------------29995809218093749221856446032--^M
-
-file=/tmp/$$-$RANDOM
-
-CR=`printf '\r'`
-
-# CGI output must start with at least empty line (or headers)
-printf '\r\n'
-
-IFS="$CR"
-read -r delim_line
-IFS=""
-
-while read -r line; do
-    test x"$line" = x"" && break
-    test x"$line" = x"$CR" && break
-done
-
-cat >"$file"
-
-# We need to delete the tail of "\r\ndelim_line--\r\n"
-tail_len=$((${#delim_line} + 6))
-
-# Get and check file size
-filesize=`stat -c"%s" "$file"`
-test "$filesize" -lt "$tail_len" && exit 1
-
-# Check that tail is correct
-dd if="$file" skip=$((filesize - tail_len)) bs=1 count=1000 >"$file.tail" 2>/dev/null
-printf "\r\n%s--\r\n" "$delim_line" >"$file.tail.expected"
-if ! diff -q "$file.tail" "$file.tail.expected" >/dev/null; then
-    printf "<html>\n<body>\nMalformed file upload"
-    exit 1
-fi
-rm "$file.tail"
-rm "$file.tail.expected"
-
-# Truncate the file
-dd of="$file" seek=$((filesize - tail_len)) bs=1 count=0 >/dev/null 2>/dev/null
-
-printf "<html>\n<body>\nFile upload has been accepted"
diff -urpN busybox-1.26.2/networking/ifenslave.c busybox-1.27.0/networking/ifenslave.c
--- busybox-1.26.2/networking/ifenslave.c	2016-12-10 18:46:36.000000000 +0100
+++ busybox-1.27.0/networking/ifenslave.c	2017-07-01 22:51:12.000000000 +0200
@@ -55,7 +55,7 @@
  *
  *    - 2003/03/18 - Tsippy Mendelson <tsippy.mendelson at intel dot com> and
  *                   Shmulik Hen <shmulik.hen at intel dot com>
- *       - Moved setting the slave's mac address and openning it, from
+ *       - Moved setting the slave's mac address and opening it, from
  *         the application to the driver. This enables support of modes
  *         that need to use the unique mac address of each slave.
  *         The driver also takes care of closing the slave and restoring its
diff -urpN busybox-1.26.2/networking/ifupdown.c busybox-1.27.0/networking/ifupdown.c
--- busybox-1.26.2/networking/ifupdown.c	2017-01-01 13:01:05.000000000 +0100
+++ busybox-1.27.0/networking/ifupdown.c	2017-01-30 21:57:30.000000000 +0100
@@ -66,14 +66,14 @@
 //config:	  utilities, or enable these applets in Busybox.
 //config:
 //config:config FEATURE_IFUPDOWN_IPV4
-//config:	bool "Support for IPv4"
+//config:	bool "Support IPv4"
 //config:	default y
 //config:	depends on IFUP || IFDOWN
 //config:	help
 //config:	  If you want ifup/ifdown to talk IPv4, leave this on.
 //config:
 //config:config FEATURE_IFUPDOWN_IPV6
-//config:	bool "Support for IPv6"
+//config:	bool "Support IPv6"
 //config:	default y
 //config:	depends on (IFUP || IFDOWN) && FEATURE_IPV6
 //config:	help
@@ -81,7 +81,7 @@
 //config:
 //UNUSED:
 ////////:config FEATURE_IFUPDOWN_IPX
-////////:	bool "Support for IPX"
+////////:	bool "Support IPX"
 ////////:	default y
 ////////:	depends on IFUP || IFDOWN
 ////////:	help
@@ -97,7 +97,7 @@
 //config:	  a weird network setup you don't need it.
 //config:
 //config:config FEATURE_IFUPDOWN_EXTERNAL_DHCP
-//config:	bool "Support for external dhcp clients"
+//config:	bool "Support external DHCP clients"
 //config:	default n
 //config:	depends on IFUP || IFDOWN
 //config:	help
@@ -106,7 +106,8 @@
 //config:	  Otherwise, if udhcpc applet is enabled, it is used.
 //config:	  Otherwise, ifup/ifdown will have no support for DHCP.
 
-//applet:IF_IFUP(APPLET_ODDNAME(ifup, ifupdown, BB_DIR_SBIN, BB_SUID_DROP, ifup))
+//                 APPLET_ODDNAME:name    main      location     suid_type     help
+//applet:IF_IFUP(  APPLET_ODDNAME(ifup,   ifupdown, BB_DIR_SBIN, BB_SUID_DROP, ifup))
 //applet:IF_IFDOWN(APPLET_ODDNAME(ifdown, ifupdown, BB_DIR_SBIN, BB_SUID_DROP, ifdown))
 
 //kbuild:lib-$(CONFIG_IFUP) += ifupdown.o
diff -urpN busybox-1.26.2/networking/inetd.c busybox-1.27.0/networking/inetd.c
--- busybox-1.26.2/networking/inetd.c	2016-12-10 18:46:36.000000000 +0100
+++ busybox-1.27.0/networking/inetd.c	2017-01-23 01:09:41.000000000 +0100
@@ -213,9 +213,9 @@
 //usage:       "Listen for network connections and launch programs\n"
 //usage:     "\n	-f	Run in foreground"
 //usage:     "\n	-e	Log to stderr"
-//usage:     "\n	-q N	Socket listen queue (default: 128)"
+//usage:     "\n	-q N	Socket listen queue (default 128)"
 //usage:     "\n	-R N	Pause services after N connects/min"
-//usage:     "\n		(default: 0 - disabled)"
+//usage:     "\n		(default 0 - disabled)"
 
 #include <syslog.h>
 #include <sys/resource.h> /* setrlimit */
@@ -1677,7 +1677,7 @@ static uint32_t machtime(void)
 	struct timeval tv;
 
 	gettimeofday(&tv, NULL);
-	return htonl((uint32_t)(tv.tv_sec + 2208988800));
+	return htonl((uint32_t)(tv.tv_sec + 2208988800U));
 }
 /* ARGSUSED */
 static void FAST_FUNC machtime_stream(int s, servtab_t *sep UNUSED_PARAM)
diff -urpN busybox-1.26.2/networking/ip.c busybox-1.27.0/networking/ip.c
--- busybox-1.26.2/networking/ip.c	2017-01-01 13:01:04.000000000 +0100
+++ busybox-1.27.0/networking/ip.c	2017-07-01 22:51:12.000000000 +0200
@@ -140,84 +140,138 @@
 //kbuild:lib-$(CONFIG_IPTUNNEL) += ip.o
 //kbuild:lib-$(CONFIG_IPNEIGH) += ip.o
 
-/* would need to make the " | " optional depending on more than one selected: */
-//usage:#define ip_trivial_usage
-//usage:       "[OPTIONS] {"
-//usage:	IF_FEATURE_IP_ADDRESS("address | ")
-//usage:	IF_FEATURE_IP_ROUTE("route | ")
-//usage:	IF_FEATURE_IP_LINK("link | ")
-//usage:	IF_FEATURE_IP_TUNNEL("tunnel | ")
-//usage:	IF_FEATURE_IP_NEIGH("neigh | ")
-//usage:	IF_FEATURE_IP_RULE("rule")
-//usage:       "} {COMMAND}"
-//usage:#define ip_full_usage "\n\n"
-//usage:       "ip [OPTIONS] OBJECT {COMMAND}\n"
-//usage:       "where OBJECT := {"
-//usage:	IF_FEATURE_IP_ADDRESS("address | ")
-//usage:	IF_FEATURE_IP_ROUTE("route | ")
-//usage:	IF_FEATURE_IP_LINK("link | ")
-//usage:	IF_FEATURE_IP_TUNNEL("tunnel | ")
-//usage:	IF_FEATURE_IP_NEIGH("neigh | ")
-//usage:	IF_FEATURE_IP_RULE("rule")
-//usage:       "}\n"
-//usage:       "OPTIONS := { -f[amily] { inet | inet6 | link } | -o[neline] }"
-//usage:
+//--------------123456789.123456789.123456789.123456789.123456789.123456789.123456789.123....79
 //usage:#define ipaddr_trivial_usage
-//usage:       "{ {add|del} IFADDR dev STRING | {show|flush}\n"
-//usage:       "		[dev STRING] [to PREFIX] }"
+//usage:       "add|del IFADDR dev IFACE | show|flush [dev IFACE] [to PREFIX]"
 //usage:#define ipaddr_full_usage "\n\n"
-//usage:       "ipaddr {add|change|replace|delete} IFADDR dev STRING\n"
-//usage:       "ipaddr {show|flush} [dev STRING] [scope SCOPE-ID]\n"
-//usage:       "	[to PREFIX] [label PATTERN]\n"
-//usage:       "	IFADDR := PREFIX | ADDR peer PREFIX\n"
-//usage:       "	[broadcast ADDR] [anycast ADDR]\n"
-//usage:       "	[label STRING] [scope SCOPE-ID]\n"
-//usage:       "	SCOPE-ID := [host | link | global | NUMBER]"
+//usage:       "ipaddr add|change|replace|delete dev IFACE IFADDR\n"
+//usage:       "	IFADDR := PREFIX | ADDR peer PREFIX [broadcast ADDR|+|-]\n"
+//usage:       "		[anycast ADDR] [label STRING] [scope SCOPE]\n"
+//usage:       "	PREFIX := ADDR[/MASK]\n"
+//usage:       "	SCOPE := [host|link|global|NUMBER]\n"
+//usage:       "ipaddr show|flush [dev IFACE] [scope SCOPE] [to PREFIX] [label PATTERN]"
 //usage:
+//--------------123456789.123456789.123456789.123456789.123456789.123456789.123456789.123....79
 //usage:#define iplink_trivial_usage
-//usage:       "{ set DEVICE { up | down | arp { on | off } | show [DEVICE] }"
+//usage:       "set IFACE [up|down] [arp on|off] | show [IFACE]"
 //usage:#define iplink_full_usage "\n\n"
-//usage:       "iplink set DEVICE { up | down | arp | multicast { on | off } |\n"
-//usage:       "			dynamic { on | off } |\n"
-//usage:       "			mtu MTU }\n"
-//usage:       "iplink show [DEVICE]"
+//usage:       "iplink set IFACE [up|down] [arp on|off] [multicast on|off] [promisc on|off]\n"
+//usage:       "	[mtu NUM] [name NAME] [qlen NUM] [address MAC]\n"
+//usage:       "iplink show [IFACE]"
 //usage:
+//--------------123456789.123456789.123456789.123456789.123456789.123456789.123456789.123....79
 //usage:#define iproute_trivial_usage
-//usage:       "{ list | flush | add | del | change | append |\n"
-//usage:       "		replace | test } ROUTE"
+//usage:       "list|flush|add|del|change|append|replace|test ROUTE"
 //usage:#define iproute_full_usage "\n\n"
-//usage:       "iproute { list | flush } SELECTOR\n"
-//usage:       "iproute get ADDRESS [from ADDRESS iif STRING]\n"
-//usage:       "	[oif STRING] [tos TOS]\n"
-//usage:       "iproute { add | del | change | append | replace | test } ROUTE\n"
+//usage:       "iproute list|flush SELECTOR\n"
 //usage:       "	SELECTOR := [root PREFIX] [match PREFIX] [proto RTPROTO]\n"
-//usage:       "	ROUTE := [TYPE] PREFIX [tos TOS] [proto RTPROTO] [metric METRIC]"
+//usage:       "	PREFIX := default|ADDR[/MASK]\n"
+//usage:       "iproute get ADDR [from ADDR iif IFACE]\n"
+//usage:       "	[oif IFACE] [tos TOS]\n"
+//usage:       "iproute add|del|change|append|replace|test ROUTE\n"
+//usage:       "	ROUTE := NODE_SPEC [INFO_SPEC]\n"
+//usage:       "	NODE_SPEC := PREFIX"IF_FEATURE_IP_RULE(" [table TABLE_ID]")" [proto RTPROTO] [scope SCOPE] [metric METRIC]\n"
+//usage:       "	INFO_SPEC := NH OPTIONS\n"
+//usage:       "	NH := [via [inet|inet6] ADDR] [dev IFACE] [src ADDR] [onlink]\n"
+//usage:       "	OPTIONS := [mtu [lock] NUM] [advmss [lock] NUM]"
+//upstream man ip-route:
+//======================
+//ip route { show | flush } SELECTOR
+//ip route save SELECTOR
+//ip route restore
+//ip route get ADDRESS [ from ADDRESS iif STRING  ] [ oif STRING ] [ tos TOS ]
+//ip route { add | del | change | append | replace } ROUTE
+//SELECTOR := [ root PREFIX ] [ match PREFIX ] [ exact PREFIX ] [ table TABLE_ID ] [ proto RTPROTO ] [ type TYPE ] [ scope SCOPE ]
+//ROUTE := NODE_SPEC [ INFO_SPEC ]
+//NODE_SPEC := [ TYPE ] PREFIX [ tos TOS ] [ table TABLE_ID ] [ proto RTPROTO ] [ scope SCOPE ] [ metric METRIC ]
+//INFO_SPEC := NH OPTIONS FLAGS [ nexthop NH ] ...
+//NH := [ encap ENCAP ] [ via [ FAMILY ] ADDRESS ] [ dev STRING ] [ weight NUMBER ] NHFLAGS
+// ..............................................................^ I guess [src ADDRESS] should be here
+//FAMILY := [ inet | inet6 | ipx | dnet | mpls | bridge | link ]
+//OPTIONS := FLAGS [ mtu NUMBER ] [ advmss NUMBER ] [ as [ to ] ADDRESS ] rtt TIME ] [ rttvar TIME ] [ reordering NUMBER ] [ window NUMBER ] [ cwnd NUMBER ] [ ssthresh REALM ] [ realms REALM ]
+//        [ rto_min TIME ] [ initcwnd NUMBER ] [ initrwnd NUMBER ] [ features FEATURES ] [ quickack BOOL ] [ congctl NAME ] [ pref PREF ] [ expires TIME ]
+//TYPE := [ unicast | local | broadcast | multicast | throw | unreachable | prohibit | blackhole | nat ]
+//TABLE_ID := [ local | main | default | all | NUMBER ]
+//SCOPE := [ host | link | global | NUMBER ]
+//NHFLAGS := [ onlink | pervasive ]
+//RTPROTO := [ kernel | boot | static | NUMBER ]
+//FEATURES := [ ecn | ]
+//PREF := [ low | medium | high ]
+//ENCAP := [ MPLS | IP ]
+//ENCAP_MPLS := mpls [ LABEL ]
+//ENCAP_IP := ip id TUNNEL_ID dst REMOTE_IP [ tos TOS ] [ ttl TTL ]
 //usage:
+//--------------123456789.123456789.123456789.123456789.123456789.123456789.123456789.123....79
 //usage:#define iprule_trivial_usage
-//usage:       "{[list | add | del] RULE}"
+//usage:       "[list] | add|del SELECTOR ACTION"
 //usage:#define iprule_full_usage "\n\n"
-//usage:       "iprule [list | add | del] SELECTOR ACTION\n"
 //usage:       "	SELECTOR := [from PREFIX] [to PREFIX] [tos TOS] [fwmark FWMARK]\n"
-//usage:       "			[dev STRING] [pref NUMBER]\n"
-//usage:       "	ACTION := [table TABLE_ID] [nat ADDRESS]\n"
-//usage:       "			[prohibit | reject | unreachable]\n"
+//usage:       "			[dev IFACE] [pref NUMBER]\n"
+//usage:       "	ACTION := [table TABLE_ID] [nat ADDR]\n"
+//usage:       "			[prohibit|reject|unreachable]\n"
 //usage:       "			[realms [SRCREALM/]DSTREALM]\n"
-//usage:       "	TABLE_ID := [local | main | default | NUMBER]"
+//usage:       "	TABLE_ID := [local|main|default|NUMBER]"
 //usage:
+//--------------123456789.123456789.123456789.123456789.123456789.123456789.123456789.123....79
 //usage:#define iptunnel_trivial_usage
-//usage:       "{ add | change | del | show } [NAME]\n"
-//usage:       "	[mode { ipip | gre | sit }]\n"
+//usage:       "add|change|del|show [NAME]\n"
+//usage:       "	[mode ipip|gre|sit]\n"
 //usage:       "	[remote ADDR] [local ADDR] [ttl TTL]"
 //usage:#define iptunnel_full_usage "\n\n"
-//usage:       "iptunnel { add | change | del | show } [NAME]\n"
-//usage:       "	[mode { ipip | gre | sit }] [remote ADDR] [local ADDR]\n"
+//usage:       "iptunnel add|change|del|show [NAME]\n"
+//usage:       "	[mode ipip|gre|sit] [remote ADDR] [local ADDR]\n"
 //usage:       "	[[i|o]seq] [[i|o]key KEY] [[i|o]csum]\n"
 //usage:       "	[ttl TTL] [tos TOS] [[no]pmtudisc] [dev PHYS_DEV]"
 //usage:
 //usage:#define ipneigh_trivial_usage
-//usage:       "{ show | flush} [ to PREFIX ] [ dev DEV ] [ nud STATE ]"
-//usage:#define ipneigh_full_usage "\n\n"
-//usage:       "ipneigh { show | flush} [ to PREFIX ] [ dev DEV ] [ nud STATE ]"
+//usage:       "show|flush [to PREFIX] [dev DEV] [nud STATE]"
+//usage:#define ipneigh_full_usage ""
+//usage:
+//usage:#if ENABLE_FEATURE_IP_ADDRESS || ENABLE_FEATURE_IP_ROUTE
+//usage:# define IP_BAR_LINK   "|"
+//usage:#else
+//usage:# define IP_BAR_LINK   ""
+//usage:#endif
+//usage:#if ENABLE_FEATURE_IP_ADDRESS || ENABLE_FEATURE_IP_ROUTE || ENABLE_FEATURE_IP_LINK
+//usage:# define IP_BAR_TUNNEL "|"
+//usage:#else
+//usage:# define IP_BAR_TUNNEL ""
+//usage:#endif
+//usage:#if ENABLE_FEATURE_IP_ADDRESS || ENABLE_FEATURE_IP_ROUTE || ENABLE_FEATURE_IP_LINK || ENABLE_FEATURE_IP_TUNNEL
+//usage:# define IP_BAR_NEIGH  "|"
+//usage:#else
+//usage:# define IP_BAR_NEIGH  ""
+//usage:#endif
+//usage:#if ENABLE_FEATURE_IP_ADDRESS || ENABLE_FEATURE_IP_ROUTE || ENABLE_FEATURE_IP_LINK || ENABLE_FEATURE_IP_TUNNEL || ENABLE_FEATURE_IP_NEIGH
+//usage:# define IP_BAR_RULE   "|"
+//usage:#else
+//usage:# define IP_BAR_RULE   ""
+//usage:#endif
+//usage:
+//usage:#define ip_trivial_usage
+//usage:       "[OPTIONS] "
+//usage:	IF_FEATURE_IP_ADDRESS("address")
+//usage:	IF_FEATURE_IP_ROUTE(  IF_FEATURE_IP_ADDRESS("|")"route")
+//usage:	IF_FEATURE_IP_LINK(   IP_BAR_LINK  "link")
+//usage:	IF_FEATURE_IP_TUNNEL( IP_BAR_TUNNEL"tunnel")
+//usage:	IF_FEATURE_IP_NEIGH(  IP_BAR_NEIGH "neigh")
+//usage:	IF_FEATURE_IP_RULE(   IP_BAR_RULE  "rule")
+//usage:       " [COMMAND]"
+//usage:#define ip_full_usage "\n\n"
+//usage:       "OPTIONS := -f[amily] inet|inet6|link | -o[neline]\n"
+//usage:       "COMMAND :="
+//usage:	IF_FEATURE_IP_ADDRESS("\n"
+//usage:	"ip addr "ipaddr_trivial_usage)
+//usage:	IF_FEATURE_IP_ROUTE("\n"
+//usage:	"ip route "iproute_trivial_usage)
+//usage:	IF_FEATURE_IP_LINK("\n"
+//usage:	"ip link "iplink_trivial_usage)
+//usage:	IF_FEATURE_IP_TUNNEL("\n"
+//usage:	"ip tunnel "iptunnel_trivial_usage)
+//usage:	IF_FEATURE_IP_NEIGH("\n"
+//usage:	"ip neigh "ipneigh_trivial_usage)
+//usage:	IF_FEATURE_IP_RULE("\n"
+//usage:	"ip rule "iprule_trivial_usage)
 
 #include "libbb.h"
 
diff -urpN busybox-1.26.2/networking/ipcalc.c busybox-1.27.0/networking/ipcalc.c
--- busybox-1.26.2/networking/ipcalc.c	2016-12-10 18:46:36.000000000 +0100
+++ busybox-1.27.0/networking/ipcalc.c	2017-01-10 16:31:40.000000000 +0100
@@ -18,6 +18,11 @@
 //config:	  ipcalc takes an IP address and netmask and calculates the
 //config:	  resulting broadcast, network, and host range.
 //config:
+//config:config FEATURE_IPCALC_LONG_OPTIONS
+//config:	bool "Enable long options"
+//config:	default y
+//config:	depends on IPCALC && LONG_OPTS
+//config:
 //config:config FEATURE_IPCALC_FANCY
 //config:	bool "Fancy IPCALC, more options, adds 1 kbyte"
 //config:	default y
@@ -25,13 +30,6 @@
 //config:	help
 //config:	  Adds the options hostname, prefix and silent to the output of
 //config:	  "ipcalc".
-//config:
-//config:config FEATURE_IPCALC_LONG_OPTIONS
-//config:	bool "Enable long options"
-//config:	default y
-//config:	depends on IPCALC && LONG_OPTS
-//config:	help
-//config:	  Support long options for the ipcalc applet.
 
 //applet:IF_IPCALC(APPLET(ipcalc, BB_DIR_BIN, BB_SUID_DROP))
 
diff -urpN busybox-1.26.2/networking/isrv.c busybox-1.27.0/networking/isrv.c
--- busybox-1.26.2/networking/isrv.c	2016-09-27 18:53:50.000000000 +0200
+++ busybox-1.27.0/networking/isrv.c	2017-07-01 22:51:12.000000000 +0200
@@ -191,7 +191,7 @@ static void handle_accept(isrv_state_t *
 	DPRINTF("new_peer(%d)", newfd);
 	n = state->new_peer(state, newfd);
 	if (n)
-		remove_peer(state, n); /* unsuccesful peer start */
+		remove_peer(state, n); /* unsuccessful peer start */
 }
 
 static void handle_fd_set(isrv_state_t *state, fd_set *fds, int (*h)(int, void **))
diff -urpN busybox-1.26.2/networking/libiproute/ipaddress.c busybox-1.27.0/networking/libiproute/ipaddress.c
--- busybox-1.26.2/networking/libiproute/ipaddress.c	2016-09-27 18:53:50.000000000 +0200
+++ busybox-1.27.0/networking/libiproute/ipaddress.c	2017-07-01 22:51:12.000000000 +0200
@@ -593,9 +593,13 @@ static int default_scope(inet_prefix *lc
 /* Return value becomes exitcode. It's okay to not return at all */
 static int ipaddr_modify(int cmd, int flags, char **argv)
 {
+	/* If you add stuff here, update ipaddr_full_usage */
 	static const char option[] ALIGN1 =
 		"peer\0""remote\0""broadcast\0""brd\0"
 		"anycast\0""scope\0""dev\0""label\0""local\0";
+#define option_peer      option
+#define option_broadcast (option           + sizeof("peer") + sizeof("remote"))
+#define option_anycast   (option_broadcast + sizeof("broadcast") + sizeof("brd"))
 	struct rtnl_handle rth;
 	struct {
 		struct nlmsghdr  n;
@@ -627,7 +631,7 @@ static int ipaddr_modify(int cmd, int fl
 
 		if (arg <= 1) { /* peer, remote */
 			if (peer_len) {
-				duparg("peer", *argv);
+				duparg(option_peer, *argv);
 			}
 			get_prefix(&peer, *argv, req.ifa.ifa_family);
 			peer_len = peer.bytelen;
@@ -639,7 +643,7 @@ static int ipaddr_modify(int cmd, int fl
 		} else if (arg <= 3) { /* broadcast, brd */
 			inet_prefix addr;
 			if (brd_len) {
-				duparg("broadcast", *argv);
+				duparg(option_broadcast, *argv);
 			}
 			if (LONE_CHAR(*argv, '+')) {
 				brd_len = -1;
@@ -655,7 +659,7 @@ static int ipaddr_modify(int cmd, int fl
 		} else if (arg == 4) { /* anycast */
 			inet_prefix addr;
 			if (any_len) {
-				duparg("anycast", *argv);
+				duparg(option_anycast, *argv);
 			}
 			get_addr(&addr, *argv, req.ifa.ifa_family);
 			if (req.ifa.ifa_family == AF_UNSPEC) {
diff -urpN busybox-1.26.2/networking/libiproute/iplink.c busybox-1.27.0/networking/libiproute/iplink.c
--- busybox-1.26.2/networking/libiproute/iplink.c	2016-09-27 18:53:50.000000000 +0200
+++ busybox-1.27.0/networking/libiproute/iplink.c	2017-07-01 22:51:12.000000000 +0200
@@ -52,6 +52,9 @@ struct ifla_vlan_flags {
 # define dbg(...) ((void)0)
 #endif
 
+
+#define str_on_off "on\0""off\0"
+
 /* Exits on error */
 static int get_ctl_fd(void)
 {
@@ -204,12 +207,14 @@ static int do_set(char **argv)
 	struct ifreq ifr0, ifr1;
 	char *newname = NULL;
 	int htype, halen;
+	/* If you add stuff here, update iplink_full_usage */
 	static const char keywords[] ALIGN1 =
 		"up\0""down\0""name\0""mtu\0""qlen\0""multicast\0"
-		"arp\0""address\0""dev\0";
+		"arp\0""promisc\0""address\0"
+		"dev\0" /* must be last */;
 	enum { ARG_up = 0, ARG_down, ARG_name, ARG_mtu, ARG_qlen, ARG_multicast,
-		ARG_arp, ARG_addr, ARG_dev };
-	static const char str_on_off[] ALIGN1 = "on\0""off\0";
+		ARG_arp, ARG_promisc, ARG_addr,
+		ARG_dev };
 	enum { PARM_on = 0, PARM_off };
 	smalluint key;
 
@@ -232,6 +237,7 @@ static int do_set(char **argv)
 				duparg("mtu", *argv);
 			mtu = get_unsigned(*argv, "mtu");
 		} else if (key == ARG_qlen) {
+//TODO: txqueuelen, txqlen are synonyms to qlen
 			NEXT_ARG();
 			if (qlen != -1)
 				duparg("qlen", *argv);
@@ -240,6 +246,7 @@ static int do_set(char **argv)
 			NEXT_ARG();
 			newaddr = *argv;
 		} else if (key >= ARG_dev) {
+			/* ^^^^^^ ">=" here results in "dev IFACE" treated as default */
 			if (key == ARG_dev) {
 				NEXT_ARG();
 			}
@@ -247,6 +254,7 @@ static int do_set(char **argv)
 				duparg2("dev", *argv);
 			dev = *argv;
 		} else {
+			/* "on|off" options */
 			int param;
 			NEXT_ARG();
 			param = index_in_strings(str_on_off, *argv);
@@ -266,8 +274,132 @@ static int do_set(char **argv)
 					flags &= ~IFF_NOARP;
 				else
 					flags |= IFF_NOARP;
+			} else if (key == ARG_promisc) {
+				if (param < 0)
+					die_must_be_on_off("promisc");
+				mask |= IFF_PROMISC;
+				if (param == PARM_on)
+					flags |= IFF_PROMISC;
+				else
+					flags &= ~IFF_PROMISC;
 			}
 		}
+
+/* Other keywords recognized by iproute2-3.12.0: */
+#if 0
+		} else if (matches(*argv, "broadcast") == 0 ||
+				strcmp(*argv, "brd") == 0) {
+			NEXT_ARG();
+			len = ll_addr_a2n(abuf, sizeof(abuf), *argv);
+			if (len < 0)
+				return -1;
+			addattr_l(&req->n, sizeof(*req), IFLA_BROADCAST, abuf, len);
+                } else if (strcmp(*argv, "netns") == 0) {
+                        NEXT_ARG();
+                        if (netns != -1)
+                                duparg("netns", *argv);
+			if ((netns = get_netns_fd(*argv)) >= 0)
+				addattr_l(&req->n, sizeof(*req), IFLA_NET_NS_FD, &netns, 4);
+			else if (get_integer(&netns, *argv, 0) == 0)
+				addattr_l(&req->n, sizeof(*req), IFLA_NET_NS_PID, &netns, 4);
+			else
+                                invarg_1_to_2(*argv, "netns");
+		} else if (strcmp(*argv, "allmulticast") == 0) {
+			NEXT_ARG();
+			req->i.ifi_change |= IFF_ALLMULTI;
+			if (strcmp(*argv, "on") == 0) {
+				req->i.ifi_flags |= IFF_ALLMULTI;
+			} else if (strcmp(*argv, "off") == 0) {
+				req->i.ifi_flags &= ~IFF_ALLMULTI;
+			} else
+				return on_off("allmulticast", *argv);
+		} else if (strcmp(*argv, "trailers") == 0) {
+			NEXT_ARG();
+			req->i.ifi_change |= IFF_NOTRAILERS;
+			if (strcmp(*argv, "off") == 0) {
+				req->i.ifi_flags |= IFF_NOTRAILERS;
+			} else if (strcmp(*argv, "on") == 0) {
+				req->i.ifi_flags &= ~IFF_NOTRAILERS;
+			} else
+				return on_off("trailers", *argv);
+		} else if (strcmp(*argv, "vf") == 0) {
+			struct rtattr *vflist;
+			NEXT_ARG();
+			if (get_integer(&vf,  *argv, 0)) {
+				invarg_1_to_2(*argv, "vf");
+			}
+			vflist = addattr_nest(&req->n, sizeof(*req),
+					      IFLA_VFINFO_LIST);
+			len = iplink_parse_vf(vf, &argc, &argv, req);
+			if (len < 0)
+				return -1;
+			addattr_nest_end(&req->n, vflist);
+		} else if (matches(*argv, "master") == 0) {
+			int ifindex;
+			NEXT_ARG();
+			ifindex = ll_name_to_index(*argv);
+			if (!ifindex)
+				invarg_1_to_2(*argv, "master");
+			addattr_l(&req->n, sizeof(*req), IFLA_MASTER,
+				  &ifindex, 4);
+		} else if (matches(*argv, "nomaster") == 0) {
+			int ifindex = 0;
+			addattr_l(&req->n, sizeof(*req), IFLA_MASTER,
+				  &ifindex, 4);
+		} else if (matches(*argv, "dynamic") == 0) {
+			NEXT_ARG();
+			req->i.ifi_change |= IFF_DYNAMIC;
+			if (strcmp(*argv, "on") == 0) {
+				req->i.ifi_flags |= IFF_DYNAMIC;
+			} else if (strcmp(*argv, "off") == 0) {
+				req->i.ifi_flags &= ~IFF_DYNAMIC;
+			} else
+				return on_off("dynamic", *argv);
+		} else if (matches(*argv, "alias") == 0) {
+			NEXT_ARG();
+			addattr_l(&req->n, sizeof(*req), IFLA_IFALIAS,
+				  *argv, strlen(*argv));
+			argc--; argv++;
+			break;
+		} else if (strcmp(*argv, "group") == 0) {
+			NEXT_ARG();
+			if (*group != -1)
+				duparg("group", *argv);
+			if (rtnl_group_a2n(group, *argv))
+				invarg_1_to_2(*argv, "group");
+		} else if (strcmp(*argv, "mode") == 0) {
+			int mode;
+			NEXT_ARG();
+			mode = get_link_mode(*argv);
+			if (mode < 0)
+				invarg_1_to_2(*argv, "mode");
+			addattr8(&req->n, sizeof(*req), IFLA_LINKMODE, mode);
+		} else if (strcmp(*argv, "state") == 0) {
+			int state;
+			NEXT_ARG();
+			state = get_operstate(*argv);
+			if (state < 0)
+				invarg_1_to_2(*argv, "state");
+			addattr8(&req->n, sizeof(*req), IFLA_OPERSTATE, state);
+		} else if (matches(*argv, "numtxqueues") == 0) {
+			NEXT_ARG();
+			if (numtxqueues != -1)
+				duparg("numtxqueues", *argv);
+			if (get_integer(&numtxqueues, *argv, 0))
+				invarg_1_to_2(*argv, "numtxqueues");
+			addattr_l(&req->n, sizeof(*req), IFLA_NUM_TX_QUEUES,
+				  &numtxqueues, 4);
+		} else if (matches(*argv, "numrxqueues") == 0) {
+			NEXT_ARG();
+			if (numrxqueues != -1)
+				duparg("numrxqueues", *argv);
+			if (get_integer(&numrxqueues, *argv, 0))
+				invarg_1_to_2(*argv, "numrxqueues");
+			addattr_l(&req->n, sizeof(*req), IFLA_NUM_RX_QUEUES,
+				  &numrxqueues, 4);
+		}
+#endif
+
 		argv++;
 	}
 
@@ -322,10 +454,6 @@ static void vlan_parse_opt(char **argv,
 		"802.1q\0"
 		"802.1ad\0"
 	;
-	static const char str_on_off[] ALIGN1 =
-		"on\0"
-		"off\0"
-	;
 	enum {
 		ARG_id = 0,
 		ARG_reorder_hdr,
@@ -520,164 +648,6 @@ static int do_add_or_delete(char **argv,
 	return 0;
 }
 
-/* Other keywords recognized by iproute2-3.12.0: */
-#if 0
-		} else if (matches(*argv, "broadcast") == 0 ||
-				strcmp(*argv, "brd") == 0) {
-			NEXT_ARG();
-			len = ll_addr_a2n(abuf, sizeof(abuf), *argv);
-			if (len < 0)
-				return -1;
-			addattr_l(&req->n, sizeof(*req), IFLA_BROADCAST, abuf, len);
-		} else if (matches(*argv, "txqueuelen") == 0 ||
-				strcmp(*argv, "qlen") == 0 ||
-				matches(*argv, "txqlen") == 0) {
-			NEXT_ARG();
-			if (qlen != -1)
-				duparg("txqueuelen", *argv);
-			if (get_integer(&qlen,  *argv, 0))
-				invarg_1_to_2(*argv, "txqueuelen");
-			addattr_l(&req->n, sizeof(*req), IFLA_TXQLEN, &qlen, 4);
-		} else if (strcmp(*argv, "mtu") == 0) {
-			NEXT_ARG();
-			if (mtu != -1)
-				duparg("mtu", *argv);
-			if (get_integer(&mtu, *argv, 0))
-				invarg_1_to_2(*argv, "mtu");
-			addattr_l(&req->n, sizeof(*req), IFLA_MTU, &mtu, 4);
-                } else if (strcmp(*argv, "netns") == 0) {
-                        NEXT_ARG();
-                        if (netns != -1)
-                                duparg("netns", *argv);
-			if ((netns = get_netns_fd(*argv)) >= 0)
-				addattr_l(&req->n, sizeof(*req), IFLA_NET_NS_FD, &netns, 4);
-			else if (get_integer(&netns, *argv, 0) == 0)
-				addattr_l(&req->n, sizeof(*req), IFLA_NET_NS_PID, &netns, 4);
-			else
-                                invarg_1_to_2(*argv, "netns");
-		} else if (strcmp(*argv, "multicast") == 0) {
-			NEXT_ARG();
-			req->i.ifi_change |= IFF_MULTICAST;
-			if (strcmp(*argv, "on") == 0) {
-				req->i.ifi_flags |= IFF_MULTICAST;
-			} else if (strcmp(*argv, "off") == 0) {
-				req->i.ifi_flags &= ~IFF_MULTICAST;
-			} else
-				return on_off("multicast", *argv);
-		} else if (strcmp(*argv, "allmulticast") == 0) {
-			NEXT_ARG();
-			req->i.ifi_change |= IFF_ALLMULTI;
-			if (strcmp(*argv, "on") == 0) {
-				req->i.ifi_flags |= IFF_ALLMULTI;
-			} else if (strcmp(*argv, "off") == 0) {
-				req->i.ifi_flags &= ~IFF_ALLMULTI;
-			} else
-				return on_off("allmulticast", *argv);
-		} else if (strcmp(*argv, "promisc") == 0) {
-			NEXT_ARG();
-			req->i.ifi_change |= IFF_PROMISC;
-			if (strcmp(*argv, "on") == 0) {
-				req->i.ifi_flags |= IFF_PROMISC;
-			} else if (strcmp(*argv, "off") == 0) {
-				req->i.ifi_flags &= ~IFF_PROMISC;
-			} else
-				return on_off("promisc", *argv);
-		} else if (strcmp(*argv, "trailers") == 0) {
-			NEXT_ARG();
-			req->i.ifi_change |= IFF_NOTRAILERS;
-			if (strcmp(*argv, "off") == 0) {
-				req->i.ifi_flags |= IFF_NOTRAILERS;
-			} else if (strcmp(*argv, "on") == 0) {
-				req->i.ifi_flags &= ~IFF_NOTRAILERS;
-			} else
-				return on_off("trailers", *argv);
-		} else if (strcmp(*argv, "arp") == 0) {
-			NEXT_ARG();
-			req->i.ifi_change |= IFF_NOARP;
-			if (strcmp(*argv, "on") == 0) {
-				req->i.ifi_flags &= ~IFF_NOARP;
-			} else if (strcmp(*argv, "off") == 0) {
-				req->i.ifi_flags |= IFF_NOARP;
-			} else
-				return on_off("noarp", *argv);
-		} else if (strcmp(*argv, "vf") == 0) {
-			struct rtattr *vflist;
-			NEXT_ARG();
-			if (get_integer(&vf,  *argv, 0)) {
-				invarg_1_to_2(*argv, "vf");
-			}
-			vflist = addattr_nest(&req->n, sizeof(*req),
-					      IFLA_VFINFO_LIST);
-			len = iplink_parse_vf(vf, &argc, &argv, req);
-			if (len < 0)
-				return -1;
-			addattr_nest_end(&req->n, vflist);
-		} else if (matches(*argv, "master") == 0) {
-			int ifindex;
-			NEXT_ARG();
-			ifindex = ll_name_to_index(*argv);
-			if (!ifindex)
-				invarg_1_to_2(*argv, "master");
-			addattr_l(&req->n, sizeof(*req), IFLA_MASTER,
-				  &ifindex, 4);
-		} else if (matches(*argv, "nomaster") == 0) {
-			int ifindex = 0;
-			addattr_l(&req->n, sizeof(*req), IFLA_MASTER,
-				  &ifindex, 4);
-		} else if (matches(*argv, "dynamic") == 0) {
-			NEXT_ARG();
-			req->i.ifi_change |= IFF_DYNAMIC;
-			if (strcmp(*argv, "on") == 0) {
-				req->i.ifi_flags |= IFF_DYNAMIC;
-			} else if (strcmp(*argv, "off") == 0) {
-				req->i.ifi_flags &= ~IFF_DYNAMIC;
-			} else
-				return on_off("dynamic", *argv);
-		} else if (matches(*argv, "alias") == 0) {
-			NEXT_ARG();
-			addattr_l(&req->n, sizeof(*req), IFLA_IFALIAS,
-				  *argv, strlen(*argv));
-			argc--; argv++;
-			break;
-		} else if (strcmp(*argv, "group") == 0) {
-			NEXT_ARG();
-			if (*group != -1)
-				duparg("group", *argv);
-			if (rtnl_group_a2n(group, *argv))
-				invarg_1_to_2(*argv, "group");
-		} else if (strcmp(*argv, "mode") == 0) {
-			int mode;
-			NEXT_ARG();
-			mode = get_link_mode(*argv);
-			if (mode < 0)
-				invarg_1_to_2(*argv, "mode");
-			addattr8(&req->n, sizeof(*req), IFLA_LINKMODE, mode);
-		} else if (strcmp(*argv, "state") == 0) {
-			int state;
-			NEXT_ARG();
-			state = get_operstate(*argv);
-			if (state < 0)
-				invarg_1_to_2(*argv, "state");
-			addattr8(&req->n, sizeof(*req), IFLA_OPERSTATE, state);
-		} else if (matches(*argv, "numtxqueues") == 0) {
-			NEXT_ARG();
-			if (numtxqueues != -1)
-				duparg("numtxqueues", *argv);
-			if (get_integer(&numtxqueues, *argv, 0))
-				invarg_1_to_2(*argv, "numtxqueues");
-			addattr_l(&req->n, sizeof(*req), IFLA_NUM_TX_QUEUES,
-				  &numtxqueues, 4);
-		} else if (matches(*argv, "numrxqueues") == 0) {
-			NEXT_ARG();
-			if (numrxqueues != -1)
-				duparg("numrxqueues", *argv);
-			if (get_integer(&numrxqueues, *argv, 0))
-				invarg_1_to_2(*argv, "numrxqueues");
-			addattr_l(&req->n, sizeof(*req), IFLA_NUM_RX_QUEUES,
-				  &numrxqueues, 4);
-		}
-#endif
-
 /* Return value becomes exitcode. It's okay to not return at all */
 int FAST_FUNC do_iplink(char **argv)
 {
diff -urpN busybox-1.26.2/networking/libiproute/iproute.c busybox-1.27.0/networking/libiproute/iproute.c
--- busybox-1.26.2/networking/libiproute/iproute.c	2016-12-22 14:10:40.000000000 +0100
+++ busybox-1.27.0/networking/libiproute/iproute.c	2017-07-01 22:51:12.000000000 +0200
@@ -28,7 +28,7 @@ struct filter_t {
 	int flushe;
 	struct rtnl_handle *rth;
 	//int protocol, protocolmask; - write-only fields?!
-	//int scope, scopemask; - unused
+	int scope, scopemask;
 	//int type; - read-only
 	//int typemask; - unused
 	//int tos, tosmask; - unused
@@ -120,6 +120,8 @@ static int FAST_FUNC print_route(const s
 			return 0;
 		}
 	}
+	if ((G_filter.scope ^ r->rtm_scope) & G_filter.scopemask)
+		return 0;
 	if (G_filter.rdst.family
 	 && (r->rtm_family != G_filter.rdst.family || G_filter.rdst.bitlen > r->rtm_dst_len)
 	) {
@@ -270,7 +272,11 @@ static int FAST_FUNC print_route(const s
 		printf("table %s ", rtnl_rttable_n2a(tid));
 #endif
 
-	/* Todo: parse & show "proto kernel", "scope link" here */
+	/* Todo: parse & show "proto kernel" here */
+	if (!(r->rtm_flags & RTM_F_CLONED)) {
+		if ((r->rtm_scope != RT_SCOPE_UNIVERSE) && G_filter.scopemask != -1)
+			printf("scope %s ", rtnl_rtscope_n2a(r->rtm_scope));
+	}
 
 	if (tb[RTA_PREFSRC] && /*G_filter.rprefsrc.bitlen - always 0*/ 0 != host_len) {
 		/* Do not use format_host(). It is our local addr
@@ -322,16 +328,31 @@ static int FAST_FUNC print_route(const s
 	return 0;
 }
 
+static int str_is_lock(const char *str)
+{
+	return strcmp(str, "lock") == 0;
+}
+
 /* Return value becomes exitcode. It's okay to not return at all */
 static int iproute_modify(int cmd, unsigned flags, char **argv)
 {
+	/* If you add stuff here, update iproute_full_usage */
 	static const char keywords[] ALIGN1 =
-		"src\0""via\0""mtu\0""lock\0""scope\0""protocol\0"IF_FEATURE_IP_RULE("table\0")
+		"src\0""via\0"
+		"mtu\0""advmss\0"
+		"scope\0""protocol\0"IF_FEATURE_IP_RULE("table\0")
 		"dev\0""oif\0""to\0""metric\0""onlink\0";
+#define keyword_via    (keywords       + sizeof("src"))
+#define keyword_mtu    (keyword_via    + sizeof("via"))
+#define keyword_advmss (keyword_mtu    + sizeof("mtu"))
+#define keyword_scope  (keyword_advmss + sizeof("advmss"))
+#define keyword_proto  (keyword_scope  + sizeof("scope"))
+#define keyword_table  (keyword_proto  + sizeof("protocol"))
 	enum {
 		ARG_src,
 		ARG_via,
-		ARG_mtu, PARM_lock,
+		ARG_mtu,
+		ARG_advmss,
 		ARG_scope,
 		ARG_protocol,
 IF_FEATURE_IP_RULE(ARG_table,)
@@ -404,24 +425,33 @@ IF_FEATURE_IP_RULE(ARG_table,)
 		} else if (arg == ARG_mtu) {
 			unsigned mtu;
 			NEXT_ARG();
-			if (index_in_strings(keywords, *argv) == PARM_lock) {
+			if (str_is_lock(*argv)) {
 				mxlock |= (1 << RTAX_MTU);
 				NEXT_ARG();
 			}
-			mtu = get_unsigned(*argv, "mtu");
+			mtu = get_unsigned(*argv, keyword_mtu);
 			rta_addattr32(mxrta, sizeof(mxbuf), RTAX_MTU, mtu);
+		} else if (arg == ARG_advmss) {
+			unsigned mss;
+			NEXT_ARG();
+			if (str_is_lock(*argv)) {
+				mxlock |= (1 << RTAX_ADVMSS);
+				NEXT_ARG();
+			}
+			mss = get_unsigned(*argv, keyword_advmss);
+			rta_addattr32(mxrta, sizeof(mxbuf), RTAX_ADVMSS, mss);
 		} else if (arg == ARG_scope) {
 			uint32_t scope;
 			NEXT_ARG();
 			if (rtnl_rtscope_a2n(&scope, *argv))
-				invarg_1_to_2(*argv, "scope");
+				invarg_1_to_2(*argv, keyword_scope);
 			req.r.rtm_scope = scope;
 			scope_ok = 1;
 		} else if (arg == ARG_protocol) {
 			uint32_t prot;
 			NEXT_ARG();
 			if (rtnl_rtprot_a2n(&prot, *argv))
-				invarg_1_to_2(*argv, "protocol");
+				invarg_1_to_2(*argv, keyword_proto);
 			req.r.rtm_protocol = prot;
 			ok |= proto_ok;
 #if ENABLE_FEATURE_IP_RULE
@@ -429,7 +459,7 @@ IF_FEATURE_IP_RULE(ARG_table,)
 			uint32_t tid;
 			NEXT_ARG();
 			if (rtnl_rttable_a2n(&tid, *argv))
-				invarg_1_to_2(*argv, "table");
+				invarg_1_to_2(*argv, keyword_table);
 			if (tid < 256)
 				req.r.rtm_table = tid;
 			else {
@@ -441,6 +471,7 @@ IF_FEATURE_IP_RULE(ARG_table,)
 			NEXT_ARG();
 			d = *argv;
 		} else if (arg == ARG_metric) {
+//TODO: "metric", "priority" and "preference" are synonyms
 			uint32_t metric;
 			NEXT_ARG();
 			metric = get_u32(*argv, "metric");
@@ -475,6 +506,158 @@ IF_FEATURE_IP_RULE(ARG_table,)
 				addattr_l(&req.n, sizeof(req), RTA_DST, &dst.data, dst.bytelen);
 			}
 		}
+/* Other keywords recognized by iproute2-3.19.0: */
+#if 0
+		} else if (strcmp(*argv, "from") == 0) {
+			inet_prefix addr;
+			NEXT_ARG();
+			get_prefix(&addr, *argv, req.r.rtm_family);
+			if (req.r.rtm_family == AF_UNSPEC)
+				req.r.rtm_family = addr.family;
+			if (addr.bytelen)
+				addattr_l(&req.n, sizeof(req), RTA_SRC, &addr.data, addr.bytelen);
+			req.r.rtm_src_len = addr.bitlen;
+		} else if (strcmp(*argv, "tos") == 0 ||
+			   matches(*argv, "dsfield") == 0) {
+			__u32 tos;
+			NEXT_ARG();
+			if (rtnl_dsfield_a2n(&tos, *argv))
+				invarg("\"tos\" value is invalid\n", *argv);
+			req.r.rtm_tos = tos;
+		} else if (strcmp(*argv, "hoplimit") == 0) {
+			unsigned hoplimit;
+			NEXT_ARG();
+			if (strcmp(*argv, "lock") == 0) {
+				mxlock |= (1<<RTAX_HOPLIMIT);
+				NEXT_ARG();
+			}
+			if (get_unsigned(&hoplimit, *argv, 0))
+				invarg("\"hoplimit\" value is invalid\n", *argv);
+			rta_addattr32(mxrta, sizeof(mxbuf), RTAX_HOPLIMIT, hoplimit);
+		} else if (matches(*argv, "reordering") == 0) {
+			unsigned reord;
+			NEXT_ARG();
+			if (strcmp(*argv, "lock") == 0) {
+				mxlock |= (1<<RTAX_REORDERING);
+				NEXT_ARG();
+			}
+			if (get_unsigned(&reord, *argv, 0))
+				invarg("\"reordering\" value is invalid\n", *argv);
+			rta_addattr32(mxrta, sizeof(mxbuf), RTAX_REORDERING, reord);
+		} else if (strcmp(*argv, "rtt") == 0) {
+			unsigned rtt;
+			NEXT_ARG();
+			if (strcmp(*argv, "lock") == 0) {
+				mxlock |= (1<<RTAX_RTT);
+				NEXT_ARG();
+			}
+			if (get_time_rtt(&rtt, *argv, &raw))
+				invarg("\"rtt\" value is invalid\n", *argv);
+			rta_addattr32(mxrta, sizeof(mxbuf), RTAX_RTT,
+				(raw) ? rtt : rtt * 8);
+		} else if (strcmp(*argv, "rto_min") == 0) {
+			unsigned rto_min;
+			NEXT_ARG();
+			mxlock |= (1<<RTAX_RTO_MIN);
+			if (get_time_rtt(&rto_min, *argv, &raw))
+				invarg("\"rto_min\" value is invalid\n",
+				       *argv);
+			rta_addattr32(mxrta, sizeof(mxbuf), RTAX_RTO_MIN,
+				      rto_min);
+		} else if (matches(*argv, "window") == 0) {
+			unsigned win;
+			NEXT_ARG();
+			if (strcmp(*argv, "lock") == 0) {
+				mxlock |= (1<<RTAX_WINDOW);
+				NEXT_ARG();
+			}
+			if (get_unsigned(&win, *argv, 0))
+				invarg("\"window\" value is invalid\n", *argv);
+			rta_addattr32(mxrta, sizeof(mxbuf), RTAX_WINDOW, win);
+		} else if (matches(*argv, "cwnd") == 0) {
+			unsigned win;
+			NEXT_ARG();
+			if (strcmp(*argv, "lock") == 0) {
+				mxlock |= (1<<RTAX_CWND);
+				NEXT_ARG();
+			}
+			if (get_unsigned(&win, *argv, 0))
+				invarg("\"cwnd\" value is invalid\n", *argv);
+			rta_addattr32(mxrta, sizeof(mxbuf), RTAX_CWND, win);
+		} else if (matches(*argv, "initcwnd") == 0) {
+			unsigned win;
+			NEXT_ARG();
+			if (strcmp(*argv, "lock") == 0) {
+				mxlock |= (1<<RTAX_INITCWND);
+				NEXT_ARG();
+			}
+			if (get_unsigned(&win, *argv, 0))
+				invarg("\"initcwnd\" value is invalid\n", *argv);
+			rta_addattr32(mxrta, sizeof(mxbuf), RTAX_INITCWND, win);
+		} else if (matches(*argv, "initrwnd") == 0) {
+			unsigned win;
+			NEXT_ARG();
+			if (strcmp(*argv, "lock") == 0) {
+				mxlock |= (1<<RTAX_INITRWND);
+				NEXT_ARG();
+			}
+			if (get_unsigned(&win, *argv, 0))
+				invarg("\"initrwnd\" value is invalid\n", *argv);
+			rta_addattr32(mxrta, sizeof(mxbuf), RTAX_INITRWND, win);
+		} else if (matches(*argv, "features") == 0) {
+			unsigned int features = 0;
+
+			while (argc > 0) {
+				NEXT_ARG();
+
+				if (strcmp(*argv, "ecn") == 0)
+					features |= RTAX_FEATURE_ECN;
+				else
+					invarg("\"features\" value not valid\n", *argv);
+				break;
+			}
+
+			rta_addattr32(mxrta, sizeof(mxbuf), RTAX_FEATURES, features);
+		} else if (matches(*argv, "quickack") == 0) {
+			unsigned quickack;
+			NEXT_ARG();
+			if (get_unsigned(&quickack, *argv, 0))
+				invarg("\"quickack\" value is invalid\n", *argv);
+			if (quickack != 1 && quickack != 0)
+				invarg("\"quickack\" value should be 0 or 1\n", *argv);
+			rta_addattr32(mxrta, sizeof(mxbuf), RTAX_QUICKACK, quickack);
+		} else if (matches(*argv, "rttvar") == 0) {
+			unsigned win;
+			NEXT_ARG();
+			if (strcmp(*argv, "lock") == 0) {
+				mxlock |= (1<<RTAX_RTTVAR);
+				NEXT_ARG();
+			}
+			if (get_time_rtt(&win, *argv, &raw))
+				invarg("\"rttvar\" value is invalid\n", *argv);
+			rta_addattr32(mxrta, sizeof(mxbuf), RTAX_RTTVAR,
+				(raw) ? win : win * 4);
+		} else if (matches(*argv, "ssthresh") == 0) {
+			unsigned win;
+			NEXT_ARG();
+			if (strcmp(*argv, "lock") == 0) {
+				mxlock |= (1<<RTAX_SSTHRESH);
+				NEXT_ARG();
+			}
+			if (get_unsigned(&win, *argv, 0))
+				invarg("\"ssthresh\" value is invalid\n", *argv);
+			rta_addattr32(mxrta, sizeof(mxbuf), RTAX_SSTHRESH, win);
+		} else if (matches(*argv, "realms") == 0) {
+			__u32 realm;
+			NEXT_ARG();
+			if (get_rt_realms(&realm, *argv))
+				invarg("\"realm\" value is invalid\n", *argv);
+			addattr32(&req.n, sizeof(req), RTA_FLOW, realm);
+		} else if (strcmp(*argv, "nexthop") == 0) {
+			nhs_ok = 1;
+			break;
+		}
+#endif
 		argv++;
 	}
 
@@ -584,10 +767,11 @@ static int iproute_list_or_flush(char **
 	char *id = NULL;
 	char *od = NULL;
 	static const char keywords[] ALIGN1 =
+		/* If you add stuff here, update iproute_full_usage */
 		/* "ip route list/flush" parameters: */
 		"protocol\0" "dev\0"   "oif\0"   "iif\0"
 		"via\0"      "table\0" "cache\0"
-		"from\0"     "to\0"
+		"from\0"     "to\0"    "scope\0"
 		/* and possible further keywords */
 		"all\0"
 		"root\0"
@@ -598,7 +782,7 @@ static int iproute_list_or_flush(char **
 	enum {
 		KW_proto, KW_dev,   KW_oif,  KW_iif,
 		KW_via,   KW_table, KW_cache,
-		KW_from,  KW_to,
+		KW_from,  KW_to,    KW_scope,
 		/* */
 		KW_all,
 		KW_root,
@@ -657,6 +841,17 @@ static int iproute_list_or_flush(char **
 			/* The command 'ip route flush cache' is used by OpenSWAN.
 			 * Assuming it's a synonym for 'ip route flush table cache' */
 			G_filter.tb = -1;
+		} else if (arg == KW_scope) {
+			uint32_t scope;
+			NEXT_ARG();
+			G_filter.scopemask = -1;
+			if (rtnl_rtscope_a2n(&scope, *argv)) {
+				if (strcmp(*argv, "all") != 0)
+					invarg_1_to_2(*argv, "scope");
+				scope = RT_SCOPE_NOWHERE;
+				G_filter.scopemask = 0;
+			}
+			G_filter.scope = scope;
 		} else if (arg == KW_from) {
 			NEXT_ARG();
 			parm = index_in_substrings(keywords, *argv);
@@ -912,9 +1107,15 @@ static int iproute_get(char **argv)
 int FAST_FUNC do_iproute(char **argv)
 {
 	static const char ip_route_commands[] ALIGN1 =
-	/*0-3*/	"add\0""append\0""change\0""chg\0"
-	/*4-7*/	"delete\0""get\0""list\0""show\0"
-	/*8..*/	"prepend\0""replace\0""test\0""flush\0";
+		"a\0""add\0""append\0""change\0""chg\0"
+		"delete\0""get\0""list\0""show\0"
+		"prepend\0""replace\0""test\0""flush\0"
+	;
+	enum {
+		CMD_a = 0, CMD_add, CMD_append, CMD_change, CMD_chg,
+		CMD_delete, CMD_get, CMD_list, CMD_show,
+		CMD_prepend, CMD_replace, CMD_test, CMD_flush,
+	};
 	int command_num;
 	unsigned flags = 0;
 	int cmd = RTM_NEWROUTE;
@@ -929,38 +1130,39 @@ int FAST_FUNC do_iproute(char **argv)
 	command_num = index_in_substrings(ip_route_commands, *argv);
 
 	switch (command_num) {
-		case 0: /* add */
+		case CMD_a:
+		case CMD_add:
 			flags = NLM_F_CREATE|NLM_F_EXCL;
 			break;
-		case 1: /* append */
+		case CMD_append:
 			flags = NLM_F_CREATE|NLM_F_APPEND;
 			break;
-		case 2: /* change */
-		case 3: /* chg */
+		case CMD_change:
+		case CMD_chg:
 			flags = NLM_F_REPLACE;
 			break;
-		case 4: /* delete */
+		case CMD_delete:
 			cmd = RTM_DELROUTE;
 			break;
-		case 5: /* get */
-			return iproute_get(argv+1);
-		case 6: /* list */
-		case 7: /* show */
-			return iproute_list_or_flush(argv+1, 0);
-		case 8: /* prepend */
+		case CMD_get:
+			return iproute_get(argv + 1);
+		case CMD_list:
+		case CMD_show:
+			return iproute_list_or_flush(argv + 1, 0);
+		case CMD_prepend:
 			flags = NLM_F_CREATE;
 			break;
-		case 9: /* replace */
+		case CMD_replace:
 			flags = NLM_F_CREATE|NLM_F_REPLACE;
 			break;
-		case 10: /* test */
+		case CMD_test:
 			flags = NLM_F_EXCL;
 			break;
-		case 11: /* flush */
-			return iproute_list_or_flush(argv+1, 1);
+		case CMD_flush:
+			return iproute_list_or_flush(argv + 1, 1);
 		default:
 			invarg_1_to_2(*argv, applet_name);
 	}
 
-	return iproute_modify(cmd, flags, argv+1);
+	return iproute_modify(cmd, flags, argv + 1);
 }
diff -urpN busybox-1.26.2/networking/libiproute/iprule.c busybox-1.27.0/networking/libiproute/iprule.c
--- busybox-1.26.2/networking/libiproute/iprule.c	2016-12-22 14:10:40.000000000 +0100
+++ busybox-1.27.0/networking/libiproute/iprule.c	2017-07-01 22:51:12.000000000 +0200
@@ -17,25 +17,32 @@
 #include <netinet/ip.h>
 #include <arpa/inet.h>
 
+/* from <linux/fib_rules.h>: */
+#define FRA_SUPPRESS_IFGROUP   13
+#define FRA_SUPPRESS_PREFIXLEN 14
+
 #include "ip_common.h"  /* #include "libbb.h" is inside */
 #include "rt_names.h"
 #include "utils.h"
 
-/*
-static void usage(void) __attribute__((noreturn));
-
-static void usage(void)
-{
-	fprintf(stderr, "Usage: ip rule [ list | add | del ] SELECTOR ACTION\n");
-	fprintf(stderr, "SELECTOR := [ from PREFIX ] [ to PREFIX ] [ tos TOS ] [ fwmark FWMARK ]\n");
-	fprintf(stderr, "            [ dev STRING ] [ pref NUMBER ]\n");
-	fprintf(stderr, "ACTION := [ table TABLE_ID ] [ nat ADDRESS ]\n");
-	fprintf(stderr, "          [ prohibit | reject | unreachable ]\n");
-	fprintf(stderr, "          [ realms [SRCREALM/]DSTREALM ]\n");
-	fprintf(stderr, "TABLE_ID := [ local | main | default | NUMBER ]\n");
-	exit(-1);
-}
-*/
+/* If you add stuff here, update iprule_full_usage */
+static const char keywords[] ALIGN1 =
+	"from\0""to\0""preference\0""order\0""priority\0"
+	"tos\0""fwmark\0""realms\0""table\0""lookup\0"
+	"suppress_prefixlength\0""suppress_ifgroup\0"
+	"dev\0""iif\0""nat\0""map-to\0""type\0""help\0"
+	;
+#define keyword_preference            (keywords           + sizeof("from") + sizeof("to"))
+#define keyword_fwmark                (keyword_preference + sizeof("preference") + sizeof("order") + sizeof("priority") + sizeof("tos"))
+#define keyword_realms                (keyword_fwmark     + sizeof("fwmark"))
+#define keyword_suppress_prefixlength (keyword_realms     + sizeof("realms") + sizeof("table") + sizeof("lookup"))
+#define keyword_suppress_ifgroup      (keyword_suppress_prefixlength + sizeof("suppress_prefixlength"))
+enum {
+	ARG_from = 1, ARG_to, ARG_preference, ARG_order, ARG_priority,
+	ARG_tos, ARG_fwmark, ARG_realms, ARG_table, ARG_lookup,
+	ARG_suppress_prefixlength, ARG_suppress_ifgroup,
+	ARG_dev, ARG_iif, ARG_nat, ARG_map_to, ARG_type, ARG_help,
+};
 
 static int FAST_FUNC print_rule(const struct sockaddr_nl *who UNUSED_PARAM,
 					struct nlmsghdr *n, void *arg UNUSED_PARAM)
@@ -119,6 +126,17 @@ static int FAST_FUNC print_rule(const st
 	else if (r->rtm_table)
 		printf("lookup %s ", rtnl_rttable_n2a(r->rtm_table));
 
+	if (tb[FRA_SUPPRESS_PREFIXLEN]) {
+		int pl = *(uint32_t*)RTA_DATA(tb[FRA_SUPPRESS_PREFIXLEN]);
+		if (pl != -1)
+			printf("%s %d ", keyword_suppress_prefixlength, pl);
+	}
+	if (tb[FRA_SUPPRESS_IFGROUP]) {
+		int grp = *(uint32_t*)RTA_DATA(tb[FRA_SUPPRESS_IFGROUP]);
+		if (grp != -1)
+			printf("%s %d ", keyword_suppress_ifgroup, grp);
+	}
+
 	if (tb[RTA_FLOW]) {
 		uint32_t to = *(uint32_t*)RTA_DATA(tb[RTA_FLOW]);
 		uint32_t from = to>>16;
@@ -174,15 +192,6 @@ static int iprule_list(char **argv)
 /* Return value becomes exitcode. It's okay to not return at all */
 static int iprule_modify(int cmd, char **argv)
 {
-	static const char keywords[] ALIGN1 =
-		"from\0""to\0""preference\0""order\0""priority\0"
-		"tos\0""fwmark\0""realms\0""table\0""lookup\0""dev\0"
-		"iif\0""nat\0""map-to\0""type\0""help\0";
-	enum {
-		ARG_from = 1, ARG_to, ARG_preference, ARG_order, ARG_priority,
-		ARG_tos, ARG_fwmark, ARG_realms, ARG_table, ARG_lookup, ARG_dev,
-		ARG_iif, ARG_nat, ARG_map_to, ARG_type, ARG_help
-	};
 	bool table_ok = 0;
 	struct rtnl_handle rth;
 	struct {
@@ -232,7 +241,7 @@ static int iprule_modify(int cmd, char *
 		) {
 			uint32_t pref;
 			NEXT_ARG();
-			pref = get_u32(*argv, "preference");
+			pref = get_u32(*argv, keyword_preference);
 			addattr32(&req.n, sizeof(req), RTA_PRIORITY, pref);
 		} else if (key == ARG_tos) {
 			uint32_t tos;
@@ -243,13 +252,13 @@ static int iprule_modify(int cmd, char *
 		} else if (key == ARG_fwmark) {
 			uint32_t fwmark;
 			NEXT_ARG();
-			fwmark = get_u32(*argv, "fwmark");
+			fwmark = get_u32(*argv, keyword_fwmark);
 			addattr32(&req.n, sizeof(req), RTA_PROTOINFO, fwmark);
 		} else if (key == ARG_realms) {
 			uint32_t realm;
 			NEXT_ARG();
 			if (get_rt_realms(&realm, *argv))
-				invarg_1_to_2(*argv, "realms");
+				invarg_1_to_2(*argv, keyword_realms);
 			addattr32(&req.n, sizeof(req), RTA_FLOW, realm);
 		} else if (key == ARG_table ||
 			   key == ARG_lookup
@@ -265,6 +274,16 @@ static int iprule_modify(int cmd, char *
 				addattr32(&req.n, sizeof(req), RTA_TABLE, tid);
 			}
 			table_ok = 1;
+		} else if (key == ARG_suppress_prefixlength) {
+			int prefix_length;
+			NEXT_ARG();
+			prefix_length = get_u32(*argv, keyword_suppress_prefixlength);
+			addattr32(&req.n, sizeof(req), FRA_SUPPRESS_PREFIXLEN, prefix_length);
+		} else if (key == ARG_suppress_ifgroup) {
+			int grp;
+			NEXT_ARG();
+			grp = get_u32(*argv, keyword_suppress_ifgroup);
+			addattr32(&req.n, sizeof(req), FRA_SUPPRESS_IFGROUP, grp);
 		} else if (key == ARG_dev ||
 			   key == ARG_iif
 		) {
diff -urpN busybox-1.26.2/networking/libiproute/utils.c busybox-1.27.0/networking/libiproute/utils.c
--- busybox-1.26.2/networking/libiproute/utils.c	2016-09-27 18:53:50.000000000 +0200
+++ busybox-1.27.0/networking/libiproute/utils.c	2017-07-01 22:51:12.000000000 +0200
@@ -13,7 +13,7 @@
 #include "utils.h"
 #include "inet_common.h"
 
-unsigned get_hz(void)
+unsigned FAST_FUNC get_hz(void)
 {
 	static unsigned hz_internal;
 	FILE *fp;
@@ -35,7 +35,7 @@ unsigned get_hz(void)
 	return hz_internal;
 }
 
-unsigned get_unsigned(char *arg, const char *errmsg)
+unsigned FAST_FUNC get_unsigned(char *arg, const char *errmsg)
 {
 	unsigned long res;
 	char *ptr;
@@ -50,7 +50,7 @@ unsigned get_unsigned(char *arg, const c
 	invarg_1_to_2(arg, errmsg); /* does not return */
 }
 
-uint32_t get_u32(char *arg, const char *errmsg)
+uint32_t FAST_FUNC get_u32(char *arg, const char *errmsg)
 {
 	unsigned long res;
 	char *ptr;
@@ -65,7 +65,7 @@ uint32_t get_u32(char *arg, const char *
 	invarg_1_to_2(arg, errmsg); /* does not return */
 }
 
-uint16_t get_u16(char *arg, const char *errmsg)
+uint16_t FAST_FUNC get_u16(char *arg, const char *errmsg)
 {
 	unsigned long res;
 	char *ptr;
@@ -80,7 +80,7 @@ uint16_t get_u16(char *arg, const char *
 	invarg_1_to_2(arg, errmsg); /* does not return */
 }
 
-int get_addr_1(inet_prefix *addr, char *name, int family)
+int FAST_FUNC get_addr_1(inet_prefix *addr, char *name, int family)
 {
 	memset(addr, 0, sizeof(*addr));
 
@@ -199,7 +199,7 @@ static void get_prefix_1(inet_prefix *ds
 	bb_error_msg_and_die("an %s %s is expected rather than \"%s\"", "inet", "prefix", arg);
 }
 
-int get_addr(inet_prefix *dst, char *arg, int family)
+int FAST_FUNC get_addr(inet_prefix *dst, char *arg, int family)
 {
 	if (family == AF_PACKET) {
 		bb_error_msg_and_die("\"%s\" may be inet %s, but it is not allowed in this context", arg, "address");
@@ -210,7 +210,7 @@ int get_addr(inet_prefix *dst, char *arg
 	return 0;
 }
 
-void get_prefix(inet_prefix *dst, char *arg, int family)
+void FAST_FUNC get_prefix(inet_prefix *dst, char *arg, int family)
 {
 	if (family == AF_PACKET) {
 		bb_error_msg_and_die("\"%s\" may be inet %s, but it is not allowed in this context", arg, "prefix");
@@ -218,7 +218,7 @@ void get_prefix(inet_prefix *dst, char *
 	get_prefix_1(dst, arg, family);
 }
 
-uint32_t get_addr32(char *name)
+uint32_t FAST_FUNC get_addr32(char *name)
 {
 	inet_prefix addr;
 
@@ -228,27 +228,29 @@ uint32_t get_addr32(char *name)
 	return addr.data[0];
 }
 
-void incomplete_command(void)
+char** FAST_FUNC next_arg(char **argv)
 {
-	bb_error_msg_and_die("command line is not complete, try \"help\"");
+	if (!*++argv)
+		bb_error_msg_and_die("command line is not complete, try \"help\"");
+	return argv;
 }
 
-void invarg_1_to_2(const char *arg, const char *opt)
+void FAST_FUNC invarg_1_to_2(const char *arg, const char *opt)
 {
 	bb_error_msg_and_die(bb_msg_invalid_arg_to, arg, opt);
 }
 
-void duparg(const char *key, const char *arg)
+void FAST_FUNC duparg(const char *key, const char *arg)
 {
 	bb_error_msg_and_die("duplicate \"%s\": \"%s\" is the second value", key, arg);
 }
 
-void duparg2(const char *key, const char *arg)
+void FAST_FUNC duparg2(const char *key, const char *arg)
 {
 	bb_error_msg_and_die("either \"%s\" is duplicate, or \"%s\" is garbage", key, arg);
 }
 
-int inet_addr_match(const inet_prefix *a, const inet_prefix *b, int bits)
+int FAST_FUNC inet_addr_match(const inet_prefix *a, const inet_prefix *b, int bits)
 {
 	const uint32_t *a1 = a->data;
 	const uint32_t *a2 = b->data;
@@ -276,7 +278,7 @@ int inet_addr_match(const inet_prefix *a
 	return 0;
 }
 
-const char *rt_addr_n2a(int af, void *addr)
+const char* FAST_FUNC rt_addr_n2a(int af, void *addr)
 {
 	switch (af) {
 	case AF_INET:
@@ -290,7 +292,7 @@ const char *rt_addr_n2a(int af, void *ad
 }
 
 #ifdef RESOLVE_HOSTNAMES
-const char *format_host(int af, int len, void *addr)
+const char* FAST_FUNC format_host(int af, int len, void *addr)
 {
 	if (resolve_hosts) {
 		struct hostent *h_ent;
diff -urpN busybox-1.26.2/networking/libiproute/utils.h busybox-1.27.0/networking/libiproute/utils.h
--- busybox-1.26.2/networking/libiproute/utils.h	2016-09-27 18:53:50.000000000 +0200
+++ busybox-1.27.0/networking/libiproute/utils.h	2017-07-01 22:51:12.000000000 +0200
@@ -26,10 +26,6 @@ extern char _SL_;
 #define SPRINT_BSIZE 64
 #define SPRINT_BUF(x)  char x[SPRINT_BSIZE]
 
-extern void incomplete_command(void) NORETURN;
-
-#define NEXT_ARG() do { if (!*++argv) incomplete_command(); } while (0)
-
 typedef struct {
 	uint8_t family;
 	uint8_t bytelen;
@@ -56,36 +52,40 @@ struct ipx_addr {
 	uint8_t  ipx_node[IPX_NODE_LEN];
 };
 
-extern uint32_t get_addr32(char *name);
-extern int get_addr_1(inet_prefix *dst, char *arg, int family);
-/*extern void get_prefix_1(inet_prefix *dst, char *arg, int family);*/
-extern int get_addr(inet_prefix *dst, char *arg, int family);
-extern void get_prefix(inet_prefix *dst, char *arg, int family);
-
-extern unsigned get_unsigned(char *arg, const char *errmsg);
-extern uint32_t get_u32(char *arg, const char *errmsg);
-extern uint16_t get_u16(char *arg, const char *errmsg);
+char** next_arg(char **argv) FAST_FUNC;
+#define NEXT_ARG() do { argv = next_arg(argv); } while (0)
 
-extern const char *rt_addr_n2a(int af, void *addr);
+uint32_t get_addr32(char *name) FAST_FUNC;
+int get_addr_1(inet_prefix *dst, char *arg, int family) FAST_FUNC;
+/*void get_prefix_1(inet_prefix *dst, char *arg, int family) FAST_FUNC;*/
+int get_addr(inet_prefix *dst, char *arg, int family) FAST_FUNC;
+void get_prefix(inet_prefix *dst, char *arg, int family) FAST_FUNC;
+
+unsigned get_unsigned(char *arg, const char *errmsg) FAST_FUNC;
+uint32_t get_u32(char *arg, const char *errmsg) FAST_FUNC;
+uint16_t get_u16(char *arg, const char *errmsg) FAST_FUNC;
+
+const char *rt_addr_n2a(int af, void *addr) FAST_FUNC;
 #ifdef RESOLVE_HOSTNAMES
-extern const char *format_host(int af, int len, void *addr);
+const char *format_host(int af, int len, void *addr) FAST_FUNC;
 #else
 #define format_host(af, len, addr) \
 	rt_addr_n2a(af, addr)
 #endif
 
-void invarg_1_to_2(const char *, const char *) NORETURN;
-void duparg(const char *, const char *) NORETURN;
-void duparg2(const char *, const char *) NORETURN;
-int inet_addr_match(const inet_prefix *a, const inet_prefix *b, int bits);
+void invarg_1_to_2(const char *, const char *) FAST_FUNC NORETURN;
+void duparg(const char *, const char *) FAST_FUNC NORETURN;
+void duparg2(const char *, const char *) FAST_FUNC NORETURN;
+
+int inet_addr_match(const inet_prefix *a, const inet_prefix *b, int bits) FAST_FUNC;
 
-const char *dnet_ntop(int af, const void *addr, char *str, size_t len);
-int dnet_pton(int af, const char *src, void *addr);
+//const char *dnet_ntop(int af, const void *addr, char *str, size_t len);
+//int dnet_pton(int af, const char *src, void *addr);
 
-const char *ipx_ntop(int af, const void *addr, char *str, size_t len);
-int ipx_pton(int af, const char *src, void *addr);
+//const char *ipx_ntop(int af, const void *addr, char *str, size_t len);
+//int ipx_pton(int af, const char *src, void *addr);
 
-unsigned get_hz(void);
+unsigned get_hz(void) FAST_FUNC;
 
 POP_SAVED_FUNCTION_VISIBILITY
 
diff -urpN busybox-1.26.2/networking/nc.c busybox-1.27.0/networking/nc.c
--- busybox-1.26.2/networking/nc.c	2016-12-10 18:46:36.000000000 +0100
+++ busybox-1.27.0/networking/nc.c	2017-04-05 18:27:36.000000000 +0200
@@ -117,7 +117,7 @@ int nc_main(int argc, char **argv)
 	IF_NOT_NC_EXTRA (const) unsigned delay = 0;
 	IF_NOT_NC_EXTRA (const int execparam = 0;)
 	IF_NC_EXTRA     (char **execparam = NULL;)
-	fd_set readfds, testfds;
+	struct pollfd pfds[2];
 	int opt; /* must be signed (getopt returns -1) */
 
 	if (ENABLE_NC_SERVER || ENABLE_NC_EXTRA) {
@@ -235,29 +235,28 @@ int nc_main(int argc, char **argv)
 		IF_NC_EXTRA(bb_perror_msg_and_die("can't execute '%s'", execparam[0]);)
 	}
 
-	/* Select loop copying stdin to cfd, and cfd to stdout */
+	/* loop copying stdin to cfd, and cfd to stdout */
 
-	FD_ZERO(&readfds);
-	FD_SET(cfd, &readfds);
-	FD_SET(STDIN_FILENO, &readfds);
+	pfds[0].fd = STDIN_FILENO;
+	pfds[0].events = POLLIN;
+	pfds[1].fd = cfd;
+	pfds[1].events = POLLIN;
 
 #define iobuf bb_common_bufsiz1
 	setup_common_bufsiz();
 	for (;;) {
-		int fd;
+		int fdidx;
 		int ofd;
 		int nread;
 
-		testfds = readfds;
+		if (safe_poll(pfds, 2, -1) < 0)
+			bb_perror_msg_and_die("poll");
 
-		if (select(cfd + 1, &testfds, NULL, NULL, NULL) < 0)
-			bb_perror_msg_and_die("select");
-
-		fd = STDIN_FILENO;
+		fdidx = 0;
 		while (1) {
-			if (FD_ISSET(fd, &testfds)) {
-				nread = safe_read(fd, iobuf, COMMON_BUFSIZE);
-				if (fd == cfd) {
+			if (pfds[fdidx].revents) {
+				nread = safe_read(pfds[fdidx].fd, iobuf, COMMON_BUFSIZE);
+				if (fdidx != 0) {
 					if (nread < 1)
 						exit(EXIT_SUCCESS);
 					ofd = STDOUT_FILENO;
@@ -266,7 +265,7 @@ int nc_main(int argc, char **argv)
 						/* Close outgoing half-connection so they get EOF,
 						 * but leave incoming alone so we can see response */
 						shutdown(cfd, SHUT_WR);
-						FD_CLR(STDIN_FILENO, &readfds);
+						pfds[0].fd = -1;
 					}
 					ofd = cfd;
 				}
@@ -274,9 +273,9 @@ int nc_main(int argc, char **argv)
 				if (delay > 0)
 					sleep(delay);
 			}
-			if (fd == cfd)
+			if (fdidx == 1)
 				break;
-			fd = cfd;
+			fdidx++;
 		}
 	}
 }
diff -urpN busybox-1.26.2/networking/nc_bloaty.c busybox-1.27.0/networking/nc_bloaty.c
--- busybox-1.26.2/networking/nc_bloaty.c	2016-09-27 18:53:50.000000000 +0200
+++ busybox-1.27.0/networking/nc_bloaty.c	2017-07-01 22:51:12.000000000 +0200
@@ -459,7 +459,7 @@ create new one, and bind() it. TODO */
 	 so I don't feel bad.
 	 The *real* question is why BFD sockets wasn't designed to allow listens for
 	 connections *from* specific hosts/ports, instead of requiring the caller to
-	 accept the connection and then reject undesireable ones by closing.
+	 accept the connection and then reject undesirable ones by closing.
 	 In other words, we need a TCP MSG_PEEK. */
 	/* bbox: removed most of it */
 		lcladdr = xmalloc_sockaddr2dotted(&ouraddr->u.sa);
@@ -502,7 +502,7 @@ static int udptest(void)
 	/* use the tcp-ping trick: try connecting to a normally refused port, which
 	 causes us to block for the time that SYN gets there and RST gets back.
 	 Not completely reliable, but it *does* mostly work. */
-	/* Set a temporary connect timeout, so packet filtration doesnt cause
+	/* Set a temporary connect timeout, so packet filtration doesn't cause
 	 us to hang forever, and hit it */
 		o_wait = 5;                     /* enough that we'll notice?? */
 		rr = xsocket(ouraddr->u.sa.sa_family, SOCK_STREAM, 0);
@@ -582,11 +582,10 @@ void oprint(int direction, unsigned char
 #endif
 
 /* readwrite:
- handle stdin/stdout/network I/O.  Bwahaha!! -- the select loop from hell.
+ handle stdin/stdout/network I/O.  Bwahaha!! -- the i/o loop from hell.
  In this instance, return what might become our exit status. */
 static int readwrite(void)
 {
-	int rr;
 	char *zp = zp; /* gcc */  /* stdin buf ptr */
 	char *np = np;            /* net-in buf ptr */
 	unsigned rzleft;
@@ -594,45 +593,41 @@ static int readwrite(void)
 	unsigned netretry;              /* net-read retry counter */
 	unsigned fds_open;
 
-	/* if you don't have all this FD_* macro hair in sys/types.h, you'll have to
-	 either find it or do your own bit-bashing: *ding1 |= (1 << fd), etc... */
-	fd_set ding1;                   /* for select loop */
-	fd_set ding2;
-	FD_ZERO(&ding1);
-	FD_SET(netfd, &ding1);
-	FD_SET(STDIN_FILENO, &ding1);
-	fds_open = 2;
+	struct pollfd pfds[2];
+	pfds[0].fd = STDIN_FILENO;
+	pfds[0].events = POLLIN;
+	pfds[1].fd = netfd;
+	pfds[1].events = POLLIN;
 
+	fds_open = 2;
 	netretry = 2;
 	rzleft = rnleft = 0;
 	if (o_interval)
 		sleep(o_interval);                /* pause *before* sending stuff, too */
 
-	/* and now the big ol' select shoveling loop ... */
+	/* and now the big ol' shoveling loop ... */
 	/* nc 1.10 has "while (FD_ISSET(netfd)" here */
 	while (fds_open) {
+		int rr;
+		int poll_tmout_ms;
 		unsigned wretry = 8200;               /* net-write sanity counter */
 
-		ding2 = ding1;                        /* FD_COPY ain't portable... */
-	/* some systems, notably linux, crap into their select timers on return, so
-	 we create a expendable copy and give *that* to select.  */
+		poll_tmout_ms = -1;
 		if (o_wait) {
-			struct timeval tmp_timer;
-			tmp_timer.tv_sec = o_wait;
-			tmp_timer.tv_usec = 0;
-		/* highest possible fd is netfd (3) */
-			rr = select(netfd+1, &ding2, NULL, NULL, &tmp_timer);
-		} else
-			rr = select(netfd+1, &ding2, NULL, NULL, NULL);
+			poll_tmout_ms = INT_MAX;
+			if (o_wait < INT_MAX / 1000)
+				poll_tmout_ms = o_wait * 1000;
+		}
+		rr = poll(pfds, 2, poll_tmout_ms);
 		if (rr < 0 && errno != EINTR) {                /* might have gotten ^Zed, etc */
-			holler_perror("select");
+			holler_perror("poll");
 			close(netfd);
 			return 1;
 		}
 	/* if we have a timeout AND stdin is closed AND we haven't heard anything
 	 from the net during that time, assume it's dead and close it too. */
 		if (rr == 0) {
-			if (!FD_ISSET(STDIN_FILENO, &ding1)) {
+			if (!pfds[0].revents) {
 				netretry--;                        /* we actually try a coupla times. */
 				if (!netretry) {
 					if (o_verbose > 1)         /* normally we don't care */
@@ -641,19 +636,17 @@ static int readwrite(void)
 					return 0;                  /* not an error! */
 				}
 			}
-		} /* select timeout */
-	/* xxx: should we check the exception fds too?  The read fds seem to give
-	 us the right info, and none of the examples I found bothered. */
+		} /* timeout */
 
 	/* Ding!!  Something arrived, go check all the incoming hoppers, net first */
-		if (FD_ISSET(netfd, &ding2)) {                /* net: ding! */
+		if (pfds[1].revents) {                /* net: ding! */
 			rr = read(netfd, bigbuf_net, BIGSIZ);
 			if (rr <= 0) {
 				if (rr < 0 && o_verbose > 1) {
 					/* nc 1.10 doesn't do this */
 					bb_perror_msg("net read");
 				}
-				FD_CLR(netfd, &ding1);                /* net closed */
+				pfds[1].fd = -1;                   /* don't poll for netfd anymore */
 				fds_open--;
 				rzleft = 0;                        /* can't write anymore: broken pipe */
 			} else {
@@ -669,12 +662,12 @@ Debug("got %d from the net, errno %d", r
 			goto shovel;
 
 	/* okay, suck more stdin */
-		if (FD_ISSET(STDIN_FILENO, &ding2)) {                /* stdin: ding! */
+		if (pfds[0].revents) {                /* stdin: ding! */
 			rr = read(STDIN_FILENO, bigbuf_in, BIGSIZ);
 	/* Considered making reads here smaller for UDP mode, but 8192-byte
 	 mobygrams are kinda fun and exercise the reassembler. */
 			if (rr <= 0) {                        /* at end, or fukt, or ... */
-				FD_CLR(STDIN_FILENO, &ding1); /* disable stdin */
+				pfds[0].fd = -1;              /* disable stdin */
 				/*close(STDIN_FILENO); - not really necessary */
 				/* Let peer know we have no more data */
 				/* nc 1.10 doesn't do this: */
@@ -718,7 +711,7 @@ Debug("wrote %d to net, errno %d", rr, e
 		} /* rzleft */
 		if (o_interval) {                        /* cycle between slow lines, or ... */
 			sleep(o_interval);
-			continue;                        /* ...with hairy select loop... */
+			continue;                        /* ...with hairy loop... */
 		}
 		if (rzleft || rnleft) {                  /* shovel that shit till they ain't */
 			wretry--;                        /* none left, and get another load */
diff -urpN busybox-1.26.2/networking/netstat.c busybox-1.27.0/networking/netstat.c
--- busybox-1.26.2/networking/netstat.c	2016-12-10 18:46:36.000000000 +0100
+++ busybox-1.27.0/networking/netstat.c	2017-01-10 16:31:40.000000000 +0100
@@ -21,7 +21,7 @@
 //config:	  netstat prints information about the Linux networking subsystem.
 //config:
 //config:config FEATURE_NETSTAT_WIDE
-//config:	bool "Enable wide netstat output"
+//config:	bool "Enable wide output"
 //config:	default y
 //config:	depends on NETSTAT
 //config:	help
diff -urpN busybox-1.26.2/networking/ntpd.c busybox-1.27.0/networking/ntpd.c
--- busybox-1.26.2/networking/ntpd.c	2016-12-10 18:46:36.000000000 +0100
+++ busybox-1.27.0/networking/ntpd.c	2017-07-01 22:51:12.000000000 +0200
@@ -155,6 +155,7 @@
 #define RETRY_INTERVAL    32    /* on send/recv error, retry in N secs (need to be power of 2) */
 #define NOREPLY_INTERVAL 512    /* sent, but got no reply: cap next query by this many seconds */
 #define RESPONSE_INTERVAL 16    /* wait for reply up to N secs */
+#define HOSTNAME_INTERVAL  5    /* hostname lookup failed. Wait N secs for next try */
 
 /* Step threshold (sec). std ntpd uses 0.128.
  */
@@ -392,7 +393,7 @@ struct globals {
 	 * too big and we will step. I observed it with -6.
 	 *
 	 * OTOH, setting precision_sec far too small would result in futile
-	 * attempts to syncronize to an unachievable precision.
+	 * attempts to synchronize to an unachievable precision.
 	 *
 	 * -6 is 1/64 sec, -7 is 1/128 sec and so on.
 	 * -8 is 1/256 ~= 0.003906 (worked well for me --vda)
@@ -753,10 +754,10 @@ reset_peer_stats(peer_t *p, double offse
 	bool small_ofs = fabs(offset) < STEP_THRESHOLD;
 
 	/* Used to set p->filter_datapoint[i].d_dispersion = MAXDISP
-	 * and clear reachable bits, but this proved to be too agressive:
+	 * and clear reachable bits, but this proved to be too aggressive:
 	 * after step (tested with suspending laptop for ~30 secs),
 	 * this caused all previous data to be considered invalid,
-	 * making us needing to collect full ~8 datapoins per peer
+	 * making us needing to collect full ~8 datapoints per peer
 	 * after step in order to start trusting them.
 	 * In turn, this was making poll interval decrease even after
 	 * step was done. (Poll interval decreases already before step
@@ -790,28 +791,22 @@ reset_peer_stats(peer_t *p, double offse
 	VERB6 bb_error_msg("%s->lastpkt_recv_time=%f", p->p_dotted, p->lastpkt_recv_time);
 }
 
-static void
-resolve_peer_hostname(peer_t *p, int loop_on_fail)
+static len_and_sockaddr*
+resolve_peer_hostname(peer_t *p)
 {
-	len_and_sockaddr *lsa;
-
- again:
-	lsa = host2sockaddr(p->p_hostname, 123);
-	if (!lsa) {
-		/* error message already emitted by host2sockaddr() */
-		if (!loop_on_fail)
-			return;
-//FIXME: do this to avoid infinite looping on typo in a hostname?
-//well... in which case, what is a good value for loop_on_fail?
-		//if (--loop_on_fail == 0)
-		//	xfunc_die();
-		sleep(5);
-		goto again;
-	}
-	free(p->p_lsa);
-	free(p->p_dotted);
-	p->p_lsa = lsa;
-	p->p_dotted = xmalloc_sockaddr2dotted_noport(&lsa->u.sa);
+	len_and_sockaddr *lsa = host2sockaddr(p->p_hostname, 123);
+	if (lsa) {
+		free(p->p_lsa);
+		free(p->p_dotted);
+		p->p_lsa = lsa;
+		p->p_dotted = xmalloc_sockaddr2dotted_noport(&lsa->u.sa);
+		VERB1 if (strcmp(p->p_hostname, p->p_dotted) != 0)
+			bb_error_msg("'%s' is %s", p->p_hostname, p->p_dotted);
+	} else {
+		/* error message is emitted by host2sockaddr() */
+		set_next(p, HOSTNAME_INTERVAL);
+	}
+	return lsa;
 }
 
 static void
@@ -822,28 +817,28 @@ add_peers(const char *s)
 
 	p = xzalloc(sizeof(*p) + strlen(s));
 	strcpy(p->p_hostname, s);
-	resolve_peer_hostname(p, /*loop_on_fail=*/ 1);
+	p->p_fd = -1;
+	p->p_xmt_msg.m_status = MODE_CLIENT | (NTP_VERSION << 3);
+	p->next_action_time = G.cur_time; /* = set_next(p, 0); */
+	reset_peer_stats(p, STEP_THRESHOLD);
 
 	/* Names like N.<country2chars>.pool.ntp.org are randomly resolved
 	 * to a pool of machines. Sometimes different N's resolve to the same IP.
 	 * It is not useful to have two peers with same IP. We skip duplicates.
 	 */
-	for (item = G.ntp_peers; item != NULL; item = item->link) {
-		peer_t *pp = (peer_t *) item->data;
-		if (strcmp(p->p_dotted, pp->p_dotted) == 0) {
-			bb_error_msg("duplicate peer %s (%s)", s, p->p_dotted);
-			free(p->p_lsa);
-			free(p->p_dotted);
-			free(p);
-			return;
+	if (resolve_peer_hostname(p)) {
+		for (item = G.ntp_peers; item != NULL; item = item->link) {
+			peer_t *pp = (peer_t *) item->data;
+			if (pp->p_dotted && strcmp(p->p_dotted, pp->p_dotted) == 0) {
+				bb_error_msg("duplicate peer %s (%s)", s, p->p_dotted);
+				free(p->p_lsa);
+				free(p->p_dotted);
+				free(p);
+				return;
+			}
 		}
 	}
 
-	p->p_fd = -1;
-	p->p_xmt_msg.m_status = MODE_CLIENT | (NTP_VERSION << 3);
-	p->next_action_time = G.cur_time; /* = set_next(p, 0); */
-	reset_peer_stats(p, STEP_THRESHOLD);
-
 	llist_add_to(&G.ntp_peers, p);
 	G.peer_cnt++;
 }
@@ -871,6 +866,11 @@ do_sendto(int fd,
 static void
 send_query_to_peer(peer_t *p)
 {
+	if (!p->p_lsa) {
+		if (!resolve_peer_hostname(p))
+			return;
+	}
+
 	/* Why do we need to bind()?
 	 * See what happens when we don't bind:
 	 *
@@ -1715,7 +1715,7 @@ update_local_clock(peer_t *p)
 	 * It looks like Linux kernel's PLL is far too gentle in changing
 	 * tmx.freq in response to clock offset. Offset keeps growing
 	 * and eventually we fall back to smaller poll intervals.
-	 * We can make correction more agressive (about x2) by supplying
+	 * We can make correction more aggressive (about x2) by supplying
 	 * PLL time constant which is one less than the real one.
 	 * To be on a safe side, let's do it only if offset is significantly
 	 * larger than jitter.
@@ -2238,7 +2238,7 @@ static NOINLINE void ntp_init(char **arg
 			IF_FEATURE_NTPD_SERVER("I:") /* compat */
 			"d" /* compat */
 			"46aAbgL", /* compat, ignored */
-			&peers,&G.script_name,
+			&peers, &G.script_name,
 #if ENABLE_FEATURE_NTPD_SERVER
 			&G.if_name,
 #endif
@@ -2263,9 +2263,6 @@ static NOINLINE void ntp_init(char **arg
 	if (opts & OPT_N)
 		setpriority(PRIO_PROCESS, 0, -15);
 
-	/* add_peers() calls can retry DNS resolution (possibly forever).
-	 * Daemonize before them, or else boot can stall forever.
-	 */
 	if (!(opts & OPT_n)) {
 		bb_daemonize_or_rexec(DAEMON_DEVNULL_STDIO, argv);
 		logmode = LOGMODE_NONE;
@@ -2400,7 +2397,7 @@ int ntpd_main(int argc UNUSED_PARAM, cha
 
 					/* What if don't see it because it changed its IP? */
 					if (p->reachable_bits == 0)
-						resolve_peer_hostname(p, /*loop_on_fail=*/ 0);
+						resolve_peer_hostname(p);
 
 					set_next(p, timeout);
 				}
diff -urpN busybox-1.26.2/networking/ping.c busybox-1.27.0/networking/ping.c
--- busybox-1.26.2/networking/ping.c	2016-12-10 18:46:36.000000000 +0100
+++ busybox-1.27.0/networking/ping.c	2017-07-01 22:51:12.000000000 +0200
@@ -94,10 +94,10 @@
 //usage:     "\n	-4,-6		Force IP or IPv6 name resolution"
 //usage:	)
 //usage:     "\n	-c CNT		Send only CNT pings"
-//usage:     "\n	-s SIZE		Send SIZE data bytes in packets (default:56)"
+//usage:     "\n	-s SIZE		Send SIZE data bytes in packets (default 56)"
 //usage:     "\n	-t TTL		Set TTL"
-//usage:     "\n	-I IFACE/IP	Use interface or IP address as source"
-//usage:     "\n	-W SEC		Seconds to wait for the first response (default:10)"
+//usage:     "\n	-I IFACE/IP	Source interface or IP address"
+//usage:     "\n	-W SEC		Seconds to wait for the first response (default 10)"
 //usage:     "\n			(after all -c CNT packets are sent)"
 //usage:     "\n	-w SEC		Seconds until ping exits (default:infinite)"
 //usage:     "\n			(can exit earlier with -c CNT)"
@@ -110,8 +110,8 @@
 //usage:# define ping6_full_usage "\n\n"
 //usage:       "Send ICMP ECHO_REQUEST packets to network hosts\n"
 //usage:     "\n	-c CNT		Send only CNT pings"
-//usage:     "\n	-s SIZE		Send SIZE data bytes in packets (default:56)"
-//usage:     "\n	-I IFACE/IP	Use interface or IP address as source"
+//usage:     "\n	-s SIZE		Send SIZE data bytes in packets (default 56)"
+//usage:     "\n	-I IFACE/IP	Source interface or IP address"
 //usage:     "\n	-q		Quiet, only display output at start"
 //usage:     "\n			and when finished"
 //usage:     "\n	-p		Pattern to use for payload"
@@ -478,7 +478,7 @@ static void sendping_tail(void (*sp)(int
 	} else { /* -c NN, and all NN are sent (and no deadline) */
 		/* Wait for the last ping to come back.
 		 * -W timeout: wait for a response in seconds.
-		 * Affects only timeout in absense of any responses,
+		 * Affects only timeout in absence of any responses,
 		 * otherwise ping waits for two RTTs. */
 		unsigned expire = timeout;
 
@@ -712,7 +712,7 @@ static void ping4(len_and_sockaddr *lsa)
 
 	if (opt_ttl != 0) {
 		setsockopt_int(pingsock, IPPROTO_IP, IP_TTL, opt_ttl);
-		/* above doesnt affect packets sent to bcast IP, so... */
+		/* above doesn't affect packets sent to bcast IP, so... */
 		setsockopt_int(pingsock, IPPROTO_IP, IP_MULTICAST_TTL, opt_ttl);
 	}
 
diff -urpN busybox-1.26.2/networking/ssl_client.c busybox-1.27.0/networking/ssl_client.c
--- busybox-1.26.2/networking/ssl_client.c	1970-01-01 01:00:00.000000000 +0100
+++ busybox-1.27.0/networking/ssl_client.c	2017-01-23 01:09:41.000000000 +0100
@@ -0,0 +1,55 @@
+/*
+ * Copyright (C) 2017 Denys Vlasenko
+ *
+ * Licensed under GPLv2, see file LICENSE in this source tree.
+ */
+//config:config SSL_CLIENT
+//config:	bool "ssl_client"
+//config:	default y
+//config:	select TLS
+//config:	help
+//config:	  This tool pipes data to/from a socket, TLS-encrypting it.
+
+//applet:IF_SSL_CLIENT(APPLET(ssl_client, BB_DIR_USR_BIN, BB_SUID_DROP))
+
+//kbuild:lib-$(CONFIG_SSL_CLIENT) += ssl_client.o
+
+//usage:#define ssl_client_trivial_usage
+//usage:       "-s FD [-r FD] [-n SNI]"
+//usage:#define ssl_client_full_usage ""
+
+#include "libbb.h"
+
+int ssl_client_main(int argc, char **argv) MAIN_EXTERNALLY_VISIBLE;
+int ssl_client_main(int argc UNUSED_PARAM, char **argv)
+{
+	tls_state_t *tls;
+	const char *sni = NULL;
+	int opt;
+
+	// INIT_G();
+
+	tls = new_tls_state();
+	opt = getopt32(argv, "s:#r:#n:", &tls->ofd, &tls->ifd, &sni);
+	if (!(opt & 2)) {
+		/* -r N defaults to -s N */
+		tls->ifd = tls->ofd;
+	}
+
+	if (!(opt & 3)) {
+		if (!argv[1])
+			bb_show_usage();
+		/* Undocumented debug feature: without -s and -r, takes HOST arg and connects to it */
+		//
+		// Talk to kernel.org:
+		// printf "GET / HTTP/1.1\r\nHost: kernel.org\r\n\r\n" | ./busybox ssl_client kernel.org
+		if (!sni)
+			sni = argv[1];
+		tls->ifd = tls->ofd = create_and_connect_stream_or_die(argv[1], 443);
+	}
+
+	tls_handshake(tls, sni);
+	tls_run_copy_loop(tls);
+
+	return EXIT_SUCCESS;
+}
diff -urpN busybox-1.26.2/networking/ssl_helper-wolfssl/README busybox-1.27.0/networking/ssl_helper-wolfssl/README
--- busybox-1.26.2/networking/ssl_helper-wolfssl/README	2017-01-01 12:57:06.000000000 +0100
+++ busybox-1.27.0/networking/ssl_helper-wolfssl/README	2016-12-22 14:50:30.000000000 +0100
@@ -5,18 +5,15 @@ http://busybox.net/downloads/binaries/
 
 Build instructions:
 
-* Unpack wolfssl-3.6.8.zip
-* Build it:
-  ./configure --enable-static --disable-shared && make
-* Drop this directory into wolfssl-3.6.8/ssl_helper
-* Run ssl_helper.sh to compile and link the helper
-
 * Unpack wolfssl-3.9.8.tar.gz from https://github.com/wolfSSL/wolfssl/releases
+  to a wolfssl-3.9.8 subdirectory here.
 * Create configure:
-  ./autogen.sh
-* Build it: see 00cfg-wolfssl-3.9.8 shell script
-* Drop this directory into wolfssl-x.y.z/ssl_helper
-* Run ssl_helper.sh to compile and link the helper
+	(cd wolfssl-* && ./autogen.sh)
+* Build it: see
+	(cd wolfssl-* && ../00cfg-wolfssl-3.9.8)
+* Run
+	./ssl_helper.sh
+  to compile and link the helper
 
 Usage: "ssl_helper -d FILE_DESCRIPTOR" where FILE_DESCRIPTOR is open to the peer.
 
diff -urpN busybox-1.26.2/networking/ssl_helper-wolfssl/ssl_helper.sh busybox-1.27.0/networking/ssl_helper-wolfssl/ssl_helper.sh
--- busybox-1.26.2/networking/ssl_helper-wolfssl/ssl_helper.sh	2017-01-01 12:57:06.000000000 +0100
+++ busybox-1.27.0/networking/ssl_helper-wolfssl/ssl_helper.sh	2016-12-22 14:47:27.000000000 +0100
@@ -7,6 +7,6 @@ STATIC="-static"
 #PREFIX=""
 #STATIC=""
 
-${PREFIX}gcc -Os -Wall -I.. -c ssl_helper.c -o ssl_helper.o
-${PREFIX}gcc $STATIC --start-group ssl_helper.o -lm ../src/.libs/libwolfssl.a --end-group -o ssl_helper
+${PREFIX}gcc -Os -Wall -I wolfssl-* -c ssl_helper.c -o ssl_helper.o
+${PREFIX}gcc $STATIC --start-group ssl_helper.o -lm wolfssl-*/src/.libs/libwolfssl.a --end-group -o ssl_helper
 ${PREFIX}strip ssl_helper
diff -urpN busybox-1.26.2/networking/tc.c busybox-1.27.0/networking/tc.c
--- busybox-1.26.2/networking/tc.c	2016-12-10 18:46:36.000000000 +0100
+++ busybox-1.27.0/networking/tc.c	2017-01-23 01:09:41.000000000 +0100
@@ -27,22 +27,22 @@
 /* //usage: "[OPTIONS] OBJECT CMD [dev STRING]" */
 //usage:	"OBJECT CMD [dev STRING]"
 //usage:#define tc_full_usage "\n\n"
-//usage:	"OBJECT: {qdisc|class|filter}\n"
-//usage:	"CMD: {add|del|change|replace|show}\n"
+//usage:	"OBJECT: qdisc|class|filter\n"
+//usage:	"CMD: add|del|change|replace|show\n"
 //usage:	"\n"
-//usage:	"qdisc [ handle QHANDLE ] [ root |"IF_FEATURE_TC_INGRESS(" ingress |")" parent CLASSID ]\n"
-/* //usage: "[ estimator INTERVAL TIME_CONSTANT ]\n" */
-//usage:	"	[ [ QDISC_KIND ] [ help | OPTIONS ] ]\n"
-//usage:	"	QDISC_KIND := { [p|b]fifo | tbf | prio | cbq | red | etc. }\n"
-//usage:	"qdisc show [ dev STRING ]"IF_FEATURE_TC_INGRESS(" [ingress]")"\n"
-//usage:	"class [ classid CLASSID ] [ root | parent CLASSID ]\n"
-//usage:	"	[ [ QDISC_KIND ] [ help | OPTIONS ] ]\n"
-//usage:	"class show [ dev STRING ] [ root | parent CLASSID ]\n"
-//usage:	"filter [ pref PRIO ] [ protocol PROTO ]\n"
-/* //usage: "\t[ estimator INTERVAL TIME_CONSTANT ]\n" */
-//usage:	"	[ root | classid CLASSID ] [ handle FILTERID ]\n"
-//usage:	"	[ [ FILTER_TYPE ] [ help | OPTIONS ] ]\n"
-//usage:	"filter show [ dev STRING ] [ root | parent CLASSID ]"
+//usage:	"qdisc [handle QHANDLE] [root|"IF_FEATURE_TC_INGRESS("ingress|")"parent CLASSID]\n"
+/* //usage: "[estimator INTERVAL TIME_CONSTANT]\n" */
+//usage:	"	[[QDISC_KIND] [help|OPTIONS]]\n"
+//usage:	"	QDISC_KIND := [p|b]fifo|tbf|prio|cbq|red|etc.\n"
+//usage:	"qdisc show [dev STRING]"IF_FEATURE_TC_INGRESS(" [ingress]")"\n"
+//usage:	"class [classid CLASSID] [root|parent CLASSID]\n"
+//usage:	"	[[QDISC_KIND] [help|OPTIONS] ]\n"
+//usage:	"class show [ dev STRING ] [root|parent CLASSID]\n"
+//usage:	"filter [pref PRIO] [protocol PROTO]\n"
+/* //usage: "\t[estimator INTERVAL TIME_CONSTANT]\n" */
+//usage:	"	[root|classid CLASSID] [handle FILTERID]\n"
+//usage:	"	[[FILTER_TYPE] [help|OPTIONS]]\n"
+//usage:	"filter show [dev STRING] [root|parent CLASSID]"
 
 #include "libbb.h"
 #include "common_bufsiz.h"
diff -urpN busybox-1.26.2/networking/tcpudp.c busybox-1.27.0/networking/tcpudp.c
--- busybox-1.26.2/networking/tcpudp.c	2017-01-10 16:55:51.000000000 +0100
+++ busybox-1.27.0/networking/tcpudp.c	2017-07-01 22:51:12.000000000 +0200
@@ -683,7 +683,7 @@ prog
 -E
     no special environment. Do not set up TCP-related environment variables.
 -v
-    verbose. Print verbose messsages to standard output.
+    verbose. Print verbose messages to standard output.
 -vv
     more verbose. Print more verbose messages to standard output.
     * no difference between -v and -vv in busyboxed version
diff -urpN busybox-1.26.2/networking/telnet.c busybox-1.27.0/networking/telnet.c
--- busybox-1.26.2/networking/telnet.c	2016-12-10 18:46:36.000000000 +0100
+++ busybox-1.27.0/networking/telnet.c	2017-01-15 00:18:53.000000000 +0100
@@ -45,6 +45,11 @@
 //config:	  remote host you are connecting to. This is useful when you need to
 //config:	  log into a machine without telling the username (autologin). This
 //config:	  option enables `-a' and `-l USER' arguments.
+//config:
+//config:config FEATURE_TELNET_WIDTH
+//config:	bool "Enable window size autodetection"
+//config:	default y
+//config:	depends on TELNET
 
 //applet:IF_TELNET(APPLET(telnet, BB_DIR_USR_BIN, BB_SUID_DROP))
 
@@ -128,7 +133,7 @@ struct globals {
 #if ENABLE_FEATURE_TELNET_AUTOLOGIN
 	const char *autologin;
 #endif
-#if ENABLE_FEATURE_AUTOWIDTH
+#if ENABLE_FEATURE_TELNET_WIDTH
 	unsigned win_width, win_height;
 #endif
 	/* same buffer used both for network and console read/write */
@@ -401,7 +406,7 @@ static void put_iac_subopt_autologin(voi
 }
 #endif
 
-#if ENABLE_FEATURE_AUTOWIDTH
+#if ENABLE_FEATURE_TELNET_WIDTH
 static void put_iac_naws(byte c, int x, int y)
 {
 	if (G.iaclen + 9 > IACBUFSIZE)
@@ -538,7 +543,7 @@ static void to_new_environ(void)
 }
 #endif
 
-#if ENABLE_FEATURE_AUTOWIDTH
+#if ENABLE_FEATURE_TELNET_WIDTH
 static void to_naws(void)
 {
 	/* Tell server we will do NAWS */
@@ -561,7 +566,7 @@ static void telopt(byte c)
 	case TELOPT_NEW_ENVIRON:
 		to_new_environ(); break;
 #endif
-#if ENABLE_FEATURE_AUTOWIDTH
+#if ENABLE_FEATURE_TELNET_WIDTH
 	case TELOPT_NAWS:
 		to_naws();
 		put_iac_naws(c, G.win_width, G.win_height);
@@ -623,7 +628,7 @@ int telnet_main(int argc UNUSED_PARAM, c
 
 	INIT_G();
 
-#if ENABLE_FEATURE_AUTOWIDTH
+#if ENABLE_FEATURE_TELNET_WIDTH
 	get_terminal_width_height(0, &G.win_width, &G.win_height);
 #endif
 
diff -urpN busybox-1.26.2/networking/tftp.c busybox-1.27.0/networking/tftp.c
--- busybox-1.26.2/networking/tftp.c	2016-12-10 18:46:36.000000000 +0100
+++ busybox-1.27.0/networking/tftp.c	2017-01-10 16:31:40.000000000 +0100
@@ -69,11 +69,9 @@
 //config:	  "blksize" and "tsize" options.
 //config:
 //config:config FEATURE_TFTP_PROGRESS_BAR
-//config:	bool "Enable tftp progress meter"
+//config:	bool "Enable progress bar"
 //config:	default y
 //config:	depends on TFTP && FEATURE_TFTP_BLOCKSIZE
-//config:	help
-//config:	  Show progress bar.
 //config:
 //config:config TFTP_DEBUG
 //config:	bool "Enable debug"
diff -urpN busybox-1.26.2/networking/tls.c busybox-1.27.0/networking/tls.c
--- busybox-1.26.2/networking/tls.c	1970-01-01 01:00:00.000000000 +0100
+++ busybox-1.27.0/networking/tls.c	2017-04-05 18:27:36.000000000 +0200
@@ -0,0 +1,1787 @@
+/*
+ * Copyright (C) 2017 Denys Vlasenko
+ *
+ * Licensed under GPLv2, see file LICENSE in this source tree.
+ */
+//config:config TLS
+//config:	bool #No description makes it a hidden option
+//config:	default n
+
+//kbuild:lib-$(CONFIG_TLS) += tls.o
+//kbuild:lib-$(CONFIG_TLS) += tls_pstm.o
+//kbuild:lib-$(CONFIG_TLS) += tls_pstm_montgomery_reduce.o
+//kbuild:lib-$(CONFIG_TLS) += tls_pstm_mul_comba.o
+//kbuild:lib-$(CONFIG_TLS) += tls_pstm_sqr_comba.o
+//kbuild:lib-$(CONFIG_TLS) += tls_rsa.o
+//kbuild:lib-$(CONFIG_TLS) += tls_aes.o
+////kbuild:lib-$(CONFIG_TLS) += tls_aes_gcm.o
+
+#include "tls.h"
+
+//Tested against kernel.org:
+//TLS 1.2
+#define TLS_MAJ 3
+#define TLS_MIN 3
+//#define CIPHER_ID TLS_ECDHE_RSA_WITH_AES_128_CBC_SHA // ok, recvs SERVER_KEY_EXCHANGE *** matrixssl uses this on my box
+//#define CIPHER_ID TLS_RSA_WITH_AES_256_CBC_SHA256 // ok, no SERVER_KEY_EXCHANGE
+//#define CIPHER_ID TLS_DH_anon_WITH_AES_256_CBC_SHA // SSL_ALERT_HANDSHAKE_FAILURE
+//^^^^^^^^^^^^^^^^^^^^^^^ (tested b/c this one doesn't req server certs... no luck, server refuses it)
+//#define CIPHER_ID TLS_ECDHE_ECDSA_WITH_AES_256_GCM_SHA384 // SSL_ALERT_HANDSHAKE_FAILURE
+//#define CIPHER_ID TLS_ECDHE_ECDSA_WITH_AES_128_GCM_SHA256 // SSL_ALERT_HANDSHAKE_FAILURE
+//#define CIPHER_ID TLS_ECDHE_RSA_WITH_AES_256_GCM_SHA384 // ok, recvs SERVER_KEY_EXCHANGE
+//#define CIPHER_ID TLS_ECDHE_RSA_WITH_AES_128_GCM_SHA256
+//#define CIPHER_ID TLS_ECDH_ECDSA_WITH_AES_256_GCM_SHA384
+//#define CIPHER_ID TLS_ECDH_ECDSA_WITH_AES_128_GCM_SHA256 // SSL_ALERT_HANDSHAKE_FAILURE
+//#define CIPHER_ID TLS_ECDH_RSA_WITH_AES_256_GCM_SHA384
+//#define CIPHER_ID TLS_ECDH_RSA_WITH_AES_128_GCM_SHA256 // SSL_ALERT_HANDSHAKE_FAILURE
+//#define CIPHER_ID TLS_RSA_WITH_AES_256_GCM_SHA384 // ok, no SERVER_KEY_EXCHANGE
+//#define CIPHER_ID TLS_RSA_WITH_AES_128_GCM_SHA256 // ok, no SERVER_KEY_EXCHANGE *** select this?
+
+// works against "openssl s_server -cipher NULL"
+// and against wolfssl-3.9.10-stable/examples/server/server.c:
+//#define CIPHER_ID1 TLS_RSA_WITH_NULL_SHA256 // for testing (does everything except encrypting)
+
+// works against wolfssl-3.9.10-stable/examples/server/server.c
+// works for kernel.org
+// does not work for cdn.kernel.org (e.g. downloading an actual tarball, not a web page)
+//  getting alert 40 "handshake failure" at once
+//  with GNU Wget 1.18, they agree on TLS_ECDHE_RSA_WITH_AES_128_GCM_SHA256 (0xC02F) cipher
+//  fail: openssl s_client -connect cdn.kernel.org:443 -debug -tls1_2 -no_tls1 -no_tls1_1 -cipher AES256-SHA256
+//  fail: openssl s_client -connect cdn.kernel.org:443 -debug -tls1_2 -no_tls1 -no_tls1_1 -cipher AES256-GCM-SHA384
+//  fail: openssl s_client -connect cdn.kernel.org:443 -debug -tls1_2 -no_tls1 -no_tls1_1 -cipher AES128-SHA256
+//  ok:   openssl s_client -connect cdn.kernel.org:443 -debug -tls1_2 -no_tls1 -no_tls1_1 -cipher AES128-GCM-SHA256
+//  ok:   openssl s_client -connect cdn.kernel.org:443 -debug -tls1_2 -no_tls1 -no_tls1_1 -cipher AES128-SHA
+//        (TLS_RSA_WITH_AES_128_CBC_SHA - in TLS 1.2 it's mandated to be always supported)
+#define CIPHER_ID1  TLS_RSA_WITH_AES_256_CBC_SHA256 // no SERVER_KEY_EXCHANGE from peer
+// Works with "wget https://cdn.kernel.org/pub/linux/kernel/v4.x/linux-4.9.5.tar.xz"
+#define CIPHER_ID2  TLS_RSA_WITH_AES_128_CBC_SHA
+
+
+#define TLS_DEBUG      0
+#define TLS_DEBUG_HASH 0
+#define TLS_DEBUG_DER  0
+#define TLS_DEBUG_FIXED_SECRETS 0
+#if 0
+# define dump_raw_out(...) dump_hex(__VA_ARGS__)
+#else
+# define dump_raw_out(...) ((void)0)
+#endif
+#if 0
+# define dump_raw_in(...) dump_hex(__VA_ARGS__)
+#else
+# define dump_raw_in(...) ((void)0)
+#endif
+
+#if TLS_DEBUG
+# define dbg(...) fprintf(stderr, __VA_ARGS__)
+#else
+# define dbg(...) ((void)0)
+#endif
+
+#if TLS_DEBUG_DER
+# define dbg_der(...) fprintf(stderr, __VA_ARGS__)
+#else
+# define dbg_der(...) ((void)0)
+#endif
+
+#define RECORD_TYPE_CHANGE_CIPHER_SPEC  20
+#define RECORD_TYPE_ALERT               21
+#define RECORD_TYPE_HANDSHAKE           22
+#define RECORD_TYPE_APPLICATION_DATA    23
+
+#define HANDSHAKE_HELLO_REQUEST         0
+#define HANDSHAKE_CLIENT_HELLO          1
+#define HANDSHAKE_SERVER_HELLO          2
+#define HANDSHAKE_HELLO_VERIFY_REQUEST  3
+#define HANDSHAKE_NEW_SESSION_TICKET    4
+#define HANDSHAKE_CERTIFICATE           11
+#define HANDSHAKE_SERVER_KEY_EXCHANGE   12
+#define HANDSHAKE_CERTIFICATE_REQUEST   13
+#define HANDSHAKE_SERVER_HELLO_DONE     14
+#define HANDSHAKE_CERTIFICATE_VERIFY    15
+#define HANDSHAKE_CLIENT_KEY_EXCHANGE   16
+#define HANDSHAKE_FINISHED              20
+
+#define SSL_NULL_WITH_NULL_NULL                 0x0000
+#define SSL_RSA_WITH_NULL_MD5                   0x0001
+#define SSL_RSA_WITH_NULL_SHA                   0x0002
+#define SSL_RSA_WITH_RC4_128_MD5                0x0004
+#define SSL_RSA_WITH_RC4_128_SHA                0x0005
+#define SSL_RSA_WITH_3DES_EDE_CBC_SHA           0x000A  /* 10 */
+#define TLS_RSA_WITH_AES_128_CBC_SHA            0x002F  /* 47 */
+#define TLS_RSA_WITH_AES_256_CBC_SHA            0x0035  /* 53 */
+#define TLS_RSA_WITH_NULL_SHA256                0x003B  /* 59 */
+
+#define TLS_EMPTY_RENEGOTIATION_INFO_SCSV       0x00FF
+
+#define TLS_RSA_WITH_IDEA_CBC_SHA               0x0007  /* 7 */
+#define SSL_DHE_RSA_WITH_3DES_EDE_CBC_SHA       0x0016  /* 22 */
+#define SSL_DH_anon_WITH_RC4_128_MD5            0x0018  /* 24 */
+#define SSL_DH_anon_WITH_3DES_EDE_CBC_SHA       0x001B  /* 27 */
+#define TLS_DHE_RSA_WITH_AES_128_CBC_SHA        0x0033  /* 51 */
+#define TLS_DHE_RSA_WITH_AES_256_CBC_SHA        0x0039  /* 57 */
+#define TLS_DHE_RSA_WITH_AES_128_CBC_SHA256     0x0067  /* 103 */
+#define TLS_DHE_RSA_WITH_AES_256_CBC_SHA256     0x006B  /* 107 */
+#define TLS_DH_anon_WITH_AES_128_CBC_SHA        0x0034  /* 52 */
+#define TLS_DH_anon_WITH_AES_256_CBC_SHA        0x003A  /* 58 */
+#define TLS_RSA_WITH_AES_128_CBC_SHA256         0x003C  /* 60 */
+#define TLS_RSA_WITH_AES_256_CBC_SHA256         0x003D  /* 61 */
+#define TLS_RSA_WITH_SEED_CBC_SHA               0x0096  /* 150 */
+#define TLS_PSK_WITH_AES_128_CBC_SHA            0x008C  /* 140 */
+#define TLS_PSK_WITH_AES_128_CBC_SHA256         0x00AE  /* 174 */
+#define TLS_PSK_WITH_AES_256_CBC_SHA384         0x00AF  /* 175 */
+#define TLS_PSK_WITH_AES_256_CBC_SHA            0x008D  /* 141 */
+#define TLS_DHE_PSK_WITH_AES_128_CBC_SHA        0x0090  /* 144 */
+#define TLS_DHE_PSK_WITH_AES_256_CBC_SHA        0x0091  /* 145 */
+#define TLS_ECDH_ECDSA_WITH_AES_128_CBC_SHA     0xC004  /* 49156 */
+#define TLS_ECDH_ECDSA_WITH_AES_256_CBC_SHA     0xC005  /* 49157 */
+#define TLS_ECDHE_ECDSA_WITH_AES_128_CBC_SHA    0xC009  /* 49161 */
+#define TLS_ECDHE_ECDSA_WITH_AES_256_CBC_SHA    0xC00A  /* 49162 */
+#define TLS_ECDHE_RSA_WITH_3DES_EDE_CBC_SHA     0xC012  /* 49170 */
+#define TLS_ECDHE_RSA_WITH_AES_128_CBC_SHA      0xC013  /* 49171 */
+#define TLS_ECDHE_RSA_WITH_AES_256_CBC_SHA      0xC014  /* 49172 */
+#define TLS_ECDH_RSA_WITH_AES_128_CBC_SHA       0xC00E  /* 49166 */
+#define TLS_ECDH_RSA_WITH_AES_256_CBC_SHA       0xC00F  /* 49167 */
+#define TLS_ECDHE_ECDSA_WITH_AES_128_CBC_SHA256 0xC023  /* 49187 */
+#define TLS_ECDHE_ECDSA_WITH_AES_256_CBC_SHA384 0xC024  /* 49188 */
+#define TLS_ECDH_ECDSA_WITH_AES_128_CBC_SHA256  0xC025  /* 49189 */
+#define TLS_ECDH_ECDSA_WITH_AES_256_CBC_SHA384  0xC026  /* 49190 */
+#define TLS_ECDHE_RSA_WITH_AES_128_CBC_SHA256   0xC027  /* 49191 */
+#define TLS_ECDHE_RSA_WITH_AES_256_CBC_SHA384   0xC028  /* 49192 */
+#define TLS_ECDH_RSA_WITH_AES_128_CBC_SHA256    0xC029  /* 49193 */
+#define TLS_ECDH_RSA_WITH_AES_256_CBC_SHA384    0xC02A  /* 49194 */
+
+/* RFC 5288 "AES Galois Counter Mode (GCM) Cipher Suites for TLS" */
+#define TLS_RSA_WITH_AES_128_GCM_SHA256         0x009C  /* 156 */
+#define TLS_RSA_WITH_AES_256_GCM_SHA384         0x009D  /* 157 */
+#define TLS_ECDHE_ECDSA_WITH_AES_128_GCM_SHA256 0xC02B  /* 49195 */
+#define TLS_ECDHE_ECDSA_WITH_AES_256_GCM_SHA384 0xC02C  /* 49196 */
+#define TLS_ECDH_ECDSA_WITH_AES_128_GCM_SHA256  0xC02D  /* 49197 */
+#define TLS_ECDH_ECDSA_WITH_AES_256_GCM_SHA384  0xC02E  /* 49198 */
+#define TLS_ECDHE_RSA_WITH_AES_128_GCM_SHA256   0xC02F  /* 49199 */
+#define TLS_ECDHE_RSA_WITH_AES_256_GCM_SHA384   0xC030  /* 49200 */
+#define TLS_ECDH_RSA_WITH_AES_128_GCM_SHA256    0xC031  /* 49201 */
+#define TLS_ECDH_RSA_WITH_AES_256_GCM_SHA384    0xC032  /* 49202 */
+
+/* Might go to libbb.h */
+#define TLS_MAX_CRYPTBLOCK_SIZE 16
+#define TLS_MAX_OUTBUF          (1 << 14)
+
+enum {
+	SHA_INSIZE     = 64,
+	SHA1_OUTSIZE   = 20,
+	SHA256_OUTSIZE = 32,
+
+	AES_BLOCKSIZE  = 16,
+	AES128_KEYSIZE = 16,
+	AES256_KEYSIZE = 32,
+
+	RSA_PREMASTER_SIZE = 48,
+
+	RECHDR_LEN = 5,
+
+	/* 8 = 3+5. 3 extra bytes result in record data being 32-bit aligned */
+	OUTBUF_PFX = 8 + AES_BLOCKSIZE, /* header + IV */
+	OUTBUF_SFX = TLS_MAX_MAC_SIZE + TLS_MAX_CRYPTBLOCK_SIZE, /* MAC + padding */
+
+	// RFC 5246
+	// | 6.2.1. Fragmentation
+	// |  The record layer fragments information blocks into TLSPlaintext
+	// |  records carrying data in chunks of 2^14 bytes or less.  Client
+	// |  message boundaries are not preserved in the record layer (i.e.,
+	// |  multiple client messages of the same ContentType MAY be coalesced
+	// |  into a single TLSPlaintext record, or a single message MAY be
+	// |  fragmented across several records)
+	// |...
+	// |  length
+	// |    The length (in bytes) of the following TLSPlaintext.fragment.
+	// |    The length MUST NOT exceed 2^14.
+	// |...
+	// | 6.2.2. Record Compression and Decompression
+	// |...
+	// |  Compression must be lossless and may not increase the content length
+	// |  by more than 1024 bytes.  If the decompression function encounters a
+	// |  TLSCompressed.fragment that would decompress to a length in excess of
+	// |  2^14 bytes, it MUST report a fatal decompression failure error.
+	// |...
+	// |  length
+	// |    The length (in bytes) of the following TLSCompressed.fragment.
+	// |    The length MUST NOT exceed 2^14 + 1024.
+	// |...
+	// | 6.2.3.  Record Payload Protection
+	// |  The encryption and MAC functions translate a TLSCompressed
+	// |  structure into a TLSCiphertext.  The decryption functions reverse
+	// |  the process.  The MAC of the record also includes a sequence
+	// |  number so that missing, extra, or repeated messages are
+	// |  detectable.
+	// |...
+	// |  length
+	// |    The length (in bytes) of the following TLSCiphertext.fragment.
+	// |    The length MUST NOT exceed 2^14 + 2048.
+	MAX_INBUF = RECHDR_LEN + (1 << 14) + 2048,
+};
+
+struct record_hdr {
+	uint8_t type;
+	uint8_t proto_maj, proto_min;
+	uint8_t len16_hi, len16_lo;
+};
+
+struct tls_handshake_data {
+	/* In bbox, md5/sha1/sha256 ctx's are the same structure */
+	md5sha_ctx_t handshake_hash_ctx;
+
+	uint8_t client_and_server_rand32[2 * 32];
+	uint8_t master_secret[48];
+//TODO: store just the DER key here, parse/use/delete it when sending client key
+//this way it will stay key type agnostic here.
+	psRsaKey_t server_rsa_pub_key;
+
+	unsigned saved_client_hello_size;
+	uint8_t saved_client_hello[1];
+};
+
+
+static unsigned get24be(const uint8_t *p)
+{
+	return 0x100*(0x100*p[0] + p[1]) + p[2];
+}
+
+#if TLS_DEBUG
+static void dump_hex(const char *fmt, const void *vp, int len)
+{
+	char hexbuf[32 * 1024 + 4];
+	const uint8_t *p = vp;
+
+	bin2hex(hexbuf, (void*)p, len)[0] = '\0';
+	dbg(fmt, hexbuf);
+}
+
+static void dump_tls_record(const void *vp, int len)
+{
+	const uint8_t *p = vp;
+
+	while (len > 0) {
+		unsigned xhdr_len;
+		if (len < RECHDR_LEN) {
+			dump_hex("< |%s|\n", p, len);
+			return;
+		}
+		xhdr_len = 0x100*p[3] + p[4];
+		dbg("< hdr_type:%u ver:%u.%u len:%u", p[0], p[1], p[2], xhdr_len);
+		p += RECHDR_LEN;
+		len -= RECHDR_LEN;
+		if (len >= 4 && p[-RECHDR_LEN] == RECORD_TYPE_HANDSHAKE) {
+			unsigned len24 = get24be(p + 1);
+			dbg(" type:%u len24:%u", p[0], len24);
+		}
+		if (xhdr_len > len)
+			xhdr_len = len;
+		dump_hex(" |%s|\n", p, xhdr_len);
+		p += xhdr_len;
+		len -= xhdr_len;
+	}
+}
+#else
+# define dump_hex(...) ((void)0)
+# define dump_tls_record(...) ((void)0)
+#endif
+
+void tls_get_random(void *buf, unsigned len)
+{
+	if (len != open_read_close("/dev/urandom", buf, len))
+		xfunc_die();
+}
+
+/* Nondestructively see the current hash value */
+static unsigned sha_peek(md5sha_ctx_t *ctx, void *buffer)
+{
+	md5sha_ctx_t ctx_copy = *ctx; /* struct copy */
+	return sha_end(&ctx_copy, buffer);
+}
+
+static ALWAYS_INLINE unsigned get_handshake_hash(tls_state_t *tls, void *buffer)
+{
+	return sha_peek(&tls->hsd->handshake_hash_ctx, buffer);
+}
+
+#if !TLS_DEBUG_HASH
+# define hash_handshake(tls, fmt, buffer, len) \
+         hash_handshake(tls, buffer, len)
+#endif
+static void hash_handshake(tls_state_t *tls, const char *fmt, const void *buffer, unsigned len)
+{
+	md5sha_hash(&tls->hsd->handshake_hash_ctx, buffer, len);
+#if TLS_DEBUG_HASH
+	{
+		uint8_t h[TLS_MAX_MAC_SIZE];
+		dump_hex(fmt, buffer, len);
+		dbg(" (%u bytes) ", (int)len);
+		len = sha_peek(&tls->hsd->handshake_hash_ctx, h);
+		if (len == SHA1_OUTSIZE)
+			dump_hex("sha1:%s\n", h, len);
+		else
+		if (len == SHA256_OUTSIZE)
+			dump_hex("sha256:%s\n", h, len);
+		else
+			dump_hex("sha???:%s\n", h, len);
+	}
+#endif
+}
+
+// RFC 2104
+// HMAC(key, text) based on a hash H (say, sha256) is:
+// ipad = [0x36 x INSIZE]
+// opad = [0x5c x INSIZE]
+// HMAC(key, text) = H((key XOR opad) + H((key XOR ipad) + text))
+//
+// H(key XOR opad) and H(key XOR ipad) can be precomputed
+// if we often need HMAC hmac with the same key.
+//
+// text is often given in disjoint pieces.
+typedef struct hmac_precomputed {
+	md5sha_ctx_t hashed_key_xor_ipad;
+	md5sha_ctx_t hashed_key_xor_opad;
+} hmac_precomputed_t;
+
+static unsigned hmac_sha_precomputed_v(
+		hmac_precomputed_t *pre,
+		uint8_t *out,
+		va_list va)
+{
+	uint8_t *text;
+	unsigned len;
+
+	/* pre->hashed_key_xor_ipad contains unclosed "H((key XOR ipad) +" state */
+	/* pre->hashed_key_xor_opad contains unclosed "H((key XOR opad) +" state */
+
+	/* calculate out = H((key XOR ipad) + text) */
+	while ((text = va_arg(va, uint8_t*)) != NULL) {
+		unsigned text_size = va_arg(va, unsigned);
+		md5sha_hash(&pre->hashed_key_xor_ipad, text, text_size);
+	}
+	len = sha_end(&pre->hashed_key_xor_ipad, out);
+
+	/* out = H((key XOR opad) + out) */
+	md5sha_hash(&pre->hashed_key_xor_opad, out, len);
+	return sha_end(&pre->hashed_key_xor_opad, out);
+}
+
+typedef void md5sha_begin_func(md5sha_ctx_t *ctx) FAST_FUNC;
+static void hmac_begin(hmac_precomputed_t *pre, uint8_t *key, unsigned key_size, md5sha_begin_func *begin)
+{
+	uint8_t key_xor_ipad[SHA_INSIZE];
+	uint8_t key_xor_opad[SHA_INSIZE];
+	uint8_t tempkey[SHA1_OUTSIZE < SHA256_OUTSIZE ? SHA256_OUTSIZE : SHA1_OUTSIZE];
+	unsigned i;
+
+	// "The authentication key can be of any length up to INSIZE, the
+	// block length of the hash function.  Applications that use keys longer
+	// than INSIZE bytes will first hash the key using H and then use the
+	// resultant OUTSIZE byte string as the actual key to HMAC."
+	if (key_size > SHA_INSIZE) {
+		md5sha_ctx_t ctx;
+		begin(&ctx);
+		md5sha_hash(&ctx, key, key_size);
+		key_size = sha_end(&ctx, tempkey);
+	}
+
+	for (i = 0; i < key_size; i++) {
+		key_xor_ipad[i] = key[i] ^ 0x36;
+		key_xor_opad[i] = key[i] ^ 0x5c;
+	}
+	for (; i < SHA_INSIZE; i++) {
+		key_xor_ipad[i] = 0x36;
+		key_xor_opad[i] = 0x5c;
+	}
+
+	begin(&pre->hashed_key_xor_ipad);
+	begin(&pre->hashed_key_xor_opad);
+	md5sha_hash(&pre->hashed_key_xor_ipad, key_xor_ipad, SHA_INSIZE);
+	md5sha_hash(&pre->hashed_key_xor_opad, key_xor_opad, SHA_INSIZE);
+}
+
+static unsigned hmac(tls_state_t *tls, uint8_t *out, uint8_t *key, unsigned key_size, ...)
+{
+	hmac_precomputed_t pre;
+	va_list va;
+	unsigned len;
+
+	va_start(va, key_size);
+
+	hmac_begin(&pre, key, key_size,
+			(tls->MAC_size == SHA256_OUTSIZE)
+				? sha256_begin
+				: sha1_begin
+	);
+	len = hmac_sha_precomputed_v(&pre, out, va);
+
+	va_end(va);
+	return len;
+}
+
+static unsigned hmac_sha256(/*tls_state_t *tls,*/ uint8_t *out, uint8_t *key, unsigned key_size, ...)
+{
+	hmac_precomputed_t pre;
+	va_list va;
+	unsigned len;
+
+	va_start(va, key_size);
+
+	hmac_begin(&pre, key, key_size, sha256_begin);
+	len = hmac_sha_precomputed_v(&pre, out, va);
+
+	va_end(va);
+	return len;
+}
+
+// RFC 5246:
+// 5.  HMAC and the Pseudorandom Function
+//...
+// In this section, we define one PRF, based on HMAC.  This PRF with the
+// SHA-256 hash function is used for all cipher suites defined in this
+// document and in TLS documents published prior to this document when
+// TLS 1.2 is negotiated.
+// ^^^^^^^^^^^^^ IMPORTANT!
+//               PRF uses sha256 regardless of cipher (at least for all ciphers
+//               defined by RFC5246). It's not sha1 for AES_128_CBC_SHA!
+//...
+//    P_hash(secret, seed) = HMAC_hash(secret, A(1) + seed) +
+//                           HMAC_hash(secret, A(2) + seed) +
+//                           HMAC_hash(secret, A(3) + seed) + ...
+// where + indicates concatenation.
+// A() is defined as:
+//    A(0) = seed
+//    A(1) = HMAC_hash(secret, A(0)) = HMAC_hash(secret, seed)
+//    A(i) = HMAC_hash(secret, A(i-1))
+// P_hash can be iterated as many times as necessary to produce the
+// required quantity of data.  For example, if P_SHA256 is being used to
+// create 80 bytes of data, it will have to be iterated three times
+// (through A(3)), creating 96 bytes of output data; the last 16 bytes
+// of the final iteration will then be discarded, leaving 80 bytes of
+// output data.
+//
+// TLS's PRF is created by applying P_hash to the secret as:
+//
+//    PRF(secret, label, seed) = P_<hash>(secret, label + seed)
+//
+// The label is an ASCII string.
+static void prf_hmac_sha256(/*tls_state_t *tls,*/
+		uint8_t *outbuf, unsigned outbuf_size,
+		uint8_t *secret, unsigned secret_size,
+		const char *label,
+		uint8_t *seed, unsigned seed_size)
+{
+	uint8_t a[TLS_MAX_MAC_SIZE];
+	uint8_t *out_p = outbuf;
+	unsigned label_size = strlen(label);
+	unsigned MAC_size = SHA256_OUTSIZE;
+
+	/* In P_hash() calculation, "seed" is "label + seed": */
+#define SEED   label, label_size, seed, seed_size
+#define SECRET secret, secret_size
+#define A      a, MAC_size
+
+	/* A(1) = HMAC_hash(secret, seed) */
+	hmac_sha256(/*tls,*/ a, SECRET, SEED, NULL);
+//TODO: convert hmac to precomputed
+
+	for (;;) {
+		/* HMAC_hash(secret, A(1) + seed) */
+		if (outbuf_size <= MAC_size) {
+			/* Last, possibly incomplete, block */
+			/* (use a[] as temp buffer) */
+			hmac_sha256(/*tls,*/ a, SECRET, A, SEED, NULL);
+			memcpy(out_p, a, outbuf_size);
+			return;
+		}
+		/* Not last block. Store directly to result buffer */
+		hmac_sha256(/*tls,*/ out_p, SECRET, A, SEED, NULL);
+		out_p += MAC_size;
+		outbuf_size -= MAC_size;
+		/* A(2) = HMAC_hash(secret, A(1)) */
+		hmac_sha256(/*tls,*/ a, SECRET, A, NULL);
+	}
+#undef A
+#undef SECRET
+#undef SEED
+}
+
+static void bad_record_die(tls_state_t *tls, const char *expected, int len)
+{
+	bb_error_msg("got bad TLS record (len:%d) while expecting %s", len, expected);
+	if (len > 0) {
+		uint8_t *p = tls->inbuf;
+		while (len > 0) {
+			fprintf(stderr, " %02x", *p++);
+			len--;
+		}
+		fputc('\n', stderr);
+	}
+	xfunc_die();
+}
+
+static void tls_error_die(tls_state_t *tls, int line)
+{
+	dump_tls_record(tls->inbuf, tls->ofs_to_buffered + tls->buffered_size);
+	bb_error_msg_and_die("tls error at line %d cipher:%04x", line, tls->cipher_id);
+}
+#define tls_error_die(tls) tls_error_die(tls, __LINE__)
+
+#if 0 //UNUSED
+static void tls_free_inbuf(tls_state_t *tls)
+{
+	if (tls->buffered_size == 0) {
+		free(tls->inbuf);
+		tls->inbuf_size = 0;
+		tls->inbuf = NULL;
+	}
+}
+#endif
+
+static void tls_free_outbuf(tls_state_t *tls)
+{
+	free(tls->outbuf);
+	tls->outbuf_size = 0;
+	tls->outbuf = NULL;
+}
+
+static void *tls_get_outbuf(tls_state_t *tls, int len)
+{
+	if (len > TLS_MAX_OUTBUF)
+		xfunc_die();
+	len += OUTBUF_PFX + OUTBUF_SFX;
+	if (tls->outbuf_size < len) {
+		tls->outbuf_size = len;
+		tls->outbuf = xrealloc(tls->outbuf, len);
+	}
+	return tls->outbuf + OUTBUF_PFX;
+}
+
+static void xwrite_encrypted(tls_state_t *tls, unsigned size, unsigned type)
+{
+	uint8_t *buf = tls->outbuf + OUTBUF_PFX;
+	struct record_hdr *xhdr;
+	uint8_t padding_length;
+
+	xhdr = (void*)(buf - RECHDR_LEN);
+	if (CIPHER_ID1 != TLS_RSA_WITH_NULL_SHA256 /* if "no encryption" can't be selected */
+	 || tls->cipher_id != TLS_RSA_WITH_NULL_SHA256 /* or if it wasn't selected */
+	) {
+		xhdr = (void*)(buf - RECHDR_LEN - AES_BLOCKSIZE); /* place for IV */
+	}
+
+	xhdr->type = type;
+	xhdr->proto_maj = TLS_MAJ;
+	xhdr->proto_min = TLS_MIN;
+	/* fake unencrypted record len for MAC calculation */
+	xhdr->len16_hi = size >> 8;
+	xhdr->len16_lo = size & 0xff;
+
+	/* Calculate MAC signature */
+	hmac(tls, buf + size, /* result */
+		tls->client_write_MAC_key, tls->MAC_size,
+		&tls->write_seq64_be, sizeof(tls->write_seq64_be),
+		xhdr, RECHDR_LEN,
+		buf, size,
+		NULL
+	);
+	tls->write_seq64_be = SWAP_BE64(1 + SWAP_BE64(tls->write_seq64_be));
+
+	size += tls->MAC_size;
+
+	// RFC 5246
+	// 6.2.3.1.  Null or Standard Stream Cipher
+	//
+	// Stream ciphers (including BulkCipherAlgorithm.null; see Appendix A.6)
+	// convert TLSCompressed.fragment structures to and from stream
+	// TLSCiphertext.fragment structures.
+	//
+	//    stream-ciphered struct {
+	//        opaque content[TLSCompressed.length];
+	//        opaque MAC[SecurityParameters.mac_length];
+	//    } GenericStreamCipher;
+	//
+	// The MAC is generated as:
+	//    MAC(MAC_write_key, seq_num +
+	//                          TLSCompressed.type +
+	//                          TLSCompressed.version +
+	//                          TLSCompressed.length +
+	//                          TLSCompressed.fragment);
+	// where "+" denotes concatenation.
+	// seq_num
+	//    The sequence number for this record.
+	// MAC
+	//    The MAC algorithm specified by SecurityParameters.mac_algorithm.
+	//
+	// Note that the MAC is computed before encryption.  The stream cipher
+	// encrypts the entire block, including the MAC.
+	//...
+	// Appendix C.  Cipher Suite Definitions
+	//...
+	// MAC       Algorithm    mac_length  mac_key_length
+	// --------  -----------  ----------  --------------
+	// SHA       HMAC-SHA1       20            20
+	// SHA256    HMAC-SHA256     32            32
+	if (CIPHER_ID1 == TLS_RSA_WITH_NULL_SHA256
+	 && tls->cipher_id == TLS_RSA_WITH_NULL_SHA256
+	) {
+		/* No encryption, only signing */
+		xhdr->len16_hi = size >> 8;
+		xhdr->len16_lo = size & 0xff;
+		dump_raw_out(">> %s\n", xhdr, RECHDR_LEN + size);
+		xwrite(tls->ofd, xhdr, RECHDR_LEN + size);
+		dbg("wrote %u bytes (NULL crypt, SHA256 hash)\n", size);
+		return;
+	}
+
+	// 6.2.3.2.  CBC Block Cipher
+	// For block ciphers (such as 3DES or AES), the encryption and MAC
+	// functions convert TLSCompressed.fragment structures to and from block
+	// TLSCiphertext.fragment structures.
+	//    struct {
+	//        opaque IV[SecurityParameters.record_iv_length];
+	//        block-ciphered struct {
+	//            opaque content[TLSCompressed.length];
+	//            opaque MAC[SecurityParameters.mac_length];
+	//            uint8 padding[GenericBlockCipher.padding_length];
+	//            uint8 padding_length;
+	//        };
+	//    } GenericBlockCipher;
+	//...
+	// IV
+	//    The Initialization Vector (IV) SHOULD be chosen at random, and
+	//    MUST be unpredictable.  Note that in versions of TLS prior to 1.1,
+	//    there was no IV field (...).  For block ciphers, the IV length is
+	//    of length SecurityParameters.record_iv_length, which is equal to the
+	//    SecurityParameters.block_size.
+	// padding
+	//    Padding that is added to force the length of the plaintext to be
+	//    an integral multiple of the block cipher's block length.
+	// padding_length
+	//    The padding length MUST be such that the total size of the
+	//    GenericBlockCipher structure is a multiple of the cipher's block
+	//    length.  Legal values range from zero to 255, inclusive.
+	//...
+	// Appendix C.  Cipher Suite Definitions
+	//...
+	//                         Key      IV   Block
+	// Cipher        Type    Material  Size  Size
+	// ------------  ------  --------  ----  -----
+	// AES_128_CBC   Block      16      16     16
+	// AES_256_CBC   Block      32      16     16
+
+	/* Fill IV and padding in outbuf */
+	tls_get_random(buf - AES_BLOCKSIZE, AES_BLOCKSIZE); /* IV */
+	dbg("before crypt: 5 hdr + %u data + %u hash bytes\n", size, tls->MAC_size);
+	// RFC is talking nonsense:
+	//    "Padding that is added to force the length of the plaintext to be
+	//    an integral multiple of the block cipher's block length."
+	// WRONG. _padding+padding_length_, not just _padding_,
+	// pads the data.
+	// IOW: padding_length is the last byte of padding[] array,
+	// contrary to what RFC depicts.
+	//
+	// What actually happens is that there is always padding.
+	// If you need one byte to reach BLOCKSIZE, this byte is 0x00.
+	// If you need two bytes, they are both 0x01.
+	// If you need three, they are 0x02,0x02,0x02. And so on.
+	// If you need no bytes to reach BLOCKSIZE, you have to pad a full
+	// BLOCKSIZE with bytes of value (BLOCKSIZE-1).
+	// It's ok to have more than minimum padding, but we do minimum.
+	padding_length = (~size) & (AES_BLOCKSIZE - 1);
+	do {
+		buf[size++] = padding_length; /* padding */
+	} while ((size & (AES_BLOCKSIZE - 1)) != 0);
+
+	/* Encrypt content+MAC+padding in place */
+	aes_cbc_encrypt(
+		tls->client_write_key, tls->key_size, /* selects 128/256 */
+		buf - AES_BLOCKSIZE, /* IV */
+		buf, size, /* plaintext */
+		buf /* ciphertext */
+	);
+
+	/* Write out */
+	dbg("writing 5 + %u IV + %u encrypted bytes, padding_length:0x%02x\n",
+			AES_BLOCKSIZE, size, padding_length);
+	size += AES_BLOCKSIZE;     /* + IV */
+	xhdr->len16_hi = size >> 8;
+	xhdr->len16_lo = size & 0xff;
+	dump_raw_out(">> %s\n", xhdr, RECHDR_LEN + size);
+	xwrite(tls->ofd, xhdr, RECHDR_LEN + size);
+	dbg("wrote %u bytes\n", (int)RECHDR_LEN + size);
+}
+
+static void xwrite_handshake_record(tls_state_t *tls, unsigned size)
+{
+	//if (!tls->encrypt_on_write) {
+		uint8_t *buf = tls->outbuf + OUTBUF_PFX;
+		struct record_hdr *xhdr = (void*)(buf - RECHDR_LEN);
+
+		xhdr->type = RECORD_TYPE_HANDSHAKE;
+		xhdr->proto_maj = TLS_MAJ;
+		xhdr->proto_min = TLS_MIN;
+		xhdr->len16_hi = size >> 8;
+		xhdr->len16_lo = size & 0xff;
+		dump_raw_out(">> %s\n", xhdr, RECHDR_LEN + size);
+		xwrite(tls->ofd, xhdr, RECHDR_LEN + size);
+		dbg("wrote %u bytes\n", (int)RECHDR_LEN + size);
+	//	return;
+	//}
+	//xwrite_encrypted(tls, size, RECORD_TYPE_HANDSHAKE);
+}
+
+static void xwrite_and_update_handshake_hash(tls_state_t *tls, unsigned size)
+{
+	if (!tls->encrypt_on_write) {
+		uint8_t *buf;
+
+		xwrite_handshake_record(tls, size);
+		/* Handshake hash does not include record headers */
+		buf = tls->outbuf + OUTBUF_PFX;
+		hash_handshake(tls, ">> hash:%s", buf, size);
+		return;
+	}
+	xwrite_encrypted(tls, size, RECORD_TYPE_HANDSHAKE);
+}
+
+static int tls_has_buffered_record(tls_state_t *tls)
+{
+	int buffered = tls->buffered_size;
+	struct record_hdr *xhdr;
+	int rec_size;
+
+	if (buffered < RECHDR_LEN)
+		return 0;
+	xhdr = (void*)(tls->inbuf + tls->ofs_to_buffered);
+	rec_size = RECHDR_LEN + (0x100 * xhdr->len16_hi + xhdr->len16_lo);
+	if (buffered < rec_size)
+		return 0;
+	return rec_size;
+}
+
+static const char *alert_text(int code)
+{
+	switch (code) {
+	case 20:  return "bad MAC";
+	case 50:  return "decode error";
+	case 51:  return "decrypt error";
+	case 40:  return "handshake failure";
+	case 112: return "unrecognized name";
+	}
+	return itoa(code);
+}
+
+static int tls_xread_record(tls_state_t *tls)
+{
+	struct record_hdr *xhdr;
+	int sz;
+	int total;
+	int target;
+
+ again:
+	dbg("ofs_to_buffered:%u buffered_size:%u\n", tls->ofs_to_buffered, tls->buffered_size);
+	total = tls->buffered_size;
+	if (total != 0) {
+		memmove(tls->inbuf, tls->inbuf + tls->ofs_to_buffered, total);
+		//dbg("<< remaining at %d [%d] ", tls->ofs_to_buffered, total);
+		//dump_raw_in("<< %s\n", tls->inbuf, total);
+	}
+	errno = 0;
+	target = MAX_INBUF;
+	for (;;) {
+		int rem;
+
+		if (total >= RECHDR_LEN && target == MAX_INBUF) {
+			xhdr = (void*)tls->inbuf;
+			target = RECHDR_LEN + (0x100 * xhdr->len16_hi + xhdr->len16_lo);
+			if (target > MAX_INBUF) {
+				/* malformed input (too long): yell and die */
+				tls->buffered_size = 0;
+				tls->ofs_to_buffered = total;
+				tls_error_die(tls);
+			}
+			/* can also check type/proto_maj/proto_min here */
+			dbg("xhdr type:%d ver:%d.%d len:%d\n",
+				xhdr->type, xhdr->proto_maj, xhdr->proto_min,
+				0x100 * xhdr->len16_hi + xhdr->len16_lo
+			);
+		}
+		/* if total >= target, we have a full packet (and possibly more)... */
+		if (total - target >= 0)
+			break;
+		/* input buffer is grown only as needed */
+		rem = tls->inbuf_size - total;
+		if (rem == 0) {
+			tls->inbuf_size += MAX_INBUF / 8;
+			if (tls->inbuf_size > MAX_INBUF)
+				tls->inbuf_size = MAX_INBUF;
+			dbg("inbuf_size:%d\n", tls->inbuf_size);
+			rem = tls->inbuf_size - total;
+			tls->inbuf = xrealloc(tls->inbuf, tls->inbuf_size);
+		}
+		sz = safe_read(tls->ifd, tls->inbuf + total, rem);
+		if (sz <= 0) {
+			if (sz == 0 && total == 0) {
+				/* "Abrupt" EOF, no TLS shutdown (seen from kernel.org) */
+				dbg("EOF (without TLS shutdown) from peer\n");
+				tls->buffered_size = 0;
+				goto end;
+			}
+			bb_perror_msg_and_die("short read, have only %d", total);
+		}
+		dump_raw_in("<< %s\n", tls->inbuf + total, sz);
+		total += sz;
+	}
+	tls->buffered_size = total - target;
+	tls->ofs_to_buffered = target;
+	//dbg("<< stashing at %d [%d] ", tls->ofs_to_buffered, tls->buffered_size);
+	//dump_hex("<< %s\n", tls->inbuf + tls->ofs_to_buffered, tls->buffered_size);
+
+	sz = target - RECHDR_LEN;
+
+	/* Needs to be decrypted? */
+	if (tls->min_encrypted_len_on_read > tls->MAC_size) {
+		uint8_t *p = tls->inbuf + RECHDR_LEN;
+		int padding_len;
+
+		if (sz & (AES_BLOCKSIZE-1)
+		 || sz < (int)tls->min_encrypted_len_on_read
+		) {
+			bb_error_msg_and_die("bad encrypted len:%u < %u",
+				sz, tls->min_encrypted_len_on_read);
+		}
+		/* Decrypt content+MAC+padding, moving it over IV in the process */
+		sz -= AES_BLOCKSIZE; /* we will overwrite IV now */
+		aes_cbc_decrypt(
+			tls->server_write_key, tls->key_size, /* selects 128/256 */
+			p, /* IV */
+			p + AES_BLOCKSIZE, sz, /* ciphertext */
+			p /* plaintext */
+		);
+		padding_len = p[sz - 1];
+		dbg("encrypted size:%u type:0x%02x padding_length:0x%02x\n", sz, p[0], padding_len);
+		padding_len++;
+		sz -= tls->MAC_size + padding_len; /* drop MAC and padding */
+		//if (sz < 0)
+		//	bb_error_msg_and_die("bad padding size:%u", padding_len);
+	} else {
+		/* if nonzero, then it's TLS_RSA_WITH_NULL_SHA256: drop MAC */
+		/* else: no encryption yet on input, subtract zero = NOP */
+		sz -= tls->min_encrypted_len_on_read;
+	}
+	if (sz < 0)
+		bb_error_msg_and_die("encrypted data too short");
+
+	//dump_hex("<< %s\n", tls->inbuf, RECHDR_LEN + sz);
+
+	xhdr = (void*)tls->inbuf;
+	if (xhdr->type == RECORD_TYPE_ALERT && sz >= 2) {
+		uint8_t *p = tls->inbuf + RECHDR_LEN;
+		dbg("ALERT size:%d level:%d description:%d\n", sz, p[0], p[1]);
+		if (p[0] == 2) { /* fatal */
+			bb_error_msg_and_die("TLS %s from peer (alert code %d): %s",
+				"error",
+				p[1], alert_text(p[1])
+			);
+		}
+		if (p[0] == 1) { /* warning */
+			if (p[1] == 0) { /* "close_notify" warning: it's EOF */
+				dbg("EOF (TLS encoded) from peer\n");
+				sz = 0;
+				goto end;
+			}
+//This possibly needs to be cached and shown only if
+//a fatal alert follows
+//			bb_error_msg("TLS %s from peer (alert code %d): %s",
+//				"warning",
+//				p[1], alert_text(p[1])
+//			);
+			/* discard it, get next record */
+			goto again;
+		}
+		/* p[0] not 1 or 2: not defined in protocol */
+		sz = 0;
+		goto end;
+	}
+
+	/* RFC 5246 is not saying it explicitly, but sha256 hash
+	 * in our FINISHED record must include data of incoming packets too!
+	 */
+	if (tls->inbuf[0] == RECORD_TYPE_HANDSHAKE
+	 && tls->MAC_size != 0 /* do we know which hash to use? (server_hello() does not!) */
+	) {
+		hash_handshake(tls, "<< hash:%s", tls->inbuf + RECHDR_LEN, sz);
+	}
+ end:
+	dbg("got block len:%u\n", sz);
+	return sz;
+}
+
+/*
+ * DER parsing routines
+ */
+static unsigned get_der_len(uint8_t **bodyp, uint8_t *der, uint8_t *end)
+{
+	unsigned len, len1;
+
+	if (end - der < 2)
+		xfunc_die();
+//	if ((der[0] & 0x1f) == 0x1f) /* not single-byte item code? */
+//		xfunc_die();
+
+	len = der[1]; /* maybe it's short len */
+	if (len >= 0x80) {
+		/* no, it's long */
+
+		if (len == 0x80 || end - der < (int)(len - 0x7e)) {
+			/* 0x80 is "0 bytes of len", invalid DER: must use short len if can */
+			/* need 3 or 4 bytes for 81, 82 */
+			xfunc_die();
+		}
+
+		len1 = der[2]; /* if (len == 0x81) it's "ii 81 xx", fetch xx */
+		if (len > 0x82) {
+			/* >0x82 is "3+ bytes of len", should not happen realistically */
+			xfunc_die();
+		}
+		if (len == 0x82) { /* it's "ii 82 xx yy" */
+			len1 = 0x100*len1 + der[3];
+			der += 1; /* skip [yy] */
+		}
+		der += 1; /* skip [xx] */
+		len = len1;
+//		if (len < 0x80)
+//			xfunc_die(); /* invalid DER: must use short len if can */
+	}
+	der += 2; /* skip [code]+[1byte] */
+
+	if (end - der < (int)len)
+		xfunc_die();
+	*bodyp = der;
+
+	return len;
+}
+
+static uint8_t *enter_der_item(uint8_t *der, uint8_t **endp)
+{
+	uint8_t *new_der;
+	unsigned len = get_der_len(&new_der, der, *endp);
+	dbg_der("entered der @%p:0x%02x len:%u inner_byte @%p:0x%02x\n", der, der[0], len, new_der, new_der[0]);
+	/* Move "end" position to cover only this item */
+	*endp = new_der + len;
+	return new_der;
+}
+
+static uint8_t *skip_der_item(uint8_t *der, uint8_t *end)
+{
+	uint8_t *new_der;
+	unsigned len = get_der_len(&new_der, der, end);
+	/* Skip body */
+	new_der += len;
+	dbg_der("skipped der 0x%02x, next byte 0x%02x\n", der[0], new_der[0]);
+	return new_der;
+}
+
+static void der_binary_to_pstm(pstm_int *pstm_n, uint8_t *der, uint8_t *end)
+{
+	uint8_t *bin_ptr;
+	unsigned len = get_der_len(&bin_ptr, der, end);
+
+	dbg_der("binary bytes:%u, first:0x%02x\n", len, bin_ptr[0]);
+	pstm_init_for_read_unsigned_bin(/*pool:*/ NULL, pstm_n, len);
+	pstm_read_unsigned_bin(pstm_n, bin_ptr, len);
+	//return bin + len;
+}
+
+static void find_key_in_der_cert(tls_state_t *tls, uint8_t *der, int len)
+{
+/* Certificate is a DER-encoded data structure. Each DER element has a length,
+ * which makes it easy to skip over large compound elements of any complexity
+ * without parsing them. Example: partial decode of kernel.org certificate:
+ *  SEQ 0x05ac/1452 bytes (Certificate): 308205ac
+ *    SEQ 0x0494/1172 bytes (tbsCertificate): 30820494
+ *      [ASN_CONTEXT_SPECIFIC | ASN_CONSTRUCTED | 0] 3 bytes: a003
+ *        INTEGER (version): 0201 02
+ *      INTEGER 0x11 bytes (serialNumber): 0211 00 9f85bf664b0cddafca508679501b2be4
+ *      //^^^^^^note: matrixSSL also allows [ASN_CONTEXT_SPECIFIC | ASN_PRIMITIVE | 2] = 0x82 type
+ *      SEQ 0x0d bytes (signatureAlgo): 300d
+ *        OID 9 bytes: 0609 2a864886f70d01010b (OID_SHA256_RSA_SIG 42.134.72.134.247.13.1.1.11)
+ *        NULL: 0500
+ *      SEQ 0x5f bytes (issuer): 305f
+ *        SET 11 bytes: 310b
+ *          SEQ 9 bytes: 3009
+ *            OID 3 bytes: 0603 550406
+ *            Printable string "FR": 1302 4652
+ *        SET 14 bytes: 310e
+ *          SEQ 12 bytes: 300c
+ *            OID 3 bytes: 0603 550408
+ *            Printable string "Paris": 1305 5061726973
+ *        SET 14 bytes: 310e
+ *          SEQ 12 bytes: 300c
+ *            OID 3 bytes: 0603 550407
+ *            Printable string "Paris": 1305 5061726973
+ *        SET 14 bytes: 310e
+ *          SEQ 12 bytes: 300c
+ *            OID 3 bytes: 0603 55040a
+ *            Printable string "Gandi": 1305 47616e6469
+ *        SET 32 bytes: 3120
+ *          SEQ 30 bytes: 301e
+ *            OID 3 bytes: 0603 550403
+ *            Printable string "Gandi Standard SSL CA 2": 1317 47616e6469205374616e646172642053534c2043412032
+ *      SEQ 30 bytes (validity): 301e
+ *        TIME "161011000000Z": 170d 3136313031313030303030305a
+ *        TIME "191011235959Z": 170d 3139313031313233353935395a
+ *      SEQ 0x5b/91 bytes (subject): 305b //I did not decode this
+ *          3121301f060355040b1318446f6d61696e20436f
+ *          6e74726f6c2056616c6964617465643121301f06
+ *          0355040b1318506f73697469766553534c204d75
+ *          6c74692d446f6d61696e31133011060355040313
+ *          0a6b65726e656c2e6f7267
+ *      SEQ 0x01a2/418 bytes (subjectPublicKeyInfo): 308201a2
+ *        SEQ 13 bytes (algorithm): 300d
+ *          OID 9 bytes: 0609 2a864886f70d010101 (OID_RSA_KEY_ALG 42.134.72.134.247.13.1.1.1)
+ *          NULL: 0500
+ *        BITSTRING 0x018f/399 bytes (publicKey): 0382018f
+ *          ????: 00
+ *          //after the zero byte, it appears key itself uses DER encoding:
+ *          SEQ 0x018a/394 bytes: 3082018a
+ *            INTEGER 0x0181/385 bytes (modulus): 02820181
+ *                  00b1ab2fc727a3bef76780c9349bf3
+ *                  ...24 more blocks of 15 bytes each...
+ *                  90e895291c6bc8693b65
+ *            INTEGER 3 bytes (exponent): 0203 010001
+ *      [ASN_CONTEXT_SPECIFIC | ASN_CONSTRUCTED | 0x3] 0x01e5 bytes (X509v3 extensions): a38201e5
+ *        SEQ 0x01e1 bytes: 308201e1
+ *        ...
+ * Certificate is a sequence of three elements:
+ *	tbsCertificate (SEQ)
+ *	signatureAlgorithm (AlgorithmIdentifier)
+ *	signatureValue (BIT STRING)
+ *
+ * In turn, tbsCertificate is a sequence of:
+ *	version
+ *	serialNumber
+ *	signatureAlgo (AlgorithmIdentifier)
+ *	issuer (Name, has complex structure)
+ *	validity (Validity, SEQ of two Times)
+ *	subject (Name)
+ *	subjectPublicKeyInfo (SEQ)
+ *	...
+ *
+ * subjectPublicKeyInfo is a sequence of:
+ *	algorithm (AlgorithmIdentifier)
+ *	publicKey (BIT STRING)
+ *
+ * We need Certificate.tbsCertificate.subjectPublicKeyInfo.publicKey
+ */
+	uint8_t *end = der + len;
+
+	/* enter "Certificate" item: [der, end) will be only Cert */
+	der = enter_der_item(der, &end);
+
+	/* enter "tbsCertificate" item: [der, end) will be only tbsCert */
+	der = enter_der_item(der, &end);
+
+	/* skip up to subjectPublicKeyInfo */
+	der = skip_der_item(der, end); /* version */
+	der = skip_der_item(der, end); /* serialNumber */
+	der = skip_der_item(der, end); /* signatureAlgo */
+	der = skip_der_item(der, end); /* issuer */
+	der = skip_der_item(der, end); /* validity */
+	der = skip_der_item(der, end); /* subject */
+
+	/* enter subjectPublicKeyInfo */
+	der = enter_der_item(der, &end);
+	{ /* check subjectPublicKeyInfo.algorithm */
+		static const uint8_t expected[] = {
+			0x30,0x0d, // SEQ 13 bytes
+			0x06,0x09, 0x2a,0x86,0x48,0x86,0xf7,0x0d,0x01,0x01,0x01, // OID RSA_KEY_ALG 42.134.72.134.247.13.1.1.1
+			//0x05,0x00, // NULL
+		};
+		if (memcmp(der, expected, sizeof(expected)) != 0)
+			bb_error_msg_and_die("not RSA key");
+	}
+	/* skip subjectPublicKeyInfo.algorithm */
+	der = skip_der_item(der, end);
+	/* enter subjectPublicKeyInfo.publicKey */
+//	die_if_not_this_der_type(der, end, 0x03); /* must be BITSTRING */
+	der = enter_der_item(der, &end);
+
+	/* parse RSA key: */
+//based on getAsnRsaPubKey(), pkcs1ParsePrivBin() is also of note
+	dbg("key bytes:%u, first:0x%02x\n", (int)(end - der), der[0]);
+	if (end - der < 14) xfunc_die();
+	/* example format:
+	 * ignore bits: 00
+	 * SEQ 0x018a/394 bytes: 3082018a
+	 *   INTEGER 0x0181/385 bytes (modulus): 02820181 XX...XXX
+	 *   INTEGER 3 bytes (exponent): 0203 010001
+	 */
+	if (*der != 0) /* "ignore bits", should be 0 */
+		xfunc_die();
+	der++;
+	der = enter_der_item(der, &end); /* enter SEQ */
+	/* memset(tls->hsd->server_rsa_pub_key, 0, sizeof(tls->hsd->server_rsa_pub_key)); - already is */
+	der_binary_to_pstm(&tls->hsd->server_rsa_pub_key.N, der, end); /* modulus */
+	der = skip_der_item(der, end);
+	der_binary_to_pstm(&tls->hsd->server_rsa_pub_key.e, der, end); /* exponent */
+	tls->hsd->server_rsa_pub_key.size = pstm_unsigned_bin_size(&tls->hsd->server_rsa_pub_key.N);
+	dbg("server_rsa_pub_key.size:%d\n", tls->hsd->server_rsa_pub_key.size);
+}
+
+/*
+ * TLS Handshake routines
+ */
+static int tls_xread_handshake_block(tls_state_t *tls, int min_len)
+{
+	struct record_hdr *xhdr;
+	int len = tls_xread_record(tls);
+
+	xhdr = (void*)tls->inbuf;
+	if (len < min_len
+	 || xhdr->type != RECORD_TYPE_HANDSHAKE
+	 || xhdr->proto_maj != TLS_MAJ
+	 || xhdr->proto_min != TLS_MIN
+	) {
+		bad_record_die(tls, "handshake record", len);
+	}
+	dbg("got HANDSHAKE\n");
+	return len;
+}
+
+static ALWAYS_INLINE void fill_handshake_record_hdr(void *buf, unsigned type, unsigned len)
+{
+	struct handshake_hdr {
+		uint8_t type;
+		uint8_t len24_hi, len24_mid, len24_lo;
+	} *h = buf;
+
+	len -= 4;
+	h->type = type;
+	h->len24_hi  = len >> 16;
+	h->len24_mid = len >> 8;
+	h->len24_lo  = len & 0xff;
+}
+
+static void send_client_hello_and_alloc_hsd(tls_state_t *tls, const char *sni)
+{
+	struct client_hello {
+		uint8_t type;
+		uint8_t len24_hi, len24_mid, len24_lo;
+		uint8_t proto_maj, proto_min;
+		uint8_t rand32[32];
+		uint8_t session_id_len;
+		/* uint8_t session_id[]; */
+		uint8_t cipherid_len16_hi, cipherid_len16_lo;
+		uint8_t cipherid[2 * (2 + !!CIPHER_ID2)]; /* actually variable */
+		uint8_t comprtypes_len;
+		uint8_t comprtypes[1]; /* actually variable */
+		/* Extensions (SNI shown):
+		 * hi,lo // len of all extensions
+		 *   00,00 // extension_type: "Server Name"
+		 *   00,0e // list len (there can be more than one SNI)
+		 *     00,0c // len of 1st Server Name Indication
+		 *       00    // name type: host_name
+		 *       00,09   // name len
+		 *       "localhost" // name
+		 */
+// GNU Wget 1.18 to cdn.kernel.org sends these extensions:
+// 0055
+//   0005 0005 0100000000 - status_request
+//   0000 0013 0011 00 000e 63646e 2e 6b65726e656c 2e 6f7267 - server_name
+//   ff01 0001 00 - renegotiation_info
+//   0023 0000 - session_ticket
+//   000a 0008 0006001700180019 - supported_groups
+//   000b 0002 0100 - ec_point_formats
+//   000d 0016 00140401040305010503060106030301030302010203 - signature_algorithms
+	};
+	struct client_hello *record;
+	int len;
+	int sni_len = sni ? strnlen(sni, 127) : 0;
+
+	len = sizeof(*record);
+	if (sni_len)
+		len += 11 + strlen(sni);
+	record = tls_get_outbuf(tls, len);
+	memset(record, 0, len);
+
+	fill_handshake_record_hdr(record, HANDSHAKE_CLIENT_HELLO, len);
+	record->proto_maj = TLS_MAJ;	/* the "requested" version of the protocol, */
+	record->proto_min = TLS_MIN;	/* can be higher than one in record headers */
+	tls_get_random(record->rand32, sizeof(record->rand32));
+	if (TLS_DEBUG_FIXED_SECRETS)
+		memset(record->rand32, 0x11, sizeof(record->rand32));
+	/* record->session_id_len = 0; - already is */
+
+	/* record->cipherid_len16_hi = 0; */
+	record->cipherid_len16_lo = sizeof(record->cipherid);
+	/* RFC 5746 Renegotiation Indication Extension - some servers will refuse to work with us otherwise */
+	/*record->cipherid[0] = TLS_EMPTY_RENEGOTIATION_INFO_SCSV >> 8; - zero */
+	record->cipherid[1] = TLS_EMPTY_RENEGOTIATION_INFO_SCSV & 0xff;
+	if ((CIPHER_ID1 >> 8) != 0) record->cipherid[2] = CIPHER_ID1 >> 8;
+	/*************************/ record->cipherid[3] = CIPHER_ID1 & 0xff;
+#if CIPHER_ID2
+	if ((CIPHER_ID2 >> 8) != 0) record->cipherid[4] = CIPHER_ID2 >> 8;
+	/*************************/ record->cipherid[5] = CIPHER_ID2 & 0xff;
+#endif
+
+	record->comprtypes_len = 1;
+	/* record->comprtypes[0] = 0; */
+
+	if (sni_len) {
+		uint8_t *p = (void*)(record + 1);
+		//p[0] = 0;         //
+		p[1] = sni_len + 9; //ext_len
+		//p[2] = 0;             //
+		//p[3] = 0;             //extension_type
+		//p[4] = 0;         //
+		p[5] = sni_len + 5; //list len
+		//p[6] = 0;             //
+		p[7] = sni_len + 3;     //len of 1st SNI
+		//p[8] = 0;         //name type
+		//p[9] = 0;             //
+		p[10] = sni_len;        //name len
+		memcpy(&p[11], sni, sni_len);
+	}
+
+	dbg(">> CLIENT_HELLO\n");
+	/* Can hash it only when we know which MAC hash to use */
+	/*xwrite_and_update_handshake_hash(tls, len); - WRONG! */
+	xwrite_handshake_record(tls, len);
+
+	tls->hsd = xzalloc(sizeof(*tls->hsd) + len);
+	tls->hsd->saved_client_hello_size = len;
+	memcpy(tls->hsd->saved_client_hello, record, len);
+	memcpy(tls->hsd->client_and_server_rand32, record->rand32, sizeof(record->rand32));
+}
+
+static void get_server_hello(tls_state_t *tls)
+{
+	struct server_hello {
+		struct record_hdr xhdr;
+		uint8_t type;
+		uint8_t len24_hi, len24_mid, len24_lo;
+		uint8_t proto_maj, proto_min;
+		uint8_t rand32[32]; /* first 4 bytes are unix time in BE format */
+		uint8_t session_id_len;
+		uint8_t session_id[32];
+		uint8_t cipherid_hi, cipherid_lo;
+		uint8_t comprtype;
+		/* extensions may follow, but only those which client offered in its Hello */
+	};
+
+	struct server_hello *hp;
+	uint8_t *cipherid;
+	unsigned cipher;
+	int len, len24;
+
+	len = tls_xread_handshake_block(tls, 74 - 32);
+
+	hp = (void*)tls->inbuf;
+	// 74 bytes:
+	// 02  000046 03|03   58|78|cf|c1 50|a5|49|ee|7e|29|48|71|fe|97|fa|e8|2d|19|87|72|90|84|9d|37|a3|f0|cb|6f|5f|e3|3c|2f |20  |d8|1a|78|96|52|d6|91|01|24|b3|d6|5b|b7|d0|6c|b3|e1|78|4e|3c|95|de|74|a0|ba|eb|a7|3a|ff|bd|a2|bf |00|9c |00|
+	//SvHl len=70 maj.min unixtime^^^ 28randbytes^^^^^^^^^^^^^^^^^^^^^^^^^^^^_^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^_^^^ slen sid32bytes^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ cipSel comprSel
+	if (hp->type != HANDSHAKE_SERVER_HELLO
+	 || hp->len24_hi  != 0
+	 || hp->len24_mid != 0
+	 /* hp->len24_lo checked later */
+	 || hp->proto_maj != TLS_MAJ
+	 || hp->proto_min != TLS_MIN
+	) {
+		bad_record_die(tls, "'server hello'", len);
+	}
+
+	cipherid = &hp->cipherid_hi;
+	len24 = hp->len24_lo;
+	if (hp->session_id_len != 32) {
+		if (hp->session_id_len != 0)
+			bad_record_die(tls, "'server hello'", len);
+
+		// session_id_len == 0: no session id
+		// "The server
+		// may return an empty session_id to indicate that the session will
+		// not be cached and therefore cannot be resumed."
+		cipherid -= 32;
+		len24 += 32; /* what len would be if session id would be present */
+	}
+
+	if (len24 < 70
+//	 || cipherid[0]  != (CIPHER_ID >> 8)
+//	 || cipherid[1]  != (CIPHER_ID & 0xff)
+//	 || cipherid[2]  != 0 /* comprtype */
+	) {
+		bad_record_die(tls, "'server hello'", len);
+	}
+	dbg("<< SERVER_HELLO\n");
+
+	memcpy(tls->hsd->client_and_server_rand32 + 32, hp->rand32, sizeof(hp->rand32));
+
+	tls->cipher_id = cipher = 0x100 * cipherid[0] + cipherid[1];
+	dbg("server chose cipher %04x\n", cipher);
+
+	if (cipher == TLS_RSA_WITH_AES_128_CBC_SHA) {
+		tls->key_size = AES128_KEYSIZE;
+		tls->MAC_size = SHA1_OUTSIZE;
+	}
+	else { /* TLS_RSA_WITH_AES_256_CBC_SHA256 */
+		tls->key_size = AES256_KEYSIZE;
+		tls->MAC_size = SHA256_OUTSIZE;
+	}
+	/* Handshake hash eventually destined to FINISHED record
+	 * is sha256 regardless of cipher
+	 * (at least for all ciphers defined by RFC5246).
+	 * It's not sha1 for AES_128_CBC_SHA - only MAC is sha1, not this hash.
+	 */
+	sha256_begin(&tls->hsd->handshake_hash_ctx);
+	hash_handshake(tls, ">> client hello hash:%s",
+		tls->hsd->saved_client_hello, tls->hsd->saved_client_hello_size
+	);
+	hash_handshake(tls, "<< server hello hash:%s",
+		tls->inbuf + RECHDR_LEN, len
+	);
+}
+
+static void get_server_cert(tls_state_t *tls)
+{
+	struct record_hdr *xhdr;
+	uint8_t *certbuf;
+	int len, len1;
+
+	len = tls_xread_handshake_block(tls, 10);
+
+	xhdr = (void*)tls->inbuf;
+	certbuf = (void*)(xhdr + 1);
+	if (certbuf[0] != HANDSHAKE_CERTIFICATE)
+		tls_error_die(tls);
+	dbg("<< CERTIFICATE\n");
+	// 4392 bytes:
+	// 0b  00|11|24 00|11|21 00|05|b0 30|82|05|ac|30|82|04|94|a0|03|02|01|02|02|11|00|9f|85|bf|66|4b|0c|dd|af|ca|50|86|79|50|1b|2b|e4|30|0d...
+	//Cert len=4388 ChainLen CertLen^ DER encoded X509 starts here. openssl x509 -in FILE -inform DER -noout -text
+	len1 = get24be(certbuf + 1);
+	if (len1 > len - 4) tls_error_die(tls);
+	len = len1;
+	len1 = get24be(certbuf + 4);
+	if (len1 > len - 3) tls_error_die(tls);
+	len = len1;
+	len1 = get24be(certbuf + 7);
+	if (len1 > len - 3) tls_error_die(tls);
+	len = len1;
+
+	if (len)
+		find_key_in_der_cert(tls, certbuf + 10, len);
+}
+
+static void send_empty_client_cert(tls_state_t *tls)
+{
+	struct client_empty_cert {
+		uint8_t type;
+		uint8_t len24_hi, len24_mid, len24_lo;
+		uint8_t cert_chain_len24_hi, cert_chain_len24_mid, cert_chain_len24_lo;
+	};
+	struct client_empty_cert *record;
+
+	record = tls_get_outbuf(tls, sizeof(*record));
+//FIXME: can just memcpy a ready-made one.
+	fill_handshake_record_hdr(record, HANDSHAKE_CERTIFICATE, sizeof(*record));
+	record->cert_chain_len24_hi = 0;
+	record->cert_chain_len24_mid = 0;
+	record->cert_chain_len24_lo = 0;
+
+	dbg(">> CERTIFICATE\n");
+	xwrite_and_update_handshake_hash(tls, sizeof(*record));
+}
+
+static void send_client_key_exchange(tls_state_t *tls)
+{
+	struct client_key_exchange {
+		uint8_t type;
+		uint8_t len24_hi, len24_mid, len24_lo;
+		/* keylen16 exists for RSA (in TLS, not in SSL), but not for some other key types */
+		uint8_t keylen16_hi, keylen16_lo;
+		uint8_t key[4 * 1024]; // size??
+	};
+//FIXME: better size estimate
+	struct client_key_exchange *record = tls_get_outbuf(tls, sizeof(*record));
+	uint8_t rsa_premaster[RSA_PREMASTER_SIZE];
+	int len;
+
+	tls_get_random(rsa_premaster, sizeof(rsa_premaster));
+	if (TLS_DEBUG_FIXED_SECRETS)
+		memset(rsa_premaster, 0x44, sizeof(rsa_premaster));
+	// RFC 5246
+	// "Note: The version number in the PreMasterSecret is the version
+	// offered by the client in the ClientHello.client_version, not the
+	// version negotiated for the connection."
+	rsa_premaster[0] = TLS_MAJ;
+	rsa_premaster[1] = TLS_MIN;
+	dump_hex("premaster:%s\n", rsa_premaster, sizeof(rsa_premaster));
+	len = psRsaEncryptPub(/*pool:*/ NULL,
+		/* psRsaKey_t* */ &tls->hsd->server_rsa_pub_key,
+		rsa_premaster, /*inlen:*/ sizeof(rsa_premaster),
+		record->key, sizeof(record->key),
+		data_param_ignored
+	);
+	record->keylen16_hi = len >> 8;
+	record->keylen16_lo = len & 0xff;
+	len += 2;
+	record->type = HANDSHAKE_CLIENT_KEY_EXCHANGE;
+	record->len24_hi  = 0;
+	record->len24_mid = len >> 8;
+	record->len24_lo  = len & 0xff;
+	len += 4;
+
+	dbg(">> CLIENT_KEY_EXCHANGE\n");
+	xwrite_and_update_handshake_hash(tls, len);
+
+	// RFC 5246
+	// For all key exchange methods, the same algorithm is used to convert
+	// the pre_master_secret into the master_secret.  The pre_master_secret
+	// should be deleted from memory once the master_secret has been
+	// computed.
+	//      master_secret = PRF(pre_master_secret, "master secret",
+	//                          ClientHello.random + ServerHello.random)
+	//                          [0..47];
+	// The master secret is always exactly 48 bytes in length.  The length
+	// of the premaster secret will vary depending on key exchange method.
+	prf_hmac_sha256(/*tls,*/
+		tls->hsd->master_secret, sizeof(tls->hsd->master_secret),
+		rsa_premaster, sizeof(rsa_premaster),
+		"master secret",
+		tls->hsd->client_and_server_rand32, sizeof(tls->hsd->client_and_server_rand32)
+	);
+	dump_hex("master secret:%s\n", tls->hsd->master_secret, sizeof(tls->hsd->master_secret));
+
+	// RFC 5246
+	// 6.3.  Key Calculation
+	//
+	// The Record Protocol requires an algorithm to generate keys required
+	// by the current connection state (see Appendix A.6) from the security
+	// parameters provided by the handshake protocol.
+	//
+	// The master secret is expanded into a sequence of secure bytes, which
+	// is then split to a client write MAC key, a server write MAC key, a
+	// client write encryption key, and a server write encryption key.  Each
+	// of these is generated from the byte sequence in that order.  Unused
+	// values are empty.  Some AEAD ciphers may additionally require a
+	// client write IV and a server write IV (see Section 6.2.3.3).
+	//
+	// When keys and MAC keys are generated, the master secret is used as an
+	// entropy source.
+	//
+	// To generate the key material, compute
+	//
+	//    key_block = PRF(SecurityParameters.master_secret,
+	//                    "key expansion",
+	//                    SecurityParameters.server_random +
+	//                    SecurityParameters.client_random);
+	//
+	// until enough output has been generated.  Then, the key_block is
+	// partitioned as follows:
+	//
+	//    client_write_MAC_key[SecurityParameters.mac_key_length]
+	//    server_write_MAC_key[SecurityParameters.mac_key_length]
+	//    client_write_key[SecurityParameters.enc_key_length]
+	//    server_write_key[SecurityParameters.enc_key_length]
+	//    client_write_IV[SecurityParameters.fixed_iv_length]
+	//    server_write_IV[SecurityParameters.fixed_iv_length]
+	{
+		uint8_t tmp64[64];
+
+		/* make "server_rand32 + client_rand32" */
+		memcpy(&tmp64[0] , &tls->hsd->client_and_server_rand32[32], 32);
+		memcpy(&tmp64[32], &tls->hsd->client_and_server_rand32[0] , 32);
+
+		prf_hmac_sha256(/*tls,*/
+			tls->client_write_MAC_key, 2 * (tls->MAC_size + tls->key_size),
+			// also fills:
+			// server_write_MAC_key[]
+			// client_write_key[]
+			// server_write_key[]
+			tls->hsd->master_secret, sizeof(tls->hsd->master_secret),
+			"key expansion",
+			tmp64, 64
+		);
+		tls->client_write_key = tls->client_write_MAC_key + (2 * tls->MAC_size);
+		tls->server_write_key = tls->client_write_key + tls->key_size;
+		dump_hex("client_write_MAC_key:%s\n",
+			tls->client_write_MAC_key, tls->MAC_size
+		);
+		dump_hex("client_write_key:%s\n",
+			tls->client_write_key, tls->key_size
+		);
+	}
+}
+
+static const uint8_t rec_CHANGE_CIPHER_SPEC[] = {
+	RECORD_TYPE_CHANGE_CIPHER_SPEC, TLS_MAJ, TLS_MIN, 00, 01,
+	01
+};
+
+static void send_change_cipher_spec(tls_state_t *tls)
+{
+	dbg(">> CHANGE_CIPHER_SPEC\n");
+	xwrite(tls->ofd, rec_CHANGE_CIPHER_SPEC, sizeof(rec_CHANGE_CIPHER_SPEC));
+}
+
+// 7.4.9.  Finished
+// A Finished message is always sent immediately after a change
+// cipher spec message to verify that the key exchange and
+// authentication processes were successful.  It is essential that a
+// change cipher spec message be received between the other handshake
+// messages and the Finished message.
+//...
+// The Finished message is the first one protected with the just
+// negotiated algorithms, keys, and secrets.  Recipients of Finished
+// messages MUST verify that the contents are correct.  Once a side
+// has sent its Finished message and received and validated the
+// Finished message from its peer, it may begin to send and receive
+// application data over the connection.
+//...
+// struct {
+//     opaque verify_data[verify_data_length];
+// } Finished;
+//
+// verify_data
+//    PRF(master_secret, finished_label, Hash(handshake_messages))
+//       [0..verify_data_length-1];
+//
+// finished_label
+//    For Finished messages sent by the client, the string
+//    "client finished".  For Finished messages sent by the server,
+//    the string "server finished".
+//
+// Hash denotes a Hash of the handshake messages.  For the PRF
+// defined in Section 5, the Hash MUST be the Hash used as the basis
+// for the PRF.  Any cipher suite which defines a different PRF MUST
+// also define the Hash to use in the Finished computation.
+//
+// In previous versions of TLS, the verify_data was always 12 octets
+// long.  In the current version of TLS, it depends on the cipher
+// suite.  Any cipher suite which does not explicitly specify
+// verify_data_length has a verify_data_length equal to 12.  This
+// includes all existing cipher suites.
+static void send_client_finished(tls_state_t *tls)
+{
+	struct finished {
+		uint8_t type;
+		uint8_t len24_hi, len24_mid, len24_lo;
+		uint8_t prf_result[12];
+	};
+	struct finished *record = tls_get_outbuf(tls, sizeof(*record));
+	uint8_t handshake_hash[TLS_MAX_MAC_SIZE];
+	unsigned len;
+
+	fill_handshake_record_hdr(record, HANDSHAKE_FINISHED, sizeof(*record));
+
+	len = get_handshake_hash(tls, handshake_hash);
+	prf_hmac_sha256(/*tls,*/
+		record->prf_result, sizeof(record->prf_result),
+		tls->hsd->master_secret, sizeof(tls->hsd->master_secret),
+		"client finished",
+		handshake_hash, len
+	);
+	dump_hex("from secret: %s\n", tls->hsd->master_secret, sizeof(tls->hsd->master_secret));
+	dump_hex("from labelSeed: %s", "client finished", sizeof("client finished")-1);
+	dump_hex("%s\n", handshake_hash, sizeof(handshake_hash));
+	dump_hex("=> digest: %s\n", record->prf_result, sizeof(record->prf_result));
+
+	dbg(">> FINISHED\n");
+	xwrite_encrypted(tls, sizeof(*record), RECORD_TYPE_HANDSHAKE);
+}
+
+void FAST_FUNC tls_handshake(tls_state_t *tls, const char *sni)
+{
+	// Client              RFC 5246                Server
+	// (*) - optional messages, not always sent
+	//
+	// ClientHello          ------->
+	//                                        ServerHello
+	//                                       Certificate*
+	//                                 ServerKeyExchange*
+	//                                CertificateRequest*
+	//                      <-------      ServerHelloDone
+	// Certificate*
+	// ClientKeyExchange
+	// CertificateVerify*
+	// [ChangeCipherSpec]
+	// Finished             ------->
+	//                                 [ChangeCipherSpec]
+	//                      <-------             Finished
+	// Application Data     <------>     Application Data
+	int len;
+
+	send_client_hello_and_alloc_hsd(tls, sni);
+	get_server_hello(tls);
+
+	// RFC 5246
+	// The server MUST send a Certificate message whenever the agreed-
+	// upon key exchange method uses certificates for authentication
+	// (this includes all key exchange methods defined in this document
+	// except DH_anon).  This message will always immediately follow the
+	// ServerHello message.
+	//
+	// IOW: in practice, Certificate *always* follows.
+	// (for example, kernel.org does not even accept DH_anon cipher id)
+	get_server_cert(tls);
+
+	len = tls_xread_handshake_block(tls, 4);
+	if (tls->inbuf[RECHDR_LEN] == HANDSHAKE_SERVER_KEY_EXCHANGE) {
+		// 459 bytes:
+		// 0c   00|01|c7 03|00|17|41|04|87|94|2e|2f|68|d0|c9|f4|97|a8|2d|ef|ed|67|ea|c6|f3|b3|56|47|5d|27|b6|bd|ee|70|25|30|5e|b0|8e|f6|21|5a...
+		//SvKey len=455^
+		// with TLS_ECDHE_RSA_WITH_AES_128_CBC_SHA: 461 bytes:
+		// 0c   00|01|c9 03|00|17|41|04|cd|9b|b4|29|1f|f6|b0|c2|84|82|7f|29|6a|47|4e|ec|87|0b|c1|9c|69|e1|f8|c6|d0|53|e9|27|90|a5|c8|02|15|75...
+		dbg("<< SERVER_KEY_EXCHANGE len:%u\n", len);
+//probably need to save it
+		len = tls_xread_handshake_block(tls, 4);
+	}
+
+	if (tls->inbuf[RECHDR_LEN] == HANDSHAKE_CERTIFICATE_REQUEST) {
+		dbg("<< CERTIFICATE_REQUEST\n");
+		// RFC 5246: "If no suitable certificate is available,
+		// the client MUST send a certificate message containing no
+		// certificates.  That is, the certificate_list structure has a
+		// length of zero. ...
+		// Client certificates are sent using the Certificate structure
+		// defined in Section 7.4.2."
+		// (i.e. the same format as server certs)
+		send_empty_client_cert(tls);
+		len = tls_xread_handshake_block(tls, 4);
+	}
+
+	if (tls->inbuf[RECHDR_LEN] != HANDSHAKE_SERVER_HELLO_DONE) {
+		bad_record_die(tls, "'server hello done'", len);
+	}
+	// 0e 000000 (len:0)
+	dbg("<< SERVER_HELLO_DONE\n");
+
+	send_client_key_exchange(tls);
+
+	send_change_cipher_spec(tls);
+	/* from now on we should send encrypted */
+	/* tls->write_seq64_be = 0; - already is */
+	tls->encrypt_on_write = 1;
+
+	send_client_finished(tls);
+
+	/* Get CHANGE_CIPHER_SPEC */
+	len = tls_xread_record(tls);
+	if (len != 1 || memcmp(tls->inbuf, rec_CHANGE_CIPHER_SPEC, 6) != 0)
+		bad_record_die(tls, "switch to encrypted traffic", len);
+	dbg("<< CHANGE_CIPHER_SPEC\n");
+	if (CIPHER_ID1 == TLS_RSA_WITH_NULL_SHA256
+	 && tls->cipher_id == TLS_RSA_WITH_NULL_SHA256
+	) {
+		tls->min_encrypted_len_on_read = tls->MAC_size;
+	} else {
+		unsigned mac_blocks = (unsigned)(tls->MAC_size + AES_BLOCKSIZE-1) / AES_BLOCKSIZE;
+		/* all incoming packets now should be encrypted and have
+		 * at least IV + (MAC padded to blocksize):
+		 */
+		tls->min_encrypted_len_on_read = AES_BLOCKSIZE + (mac_blocks * AES_BLOCKSIZE);
+		dbg("min_encrypted_len_on_read: %u", tls->min_encrypted_len_on_read);
+	}
+
+	/* Get (encrypted) FINISHED from the server */
+	len = tls_xread_record(tls);
+	if (len < 4 || tls->inbuf[RECHDR_LEN] != HANDSHAKE_FINISHED)
+		tls_error_die(tls);
+	dbg("<< FINISHED\n");
+	/* application data can be sent/received */
+
+	/* free handshake data */
+//	if (PARANOIA)
+//		memset(tls->hsd, 0, tls->hsd->hsd_size);
+	free(tls->hsd);
+	tls->hsd = NULL;
+}
+
+static void tls_xwrite(tls_state_t *tls, int len)
+{
+	dbg(">> DATA\n");
+	xwrite_encrypted(tls, len, RECORD_TYPE_APPLICATION_DATA);
+}
+
+// To run a test server using openssl:
+// openssl req -x509 -newkey rsa:$((4096/4*3)) -keyout key.pem -out server.pem -nodes -days 99999 -subj '/CN=localhost'
+// openssl s_server -key key.pem -cert server.pem -debug -tls1_2 -no_tls1 -no_tls1_1
+//
+// Unencryped SHA256 example:
+// openssl req -x509 -newkey rsa:$((4096/4*3)) -keyout key.pem -out server.pem -nodes -days 99999 -subj '/CN=localhost'
+// openssl s_server -key key.pem -cert server.pem -debug -tls1_2 -no_tls1 -no_tls1_1 -cipher NULL
+// openssl s_client -connect 127.0.0.1:4433 -debug -tls1_2 -no_tls1 -no_tls1_1 -cipher NULL-SHA256
+
+void FAST_FUNC tls_run_copy_loop(tls_state_t *tls)
+{
+	int inbuf_size;
+	const int INBUF_STEP = 4 * 1024;
+	struct pollfd pfds[2];
+
+	pfds[0].fd = STDIN_FILENO;
+	pfds[0].events = POLLIN;
+	pfds[1].fd = tls->ifd;
+	pfds[1].events = POLLIN;
+
+	inbuf_size = INBUF_STEP;
+	for (;;) {
+		int nread;
+
+		if (safe_poll(pfds, 2, -1) < 0)
+			bb_perror_msg_and_die("poll");
+
+		if (pfds[0].revents) {
+			void *buf;
+
+			dbg("STDIN HAS DATA\n");
+			buf = tls_get_outbuf(tls, inbuf_size);
+			nread = safe_read(STDIN_FILENO, buf, inbuf_size);
+			if (nread < 1) {
+				/* We'd want to do this: */
+				/* Close outgoing half-connection so they get EOF,
+				 * but leave incoming alone so we can see response
+				 */
+				//shutdown(tls->ofd, SHUT_WR);
+				/* But TLS has no way to encode this,
+				 * doubt it's ok to do it "raw"
+				 */
+				pfds[0].fd = -1;
+				tls_free_outbuf(tls); /* mem usage optimization */
+			} else {
+				if (nread == inbuf_size) {
+					/* TLS has per record overhead, if input comes fast,
+					 * read, encrypt and send bigger chunks
+					 */
+					inbuf_size += INBUF_STEP;
+					if (inbuf_size > TLS_MAX_OUTBUF)
+						inbuf_size = TLS_MAX_OUTBUF;
+				}
+				tls_xwrite(tls, nread);
+			}
+		}
+		if (pfds[1].revents) {
+			dbg("NETWORK HAS DATA\n");
+ read_record:
+			nread = tls_xread_record(tls);
+			if (nread < 1) {
+				/* TLS protocol has no real concept of one-sided shutdowns:
+				 * if we get "TLS EOF" from the peer, writes will fail too
+				 */
+				//pfds[1].fd = -1;
+				//close(STDOUT_FILENO);
+				//tls_free_inbuf(tls); /* mem usage optimization */
+				//continue;
+				break;
+			}
+			if (tls->inbuf[0] != RECORD_TYPE_APPLICATION_DATA)
+				bb_error_msg_and_die("unexpected record type %d", tls->inbuf[0]);
+			xwrite(STDOUT_FILENO, tls->inbuf + RECHDR_LEN, nread);
+			/* We may already have a complete next record buffered,
+			 * can process it without network reads (and possible blocking)
+			 */
+			if (tls_has_buffered_record(tls))
+				goto read_record;
+		}
+	}
+}
diff -urpN busybox-1.26.2/networking/tls.h busybox-1.27.0/networking/tls.h
--- busybox-1.26.2/networking/tls.h	1970-01-01 01:00:00.000000000 +0100
+++ busybox-1.27.0/networking/tls.h	2017-01-23 01:09:41.000000000 +0100
@@ -0,0 +1,99 @@
+/*
+ * Copyright (C) 2017 Denys Vlasenko
+ *
+ * Licensed under GPLv2, see file LICENSE in this source tree.
+ */
+/* Interface glue between bbox code and minimally tweaked matrixssl
+ * code. All C files (matrixssl and bbox (ones which need TLS))
+ * include this file, and guaranteed to see a consistent API,
+ * defines, types, etc.
+ */
+#include "libbb.h"
+
+
+/* Config tweaks */
+#define HAVE_NATIVE_INT64
+#undef  USE_1024_KEY_SPEED_OPTIMIZATIONS
+#undef  USE_2048_KEY_SPEED_OPTIMIZATIONS
+#define USE_AES
+#undef  USE_AES_CBC_EXTERNAL
+#undef  USE_AES_CCM
+#undef  USE_AES_GCM
+#undef  USE_3DES
+#undef  USE_ARC4
+#undef  USE_IDEA
+#undef  USE_RC2
+#undef  USE_SEED
+/* pstm: multiprecision numbers */
+#undef  DISABLE_PSTM
+#if defined(__GNUC__) && defined(__i386__)
+  /* PSTM_X86 works correctly. +25 bytes. */
+# define PSTM_32BIT
+# define PSTM_X86
+#endif
+//#if defined(__GNUC__) && defined(__x86_64__)
+//  /* PSTM_X86_64 works correctly, but +782 bytes. */
+//  /* Looks like most of the growth is because of PSTM_64BIT. */
+//# define PSTM_64BIT
+//# define PSTM_X86_64
+//#endif
+//#if SOME_COND #define PSTM_MIPS, #define PSTM_32BIT
+//#if SOME_COND #define PSTM_ARM,  #define PSTM_32BIT
+
+
+#define PS_SUCCESS              0
+#define PS_FAILURE              -1
+#define PS_ARG_FAIL             -6      /* Failure due to bad function param */
+#define PS_PLATFORM_FAIL        -7      /* Failure as a result of system call error */
+#define PS_MEM_FAIL             -8      /* Failure to allocate requested memory */
+#define PS_LIMIT_FAIL           -9      /* Failure on sanity/limit tests */
+
+#define PS_TRUE         1
+#define PS_FALSE        0
+
+#if BB_BIG_ENDIAN
+# define ENDIAN_BIG     1
+# undef  ENDIAN_LITTLE
+//#????  ENDIAN_32BITWORD
+// controls only STORE32L, which we don't use
+#else
+# define ENDIAN_LITTLE  1
+# undef  ENDIAN_BIG
+#endif
+
+typedef uint64_t uint64;
+typedef  int64_t  int64;
+typedef uint32_t uint32;
+typedef  int32_t  int32;
+typedef uint16_t uint16;
+typedef  int16_t  int16;
+
+//typedef char psPool_t;
+
+//#ifdef PS_PUBKEY_OPTIMIZE_FOR_SMALLER_RAM
+#define PS_EXPTMOD_WINSIZE   3
+//#ifdef PS_PUBKEY_OPTIMIZE_FOR_FASTER_SPEED
+//#define PS_EXPTMOD_WINSIZE 5
+
+#define PUBKEY_TYPE     0x01
+#define PRIVKEY_TYPE    0x02
+
+void tls_get_random(void *buf, unsigned len);
+
+#define matrixCryptoGetPrngData(buf, len, userPtr) (tls_get_random(buf, len), PS_SUCCESS)
+
+#define psFree(p, pool)    free(p)
+#define psTraceCrypto(...) bb_error_msg_and_die(__VA_ARGS__)
+
+/* Secure zerofill */
+#define memset_s(A,B,C,D) memset((A),(C),(D))
+/* Constant time memory comparison */
+#define memcmpct(s1, s2, len) memcmp((s1), (s2), (len))
+#undef  min
+#define min(x, y) ((x) < (y) ? (x) : (y))
+
+
+#include "tls_pstm.h"
+#include "tls_rsa.h"
+#include "tls_symmetric.h"
+#include "tls_aes.h"
diff -urpN busybox-1.26.2/networking/tls_aes.c busybox-1.27.0/networking/tls_aes.c
--- busybox-1.26.2/networking/tls_aes.c	1970-01-01 01:00:00.000000000 +0100
+++ busybox-1.27.0/networking/tls_aes.c	2017-04-05 18:27:36.000000000 +0200
@@ -0,0 +1,460 @@
+/*
+ * Copyright (C) 2017 Denys Vlasenko
+ *
+ * Licensed under GPLv2, see file LICENSE in this source tree.
+ */
+
+/* This AES implementation is derived from tiny-AES128-C code,
+ * which was put by its author into public domain:
+ *
+ * tiny-AES128-C/unlicense.txt, Dec 8, 2014
+ * """
+ * This is free and unencumbered software released into the public domain.
+ *
+ * Anyone is free to copy, modify, publish, use, compile, sell, or
+ * distribute this software, either in source code form or as a compiled
+ * binary, for any purpose, commercial or non-commercial, and by any
+ * means.
+ *
+ * In jurisdictions that recognize copyright laws, the author or authors
+ * of this software dedicate any and all copyright interest in the
+ * software to the public domain. We make this dedication for the benefit
+ * of the public at large and to the detriment of our heirs and
+ * successors. We intend this dedication to be an overt act of
+ * relinquishment in perpetuity of all present and future rights to this
+ * software under copyright law.
+ *
+ * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
+ * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
+ * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.
+ * IN NO EVENT SHALL THE AUTHORS BE LIABLE FOR ANY CLAIM, DAMAGES OR
+ * OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE,
+ * ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR
+ * OTHER DEALINGS IN THE SOFTWARE.
+ * """
+ */
+/* Note that only original tiny-AES128-C code is public domain.
+ * The derived code in this file has been expanded to also implement aes192
+ * and aes256 and use more efficient word-sized operations in many places,
+ * and put under GPLv2 license.
+ */
+#include "tls.h"
+
+/* TODO: grep for this and move to libbb */
+#define get_unaligned_be32(buf) ({ uint32_t v; move_from_unaligned32(v, buf); SWAP_BE32(v); })
+
+
+// The lookup-tables are marked const so they can be placed in read-only storage instead of RAM
+// The numbers below can be computed dynamically trading ROM for RAM -
+// This can be useful in (embedded) bootloader applications, where ROM is often limited.
+static const uint8_t sbox[] = {
+	0x63, 0x7c, 0x77, 0x7b, 0xf2, 0x6b, 0x6f, 0xc5,
+	0x30, 0x01, 0x67, 0x2b, 0xfe, 0xd7, 0xab, 0x76,
+	0xca, 0x82, 0xc9, 0x7d, 0xfa, 0x59, 0x47, 0xf0,
+	0xad, 0xd4, 0xa2, 0xaf, 0x9c, 0xa4, 0x72, 0xc0,
+	0xb7, 0xfd, 0x93, 0x26,	0x36, 0x3f, 0xf7, 0xcc,
+	0x34, 0xa5, 0xe5, 0xf1, 0x71, 0xd8, 0x31, 0x15,
+	0x04, 0xc7, 0x23, 0xc3, 0x18, 0x96, 0x05, 0x9a,
+	0x07, 0x12, 0x80, 0xe2,	0xeb, 0x27, 0xb2, 0x75,
+	0x09, 0x83, 0x2c, 0x1a, 0x1b, 0x6e, 0x5a, 0xa0,
+	0x52, 0x3b, 0xd6, 0xb3, 0x29, 0xe3, 0x2f, 0x84,
+	0x53, 0xd1, 0x00, 0xed,	0x20, 0xfc, 0xb1, 0x5b,
+	0x6a, 0xcb, 0xbe, 0x39, 0x4a, 0x4c, 0x58, 0xcf,
+	0xd0, 0xef, 0xaa, 0xfb, 0x43, 0x4d, 0x33, 0x85,
+	0x45, 0xf9, 0x02, 0x7f,	0x50, 0x3c, 0x9f, 0xa8,
+	0x51, 0xa3, 0x40, 0x8f, 0x92, 0x9d, 0x38, 0xf5,
+	0xbc, 0xb6, 0xda, 0x21, 0x10, 0xff, 0xf3, 0xd2,
+	0xcd, 0x0c, 0x13, 0xec,	0x5f, 0x97, 0x44, 0x17,
+	0xc4, 0xa7, 0x7e, 0x3d, 0x64, 0x5d, 0x19, 0x73,
+	0x60, 0x81, 0x4f, 0xdc, 0x22, 0x2a, 0x90, 0x88,
+	0x46, 0xee, 0xb8, 0x14,	0xde, 0x5e, 0x0b, 0xdb,
+	0xe0, 0x32, 0x3a, 0x0a, 0x49, 0x06, 0x24, 0x5c,
+	0xc2, 0xd3, 0xac, 0x62, 0x91, 0x95, 0xe4, 0x79,
+	0xe7, 0xc8, 0x37, 0x6d,	0x8d, 0xd5, 0x4e, 0xa9,
+	0x6c, 0x56, 0xf4, 0xea, 0x65, 0x7a, 0xae, 0x08,
+	0xba, 0x78, 0x25, 0x2e, 0x1c, 0xa6, 0xb4, 0xc6,
+	0xe8, 0xdd, 0x74, 0x1f,	0x4b, 0xbd, 0x8b, 0x8a,
+	0x70, 0x3e, 0xb5, 0x66, 0x48, 0x03, 0xf6, 0x0e,
+	0x61, 0x35, 0x57, 0xb9, 0x86, 0xc1, 0x1d, 0x9e,
+	0xe1, 0xf8, 0x98, 0x11,	0x69, 0xd9, 0x8e, 0x94,
+	0x9b, 0x1e, 0x87, 0xe9, 0xce, 0x55, 0x28, 0xdf,
+	0x8c, 0xa1, 0x89, 0x0d, 0xbf, 0xe6, 0x42, 0x68,
+	0x41, 0x99, 0x2d, 0x0f, 0xb0, 0x54, 0xbb, 0x16,
+};
+
+static const uint8_t rsbox[] = {
+	0x52, 0x09, 0x6a, 0xd5, 0x30, 0x36, 0xa5, 0x38,
+	0xbf, 0x40, 0xa3, 0x9e,	0x81, 0xf3, 0xd7, 0xfb,
+	0x7c, 0xe3, 0x39, 0x82,	0x9b, 0x2f, 0xff, 0x87,
+	0x34, 0x8e, 0x43, 0x44, 0xc4, 0xde, 0xe9, 0xcb,
+	0x54, 0x7b, 0x94, 0x32, 0xa6, 0xc2, 0x23, 0x3d,
+	0xee, 0x4c, 0x95, 0x0b,	0x42, 0xfa, 0xc3, 0x4e,
+	0x08, 0x2e, 0xa1, 0x66,	0x28, 0xd9, 0x24, 0xb2,
+	0x76, 0x5b, 0xa2, 0x49,	0x6d, 0x8b, 0xd1, 0x25,
+	0x72, 0xf8, 0xf6, 0x64, 0x86, 0x68, 0x98, 0x16,
+	0xd4, 0xa4, 0x5c, 0xcc, 0x5d, 0x65, 0xb6, 0x92,
+	0x6c, 0x70, 0x48, 0x50,	0xfd, 0xed, 0xb9, 0xda,
+	0x5e, 0x15, 0x46, 0x57, 0xa7, 0x8d, 0x9d, 0x84,
+	0x90, 0xd8, 0xab, 0x00, 0x8c, 0xbc, 0xd3, 0x0a,
+	0xf7, 0xe4, 0x58, 0x05, 0xb8, 0xb3, 0x45, 0x06,
+	0xd0, 0x2c, 0x1e, 0x8f, 0xca, 0x3f, 0x0f, 0x02,
+	0xc1, 0xaf, 0xbd, 0x03, 0x01, 0x13, 0x8a, 0x6b,
+	0x3a, 0x91, 0x11, 0x41,	0x4f, 0x67, 0xdc, 0xea,
+	0x97, 0xf2, 0xcf, 0xce, 0xf0, 0xb4, 0xe6, 0x73,
+	0x96, 0xac, 0x74, 0x22, 0xe7, 0xad, 0x35, 0x85,
+	0xe2, 0xf9, 0x37, 0xe8,	0x1c, 0x75, 0xdf, 0x6e,
+	0x47, 0xf1, 0x1a, 0x71, 0x1d, 0x29, 0xc5, 0x89,
+	0x6f, 0xb7, 0x62, 0x0e, 0xaa, 0x18, 0xbe, 0x1b,
+	0xfc, 0x56, 0x3e, 0x4b,	0xc6, 0xd2, 0x79, 0x20,
+	0x9a, 0xdb, 0xc0, 0xfe, 0x78, 0xcd, 0x5a, 0xf4,
+	0x1f, 0xdd, 0xa8, 0x33, 0x88, 0x07, 0xc7, 0x31,
+	0xb1, 0x12, 0x10, 0x59,	0x27, 0x80, 0xec, 0x5f,
+	0x60, 0x51, 0x7f, 0xa9, 0x19, 0xb5, 0x4a, 0x0d,
+	0x2d, 0xe5, 0x7a, 0x9f, 0x93, 0xc9, 0x9c, 0xef,
+	0xa0, 0xe0, 0x3b, 0x4d,	0xae, 0x2a, 0xf5, 0xb0,
+	0xc8, 0xeb, 0xbb, 0x3c,	0x83, 0x53, 0x99, 0x61,
+	0x17, 0x2b, 0x04, 0x7e,	0xba, 0x77, 0xd6, 0x26,
+	0xe1, 0x69, 0x14, 0x63,	0x55, 0x21, 0x0c, 0x7d,
+};
+
+// SubWord() is a function that takes a four-byte input word and
+// applies the S-box to each of the four bytes to produce an output word.
+static uint32_t Subword(uint32_t x)
+{
+	return (sbox[(x >> 24)      ] << 24)
+	|      (sbox[(x >> 16) & 255] << 16)
+	|      (sbox[(x >> 8 ) & 255] << 8 )
+	|      (sbox[(x      ) & 255]      );
+}
+
+// This function produces Nb(Nr+1) round keys.
+// The round keys are used in each round to decrypt the states.
+static int KeyExpansion(uint32_t *RoundKey, const void *key, unsigned key_len)
+{
+	// The round constant word array, Rcon[i], contains the values given by
+	// x to th e power (i-1) being powers of x (x is denoted as {02}) in the field GF(2^8).
+	// Note that i starts at 2, not 0.
+	static const uint8_t Rcon[] = {
+		0x01, 0x02, 0x04, 0x08, 0x10, 0x20, 0x40, 0x80, 0x1b, 0x36
+	//..... 0x6c, 0xd8, 0xab, 0x4d, 0x9a, 0x2f, 0x5e, 0xbc, 0x63, 0xc6,...
+	// but aes256 only uses values up to 0x36
+	};
+	int rounds, words_key, words_RoundKey;
+	int i, j, k;
+
+	// key_len 16: aes128, rounds 10, words_key 4, words_RoundKey 44
+	// key_len 24: aes192, rounds 12, words_key 6, words_RoundKey 52
+	// key_len 32: aes256, rounds 14, words_key 8, words_RoundKey 60
+	words_key = key_len / 4;
+	rounds = 6 + (key_len / 4);
+	words_RoundKey = 28 + key_len;
+
+	// The first round key is the key itself.
+	for (i = 0; i < words_key; i++)
+		RoundKey[i] = get_unaligned_be32((uint32_t*)key + i);
+	// i == words_key now
+
+	// All other round keys are found from the previous round keys.
+	j = k = 0;
+	for (; i < words_RoundKey; i++) {
+		uint32_t tempa;
+
+		tempa = RoundKey[i - 1];
+		if (j == 0) {
+			// RotWord(): rotates the 4 bytes in a word to the left once.
+			tempa = (tempa << 8) | (tempa >> 24);
+			tempa = Subword(tempa);
+			tempa ^= (uint32_t)Rcon[k] << 24;
+		} else if (words_key > 6 && j == 4) {
+			tempa = Subword(tempa);
+		}
+		RoundKey[i] = RoundKey[i - words_key] ^ tempa;
+		j++;
+		if (j == words_key) {
+			j = 0;
+			k++;
+		}
+	}
+	return rounds;
+}
+
+// This function adds the round key to state.
+// The round key is added to the state by an XOR function.
+static void AddRoundKey(unsigned astate[16], const uint32_t *RoundKeys)
+{
+	int i;
+
+	for (i = 0; i < 16; i += 4) {
+		uint32_t n = *RoundKeys++;
+		astate[i + 0] ^= (n >> 24);
+		astate[i + 1] ^= (n >> 16) & 255;
+		astate[i + 2] ^= (n >> 8) & 255;
+		astate[i + 3] ^= n & 255;
+	}
+}
+
+// The SubBytes Function Substitutes the values in the
+// state matrix with values in an S-box.
+static void SubBytes(unsigned astate[16])
+{
+	int i;
+
+	for (i = 0; i < 16; i++)
+		astate[i] = sbox[astate[i]];
+}
+
+// Our code actually stores "columns" (in aes encryption terminology)
+// of state in rows: first 4 elements are "row 0, col 0", "row 1, col 0".
+// "row 2, col 0", "row 3, col 0". The fifth element is "row 0, col 1",
+// and so on.
+#define ASTATE(col,row) astate[(col)*4 + (row)]
+
+// The ShiftRows() function shifts the rows in the state to the left.
+// Each row is shifted with different offset.
+// Offset = Row number. So the first row is not shifted.
+static void ShiftRows(unsigned astate[16])
+{
+	unsigned v;
+
+	// Rotate first row 1 columns to left
+	v = ASTATE(0,1);
+	ASTATE(0,1) = ASTATE(1,1);
+	ASTATE(1,1) = ASTATE(2,1);
+	ASTATE(2,1) = ASTATE(3,1);
+	ASTATE(3,1) = v;
+
+	// Rotate second row 2 columns to left
+	v = ASTATE(0,2); ASTATE(0,2) = ASTATE(2,2); ASTATE(2,2) = v;
+	v = ASTATE(1,2); ASTATE(1,2) = ASTATE(3,2); ASTATE(3,2) = v;
+
+	// Rotate third row 3 columns to left
+	v = ASTATE(3,3);
+	ASTATE(3,3) = ASTATE(2,3);
+	ASTATE(2,3) = ASTATE(1,3);
+	ASTATE(1,3) = ASTATE(0,3);
+	ASTATE(0,3) = v;
+}
+
+// MixColumns function mixes the columns of the state matrix
+static void MixColumns(unsigned astate[16])
+{
+	int i;
+
+	for (i = 0; i < 16; i += 4) {
+		unsigned a, b, c, d;
+		unsigned x, y, z, t;
+
+		a = astate[i + 0];
+		b = astate[i + 1];
+		c = astate[i + 2];
+		d = astate[i + 3];
+		x = (a << 1) ^ b ^ (b << 1) ^ c ^ d;
+		y = a ^ (b << 1) ^ c ^ (c << 1) ^ d;
+		z = a ^ b ^ (c << 1) ^ d ^ (d << 1);
+		t = a ^ (a << 1) ^ b ^ c ^ (d << 1);
+		astate[i + 0] = x ^ ((-(int)(x >> 8)) & 0x11b);
+		astate[i + 1] = y ^ ((-(int)(y >> 8)) & 0x11b);
+		astate[i + 2] = z ^ ((-(int)(z >> 8)) & 0x11b);
+		astate[i + 3] = t ^ ((-(int)(t >> 8)) & 0x11b);
+	}
+}
+
+// The SubBytes Function Substitutes the values in the
+// state matrix with values in an S-box.
+static void InvSubBytes(unsigned astate[16])
+{
+	int i;
+
+	for (i = 0; i < 16; i++)
+		astate[i] = rsbox[astate[i]];
+}
+
+static void InvShiftRows(unsigned astate[16])
+{
+	unsigned v;
+
+	// Rotate first row 1 columns to right
+	v = ASTATE(3,1);
+	ASTATE(3,1) = ASTATE(2,1);
+	ASTATE(2,1) = ASTATE(1,1);
+	ASTATE(1,1) = ASTATE(0,1);
+	ASTATE(0,1) = v;
+
+	// Rotate second row 2 columns to right
+	v = ASTATE(0,2); ASTATE(0,2) = ASTATE(2,2); ASTATE(2,2) = v;
+	v = ASTATE(1,2); ASTATE(1,2) = ASTATE(3,2); ASTATE(3,2) = v;
+
+	// Rotate third row 3 columns to right
+	v = ASTATE(0,3);
+	ASTATE(0,3) = ASTATE(1,3);
+	ASTATE(1,3) = ASTATE(2,3);
+	ASTATE(2,3) = ASTATE(3,3);
+	ASTATE(3,3) = v;
+}
+
+static ALWAYS_INLINE unsigned Multiply(unsigned x)
+{
+	unsigned y;
+
+	y = x >> 8;
+	return (x ^ y ^ (y << 1) ^ (y << 3) ^ (y << 4)) & 255;
+}
+
+// MixColumns function mixes the columns of the state matrix.
+// The method used to multiply may be difficult to understand for the inexperienced.
+// Please use the references to gain more information.
+static void InvMixColumns(unsigned astate[16])
+{
+	int i;
+
+	for (i = 0; i < 16; i += 4) {
+		unsigned a, b, c, d;
+		unsigned x, y, z, t;
+
+		a = astate[i + 0];
+		b = astate[i + 1];
+		c = astate[i + 2];
+		d = astate[i + 3];
+		x = (a << 1) ^ (a << 2) ^ (a << 3) ^ b ^ (b << 1) ^ (b << 3)
+		/***/ ^ c ^ (c << 2) ^ (c << 3) ^ d ^ (d << 3);
+		y = a ^ (a << 3) ^ (b << 1) ^ (b << 2) ^ (b << 3)
+		/***/ ^ c ^ (c << 1) ^ (c << 3) ^ d ^ (d << 2) ^ (d << 3);
+		z = a ^ (a << 2) ^ (a << 3) ^ b ^ (b << 3)
+		/***/ ^ (c << 1) ^ (c << 2) ^ (c << 3) ^ d ^ (d << 1) ^ (d << 3);
+		t = a ^ (a << 1) ^ (a << 3) ^ b ^ (b << 2) ^ (b << 3)
+		/***/ ^ c ^ (c << 3) ^ (d << 1) ^ (d << 2) ^ (d << 3);
+		astate[i + 0] = Multiply(x);
+		astate[i + 1] = Multiply(y);
+		astate[i + 2] = Multiply(z);
+		astate[i + 3] = Multiply(t);
+	}
+}
+
+static void aes_encrypt_1(unsigned astate[16], unsigned rounds, const uint32_t *RoundKey)
+{
+	for (;;) {
+		AddRoundKey(astate, RoundKey);
+		RoundKey += 4;
+		SubBytes(astate);
+		ShiftRows(astate);
+		if (--rounds == 0)
+			break;
+		MixColumns(astate);
+	}
+	AddRoundKey(astate, RoundKey);
+}
+
+#if 0 // UNUSED
+static void aes_encrypt_one_block(unsigned rounds, const uint32_t *RoundKey, const void *data, void *dst)
+{
+	unsigned astate[16];
+	unsigned i;
+
+	const uint8_t *pt = data;
+	uint8_t *ct = dst;
+
+	for (i = 0; i < 16; i++)
+		astate[i] = pt[i];
+	aes_encrypt_1(astate, rounds, RoundKey);
+	for (i = 0; i < 16; i++)
+		ct[i] = astate[i];
+}
+#endif
+
+void aes_cbc_encrypt(const void *key, int klen, void *iv, const void *data, size_t len, void *dst)
+{
+	uint32_t RoundKey[60];
+	uint8_t iv2[16];
+	unsigned rounds;
+
+	const uint8_t *pt = data;
+	uint8_t *ct = dst;
+
+	memcpy(iv2, iv, 16);
+	rounds = KeyExpansion(RoundKey, key, klen);
+	while (len > 0) {
+		{
+			/* almost aes_encrypt_one_block(rounds, RoundKey, pt, ct);
+			 * but xor'ing of IV with plaintext[] is combined
+			 * with plaintext[] -> astate[]
+			 */
+			int i;
+			unsigned astate[16];
+			for (i = 0; i < 16; i++)
+				astate[i] = pt[i] ^ iv2[i];
+			aes_encrypt_1(astate, rounds, RoundKey);
+			for (i = 0; i < 16; i++)
+				iv2[i] = ct[i] = astate[i];
+		}
+		ct += 16;
+		pt += 16;
+		len -= 16;
+	}
+}
+
+static void aes_decrypt_1(unsigned astate[16], unsigned rounds, const uint32_t *RoundKey)
+{
+	RoundKey += rounds * 4;
+	AddRoundKey(astate, RoundKey);
+	for (;;) {
+		InvShiftRows(astate);
+		InvSubBytes(astate);
+		RoundKey -= 4;
+		AddRoundKey(astate, RoundKey);
+		if (--rounds == 0)
+			break;
+		InvMixColumns(astate);
+	}
+}
+
+#if 0 //UNUSED
+static void aes_decrypt_one_block(unsigned rounds, const uint32_t *RoundKey, const void *data, void *dst)
+{
+	unsigned astate[16];
+	unsigned i;
+
+	const uint8_t *ct = data;
+	uint8_t *pt = dst;
+
+	for (i = 0; i < 16; i++)
+		astate[i] = ct[i];
+	aes_decrypt_1(astate, rounds, RoundKey);
+	for (i = 0; i < 16; i++)
+		pt[i] = astate[i];
+}
+#endif
+
+void aes_cbc_decrypt(const void *key, int klen, void *iv, const void *data, size_t len, void *dst)
+{
+	uint32_t RoundKey[60];
+	uint8_t iv2[16];
+	uint8_t iv3[16];
+	unsigned rounds;
+	uint8_t *ivbuf;
+	uint8_t *ivnext;
+
+	const uint8_t *ct = data;
+	uint8_t *pt = dst;
+
+	rounds = KeyExpansion(RoundKey, key, klen);
+	ivbuf = memcpy(iv2, iv, 16);
+	while (len) {
+		ivnext = (ivbuf==iv2) ? iv3 : iv2;
+		{
+			/* almost aes_decrypt_one_block(rounds, RoundKey, ct, pt)
+			 * but xor'ing of ivbuf is combined with astate[] -> plaintext[]
+			 */
+			int i;
+			unsigned astate[16];
+			for (i = 0; i < 16; i++)
+				ivnext[i] = astate[i] = ct[i];
+			aes_decrypt_1(astate, rounds, RoundKey);
+			for (i = 0; i < 16; i++)
+				pt[i] = astate[i] ^ ivbuf[i];
+		}
+		ivbuf = ivnext;
+		ct += 16;
+		pt += 16;
+		len -= 16;
+	}
+}
diff -urpN busybox-1.26.2/networking/tls_aes.h busybox-1.27.0/networking/tls_aes.h
--- busybox-1.26.2/networking/tls_aes.h	1970-01-01 01:00:00.000000000 +0100
+++ busybox-1.27.0/networking/tls_aes.h	2017-02-04 20:10:03.000000000 +0100
@@ -0,0 +1,10 @@
+/*
+ * Copyright (C) 2017 Denys Vlasenko
+ *
+ * Licensed under GPLv2, see file LICENSE in this source tree.
+ *
+ * Selected few declarations for AES.
+ */
+
+void aes_cbc_encrypt(const void *key, int klen, void *iv, const void *data, size_t len, void *dst);
+void aes_cbc_decrypt(const void *key, int klen, void *iv, const void *data, size_t len, void *dst);
diff -urpN busybox-1.26.2/networking/tls_pstm.c busybox-1.27.0/networking/tls_pstm.c
--- busybox-1.26.2/networking/tls_pstm.c	1970-01-01 01:00:00.000000000 +0100
+++ busybox-1.27.0/networking/tls_pstm.c	2017-04-05 18:27:36.000000000 +0200
@@ -0,0 +1,2263 @@
+/*
+ * Copyright (C) 2017 Denys Vlasenko
+ *
+ * Licensed under GPLv2, see file LICENSE in this source tree.
+ */
+#include "tls.h"
+
+/* The file is taken almost verbatim from matrixssl-3-7-2b-open/crypto/math/.
+ * Changes are flagged with //bbox
+ */
+
+/**
+ *	@file    pstm.c
+ *	@version 33ef80f (HEAD, tag: MATRIXSSL-3-7-2-OPEN, tag: MATRIXSSL-3-7-2-COMM, origin/master, origin/HEAD, master)
+ *
+ *	Multiprecision number implementation.
+ */
+/*
+ *	Copyright (c) 2013-2015 INSIDE Secure Corporation
+ *	Copyright (c) PeerSec Networks, 2002-2011
+ *	All Rights Reserved
+ *
+ *	The latest version of this code is available at http://www.matrixssl.org
+ *
+ *	This software is open source; you can redistribute it and/or modify
+ *	it under the terms of the GNU General Public License as published by
+ *	the Free Software Foundation; either version 2 of the License, or
+ *	(at your option) any later version.
+ *
+ *	This General Public License does NOT permit incorporating this software
+ *	into proprietary programs.  If you are unable to comply with the GPL, a
+ *	commercial license for this software may be purchased from INSIDE at
+ *	http://www.insidesecure.com/eng/Company/Locations
+ *
+ *	This program is distributed in WITHOUT ANY WARRANTY; without even the
+ *	implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
+ *	See the GNU General Public License for more details.
+ *
+ *	You should have received a copy of the GNU General Public License
+ *	along with this program; if not, write to the Free Software
+ *	Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+ *	http://www.gnu.org/copyleft/gpl.html
+ */
+/******************************************************************************/
+
+//bbox
+//#include "../cryptoApi.h"
+#ifndef DISABLE_PSTM
+
+static int32 pstm_mul_2d(pstm_int *a, int b, pstm_int *c); //bbox: was int16 b
+
+/******************************************************************************/
+/*
+	init an pstm_int for a given size
+ */
+int32 pstm_init_size(psPool_t *pool, pstm_int * a, uint32 size)
+{
+//bbox
+//	uint16		x;
+
+/*
+	alloc mem
+ */
+	a->dp = xzalloc(sizeof (pstm_digit) * size);//bbox
+//bbox	a->pool = pool;
+	a->used  = 0;
+	a->alloc = size;
+	a->sign  = PSTM_ZPOS;
+/*
+	zero the digits
+ */
+//bbox
+//	for (x = 0; x < size; x++) {
+//		a->dp[x] = 0;
+//	}
+	return PSTM_OKAY;
+}
+
+/******************************************************************************/
+/*
+	Init a new pstm_int.
+*/
+int32 pstm_init(psPool_t *pool, pstm_int * a)
+{
+//bbox
+//	int32		i;
+/*
+	allocate memory required and clear it
+ */
+	a->dp = xzalloc(sizeof (pstm_digit) * PSTM_DEFAULT_INIT);//bbox
+/*
+	set the digits to zero
+ */
+//bbox
+//	for (i = 0; i < PSTM_DEFAULT_INIT; i++) {
+//		a->dp[i] = 0;
+//	}
+/*
+	set the used to zero, allocated digits to the default precision and sign
+	to positive
+ */
+//bbox	a->pool = pool;
+	a->used  = 0;
+	a->alloc = PSTM_DEFAULT_INIT;
+	a->sign  = PSTM_ZPOS;
+
+	return PSTM_OKAY;
+}
+
+/******************************************************************************/
+/*
+	Grow as required
+ */
+int32 pstm_grow(pstm_int * a, int size)
+{
+	int			i; //bbox: was int16
+	pstm_digit		*tmp;
+
+/*
+	If the alloc size is smaller alloc more ram.
+ */
+	if (a->alloc < size) {
+/*
+		Reallocate the array a->dp
+
+		We store the return in a temporary variable in case the operation
+		failed we don't want to overwrite the dp member of a.
+*/
+		tmp = xrealloc(a->dp, sizeof (pstm_digit) * size);//bbox
+/*
+		reallocation succeeded so set a->dp
+ */
+		a->dp = tmp;
+/*
+		zero excess digits
+ */
+		i			= a->alloc;
+		a->alloc	= size;
+		for (; i < a->alloc; i++) {
+			a->dp[i] = 0;
+		}
+	}
+	return PSTM_OKAY;
+}
+
+/******************************************************************************/
+/*
+	copy, b = a (b must be pre-allocated)
+ */
+int32 pstm_copy(pstm_int * a, pstm_int * b)
+{
+	int32	res, n;
+
+/*
+	If dst == src do nothing
+ */
+	if (a == b) {
+		return PSTM_OKAY;
+	}
+/*
+	Grow dest
+ */
+	if (b->alloc < a->used) {
+		if ((res = pstm_grow (b, a->used)) != PSTM_OKAY) {
+			return res;
+		}
+	}
+/*
+	Zero b and copy the parameters over
+ */
+	{
+		register pstm_digit *tmpa, *tmpb;
+
+		/* pointer aliases */
+		/* source */
+		tmpa = a->dp;
+
+		/* destination */
+		tmpb = b->dp;
+
+		/* copy all the digits */
+		for (n = 0; n < a->used; n++) {
+			*tmpb++ = *tmpa++;
+		}
+
+		/* clear high digits */
+		for (; n < b->used; n++) {
+			*tmpb++ = 0;
+		}
+	}
+/*
+	copy used count and sign
+ */
+	b->used = a->used;
+	b->sign = a->sign;
+	return PSTM_OKAY;
+}
+
+/******************************************************************************/
+/*
+	Trim unused digits
+
+	This is used to ensure that leading zero digits are trimed and the
+	leading "used" digit will be non-zero. Typically very fast.  Also fixes
+	the sign if there are no more leading digits
+*/
+void pstm_clamp(pstm_int * a)
+{
+/*	decrease used while the most significant digit is zero. */
+	while (a->used > 0 && a->dp[a->used - 1] == 0) {
+		--(a->used);
+	}
+/*	reset the sign flag if used == 0 */
+	if (a->used == 0) {
+		a->sign = PSTM_ZPOS;
+	}
+}
+
+/******************************************************************************/
+/*
+	clear one (frees).
+ */
+void pstm_clear(pstm_int * a)
+{
+	int32		i;
+/*
+	only do anything if a hasn't been freed previously
+ */
+	if (a != NULL && a->dp != NULL) {
+/*
+		first zero the digits
+ */
+		for (i = 0; i < a->used; i++) {
+			a->dp[i] = 0;
+		}
+
+		psFree (a->dp, a->pool);
+/*
+		reset members to make debugging easier
+ */
+		a->dp		= NULL;
+		a->alloc	= a->used = 0;
+		a->sign		= PSTM_ZPOS;
+	}
+}
+
+/******************************************************************************/
+/*
+	clear many (frees).
+ */
+void pstm_clear_multi(pstm_int *mp0, pstm_int *mp1, pstm_int *mp2,
+					pstm_int *mp3, pstm_int *mp4, pstm_int *mp5,
+					pstm_int *mp6, pstm_int *mp7)
+{
+	int32		n;		/* Number of ok inits */
+
+	pstm_int	*tempArray[9];
+
+	tempArray[0] = mp0;
+	tempArray[1] = mp1;
+	tempArray[2] = mp2;
+	tempArray[3] = mp3;
+	tempArray[4] = mp4;
+	tempArray[5] = mp5;
+	tempArray[6] = mp6;
+	tempArray[7] = mp7;
+	tempArray[8] = NULL;
+
+	for (n = 0; tempArray[n] != NULL; n++) {
+		if ((tempArray[n] != NULL) && (tempArray[n]->dp != NULL)) {
+			pstm_clear(tempArray[n]);
+		}
+	}
+}
+
+/******************************************************************************/
+/*
+	Set to zero.
+ */
+void pstm_zero(pstm_int * a)
+{
+	int32		n;
+	pstm_digit	*tmp;
+
+	a->sign = PSTM_ZPOS;
+	a->used = 0;
+
+	tmp = a->dp;
+	for (n = 0; n < a->alloc; n++) {
+		*tmp++ = 0;
+	}
+}
+
+
+/******************************************************************************/
+/*
+	Compare maginitude of two ints (unsigned).
+ */
+int32 pstm_cmp_mag(pstm_int * a, pstm_int * b)
+{
+	int		n; //bbox: was int16
+	pstm_digit	*tmpa, *tmpb;
+
+/*
+	compare based on # of non-zero digits
+ */
+	if (a->used > b->used) {
+		return PSTM_GT;
+	}
+
+	if (a->used < b->used) {
+		return PSTM_LT;
+	}
+
+	/* alias for a */
+	tmpa = a->dp + (a->used - 1);
+
+	/* alias for b */
+	tmpb = b->dp + (a->used - 1);
+
+/*
+	compare based on digits
+ */
+	for (n = 0; n < a->used; ++n, --tmpa, --tmpb) {
+		if (*tmpa > *tmpb) {
+			return PSTM_GT;
+		}
+		if (*tmpa < *tmpb) {
+			return PSTM_LT;
+		}
+	}
+	return PSTM_EQ;
+}
+
+/******************************************************************************/
+/*
+	Compare two ints (signed)
+ */
+int32 pstm_cmp(pstm_int * a, pstm_int * b)
+{
+/*
+	compare based on sign
+ */
+	if (a->sign != b->sign) {
+		if (a->sign == PSTM_NEG) {
+			return PSTM_LT;
+		} else {
+			return PSTM_GT;
+		}
+	}
+/*
+	compare digits
+ */
+	if (a->sign == PSTM_NEG) {
+		/* if negative compare opposite direction */
+		return pstm_cmp_mag(b, a);
+	} else {
+		return pstm_cmp_mag(a, b);
+	}
+}
+
+/******************************************************************************/
+/*
+	pstm_ints can be initialized more precisely when they will populated
+	using pstm_read_unsigned_bin since the length of the byte stream is known
+*/
+int32 pstm_init_for_read_unsigned_bin(psPool_t *pool, pstm_int *a, uint32 len)
+{
+	int32 size;
+/*
+	Need to set this based on how many words max it will take to store the bin.
+	The magic + 2:
+		1 to round up for the remainder of this integer math
+		1 for the initial carry of '1' bits that fall between DIGIT_BIT and 8
+*/
+	size = (((len / sizeof(pstm_digit)) * (sizeof(pstm_digit) * CHAR_BIT))
+		/ DIGIT_BIT) + 2;
+	return pstm_init_size(pool, a, size);
+}
+
+
+/******************************************************************************/
+/*
+	Reads a unsigned char array into pstm_int format.  User should have
+	called pstm_init_for_read_unsigned_bin first.  There is some grow logic
+	here if the default pstm_init was used but we don't really want to hit it.
+*/
+int32 pstm_read_unsigned_bin(pstm_int *a, unsigned char *b, int32 c)
+{
+	/* zero the int */
+	pstm_zero (a);
+
+/*
+	If we know the endianness of this architecture, and we're using
+	32-bit pstm_digits, we can optimize this
+*/
+#if (defined(ENDIAN_LITTLE) || defined(ENDIAN_BIG)) && !defined(PSTM_64BIT)
+  /* But not for both simultaneously */
+#if defined(ENDIAN_LITTLE) && defined(ENDIAN_BIG)
+#error Both ENDIAN_LITTLE and ENDIAN_BIG defined.
+#endif
+	{
+		unsigned char *pd;
+		if ((unsigned)c > (PSTM_MAX_SIZE * sizeof(pstm_digit))) {
+			uint32 excess = c - (PSTM_MAX_SIZE * sizeof(pstm_digit));
+			c -= excess;
+			b += excess;
+		}
+		a->used = ((c + sizeof(pstm_digit) - 1)/sizeof(pstm_digit));
+		if (a->alloc < a->used) {
+			if (pstm_grow(a, a->used) != PSTM_OKAY) {
+				return PSTM_MEM;
+			}
+		}
+		pd = (unsigned char *)a->dp;
+		/* read the bytes in */
+#ifdef ENDIAN_BIG
+		{
+			/* Use Duff's device to unroll the loop. */
+			int32 idx = (c - 1) & ~3;
+			switch (c % 4) {
+				case 0:	do { pd[idx+0] = *b++;
+					case 3:	     pd[idx+1] = *b++;
+					case 2:	     pd[idx+2] = *b++;
+					case 1:	     pd[idx+3] = *b++;
+					idx -= 4;
+				} while ((c -= 4) > 0);
+			}
+		}
+#else
+		for (c -= 1; c >= 0; c -= 1) {
+			pd[c] = *b++;
+		}
+#endif
+	}
+#else
+	/* Big enough based on the len? */
+	a->used = (((c / sizeof(pstm_digit)) * (sizeof(pstm_digit) * CHAR_BIT))
+		/ DIGIT_BIT) + 2;
+
+	if (a->alloc < a->used) {
+		if (pstm_grow(a, a->used) != PSTM_OKAY) {
+			return PSTM_MEM;
+		}
+	}
+	/* read the bytes in */
+	for (; c > 0; c--) {
+		if (pstm_mul_2d (a, 8, a) != PSTM_OKAY) {
+			return PS_MEM_FAIL;
+		}
+		a->dp[0] |= *b++;
+		a->used += 1;
+	}
+#endif
+
+	pstm_clamp (a);
+	return PS_SUCCESS;
+}
+
+/******************************************************************************/
+/*
+*/
+int pstm_count_bits (pstm_int * a)
+{
+	int     r; //bbox: was int16
+	pstm_digit q;
+
+	if (a->used == 0) {
+		return 0;
+	}
+
+	/* get number of digits and add that */
+	r = (a->used - 1) * DIGIT_BIT;
+
+	/* take the last digit and count the bits in it */
+	q = a->dp[a->used - 1];
+	while (q > ((pstm_digit) 0)) {
+		++r;
+		q >>= ((pstm_digit) 1);
+	}
+	return r;
+}
+
+/******************************************************************************/
+int32 pstm_unsigned_bin_size(pstm_int *a)
+{
+	int32     size = pstm_count_bits (a);
+	return (size / 8 + ((size & 7) != 0 ? 1 : 0));
+}
+
+/******************************************************************************/
+void pstm_set(pstm_int *a, pstm_digit b)
+{
+   pstm_zero(a);
+   a->dp[0] = b;
+   a->used  = a->dp[0] ? 1 : 0;
+}
+
+/******************************************************************************/
+/*
+	Right shift
+*/
+void pstm_rshd(pstm_int *a, int x)
+{
+	int y; //bbox: was int16
+
+	/* too many digits just zero and return */
+	if (x >= a->used) {
+		pstm_zero(a);
+		return;
+	}
+
+	/* shift */
+	for (y = 0; y < a->used - x; y++) {
+		a->dp[y] = a->dp[y+x];
+	}
+
+	/* zero rest */
+	for (; y < a->used; y++) {
+		a->dp[y] = 0;
+	}
+
+	/* decrement count */
+	a->used -= x;
+	pstm_clamp(a);
+}
+
+/******************************************************************************/
+/*
+	Shift left a certain amount of digits.
+ */
+int32 pstm_lshd(pstm_int * a, int b)
+{
+	int	x; //bbox: was int16
+	int32	res;
+
+/*
+	If its less than zero return.
+ */
+	if (b <= 0) {
+		return PSTM_OKAY;
+	}
+/*
+	Grow to fit the new digits.
+ */
+	if (a->alloc < a->used + b) {
+		if ((res = pstm_grow (a, a->used + b)) != PSTM_OKAY) {
+			return res;
+		}
+	}
+
+	{
+		register pstm_digit *top, *bottom;
+/*
+		Increment the used by the shift amount then copy upwards.
+ */
+		a->used += b;
+
+		/* top */
+		top = a->dp + a->used - 1;
+
+		/* base */
+		bottom = a->dp + a->used - 1 - b;
+/*
+		This is implemented using a sliding window except the window goes the
+		other way around.  Copying from the bottom to the top.
+ */
+		for (x = a->used - 1; x >= b; x--) {
+			*top-- = *bottom--;
+		}
+
+		/* zero the lower digits */
+		top = a->dp;
+		for (x = 0; x < b; x++) {
+			*top++ = 0;
+		}
+	}
+	return PSTM_OKAY;
+}
+
+/******************************************************************************/
+/*
+	computes a = 2**b
+*/
+int32 pstm_2expt(pstm_int *a, int b)
+{
+	int     z; //bbox: was int16
+
+   /* zero a as per default */
+	pstm_zero (a);
+
+	if (b < 0) {
+		return PSTM_OKAY;
+	}
+
+	z = b / DIGIT_BIT;
+	if (z >= PSTM_MAX_SIZE) {
+		return PS_LIMIT_FAIL;
+	}
+
+	/* set the used count of where the bit will go */
+	a->used = z + 1;
+
+	if (a->used > a->alloc) {
+		if (pstm_grow(a, a->used) != PSTM_OKAY) {
+			return PS_MEM_FAIL;
+		}
+	}
+
+	/* put the single bit in its place */
+	a->dp[z] = ((pstm_digit)1) << (b % DIGIT_BIT);
+	return PSTM_OKAY;
+}
+
+/******************************************************************************/
+/*
+
+*/
+int32 pstm_mul_2(pstm_int * a, pstm_int * b)
+{
+	int32	res;
+	int	x, oldused; //bbox: was int16
+
+/*
+	grow to accomodate result
+ */
+	if (b->alloc < a->used + 1) {
+		if ((res = pstm_grow (b, a->used + 1)) != PSTM_OKAY) {
+			return res;
+		}
+	}
+	oldused = b->used;
+	b->used = a->used;
+
+	{
+		register pstm_digit r, rr, *tmpa, *tmpb;
+
+		/* alias for source */
+		tmpa = a->dp;
+
+		/* alias for dest */
+		tmpb = b->dp;
+
+		/* carry */
+		r = 0;
+		for (x = 0; x < a->used; x++) {
+/*
+			get what will be the *next* carry bit from the
+			MSB of the current digit
+*/
+			rr = *tmpa >> ((pstm_digit)(DIGIT_BIT - 1));
+/*
+			now shift up this digit, add in the carry [from the previous]
+*/
+			*tmpb++ = ((*tmpa++ << ((pstm_digit)1)) | r);
+/*
+			copy the carry that would be from the source
+			digit into the next iteration
+*/
+			r = rr;
+		}
+
+		/* new leading digit? */
+		if (r != 0 && b->used != (PSTM_MAX_SIZE-1)) {
+			/* add a MSB which is always 1 at this point */
+			*tmpb = 1;
+			++(b->used);
+		}
+/*
+		now zero any excess digits on the destination that we didn't write to
+*/
+		tmpb = b->dp + b->used;
+		for (x = b->used; x < oldused; x++) {
+			*tmpb++ = 0;
+		}
+	}
+	b->sign = a->sign;
+	return PSTM_OKAY;
+}
+
+/******************************************************************************/
+/*
+	unsigned subtraction ||a|| >= ||b|| ALWAYS!
+*/
+int32 s_pstm_sub(pstm_int *a, pstm_int *b, pstm_int *c)
+{
+	int		oldbused, oldused; //bbox: was int16
+	int32		x;
+	pstm_word	t;
+
+	if (b->used > a->used) {
+		return PS_LIMIT_FAIL;
+	}
+	if (c->alloc < a->used) {
+		if ((x = pstm_grow (c, a->used)) != PSTM_OKAY) {
+			return x;
+		}
+	}
+	oldused  = c->used;
+	oldbused = b->used;
+	c->used  = a->used;
+	t = 0;
+
+	for (x = 0; x < oldbused; x++) {
+		t = ((pstm_word)a->dp[x]) - (((pstm_word)b->dp[x]) + t);
+		c->dp[x] = (pstm_digit)t;
+		t = (t >> DIGIT_BIT)&1;
+	}
+	for (; x < a->used; x++) {
+		t = ((pstm_word)a->dp[x]) - t;
+		c->dp[x] = (pstm_digit)t;
+		t = (t >> DIGIT_BIT);
+	}
+	for (; x < oldused; x++) {
+		c->dp[x] = 0;
+	}
+	pstm_clamp(c);
+	return PSTM_OKAY;
+}
+
+/******************************************************************************/
+/*
+	unsigned addition
+*/
+static int32 s_pstm_add(pstm_int *a, pstm_int *b, pstm_int *c)
+{
+	int				x, y, oldused; //bbox: was int16
+	register pstm_word	t, adp, bdp;
+
+	y = a->used;
+	if (b->used > y) {
+		y = b->used;
+	}
+	oldused = c->used;
+	c->used = y;
+
+	if (c->used > c->alloc) {
+		if (pstm_grow(c, c->used) != PSTM_OKAY) {
+			return PS_MEM_FAIL;
+		}
+	}
+
+	t = 0;
+	for (x = 0; x < y; x++) {
+		if (a->used < x) {
+			adp = 0;
+		} else {
+			adp = (pstm_word)a->dp[x];
+		}
+		if (b->used < x) {
+			bdp = 0;
+		} else {
+			bdp = (pstm_word)b->dp[x];
+		}
+		t         += (adp) + (bdp);
+		c->dp[x]   = (pstm_digit)t;
+		t        >>= DIGIT_BIT;
+	}
+	if (t != 0 && x < PSTM_MAX_SIZE) {
+		if (c->used == c->alloc) {
+			if (pstm_grow(c, c->alloc + 1) != PSTM_OKAY) {
+				return PS_MEM_FAIL;
+			}
+		}
+		c->dp[c->used++] = (pstm_digit)t;
+		++x;
+	}
+
+	c->used = x;
+	for (; x < oldused; x++) {
+		c->dp[x] = 0;
+	}
+	pstm_clamp(c);
+	return PSTM_OKAY;
+}
+
+
+/******************************************************************************/
+/*
+
+*/
+int32 pstm_sub(pstm_int *a, pstm_int *b, pstm_int *c)
+{
+	int32	res;
+	int	sa, sb; //bbox: was int16
+
+	sa = a->sign;
+	sb = b->sign;
+
+	if (sa != sb) {
+/*
+		subtract a negative from a positive, OR a positive from a negative.
+		For both, ADD their magnitudes, and use the sign of the first number.
+ */
+		c->sign = sa;
+		if ((res = s_pstm_add (a, b, c)) != PSTM_OKAY) {
+			return res;
+		}
+	} else {
+/*
+		subtract a positive from a positive, OR a negative from a negative.
+		First, take the difference between their magnitudes, then...
+ */
+		if (pstm_cmp_mag (a, b) != PSTM_LT) {
+			/* Copy the sign from the first */
+			c->sign = sa;
+			/* The first has a larger or equal magnitude */
+			if ((res = s_pstm_sub (a, b, c)) != PSTM_OKAY) {
+				return res;
+			}
+		} else {
+			/* The result has the _opposite_ sign from the first number. */
+			c->sign = (sa == PSTM_ZPOS) ? PSTM_NEG : PSTM_ZPOS;
+			/* The second has a larger magnitude */
+			if ((res = s_pstm_sub (b, a, c)) != PSTM_OKAY) {
+				return res;
+			}
+		}
+	}
+	return PS_SUCCESS;
+}
+
+/******************************************************************************/
+/*
+	c = a - b
+*/
+int32 pstm_sub_d(psPool_t *pool, pstm_int *a, pstm_digit b, pstm_int *c)
+{
+	pstm_int	tmp;
+	int32		res;
+
+	if (pstm_init_size(pool, &tmp, sizeof(pstm_digit)) != PSTM_OKAY) {
+		return PS_MEM_FAIL;
+	}
+	pstm_set(&tmp, b);
+	res = pstm_sub(a, &tmp, c);
+	pstm_clear(&tmp);
+	return res;
+}
+
+/******************************************************************************/
+/*
+	setups the montgomery reduction
+*/
+int32 pstm_montgomery_setup(pstm_int *a, pstm_digit *rho)
+{
+	pstm_digit x, b;
+
+/*
+	fast inversion mod 2**k
+	Based on the fact that
+	XA = 1 (mod 2**n)	=>  (X(2-XA)) A = 1 (mod 2**2n)
+						=>  2*X*A - X*X*A*A = 1
+						=>  2*(1) - (1)     = 1
+ */
+	b = a->dp[0];
+
+	if ((b & 1) == 0) {
+		psTraceCrypto("pstm_montogomery_setup failure\n");
+		return PS_ARG_FAIL;
+	}
+
+	x = (((b + 2) & 4) << 1) + b; /* here x*a==1 mod 2**4 */
+	x *= 2 - b * x;               /* here x*a==1 mod 2**8 */
+	x *= 2 - b * x;               /* here x*a==1 mod 2**16 */
+	x *= 2 - b * x;               /* here x*a==1 mod 2**32 */
+#ifdef PSTM_64BIT
+	x *= 2 - b * x;               /* here x*a==1 mod 2**64 */
+#endif
+	/* rho = -1/m mod b */
+	*rho = (pstm_digit)(((pstm_word) 1 << ((pstm_word) DIGIT_BIT)) -
+		((pstm_word)x));
+	return PSTM_OKAY;
+}
+
+/******************************************************************************/
+/*
+ *	computes a = B**n mod b without division or multiplication useful for
+ *	normalizing numbers in a Montgomery system.
+ */
+int32 pstm_montgomery_calc_normalization(pstm_int *a, pstm_int *b)
+{
+	int32     x;
+	int	bits; //bbox: was int16
+
+	/* how many bits of last digit does b use */
+	bits = pstm_count_bits (b) % DIGIT_BIT;
+	if (!bits) bits = DIGIT_BIT;
+
+	/* compute A = B^(n-1) * 2^(bits-1) */
+	if (b->used > 1) {
+		if ((x = pstm_2expt (a, (b->used - 1) * DIGIT_BIT + bits - 1)) !=
+				PSTM_OKAY) {
+			return x;
+		}
+	} else {
+		pstm_set(a, 1);
+		bits = 1;
+	}
+
+	/* now compute C = A * B mod b */
+	for (x = bits - 1; x < (int32)DIGIT_BIT; x++) {
+		if (pstm_mul_2 (a, a) != PSTM_OKAY) {
+			return PS_MEM_FAIL;
+		}
+		if (pstm_cmp_mag (a, b) != PSTM_LT) {
+			if (s_pstm_sub (a, b, a) != PSTM_OKAY) {
+				return PS_MEM_FAIL;
+			}
+		}
+	}
+	return PSTM_OKAY;
+}
+
+/******************************************************************************/
+/*
+	c = a * 2**d
+*/
+static int32 pstm_mul_2d(pstm_int *a, int b, pstm_int *c)
+{
+	pstm_digit	carry, carrytmp, shift;
+	int		x; //bbox: was int16
+
+	/* copy it */
+	if (pstm_copy(a, c) != PSTM_OKAY) {
+		return PS_MEM_FAIL;
+	}
+
+	/* handle whole digits */
+	if (b >= DIGIT_BIT) {
+		if (pstm_lshd(c, b/DIGIT_BIT) != PSTM_OKAY) {
+			return PS_MEM_FAIL;
+		}
+	}
+	b %= DIGIT_BIT;
+
+	/* shift the digits */
+	if (b != 0) {
+		carry = 0;
+		shift = DIGIT_BIT - b;
+		for (x = 0; x < c->used; x++) {
+			carrytmp = c->dp[x] >> shift;
+			c->dp[x] = (c->dp[x] << b) + carry;
+			carry = carrytmp;
+		}
+		/* store last carry if room */
+		if (carry && x < PSTM_MAX_SIZE) {
+			if (c->used == c->alloc) {
+				if (pstm_grow(c, c->alloc + 1) != PSTM_OKAY) {
+					return PS_MEM_FAIL;
+				}
+			}
+			c->dp[c->used++] = carry;
+		}
+	}
+	pstm_clamp(c);
+	return PSTM_OKAY;
+}
+
+/******************************************************************************/
+/*
+	c = a mod 2**d
+*/
+static int32 pstm_mod_2d(pstm_int *a, int b, pstm_int *c) //bbox: was int16 b
+{
+	int	x; //bbox: was int16
+
+	/* zero if count less than or equal to zero */
+	if (b <= 0) {
+		pstm_zero(c);
+		return PSTM_OKAY;
+	}
+
+	/* get copy of input */
+	if (pstm_copy(a, c) != PSTM_OKAY) {
+		return PS_MEM_FAIL;
+	}
+
+	/* if 2**d is larger than we just return */
+	if (b >= (DIGIT_BIT * a->used)) {
+		return PSTM_OKAY;
+	}
+
+	/* zero digits above the last digit of the modulus */
+	for (x = (b / DIGIT_BIT) + ((b % DIGIT_BIT) == 0 ? 0 : 1); x < c->used; x++)
+	{
+		c->dp[x] = 0;
+	}
+	/* clear the digit that is not completely outside/inside the modulus */
+	c->dp[b / DIGIT_BIT] &= ~((pstm_digit)0) >> (DIGIT_BIT - b);
+	pstm_clamp (c);
+	return PSTM_OKAY;
+}
+
+
+/******************************************************************************/
+/*
+	c = a * b
+*/
+int32 pstm_mul_d(pstm_int *a, pstm_digit b, pstm_int *c)
+{
+	pstm_word	w;
+	int32		res;
+	int		x, oldused; //bbox: was int16
+
+	if (c->alloc < a->used + 1) {
+		if ((res = pstm_grow (c, a->used + 1)) != PSTM_OKAY) {
+			return res;
+		}
+	}
+	oldused = c->used;
+	c->used = a->used;
+	c->sign = a->sign;
+	w       = 0;
+	for (x = 0; x < a->used; x++) {
+		w         = ((pstm_word)a->dp[x]) * ((pstm_word)b) + w;
+		c->dp[x]  = (pstm_digit)w;
+		w         = w >> DIGIT_BIT;
+	}
+	if (w != 0 && (a->used != PSTM_MAX_SIZE)) {
+		c->dp[c->used++] = (pstm_digit)w;
+		++x;
+	}
+	for (; x < oldused; x++) {
+		c->dp[x] = 0;
+	}
+	pstm_clamp(c);
+	return PSTM_OKAY;
+}
+
+/******************************************************************************/
+/*
+	c = a / 2**b
+*/
+int32 pstm_div_2d(psPool_t *pool, pstm_int *a, int b, pstm_int *c,
+					pstm_int *d)
+{
+	pstm_digit	D, r, rr;
+	int32		res;
+	int		x; //bbox: was int16
+	pstm_int	t;
+
+	/* if the shift count is <= 0 then we do no work */
+	if (b <= 0) {
+		if (pstm_copy (a, c) != PSTM_OKAY) {
+			return PS_MEM_FAIL;
+		}
+		if (d != NULL) {
+			pstm_zero (d);
+		}
+		return PSTM_OKAY;
+	}
+
+	/* get the remainder */
+	if (d != NULL) {
+		if (pstm_init(pool, &t) != PSTM_OKAY) {
+			return PS_MEM_FAIL;
+		}
+		if (pstm_mod_2d (a, b, &t) != PSTM_OKAY) {
+			res = PS_MEM_FAIL;
+			goto LBL_DONE;
+		}
+	}
+
+	/* copy */
+	if (pstm_copy(a, c) != PSTM_OKAY) {
+		res = PS_MEM_FAIL;
+		goto LBL_DONE;
+	}
+
+	/* shift by as many digits in the bit count */
+	if (b >= (int32)DIGIT_BIT) {
+		pstm_rshd (c, b / DIGIT_BIT);
+	}
+
+	/* shift any bit count < DIGIT_BIT */
+	D = (pstm_digit) (b % DIGIT_BIT);
+	if (D != 0) {
+		register pstm_digit *tmpc, mask, shift;
+
+		/* mask */
+		mask = (((pstm_digit)1) << D) - 1;
+
+		/* shift for lsb */
+		shift = DIGIT_BIT - D;
+
+		/* alias */
+		tmpc = c->dp + (c->used - 1);
+
+		/* carry */
+		r = 0;
+		for (x = c->used - 1; x >= 0; x--) {
+			/* get the lower  bits of this word in a temp */
+			rr = *tmpc & mask;
+
+			/* shift the current word and mix in the carry bits from previous */
+			*tmpc = (*tmpc >> D) | (r << shift);
+			--tmpc;
+
+			/* set the carry to the carry bits of the current word above */
+			r = rr;
+		}
+	}
+	pstm_clamp (c);
+
+	res = PSTM_OKAY;
+LBL_DONE:
+	if (d != NULL) {
+		if (pstm_copy(&t, d) != PSTM_OKAY) {
+			res = PS_MEM_FAIL;
+		}
+		pstm_clear(&t);
+	}
+	return res;
+}
+
+/******************************************************************************/
+/*
+	b = a/2
+*/
+int32 pstm_div_2(pstm_int * a, pstm_int * b)
+{
+	int	x, oldused; //bbox: was int16
+
+	if (b->alloc < a->used) {
+		if (pstm_grow(b, a->used) != PSTM_OKAY) {
+			return PS_MEM_FAIL;
+		}
+	}
+	oldused = b->used;
+	b->used = a->used;
+	{
+		register pstm_digit r, rr, *tmpa, *tmpb;
+
+		/* source alias */
+		tmpa = a->dp + b->used - 1;
+
+		/* dest alias */
+		tmpb = b->dp + b->used - 1;
+
+		/* carry */
+		r = 0;
+		for (x = b->used - 1; x >= 0; x--) {
+			/* get the carry for the next iteration */
+			rr = *tmpa & 1;
+
+			/* shift the current digit, add in carry and store */
+			*tmpb-- = (*tmpa-- >> 1) | (r << (DIGIT_BIT - 1));
+
+			/* forward carry to next iteration */
+			r = rr;
+		}
+
+		/* zero excess digits */
+		tmpb = b->dp + b->used;
+		for (x = b->used; x < oldused; x++) {
+			*tmpb++ = 0;
+		}
+	}
+	b->sign = a->sign;
+	pstm_clamp (b);
+	return PSTM_OKAY;
+}
+
+/******************************************************************************/
+/*
+	Creates "a" then copies b into it
+ */
+int32 pstm_init_copy(psPool_t *pool, pstm_int * a, pstm_int * b, int toSqr)
+{
+	int	x; //bbox: was int16
+	int32	res;
+
+	if (a == b) {
+		return PSTM_OKAY;
+	}
+	x = b->alloc;
+
+	if (toSqr) {
+/*
+		Smart-size:  Increasing size of a if b->used is roughly half
+		of b->alloc because usage has shown that a lot of these copies
+		go on to be squared and need these extra digits
+*/
+		if ((b->used * 2) + 2 >= x) {
+			x = (b->used * 2) + 3;
+		}
+	}
+	if ((res = pstm_init_size(pool, a, x)) != PSTM_OKAY) {
+		return res;
+	}
+	return pstm_copy(b, a);
+}
+
+/******************************************************************************/
+/*
+	With some compilers, we have seen issues linking with the builtin
+	64 bit division routine. The issues with either manifest in a failure
+	to find 'udivdi3' at link time, or a runtime invalid instruction fault
+	during an RSA operation.
+	The routine below divides a 64 bit unsigned int by a 32 bit unsigned int
+	explicitly, rather than using the division operation
+		The 64 bit result is placed in the 'numerator' parameter
+		The 32 bit mod (remainder) of the division is the return parameter
+	Based on implementations by:
+		Copyright (C) 2003 Bernardo Innocenti <bernie@develer.com>
+		Copyright (C) 1999 Hewlett-Packard Co
+		Copyright (C) 1999 David Mosberger-Tang <davidm@hpl.hp.com>
+*/
+#if defined(USE_MATRIX_DIV64) && defined(PSTM_32BIT)
+static uint32 psDiv64(uint64 *numerator, uint32 denominator)
+{
+	uint64	rem = *numerator;
+	uint64	b = denominator;
+	uint64	res = 0;
+	uint64	d = 1;
+	uint32	high = rem >> 32;
+
+	if (high >= denominator) {
+		high /= denominator;
+		res = (uint64) high << 32;
+		rem -= (uint64) (high * denominator) << 32;
+	}
+	while ((int64)b > 0 && b < rem) {
+		b = b+b;
+		d = d+d;
+	}
+	do {
+		if (rem >= b) {
+			rem -= b;
+			res += d;
+		}
+		b >>= 1;
+		d >>= 1;
+	} while (d);
+	*numerator = res;
+	return rem;
+}
+#endif /* USE_MATRIX_DIV64 */
+
+#if defined(USE_MATRIX_DIV128) && defined(PSTM_64BIT)
+typedef unsigned long	uint128 __attribute__ ((mode(TI)));
+static uint64 psDiv128(uint128 *numerator, uint64 denominator)
+{
+	uint128	rem = *numerator;
+	uint128	b = denominator;
+	uint128	res = 0;
+	uint128	d = 1;
+	uint64	high = rem >> 64;
+
+	if (high >= denominator) {
+		high /= denominator;
+		res = (uint128) high << 64;
+		rem -= (uint128) (high * denominator) << 64;
+	}
+	while ((uint128)b > 0 && b < rem) {
+		b = b+b;
+		d = d+d;
+	}
+	do {
+		if (rem >= b) {
+			rem -= b;
+			res += d;
+		}
+		b >>= 1;
+		d >>= 1;
+	} while (d);
+	*numerator = res;
+	return rem;
+}
+#endif /* USE_MATRIX_DIV128 */
+
+/******************************************************************************/
+/*
+	a/b => cb + d == a
+*/
+int32 pstm_div(psPool_t *pool, pstm_int *a, pstm_int *b, pstm_int *c,
+				pstm_int *d)
+{
+	pstm_int	q, x, y, t1, t2;
+	int32		res;
+	int		n, t, i, norm, neg; //bbox: was int16
+
+	/* is divisor zero ? */
+	if (pstm_iszero (b) == 1) {
+		return PS_LIMIT_FAIL;
+	}
+
+	/* if a < b then q=0, r = a */
+	if (pstm_cmp_mag (a, b) == PSTM_LT) {
+		if (d != NULL) {
+			if (pstm_copy(a, d) != PSTM_OKAY) {
+				return PS_MEM_FAIL;
+			}
+		}
+		if (c != NULL) {
+			pstm_zero (c);
+		}
+		return PSTM_OKAY;
+	}
+/*
+	Smart-size inits
+*/
+	if ((res = pstm_init_size(pool, &t1, a->alloc)) != PSTM_OKAY) {
+		return res;
+	}
+	if ((res = pstm_init_size(pool, &t2, 3)) != PSTM_OKAY) {
+		goto LBL_T1;
+	}
+	if ((res = pstm_init_copy(pool, &x, a, 0)) != PSTM_OKAY) {
+		goto LBL_T2;
+	}
+/*
+	Used to be an init_copy on b but pstm_grow was always hit with triple size
+*/
+	if ((res = pstm_init_size(pool, &y, b->used * 3)) != PSTM_OKAY) {
+		goto LBL_X;
+	}
+	if ((res = pstm_copy(b, &y)) != PSTM_OKAY) {
+		goto LBL_Y;
+	}
+
+	/* fix the sign */
+	neg = (a->sign == b->sign) ? PSTM_ZPOS : PSTM_NEG;
+	x.sign = y.sign = PSTM_ZPOS;
+
+	/* normalize both x and y, ensure that y >= b/2, [b == 2**DIGIT_BIT] */
+	norm = pstm_count_bits(&y) % DIGIT_BIT;
+	if (norm < (int32)(DIGIT_BIT-1)) {
+		norm = (DIGIT_BIT-1) - norm;
+		if ((res = pstm_mul_2d(&x, norm, &x)) != PSTM_OKAY) {
+			goto LBL_Y;
+		}
+		if ((res = pstm_mul_2d(&y, norm, &y)) != PSTM_OKAY) {
+			goto LBL_Y;
+		}
+	} else {
+		norm = 0;
+	}
+
+	/* note hac does 0 based, so if used==5 then its 0,1,2,3,4, e.g. use 4 */
+	n = x.used - 1;
+	t = y.used - 1;
+
+	if ((res = pstm_init_size(pool, &q, n - t + 1)) != PSTM_OKAY) {
+		goto LBL_Y;
+	}
+	q.used = n - t + 1;
+
+	/* while (x >= y*b**n-t) do { q[n-t] += 1; x -= y*b**{n-t} } */
+	if ((res = pstm_lshd(&y, n - t)) != PSTM_OKAY) { /* y = y*b**{n-t} */
+		goto LBL_Q;
+	}
+
+	while (pstm_cmp (&x, &y) != PSTM_LT) {
+		++(q.dp[n - t]);
+		if ((res = pstm_sub(&x, &y, &x)) != PSTM_OKAY) {
+			goto LBL_Q;
+		}
+	}
+
+	/* reset y by shifting it back down */
+	pstm_rshd (&y, n - t);
+
+	/* step 3. for i from n down to (t + 1) */
+	for (i = n; i >= (t + 1); i--) {
+		if (i > x.used) {
+			continue;
+		}
+
+		/* step 3.1 if xi == yt then set q{i-t-1} to b-1,
+		 * otherwise set q{i-t-1} to (xi*b + x{i-1})/yt */
+		if (x.dp[i] == y.dp[t]) {
+			q.dp[i - t - 1] = (pstm_digit)((((pstm_word)1) << DIGIT_BIT) - 1);
+		} else {
+			pstm_word tmp;
+			tmp = ((pstm_word) x.dp[i]) << ((pstm_word) DIGIT_BIT);
+			tmp |= ((pstm_word) x.dp[i - 1]);
+#if defined(USE_MATRIX_DIV64) && defined(PSTM_32BIT)
+			psDiv64(&tmp, y.dp[t]);
+#elif defined(USE_MATRIX_DIV128) && defined(PSTM_64BIT)
+			psDiv128(&tmp, y.dp[t]);
+#else
+			tmp /= ((pstm_word) y.dp[t]);
+#endif /* USE_MATRIX_DIV64 */
+			q.dp[i - t - 1] = (pstm_digit) (tmp);
+		}
+
+		/* while (q{i-t-1} * (yt * b + y{t-1})) >
+			 xi * b**2 + xi-1 * b + xi-2
+
+			do q{i-t-1} -= 1;
+		*/
+		q.dp[i - t - 1] = (q.dp[i - t - 1] + 1);
+		do {
+			q.dp[i - t - 1] = (q.dp[i - t - 1] - 1);
+
+			/* find left hand */
+			pstm_zero (&t1);
+			t1.dp[0] = (t - 1 < 0) ? 0 : y.dp[t - 1];
+			t1.dp[1] = y.dp[t];
+			t1.used = 2;
+			if ((res = pstm_mul_d (&t1, q.dp[i - t - 1], &t1)) != PSTM_OKAY) {
+				goto LBL_Q;
+			}
+
+			/* find right hand */
+			t2.dp[0] = (i - 2 < 0) ? 0 : x.dp[i - 2];
+			t2.dp[1] = (i - 1 < 0) ? 0 : x.dp[i - 1];
+			t2.dp[2] = x.dp[i];
+			t2.used = 3;
+		} while (pstm_cmp_mag(&t1, &t2) == PSTM_GT);
+
+		/* step 3.3 x = x - q{i-t-1} * y * b**{i-t-1} */
+		if ((res = pstm_mul_d(&y, q.dp[i - t - 1], &t1)) != PSTM_OKAY) {
+			goto LBL_Q;
+		}
+
+		if ((res = pstm_lshd(&t1, i - t - 1)) != PSTM_OKAY) {
+			goto LBL_Q;
+		}
+
+		if ((res = pstm_sub(&x, &t1, &x)) != PSTM_OKAY) {
+			goto LBL_Q;
+		}
+
+		/* if x < 0 then { x = x + y*b**{i-t-1}; q{i-t-1} -= 1; } */
+		if (x.sign == PSTM_NEG) {
+			if ((res = pstm_copy(&y, &t1)) != PSTM_OKAY) {
+				goto LBL_Q;
+			}
+			if ((res = pstm_lshd (&t1, i - t - 1)) != PSTM_OKAY) {
+				goto LBL_Q;
+			}
+			if ((res = pstm_add (&x, &t1, &x)) != PSTM_OKAY) {
+				goto LBL_Q;
+			}
+			q.dp[i - t - 1] = q.dp[i - t - 1] - 1;
+		}
+	}
+/*
+	now q is the quotient and x is the remainder (which we have to normalize)
+*/
+	/* get sign before writing to c */
+	x.sign = x.used == 0 ? PSTM_ZPOS : a->sign;
+
+	if (c != NULL) {
+		pstm_clamp (&q);
+		if (pstm_copy (&q, c) != PSTM_OKAY) {
+			res = PS_MEM_FAIL;
+			goto LBL_Q;
+		}
+		c->sign = neg;
+	}
+
+	if (d != NULL) {
+		if ((res = pstm_div_2d (pool, &x, norm, &x, NULL)) != PSTM_OKAY) {
+			goto LBL_Q;
+		}
+/*
+		the following is a kludge, essentially we were seeing the right
+		remainder but with excess digits that should have been zero
+ */
+		for (i = b->used; i < x.used; i++) {
+			x.dp[i] = 0;
+		}
+		pstm_clamp(&x);
+		if (pstm_copy (&x, d) != PSTM_OKAY) {
+			res = PS_MEM_FAIL;
+			goto LBL_Q;
+		}
+	}
+
+	res = PSTM_OKAY;
+
+LBL_Q:pstm_clear (&q);
+LBL_Y:pstm_clear (&y);
+LBL_X:pstm_clear (&x);
+LBL_T2:pstm_clear (&t2);
+LBL_T1:pstm_clear (&t1);
+
+	return res;
+}
+
+/******************************************************************************/
+/*
+	Swap the elements of two integers, for cases where you can't simply swap
+	the pstm_int pointers around
+*/
+void pstm_exch(pstm_int * a, pstm_int * b)
+{
+	pstm_int		t;
+
+	t	= *a;
+	*a	= *b;
+	*b	= t;
+}
+
+/******************************************************************************/
+/*
+	c = a mod b, 0 <= c < b
+*/
+int32 pstm_mod(psPool_t *pool, pstm_int *a, pstm_int *b, pstm_int *c)
+{
+	pstm_int	t;
+	int32		err;
+/*
+	Smart-size
+*/
+	if ((err = pstm_init_size(pool, &t, b->alloc)) != PSTM_OKAY) {
+		return err;
+	}
+	if ((err = pstm_div(pool, a, b, NULL, &t)) != PSTM_OKAY) {
+		pstm_clear (&t);
+		return err;
+	}
+	if (t.sign != b->sign) {
+		err = pstm_add(&t, b, c);
+	} else {
+		pstm_exch (&t, c);
+	}
+	pstm_clear (&t);
+	return err;
+}
+
+/******************************************************************************/
+/*
+	d = a * b (mod c)
+*/
+int32 pstm_mulmod(psPool_t *pool, pstm_int *a, pstm_int *b, pstm_int *c,
+			pstm_int *d)
+{
+	int32		res;
+	int		size; //bbox: was int16
+	pstm_int	tmp;
+
+/*
+	Smart-size pstm_inits.  d is an output that is influenced by this local 't'
+	so don't shrink 'd' if it wants to becuase this will lead to an pstm_grow
+	in RSA operations
+*/
+	size = a->used + b->used + 1;
+	if ((a == d) && (size < a->alloc)) {
+		size = a->alloc;
+	}
+	if ((res = pstm_init_size(pool, &tmp, size)) != PSTM_OKAY) {
+		return res;
+	}
+	if ((res = pstm_mul_comba(pool, a, b, &tmp, NULL, 0)) != PSTM_OKAY) {
+		pstm_clear(&tmp);
+		return res;
+	}
+	res = pstm_mod(pool, &tmp, c, d);
+	pstm_clear(&tmp);
+	return res;
+}
+
+/******************************************************************************/
+/*
+ *	y = g**x (mod b)
+ *	Some restrictions... x must be positive and < b
+ */
+int32 pstm_exptmod(psPool_t *pool, pstm_int *G, pstm_int *X, pstm_int *P,
+			pstm_int *Y)
+{
+	pstm_int	M[32], res; /* Keep this winsize based: (1 << max_winsize) */
+	pstm_digit	buf, mp;
+	pstm_digit	*paD;
+	int32		err, bitbuf;
+	int		bitcpy, bitcnt, mode, digidx, x, y, winsize; //bbox: was int16
+	uint32		paDlen;
+
+	/* set window size from what user set as optimization */
+	x = pstm_count_bits(X);
+	if (x < 50) {
+		winsize = 2;
+	} else {
+		winsize = PS_EXPTMOD_WINSIZE;
+	}
+
+	/* now setup montgomery  */
+	if ((err = pstm_montgomery_setup (P, &mp)) != PSTM_OKAY) {
+		return err;
+	}
+
+	/* setup result */
+	if ((err = pstm_init_size(pool, &res, (P->used * 2) + 1)) != PSTM_OKAY) {
+		return err;
+	}
+/*
+	create M table
+	The M table contains powers of the input base, e.g. M[x] = G^x mod P
+	The first half of the table is not computed though except for M[0] and M[1]
+ */
+	/* now we need R mod m */
+	if ((err = pstm_montgomery_calc_normalization (&res, P)) != PSTM_OKAY) {
+		goto LBL_RES;
+	}
+/*
+	init M array
+	init first cell
+ */
+	if ((err = pstm_init_size(pool, &M[1], res.used)) != PSTM_OKAY) {
+		goto LBL_RES;
+	}
+
+	/* now set M[1] to G * R mod m */
+	if (pstm_cmp_mag(P, G) != PSTM_GT) {
+		/* G > P so we reduce it first */
+		if ((err = pstm_mod(pool, G, P, &M[1])) != PSTM_OKAY) {
+			goto LBL_M;
+		}
+	} else {
+		if ((err = pstm_copy(G, &M[1])) != PSTM_OKAY) {
+			goto LBL_M;
+		}
+	}
+	if ((err = pstm_mulmod (pool, &M[1], &res, P, &M[1])) != PSTM_OKAY) {
+		goto LBL_M;
+	}
+/*
+	Pre-allocated digit.  Used for mul, sqr, AND reduce
+*/
+	paDlen = ((M[1].used + 3) * 2) * sizeof(pstm_digit);
+	paD = xzalloc(paDlen);//bbox
+/*
+	compute the value at M[1<<(winsize-1)] by squaring M[1] (winsize-1) times
+ */
+	if (pstm_init_copy(pool, &M[1 << (winsize - 1)], &M[1], 1) != PSTM_OKAY) {
+		err = PS_MEM_FAIL;
+		goto LBL_PAD;
+	}
+	for (x = 0; x < (winsize - 1); x++) {
+		if ((err = pstm_sqr_comba (pool, &M[1 << (winsize - 1)],
+				&M[1 << (winsize - 1)], paD, paDlen)) != PSTM_OKAY) {
+			goto LBL_PAD;
+		}
+		if ((err = pstm_montgomery_reduce(pool, &M[1 << (winsize - 1)], P, mp,
+				paD, paDlen)) != PSTM_OKAY) {
+			goto LBL_PAD;
+		}
+	}
+/*
+	now init the second half of the array
+*/
+	for (x = (1<<(winsize-1)) + 1; x < (1 << winsize); x++) {
+		if ((err = pstm_init_size(pool, &M[x], M[1<<(winsize-1)].alloc + 1))
+				!= PSTM_OKAY) {
+			for (y = 1<<(winsize-1); y < x; y++) {
+				pstm_clear(&M[y]);
+			}
+			goto LBL_PAD;
+		}
+	}
+
+	/* create upper table */
+	for (x = (1 << (winsize - 1)) + 1; x < (1 << winsize); x++) {
+		if ((err = pstm_mul_comba(pool, &M[x - 1], &M[1], &M[x], paD, paDlen))
+				!= PSTM_OKAY) {
+			goto LBL_MARRAY;
+		}
+		if ((err = pstm_montgomery_reduce(pool, &M[x], P, mp, paD, paDlen)) !=
+				PSTM_OKAY) {
+			goto LBL_MARRAY;
+		}
+	}
+
+	/* set initial mode and bit cnt */
+	mode   = 0;
+	bitcnt = 1;
+	buf    = 0;
+	digidx = X->used - 1;
+	bitcpy = 0;
+	bitbuf = 0;
+
+	for (;;) {
+		/* grab next digit as required */
+		if (--bitcnt == 0) {
+			/* if digidx == -1 we are out of digits so break */
+			if (digidx == -1) {
+				break;
+			}
+			/* read next digit and reset bitcnt */
+			buf    = X->dp[digidx--];
+			bitcnt = (int32)DIGIT_BIT;
+		}
+
+		/* grab the next msb from the exponent */
+		y     = (pstm_digit)(buf >> (DIGIT_BIT - 1)) & 1;
+		buf <<= (pstm_digit)1;
+/*
+		 If the bit is zero and mode == 0 then we ignore it.
+		 These represent the leading zero bits before the first 1 bit
+		 in the exponent.  Technically this opt is not required but it
+		 does lower the # of trivial squaring/reductions used
+*/
+		if (mode == 0 && y == 0) {
+			continue;
+		}
+
+		/* if the bit is zero and mode == 1 then we square */
+		if (mode == 1 && y == 0) {
+			if ((err = pstm_sqr_comba(pool, &res, &res, paD, paDlen)) !=
+					PSTM_OKAY) {
+				goto LBL_MARRAY;
+			}
+			if ((err = pstm_montgomery_reduce(pool, &res, P, mp, paD, paDlen))
+					!= PSTM_OKAY) {
+				goto LBL_MARRAY;
+			}
+			continue;
+		}
+
+		/* else we add it to the window */
+		bitbuf |= (y << (winsize - ++bitcpy));
+		mode    = 2;
+
+		if (bitcpy == winsize) {
+			/* ok window is filled so square as required and mul square first */
+			for (x = 0; x < winsize; x++) {
+				if ((err = pstm_sqr_comba(pool, &res, &res, paD, paDlen)) !=
+						PSTM_OKAY) {
+					goto LBL_MARRAY;
+				}
+				if ((err = pstm_montgomery_reduce(pool, &res, P, mp, paD,
+						paDlen)) != PSTM_OKAY) {
+					goto LBL_MARRAY;
+				}
+			}
+
+			/* then multiply */
+			if ((err = pstm_mul_comba(pool, &res, &M[bitbuf], &res, paD,
+					paDlen)) != PSTM_OKAY) {
+				goto LBL_MARRAY;
+			}
+			if ((err = pstm_montgomery_reduce(pool, &res, P, mp, paD, paDlen))
+					!= PSTM_OKAY) {
+				goto LBL_MARRAY;
+			}
+
+			/* empty window and reset */
+			bitcpy = 0;
+			bitbuf = 0;
+			mode   = 1;
+		}
+	}
+
+	/* if bits remain then square/multiply */
+	if (mode == 2 && bitcpy > 0) {
+		/* square then multiply if the bit is set */
+		for (x = 0; x < bitcpy; x++) {
+			if ((err = pstm_sqr_comba(pool, &res, &res, paD, paDlen)) !=
+					PSTM_OKAY) {
+				goto LBL_MARRAY;
+			}
+			if ((err = pstm_montgomery_reduce(pool, &res, P, mp, paD, paDlen))
+					!= PSTM_OKAY) {
+				goto LBL_MARRAY;
+			}
+
+			/* get next bit of the window */
+			bitbuf <<= 1;
+			if ((bitbuf & (1 << winsize)) != 0) {
+			/* then multiply */
+				if ((err = pstm_mul_comba(pool, &res, &M[1], &res, paD, paDlen))
+						!= PSTM_OKAY) {
+					goto LBL_MARRAY;
+				}
+				if ((err = pstm_montgomery_reduce(pool, &res, P, mp, paD,
+						paDlen)) != PSTM_OKAY) {
+					goto LBL_MARRAY;
+				}
+			}
+		}
+	}
+/*
+	Fix up result if Montgomery reduction is used recall that any value in a
+	Montgomery system is actually multiplied by R mod n.  So we have to reduce
+	one more time to cancel out the factor of R.
+*/
+	if ((err = pstm_montgomery_reduce(pool, &res, P, mp, paD, paDlen)) !=
+			PSTM_OKAY) {
+		goto LBL_MARRAY;
+	}
+	/* swap res with Y */
+	if ((err = pstm_copy (&res, Y)) != PSTM_OKAY) {
+		goto LBL_MARRAY;
+	}
+	err = PSTM_OKAY;
+LBL_MARRAY:
+	for (x = 1<<(winsize-1); x < (1 << winsize); x++) {
+		pstm_clear(&M[x]);
+	}
+LBL_PAD:psFree(paD, pool);
+LBL_M: pstm_clear(&M[1]);
+LBL_RES:pstm_clear(&res);
+	return err;
+}
+
+/******************************************************************************/
+/*
+
+*/
+int32 pstm_add(pstm_int *a, pstm_int *b, pstm_int *c)
+{
+	int32	res;
+	int	sa, sb; //bbox: was int16
+
+	/* get sign of both inputs */
+	sa = a->sign;
+	sb = b->sign;
+
+	/* handle two cases, not four */
+	if (sa == sb) {
+		/* both positive or both negative, add their mags, copy the sign */
+		c->sign = sa;
+		if ((res = s_pstm_add (a, b, c)) != PSTM_OKAY) {
+			return res;
+		}
+	} else {
+/*
+		one positive, the other negative
+		subtract the one with the greater magnitude from the one of the lesser
+		magnitude. The result gets the sign of the one with the greater mag.
+ */
+		if (pstm_cmp_mag (a, b) == PSTM_LT) {
+			c->sign = sb;
+			if ((res = s_pstm_sub (b, a, c)) != PSTM_OKAY) {
+				return res;
+			}
+		} else {
+			c->sign = sa;
+			if ((res = s_pstm_sub (a, b, c)) != PSTM_OKAY) {
+				return res;
+			}
+		}
+	}
+	return PS_SUCCESS;
+}
+
+/******************************************************************************/
+/*
+	reverse an array, used for radix code
+*/
+static void pstm_reverse (unsigned char *s, int len) //bbox: was int16 len
+{
+	int32     ix, iy;
+	unsigned char t;
+
+	ix = 0;
+	iy = len - 1;
+	while (ix < iy) {
+		t     = s[ix];
+		s[ix] = s[iy];
+		s[iy] = t;
+		++ix;
+		--iy;
+	}
+}
+/******************************************************************************/
+/*
+	No reverse.  Useful in some of the EIP-154 PKA stuff where special byte
+	order seems to come into play more often
+*/
+int32 pstm_to_unsigned_bin_nr(psPool_t *pool, pstm_int *a, unsigned char *b)
+{
+	int32     res;
+	int     x; //bbox: was int16
+	pstm_int  t = { 0 };
+
+	if ((res = pstm_init_copy(pool, &t, a, 0)) != PSTM_OKAY) {
+		return res;
+	}
+
+	x = 0;
+	while (pstm_iszero (&t) == 0) {
+		b[x++] = (unsigned char) (t.dp[0] & 255);
+		if ((res = pstm_div_2d (pool, &t, 8, &t, NULL)) != PSTM_OKAY) {
+			pstm_clear(&t);
+			return res;
+		}
+	}
+	pstm_clear(&t);
+	return PS_SUCCESS;
+}
+/******************************************************************************/
+/*
+
+*/
+int32 pstm_to_unsigned_bin(psPool_t *pool, pstm_int *a, unsigned char *b)
+{
+	int32     res;
+	int	x; //bbox: was int16
+	pstm_int  t = { 0 };
+
+	if ((res = pstm_init_copy(pool, &t, a, 0)) != PSTM_OKAY) {
+		return res;
+	}
+
+	x = 0;
+	while (pstm_iszero (&t) == 0) {
+		b[x++] = (unsigned char) (t.dp[0] & 255);
+		if ((res = pstm_div_2d (pool, &t, 8, &t, NULL)) != PSTM_OKAY) {
+			pstm_clear(&t);
+			return res;
+		}
+	}
+	pstm_reverse (b, x);
+	pstm_clear(&t);
+	return PS_SUCCESS;
+}
+
+/******************************************************************************/
+/*
+	compare against a single digit
+*/
+int32 pstm_cmp_d(pstm_int *a, pstm_digit b)
+{
+	/* compare based on sign */
+	if ((b && a->used == 0) || a->sign == PSTM_NEG) {
+		return PSTM_LT;
+	}
+
+	/* compare based on magnitude */
+	if (a->used > 1) {
+		return PSTM_GT;
+	}
+
+	/* compare the only digit of a to b */
+	if (a->dp[0] > b) {
+		return PSTM_GT;
+	} else if (a->dp[0] < b) {
+		return PSTM_LT;
+	} else {
+		return PSTM_EQ;
+	}
+}
+
+/*
+	Need invmod for ECC and also private key loading for hardware crypto
+	in cases where dQ > dP.  The values must be switched and a new qP must be
+	calculated using this function
+*/
+//bbox: pool unused
+#define pstm_invmod_slow(pool, a, b, c) \
+        pstm_invmod_slow(      a, b, c)
+static int32 pstm_invmod_slow(psPool_t *pool, pstm_int * a, pstm_int * b,
+				pstm_int * c)
+{
+	pstm_int  x, y, u, v, A, B, C, D;
+	int32     res;
+
+	/* b cannot be negative */
+	if (b->sign == PSTM_NEG || pstm_iszero(b) == 1) {
+		return PS_LIMIT_FAIL;
+	}
+
+	/* init temps */
+	if (pstm_init_size(pool, &x, b->used) != PSTM_OKAY) {
+		return PS_MEM_FAIL;
+	}
+
+	/* x = a, y = b */
+	if ((res = pstm_mod(pool, a, b, &x)) != PSTM_OKAY) {
+		goto LBL_X;
+	}
+
+	if (pstm_init_copy(pool, &y, b, 0) != PSTM_OKAY) {
+		goto LBL_X;
+	}
+
+	/* 2. [modified] if x,y are both even then return an error! */
+	if (pstm_iseven (&x) == 1 && pstm_iseven (&y) == 1) {
+		res = PS_FAILURE;
+		goto LBL_Y;
+	}
+
+	/* 3. u=x, v=y, A=1, B=0, C=0,D=1 */
+	if ((res = pstm_init_copy(pool, &u, &x, 0)) != PSTM_OKAY) {
+		goto LBL_Y;
+	}
+	if ((res = pstm_init_copy(pool, &v, &y, 0)) != PSTM_OKAY) {
+		goto LBL_U;
+	}
+
+	if ((res = pstm_init_size(pool, &A, sizeof(pstm_digit))) != PSTM_OKAY) {
+		goto LBL_V;
+	}
+
+	if ((res = pstm_init_size(pool, &D, sizeof(pstm_digit))) != PSTM_OKAY) {
+		goto LBL_A;
+	}
+	pstm_set (&A, 1);
+	pstm_set (&D, 1);
+
+	if ((res = pstm_init(pool, &B)) != PSTM_OKAY) {
+		goto LBL_D;
+	}
+	if ((res = pstm_init(pool, &C)) != PSTM_OKAY) {
+		goto LBL_B;
+	}
+
+top:
+	/* 4.  while u is even do */
+	while (pstm_iseven (&u) == 1) {
+		/* 4.1 u = u/2 */
+		if ((res = pstm_div_2 (&u, &u)) != PSTM_OKAY) {
+			goto LBL_C;
+		}
+
+		/* 4.2 if A or B is odd then */
+		if (pstm_isodd (&A) == 1 || pstm_isodd (&B) == 1) {
+			/* A = (A+y)/2, B = (B-x)/2 */
+			if ((res = pstm_add (&A, &y, &A)) != PSTM_OKAY) {
+				goto LBL_C;
+			}
+			if ((res = pstm_sub (&B, &x, &B)) != PSTM_OKAY) {
+				goto LBL_C;
+			}
+		}
+		/* A = A/2, B = B/2 */
+		if ((res = pstm_div_2 (&A, &A)) != PSTM_OKAY) {
+			goto LBL_C;
+		}
+		if ((res = pstm_div_2 (&B, &B)) != PSTM_OKAY) {
+			goto LBL_C;
+		}
+	}
+
+	/* 5.  while v is even do */
+	while (pstm_iseven (&v) == 1) {
+		/* 5.1 v = v/2 */
+		if ((res = pstm_div_2 (&v, &v)) != PSTM_OKAY) {
+			goto LBL_C;
+		}
+
+		/* 5.2 if C or D is odd then */
+		if (pstm_isodd (&C) == 1 || pstm_isodd (&D) == 1) {
+			/* C = (C+y)/2, D = (D-x)/2 */
+			if ((res = pstm_add (&C, &y, &C)) != PSTM_OKAY) {
+				goto LBL_C;
+			}
+			if ((res = pstm_sub (&D, &x, &D)) != PSTM_OKAY) {
+				goto LBL_C;
+			}
+		}
+		/* C = C/2, D = D/2 */
+		if ((res = pstm_div_2 (&C, &C)) != PSTM_OKAY) {
+			goto LBL_C;
+		}
+		if ((res = pstm_div_2 (&D, &D)) != PSTM_OKAY) {
+			goto LBL_C;
+		}
+	}
+
+	/* 6.  if u >= v then */
+	if (pstm_cmp (&u, &v) != PSTM_LT) {
+		/* u = u - v, A = A - C, B = B - D */
+		if ((res = pstm_sub (&u, &v, &u)) != PSTM_OKAY) {
+				goto LBL_C;
+		}
+		if ((res = pstm_sub (&A, &C, &A)) != PSTM_OKAY) {
+				goto LBL_C;
+		}
+		if ((res = pstm_sub (&B, &D, &B)) != PSTM_OKAY) {
+				goto LBL_C;
+		}
+	} else {
+		/* v - v - u, C = C - A, D = D - B */
+		if ((res = pstm_sub (&v, &u, &v)) != PSTM_OKAY) {
+				goto LBL_C;
+		}
+		if ((res = pstm_sub (&C, &A, &C)) != PSTM_OKAY) {
+				goto LBL_C;
+		}
+		if ((res = pstm_sub (&D, &B, &D)) != PSTM_OKAY) {
+				goto LBL_C;
+		}
+	}
+
+	/* if not zero goto step 4 */
+	if (pstm_iszero (&u) == 0)
+		goto top;
+
+	/* now a = C, b = D, gcd == g*v */
+
+	/* if v != 1 then there is no inverse */
+	if (pstm_cmp_d (&v, 1) != PSTM_EQ) {
+		res = PS_FAILURE;
+		goto LBL_C;
+	}
+
+	/* if its too low */
+	while (pstm_cmp_d(&C, 0) == PSTM_LT) {
+		if ((res = pstm_add(&C, b, &C)) != PSTM_OKAY) {
+			goto LBL_C;
+		}
+	}
+
+	/* too big */
+	while (pstm_cmp_mag(&C, b) != PSTM_LT) {
+		if ((res = pstm_sub(&C, b, &C)) != PSTM_OKAY) {
+			goto LBL_C;
+		}
+	}
+
+	/* C is now the inverse */
+	if ((res = pstm_copy(&C, c)) != PSTM_OKAY) {
+		goto LBL_C;
+	}
+	res = PSTM_OKAY;
+
+LBL_C: pstm_clear(&C);
+LBL_D: pstm_clear(&D);
+LBL_B: pstm_clear(&B);
+LBL_A: pstm_clear(&A);
+LBL_V: pstm_clear(&v);
+LBL_U: pstm_clear(&u);
+LBL_Y: pstm_clear(&y);
+LBL_X: pstm_clear(&x);
+
+	return res;
+}
+
+/* c = 1/a (mod b) for odd b only */
+int32 pstm_invmod(psPool_t *pool, pstm_int *a, pstm_int *b, pstm_int *c)
+{
+	pstm_int	x, y, u, v, B, D;
+	int32		res;
+	uint16		neg, sanity;
+
+	/* 2. [modified] b must be odd   */
+	if (pstm_iseven (b) == 1) {
+		return pstm_invmod_slow(pool, a,b,c);
+	}
+
+	/* x == modulus, y == value to invert */
+	if ((res = pstm_init_copy(pool, &x, b, 0)) != PSTM_OKAY) {
+		return res;
+	}
+
+	if ((res = pstm_init_size(pool, &y, a->alloc)) != PSTM_OKAY) {
+		goto LBL_X;
+	}
+
+	/* we need y = |a| */
+	pstm_abs(a, &y);
+
+	/* 3. u=x, v=y, A=1, B=0, C=0,D=1 */
+	if ((res = pstm_init_copy(pool, &u, &x, 0)) != PSTM_OKAY) {
+		goto LBL_Y;
+	}
+	if ((res = pstm_init_copy(pool, &v, &y, 0)) != PSTM_OKAY) {
+		goto LBL_U;
+	}
+	if ((res = pstm_init(pool, &B)) != PSTM_OKAY) {
+		goto LBL_V;
+	}
+	if ((res = pstm_init(pool, &D)) != PSTM_OKAY) {
+		goto LBL_B;
+	}
+
+	pstm_set (&D, 1);
+
+	sanity = 0;
+top:
+	/* 4.  while u is even do */
+	while (pstm_iseven (&u) == 1) {
+		/* 4.1 u = u/2 */
+		if ((res = pstm_div_2 (&u, &u)) != PSTM_OKAY) {
+			goto LBL_D;
+		}
+
+		/* 4.2 if B is odd then */
+		if (pstm_isodd (&B) == 1) {
+			if ((res = pstm_sub (&B, &x, &B)) != PSTM_OKAY) {
+				goto LBL_D;
+			}
+		}
+		/* B = B/2 */
+		if ((res = pstm_div_2 (&B, &B)) !=  PSTM_OKAY) {
+			goto LBL_D;
+		}
+	}
+
+	/* 5.  while v is even do */
+	while (pstm_iseven (&v) == 1) {
+		/* 5.1 v = v/2 */
+		if ((res = pstm_div_2 (&v, &v)) != PSTM_OKAY) {
+			goto LBL_D;
+		}
+		/* 5.2 if D is odd then */
+		if (pstm_isodd (&D) == 1) {
+			/* D = (D-x)/2 */
+			if ((res = pstm_sub (&D, &x, &D)) != PSTM_OKAY) {
+				goto LBL_D;
+			}
+		}
+		/* D = D/2 */
+		if ((res = pstm_div_2 (&D, &D)) !=  PSTM_OKAY) {
+			goto LBL_D;
+		}
+	}
+
+	/* 6.  if u >= v then */
+	if (pstm_cmp (&u, &v) != PSTM_LT) {
+		/* u = u - v, B = B - D */
+		if ((res = pstm_sub (&u, &v, &u)) != PSTM_OKAY) {
+				goto LBL_D;
+		}
+		if ((res = pstm_sub (&B, &D, &B)) != PSTM_OKAY) {
+				goto LBL_D;
+		}
+	} else {
+		/* v - v - u, D = D - B */
+		if ((res = pstm_sub (&v, &u, &v)) != PSTM_OKAY) {
+				goto LBL_D;
+		}
+		if ((res = pstm_sub (&D, &B, &D)) != PSTM_OKAY) {
+				goto LBL_D;
+		}
+	}
+
+	/* if not zero goto step 4 */
+	if (sanity++ > 1000) {
+		res = PS_LIMIT_FAIL;
+		goto LBL_D;
+	}
+	if (pstm_iszero (&u) == 0) {
+		goto top;
+	}
+
+	/* now a = C, b = D, gcd == g*v */
+
+	/* if v != 1 then there is no inverse */
+	if (pstm_cmp_d (&v, 1) != PSTM_EQ) {
+		res = PS_FAILURE;
+		goto LBL_D;
+	}
+
+	/* b is now the inverse */
+	neg = a->sign;
+	while (D.sign == PSTM_NEG) {
+		if ((res = pstm_add (&D, b, &D)) != PSTM_OKAY) {
+			goto LBL_D;
+		}
+	}
+	if ((res = pstm_copy (&D, c)) != PSTM_OKAY) {
+		goto LBL_D;
+	}
+	c->sign = neg;
+	res = PSTM_OKAY;
+
+LBL_D: pstm_clear(&D);
+LBL_B: pstm_clear(&B);
+LBL_V: pstm_clear(&v);
+LBL_U: pstm_clear(&u);
+LBL_Y: pstm_clear(&y);
+LBL_X: pstm_clear(&x);
+	return res;
+}
+#endif /* !DISABLE_PSTM */
+/******************************************************************************/
diff -urpN busybox-1.26.2/networking/tls_pstm.h busybox-1.27.0/networking/tls_pstm.h
--- busybox-1.26.2/networking/tls_pstm.h	1970-01-01 01:00:00.000000000 +0100
+++ busybox-1.27.0/networking/tls_pstm.h	2017-04-05 18:27:36.000000000 +0200
@@ -0,0 +1,286 @@
+/*
+ * Copyright (C) 2017 Denys Vlasenko
+ *
+ * Licensed under GPLv2, see file LICENSE in this source tree.
+ */
+/* The file is taken almost verbatim from matrixssl-3-7-2b-open/crypto/math/.
+ * Changes are flagged with //bbox
+ */
+
+/**
+ *	@file    pstm.h
+ *	@version 33ef80f (HEAD, tag: MATRIXSSL-3-7-2-OPEN, tag: MATRIXSSL-3-7-2-COMM, origin/master, origin/HEAD, master)
+ *
+ *	multiple-precision integer library.
+ */
+/*
+ *	Copyright (c) 2013-2015 INSIDE Secure Corporation
+ *	Copyright (c) PeerSec Networks, 2002-2011
+ *	All Rights Reserved
+ *
+ *	The latest version of this code is available at http://www.matrixssl.org
+ *
+ *	This software is open source; you can redistribute it and/or modify
+ *	it under the terms of the GNU General Public License as published by
+ *	the Free Software Foundation; either version 2 of the License, or
+ *	(at your option) any later version.
+ *
+ *	This General Public License does NOT permit incorporating this software
+ *	into proprietary programs.  If you are unable to comply with the GPL, a
+ *	commercial license for this software may be purchased from INSIDE at
+ *	http://www.insidesecure.com/eng/Company/Locations
+ *
+ *	This program is distributed in WITHOUT ANY WARRANTY; without even the
+ *	implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
+ *	See the GNU General Public License for more details.
+ *
+ *	You should have received a copy of the GNU General Public License
+ *	along with this program; if not, write to the Free Software
+ *	Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+ *	http://www.gnu.org/copyleft/gpl.html
+ */
+/******************************************************************************/
+
+#ifndef _h_PSTMATH
+#define _h_PSTMATH
+#ifndef DISABLE_PSTM
+
+/* Define this here to avoid including circular limits.h on some platforms */
+#ifndef CHAR_BIT
+#define CHAR_BIT	8
+#endif
+
+/******************************************************************************/
+/*
+	If native 64 bit integers are not supported, we do not support 32x32->64
+	in hardware, so we must set the 16 bit flag to produce 16x16->32 products.
+*/
+#ifndef HAVE_NATIVE_INT64
+	#define PSTM_16BIT
+#endif /* ! HAVE_NATIVE_INT64 */
+
+/******************************************************************************/
+/*
+	Some default configurations.
+
+	pstm_word should be the largest value the processor can hold as the product
+		of a multiplication. Most platforms support a 32x32->64 MAC instruction,
+		so 64bits is the default pstm_word size.
+	pstm_digit should be half the size of pstm_word
+ */
+#ifdef PSTM_8BIT
+/*	8-bit digits, 16-bit word products */
+	typedef unsigned char		pstm_digit;
+	typedef unsigned short		pstm_word;
+	#define DIGIT_BIT			8
+
+#elif defined(PSTM_16BIT)
+/*	16-bit digits, 32-bit word products */
+	typedef unsigned short		pstm_digit;
+	typedef unsigned long		pstm_word;
+	#define	DIGIT_BIT			16
+
+#elif defined(PSTM_64BIT)
+/*	64-bit digits, 128-bit word products */
+	#ifndef __GNUC__
+	#error "64bit digits requires GCC"
+	#endif
+	typedef unsigned long		pstm_digit;
+	typedef unsigned long		pstm_word __attribute__ ((mode(TI)));
+	#define DIGIT_BIT			64
+
+#else
+/*	This is the default case, 32-bit digits, 64-bit word products */
+	typedef uint32			pstm_digit;
+	typedef uint64			pstm_word;
+	#define DIGIT_BIT		32
+	#define PSTM_32BIT
+#endif /* digit and word size */
+
+#define PSTM_MASK			(pstm_digit)(-1)
+#define PSTM_DIGIT_MAX		PSTM_MASK
+
+/******************************************************************************/
+/*
+	equalities
+ */
+#define PSTM_LT			-1		/* less than */
+#define PSTM_EQ			0		/* equal to */
+#define PSTM_GT			1		/* greater than */
+
+#define PSTM_ZPOS		0		/* positive integer */
+#define PSTM_NEG		1		/* negative */
+
+#define PSTM_OKAY		PS_SUCCESS
+#define PSTM_MEM		PS_MEM_FAIL
+
+/******************************************************************************/
+/*
+	Various build options
+ */
+#define PSTM_DEFAULT_INIT 64		/* default (64) digits of allocation */
+#define PSTM_MAX_SIZE	4096
+
+typedef struct  {
+	int	used, alloc, sign; //bbox: was int16
+	pstm_digit	*dp;
+//bbox	psPool_t	*pool;
+} pstm_int;
+
+/******************************************************************************/
+/*
+	Operations on large integers
+ */
+#define pstm_iszero(a) (((a)->used == 0) ? PS_TRUE : PS_FALSE)
+#define pstm_iseven(a) (((a)->used > 0 && (((a)->dp[0] & 1) == 0)) ? PS_TRUE : PS_FALSE)
+#define pstm_isodd(a)  (((a)->used > 0 && (((a)->dp[0] & 1) == 1)) ? PS_TRUE : PS_FALSE)
+#define pstm_abs(a, b)  { pstm_copy(a, b); (b)->sign  = 0; }
+
+extern void pstm_set(pstm_int *a, pstm_digit b);
+
+extern void pstm_zero(pstm_int * a);
+
+//bbox: pool unused
+#define pstm_init(pool, a) \
+        pstm_init(      a)
+extern int32 pstm_init(psPool_t *pool, pstm_int * a);
+
+//bbox: pool unused
+#define pstm_init_size(pool, a, size) \
+        pstm_init_size(      a, size)
+extern int32 pstm_init_size(psPool_t *pool, pstm_int * a, uint32 size);
+
+//bbox: pool unused
+#define pstm_init_copy(pool, a, b, toSqr) \
+        pstm_init_copy(      a, b, toSqr)
+extern int32 pstm_init_copy(psPool_t *pool, pstm_int * a, pstm_int * b,
+				int toSqr); //bbox: was int16 toSqr
+
+extern int pstm_count_bits (pstm_int * a); //bbox: was returning int16
+
+//bbox: pool unused
+#define pstm_init_for_read_unsigned_bin(pool, a, len) \
+        pstm_init_for_read_unsigned_bin(      a, len)
+extern int32 pstm_init_for_read_unsigned_bin(psPool_t *pool, pstm_int *a,
+				uint32 len);
+
+extern int32 pstm_read_unsigned_bin(pstm_int *a, unsigned char *b, int32 c);
+
+extern int32 pstm_unsigned_bin_size(pstm_int *a);
+
+extern int32 pstm_copy(pstm_int * a, pstm_int * b);
+
+extern void pstm_exch(pstm_int * a, pstm_int * b);
+
+extern void pstm_clear(pstm_int * a);
+
+extern void pstm_clear_multi(pstm_int *mp0, pstm_int *mp1, pstm_int *mp2,
+				pstm_int *mp3, pstm_int *mp4, pstm_int *mp5, pstm_int *mp6,
+				pstm_int *mp7);
+
+extern int32 pstm_grow(pstm_int * a, int size); //bbox: was int16 size
+
+extern void pstm_clamp(pstm_int * a);
+
+extern int32 pstm_cmp(pstm_int * a, pstm_int * b);
+
+extern int32 pstm_cmp_mag(pstm_int * a, pstm_int * b);
+
+extern void pstm_rshd(pstm_int *a, int x); //bbox: was int16 x
+
+extern int32 pstm_lshd(pstm_int * a, int b); //bbox: was int16 b
+
+//bbox: pool unused
+#define pstm_div(pool, a, b, c, d) \
+        pstm_div(      a, b, c, d)
+extern int32 pstm_div(psPool_t *pool, pstm_int *a, pstm_int *b, pstm_int *c,
+				pstm_int *d);
+
+//bbox: pool unused
+#define pstm_div_2d(pool, a, b, c, d) \
+        pstm_div_2d(      a, b, c, d)
+extern int32 pstm_div_2d(psPool_t *pool, pstm_int *a, int b, pstm_int *c,
+				pstm_int *d); //bbox: was int16 b
+
+extern int32 pstm_div_2(pstm_int * a, pstm_int * b);
+
+extern int32 s_pstm_sub(pstm_int *a, pstm_int *b, pstm_int *c);
+
+extern int32 pstm_sub(pstm_int *a, pstm_int *b, pstm_int *c);
+
+//bbox: pool unused
+#define pstm_sub_d(pool, a, b, c) \
+        pstm_sub_d(      a, b, c)
+extern int32 pstm_sub_d(psPool_t *pool, pstm_int *a, pstm_digit b, pstm_int *c);
+
+extern int32 pstm_mul_2(pstm_int * a, pstm_int * b);
+
+//bbox: pool unused
+#define pstm_mod(pool, a, b, c) \
+        pstm_mod(      a, b, c)
+extern int32 pstm_mod(psPool_t *pool, pstm_int *a, pstm_int *b, pstm_int *c);
+
+//bbox: pool unused
+#define pstm_mulmod(pool, a, b, c, d) \
+        pstm_mulmod(      a, b, c, d)
+extern int32 pstm_mulmod(psPool_t *pool, pstm_int *a, pstm_int *b, pstm_int *c,
+				pstm_int *d);
+
+//bbox: pool unused
+#define pstm_exptmod(pool, G, X, P, Y) \
+        pstm_exptmod(      G, X, P, Y)
+extern int32 pstm_exptmod(psPool_t *pool, pstm_int *G, pstm_int *X, pstm_int *P,
+				pstm_int *Y);
+
+extern int32 pstm_2expt(pstm_int *a, int b); //bbox: was int16 b
+
+extern int32 pstm_add(pstm_int *a, pstm_int *b, pstm_int *c);
+
+//bbox: pool unused
+#define pstm_to_unsigned_bin(pool, a, b) \
+        pstm_to_unsigned_bin(      a, b)
+extern int32 pstm_to_unsigned_bin(psPool_t *pool, pstm_int *a,
+				unsigned char *b);
+
+//bbox: pool unused
+#define pstm_to_unsigned_bin_nr(pool, a, b) \
+        pstm_to_unsigned_bin_nr(      a, b)
+extern int32 pstm_to_unsigned_bin_nr(psPool_t *pool, pstm_int *a,
+				unsigned char *b);
+
+extern int32 pstm_montgomery_setup(pstm_int *a, pstm_digit *rho);
+
+//bbox: pool unused
+#define pstm_montgomery_reduce(pool, a, m, mp, paD, paDlen) \
+        pstm_montgomery_reduce(      a, m, mp, paD, paDlen)
+extern int32 pstm_montgomery_reduce(psPool_t *pool, pstm_int *a, pstm_int *m,
+				pstm_digit mp, pstm_digit *paD, uint32 paDlen);
+
+#define pstm_mul_comba(pool, A, B, C, paD, paDlen) \
+        pstm_mul_comba(      A, B, C, paD, paDlen)
+extern int32 pstm_mul_comba(psPool_t *pool, pstm_int *A, pstm_int *B,
+				pstm_int *C, pstm_digit *paD, uint32 paDlen);
+
+//bbox: pool unused
+#define pstm_sqr_comba(pool, A, B, paD, paDlen) \
+        pstm_sqr_comba(      A, B, paD, paDlen)
+extern int32 pstm_sqr_comba(psPool_t *pool, pstm_int *A, pstm_int *B,
+				pstm_digit *paD, uint32 paDlen);
+
+extern int32 pstm_cmp_d(pstm_int *a, pstm_digit b);
+
+extern int32 pstm_montgomery_calc_normalization(pstm_int *a, pstm_int *b);
+
+extern int32 pstm_mul_d(pstm_int *a, pstm_digit b, pstm_int *c);
+
+//bbox: pool unused
+#define pstm_invmod(pool, a, b, c) \
+        pstm_invmod(      a, b, c)
+extern int32 pstm_invmod(psPool_t *pool, pstm_int * a, pstm_int * b,
+				pstm_int * c);
+
+#else /* DISABLE_PSTM */
+	typedef int32 pstm_int;
+#endif /* !DISABLE_PSTM */
+#endif /* _h_PSTMATH */
+
diff -urpN busybox-1.26.2/networking/tls_pstm_montgomery_reduce.c busybox-1.27.0/networking/tls_pstm_montgomery_reduce.c
--- busybox-1.26.2/networking/tls_pstm_montgomery_reduce.c	1970-01-01 01:00:00.000000000 +0100
+++ busybox-1.27.0/networking/tls_pstm_montgomery_reduce.c	2017-01-19 16:21:18.000000000 +0100
@@ -0,0 +1,427 @@
+/*
+ * Copyright (C) 2017 Denys Vlasenko
+ *
+ * Licensed under GPLv2, see file LICENSE in this source tree.
+ */
+#include "tls.h"
+
+/* The file is taken almost verbatim from matrixssl-3-7-2b-open/crypto/math/.
+ * Changes are flagged with //bbox
+ */
+
+/**
+ *	@file    pstm_montgomery_reduce.c
+ *	@version 33ef80f (HEAD, tag: MATRIXSSL-3-7-2-OPEN, tag: MATRIXSSL-3-7-2-COMM, origin/master, origin/HEAD, master)
+ *
+ *	Multiprecision Montgomery Reduction.
+ */
+/*
+ *	Copyright (c) 2013-2015 INSIDE Secure Corporation
+ *	Copyright (c) PeerSec Networks, 2002-2011
+ *	All Rights Reserved
+ *
+ *	The latest version of this code is available at http://www.matrixssl.org
+ *
+ *	This software is open source; you can redistribute it and/or modify
+ *	it under the terms of the GNU General Public License as published by
+ *	the Free Software Foundation; either version 2 of the License, or
+ *	(at your option) any later version.
+ *
+ *	This General Public License does NOT permit incorporating this software
+ *	into proprietary programs.  If you are unable to comply with the GPL, a
+ *	commercial license for this software may be purchased from INSIDE at
+ *	http://www.insidesecure.com/eng/Company/Locations
+ *
+ *	This program is distributed in WITHOUT ANY WARRANTY; without even the
+ *	implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
+ *	See the GNU General Public License for more details.
+ *
+ *	You should have received a copy of the GNU General Public License
+ *	along with this program; if not, write to the Free Software
+ *	Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+ *	http://www.gnu.org/copyleft/gpl.html
+ */
+/******************************************************************************/
+
+//bbox
+//#include "../cryptoApi.h"
+#ifndef DISABLE_PSTM
+
+/******************************************************************************/
+
+#if defined(PSTM_X86)
+/* x86-32 optimized for 32 bit platforms. For 64 bit mode use X86_64 instead */
+#if !defined(__GNUC__) || !defined(__i386__) || !defined(PSTM_32BIT)
+#error "PSTM_X86 option requires GCC and 32 bit mode x86 processor"
+#endif
+//#pragma message ("Using 32 bit x86 Assembly Optimizations")
+
+#define MONT_START
+#define MONT_FINI
+#define LOOP_END
+#define LOOP_START \
+   mu = c[x] * mp
+
+#define INNERMUL                                          \
+asm(                                                      \
+   "movl %5,%%eax \n\t"                                   \
+   "mull %4       \n\t"                                   \
+   "addl %1,%%eax \n\t"                                   \
+   "adcl $0,%%edx \n\t"                                   \
+   "addl %%eax,%0 \n\t"                                   \
+   "adcl $0,%%edx \n\t"                                   \
+   "movl %%edx,%1 \n\t"                                   \
+:"=g"(_c[LO]), "=r"(cy)                                   \
+:"0"(_c[LO]), "1"(cy), "g"(mu), "g"(*tmpm++)              \
+: "%eax", "%edx", "%cc")
+
+#define PROPCARRY                           \
+asm(                                        \
+   "addl   %1,%0    \n\t"                   \
+   "setb   %%al     \n\t"                   \
+   "movzbl %%al,%1 \n\t"                    \
+:"=g"(_c[LO]), "=r"(cy)                     \
+:"0"(_c[LO]), "1"(cy)                       \
+: "%eax", "%cc")
+
+/******************************************************************************/
+#elif defined(PSTM_X86_64)
+/* x86-64 optimized */
+#if !defined(__GNUC__) || !defined(__x86_64__) || !defined(PSTM_64BIT)
+#error "PSTM_X86_64 option requires PSTM_64BIT, GCC and 64 bit mode x86 processor"
+#endif
+//#pragma message ("Using 64 bit x86_64 Assembly Optimizations")
+
+#define MONT_START
+#define MONT_FINI
+#define LOOP_END
+#define LOOP_START \
+mu = c[x] * mp
+
+#define INNERMUL                                           \
+asm(                                                       \
+	"movq %5,%%rax \n\t"                                   \
+	"mulq %4       \n\t"                                   \
+	"addq %1,%%rax \n\t"                                   \
+	"adcq $0,%%rdx \n\t"                                   \
+	"addq %%rax,%0 \n\t"                                   \
+	"adcq $0,%%rdx \n\t"                                   \
+	"movq %%rdx,%1 \n\t"                                   \
+	:"=g"(_c[LO]), "=r"(cy)                                \
+	:"0"(_c[LO]), "1"(cy), "r"(mu), "r"(*tmpm++)           \
+	: "%rax", "%rdx", "cc")
+
+#define INNERMUL8				\
+asm(							\
+	"movq 0(%5),%%rax    \n\t"  \
+	"movq 0(%2),%%r10    \n\t"  \
+	"movq 0x8(%5),%%r11  \n\t"  \
+	"mulq %4             \n\t"  \
+	"addq %%r10,%%rax    \n\t"  \
+	"adcq $0,%%rdx       \n\t"  \
+	"movq 0x8(%2),%%r10  \n\t"  \
+	"addq %3,%%rax       \n\t"  \
+	"adcq $0,%%rdx       \n\t"  \
+	"movq %%rax,0(%0)    \n\t"  \
+	"movq %%rdx,%1       \n\t"  \
+	\
+	"movq %%r11,%%rax    \n\t"  \
+	"movq 0x10(%5),%%r11 \n\t"  \
+	"mulq %4             \n\t"  \
+	"addq %%r10,%%rax    \n\t"  \
+	"adcq $0,%%rdx       \n\t"  \
+	"movq 0x10(%2),%%r10 \n\t"  \
+	"addq %3,%%rax       \n\t"  \
+	"adcq $0,%%rdx       \n\t"  \
+	"movq %%rax,0x8(%0)  \n\t"  \
+	"movq %%rdx,%1       \n\t"  \
+	\
+	"movq %%r11,%%rax    \n\t"  \
+	"movq 0x18(%5),%%r11 \n\t"  \
+	"mulq %4             \n\t"  \
+	"addq %%r10,%%rax    \n\t"  \
+	"adcq $0,%%rdx       \n\t"  \
+	"movq 0x18(%2),%%r10 \n\t"  \
+	"addq %3,%%rax       \n\t"  \
+	"adcq $0,%%rdx       \n\t"  \
+	"movq %%rax,0x10(%0) \n\t"  \
+	"movq %%rdx,%1       \n\t"  \
+	\
+	"movq %%r11,%%rax    \n\t"  \
+	"movq 0x20(%5),%%r11 \n\t"  \
+	"mulq %4             \n\t"  \
+	"addq %%r10,%%rax    \n\t"  \
+	"adcq $0,%%rdx       \n\t"  \
+	"movq 0x20(%2),%%r10 \n\t"  \
+	"addq %3,%%rax       \n\t"  \
+	"adcq $0,%%rdx       \n\t"  \
+	"movq %%rax,0x18(%0) \n\t"  \
+	"movq %%rdx,%1       \n\t"  \
+	\
+	"movq %%r11,%%rax    \n\t"  \
+	"movq 0x28(%5),%%r11 \n\t"  \
+	"mulq %4             \n\t"  \
+	"addq %%r10,%%rax    \n\t"  \
+	"adcq $0,%%rdx       \n\t"  \
+	"movq 0x28(%2),%%r10 \n\t"  \
+	"addq %3,%%rax       \n\t"  \
+	"adcq $0,%%rdx       \n\t"  \
+	"movq %%rax,0x20(%0) \n\t"  \
+	"movq %%rdx,%1       \n\t"  \
+	\
+	"movq %%r11,%%rax    \n\t"  \
+	"movq 0x30(%5),%%r11 \n\t"  \
+	"mulq %4             \n\t"  \
+	"addq %%r10,%%rax    \n\t"  \
+	"adcq $0,%%rdx       \n\t"  \
+	"movq 0x30(%2),%%r10 \n\t"  \
+	"addq %3,%%rax       \n\t"  \
+	"adcq $0,%%rdx       \n\t"  \
+	"movq %%rax,0x28(%0) \n\t"  \
+	"movq %%rdx,%1       \n\t"  \
+	\
+	"movq %%r11,%%rax    \n\t"  \
+	"movq 0x38(%5),%%r11 \n\t"  \
+	"mulq %4             \n\t"  \
+	"addq %%r10,%%rax    \n\t"  \
+	"adcq $0,%%rdx       \n\t"  \
+	"movq 0x38(%2),%%r10 \n\t"  \
+	"addq %3,%%rax       \n\t"  \
+	"adcq $0,%%rdx       \n\t"  \
+	"movq %%rax,0x30(%0) \n\t"  \
+	"movq %%rdx,%1       \n\t"  \
+	\
+	"movq %%r11,%%rax    \n\t"  \
+	"mulq %4             \n\t"  \
+	"addq %%r10,%%rax    \n\t"  \
+	"adcq $0,%%rdx       \n\t"  \
+	"addq %3,%%rax       \n\t"  \
+	"adcq $0,%%rdx       \n\t"  \
+	"movq %%rax,0x38(%0) \n\t"  \
+	"movq %%rdx,%1       \n\t"  \
+	\
+	:"=r"(_c), "=r"(cy)                    \
+	: "0"(_c),  "1"(cy), "g"(mu), "r"(tmpm)\
+	: "%rax", "%rdx", "%r10", "%r11", "cc")
+
+#define PROPCARRY                          \
+asm(                                       \
+	"addq   %1,%0    \n\t"                 \
+	"setb   %%al     \n\t"                 \
+	"movzbq %%al,%1 \n\t"                  \
+	:"=g"(_c[LO]), "=r"(cy)                \
+	:"0"(_c[LO]), "1"(cy)                  \
+	: "%rax", "cc")
+
+/******************************************************************************/
+#elif defined(PSTM_ARM)
+
+#define MONT_START
+#define MONT_FINI
+#define LOOP_END
+#define LOOP_START \
+mu = c[x] * mp
+
+#ifdef __thumb2__
+//#pragma message ("Using 32 bit ARM Thumb2 Assembly Optimizations")
+#define INNERMUL                    \
+asm(                                \
+	" LDR    r0,%1            \n\t" \
+	" ADDS   r0,r0,%0         \n\t" \
+	" ITE CS                  \n\t" \
+	" MOVCS  %0,#1            \n\t" \
+	" MOVCC  %0,#0            \n\t" \
+	" UMLAL  r0,%0,%3,%4      \n\t" \
+	" STR    r0,%1            \n\t" \
+	:"=r"(cy),"=m"(_c[0])\
+	:"0"(cy),"r"(mu),"r"(*tmpm++),"m"(_c[0])\
+	:"r0","%cc");
+#define PROPCARRY                  \
+asm(                               \
+	" LDR   r0,%1            \n\t" \
+	" ADDS  r0,r0,%0         \n\t" \
+	" STR   r0,%1            \n\t" \
+	" ITE CS                 \n\t" \
+	" MOVCS %0,#1            \n\t" \
+	" MOVCC %0,#0            \n\t" \
+	:"=r"(cy),"=m"(_c[0])\
+	:"0"(cy),"m"(_c[0])\
+	:"r0","%cc");
+#else /* Non-Thumb2 code */
+//#pragma message ("Using 32 bit ARM Assembly Optimizations")
+#define INNERMUL                    \
+asm(                                \
+	" LDR    r0,%1            \n\t" \
+	" ADDS   r0,r0,%0         \n\t" \
+	" MOVCS  %0,#1            \n\t" \
+	" MOVCC  %0,#0            \n\t" \
+	" UMLAL  r0,%0,%3,%4      \n\t" \
+	" STR    r0,%1            \n\t" \
+	:"=r"(cy),"=m"(_c[0])\
+	:"0"(cy),"r"(mu),"r"(*tmpm++),"m"(_c[0])\
+	:"r0","%cc");
+#define PROPCARRY                  \
+asm(                               \
+	" LDR   r0,%1            \n\t" \
+	" ADDS  r0,r0,%0         \n\t" \
+	" STR   r0,%1            \n\t" \
+	" MOVCS %0,#1            \n\t" \
+	" MOVCC %0,#0            \n\t" \
+	:"=r"(cy),"=m"(_c[0])\
+	:"0"(cy),"m"(_c[0])\
+	:"r0","%cc");
+#endif /* __thumb2__ */
+
+
+/******************************************************************************/
+#elif defined(PSTM_MIPS)
+/* MIPS32 */
+//#pragma message ("Using 32 bit MIPS Assembly Optimizations")
+#define MONT_START
+#define MONT_FINI
+#define LOOP_END
+#define LOOP_START \
+mu = c[x] * mp
+
+#define INNERMUL                      \
+asm(								  \
+	" multu    %3,%4          \n\t"   \
+	" mflo     $12            \n\t"   \
+	" mfhi     $13            \n\t"   \
+	" addu     $12,$12,%0     \n\t"   \
+	" sltu     $10,$12,%0     \n\t"   \
+	" addu     $13,$13,$10    \n\t"   \
+	" lw       $10,%1         \n\t"   \
+	" addu     $12,$12,$10    \n\t"   \
+	" sltu     $10,$12,$10    \n\t"   \
+	" addu     %0,$13,$10     \n\t"   \
+	" sw       $12,%1         \n\t"   \
+	:"=r"(cy),"=m"(_c[0])\
+	:"r"(cy),"r"(mu),"r"(tmpm[0]),"r"(_c[0])\
+	:"$10","$12","$13")\
+; ++tmpm;
+
+#define PROPCARRY                     \
+asm(                                  \
+	" lw       $10,%1        \n\t"    \
+	" addu     $10,$10,%0    \n\t"    \
+	" sw       $10,%1        \n\t"    \
+	" sltu     %0,$10,%0     \n\t"    \
+	:"=r"(cy),"=m"(_c[0])\
+	:"r"(cy),"r"(_c[0])\
+	:"$10");
+
+
+/******************************************************************************/
+#else
+
+/* ISO C code */
+#define MONT_START
+#define MONT_FINI
+#define LOOP_END
+#define LOOP_START \
+   mu = c[x] * mp
+
+#define INNERMUL										\
+	do { pstm_word t;									\
+		t = ((pstm_word)_c[0] + (pstm_word)cy) +		\
+			(((pstm_word)mu) * ((pstm_word)*tmpm++));	\
+		_c[0] = (pstm_digit)t;							\
+		cy = (pstm_digit)(t >> DIGIT_BIT);				\
+	} while (0)
+
+#define PROPCARRY \
+   do { pstm_digit t = _c[0] += cy; cy = (t < cy); } while (0)
+
+#endif
+
+/******************************************************************************/
+
+#define LO 0
+
+/* computes x/R == x (mod N) via Montgomery Reduction */
+int32 pstm_montgomery_reduce(psPool_t *pool, pstm_int *a, pstm_int *m,
+		pstm_digit mp, pstm_digit *paD, uint32 paDlen)
+{
+	pstm_digit	*c, *_c, *tmpm, mu;
+	int32		oldused, x, y;
+	int16		pa;
+
+	pa = m->used;
+	if (pa > a->alloc) {
+		/* Sanity test for bad numbers.  This will confirm no buffer overruns */
+		return PS_LIMIT_FAIL;
+	}
+
+	if (paD && paDlen >= (uint32)2*pa+1) {
+		c = paD;
+		memset(c, 0x0, paDlen);
+	} else {
+		c = xzalloc(2*pa+1);//bbox
+	}
+	/* copy the input */
+	oldused = a->used;
+	for (x = 0; x < oldused; x++) {
+		c[x] = a->dp[x];
+	}
+
+	MONT_START;
+
+	for (x = 0; x < pa; x++) {
+		pstm_digit cy = 0;
+		/* get Mu for this round */
+		LOOP_START;
+		_c   = c + x;
+		tmpm = m->dp;
+		y = 0;
+#ifdef PSTM_X86_64
+		for (; y < (pa & ~7); y += 8) {
+			INNERMUL8;
+			_c   += 8;
+			tmpm += 8;
+		}
+#endif /* PSTM_X86_64 */
+		for (; y < pa; y++) {
+			INNERMUL;
+			++_c;
+		}
+		LOOP_END;
+		while (cy) {
+			PROPCARRY;
+			++_c;
+		}
+	}
+
+	/* now copy out */
+	_c   = c + pa;
+	tmpm = a->dp;
+	for (x = 0; x < pa+1; x++) {
+		*tmpm++ = *_c++;
+	}
+
+	for (; x < oldused; x++)   {
+		*tmpm++ = 0;
+	}
+
+	MONT_FINI;
+
+	a->used = pa+1;
+	pstm_clamp(a);
+
+	/* reuse x as return code */
+	x = PSTM_OKAY;
+
+	/* if A >= m then A = A - m */
+	if (pstm_cmp_mag (a, m) != PSTM_LT) {
+		if (s_pstm_sub (a, m, a) != PSTM_OKAY) {
+			x = PS_MEM_FAIL;
+		}
+	}
+	if (paDlen < (uint32)2*pa+1) {
+		psFree(c, pool);
+	}
+	return x;
+}
+
+#endif /* !DISABLE_PSTM */
+/******************************************************************************/
diff -urpN busybox-1.26.2/networking/tls_pstm_mul_comba.c busybox-1.27.0/networking/tls_pstm_mul_comba.c
--- busybox-1.26.2/networking/tls_pstm_mul_comba.c	1970-01-01 01:00:00.000000000 +0100
+++ busybox-1.27.0/networking/tls_pstm_mul_comba.c	2017-01-19 16:21:18.000000000 +0100
@@ -0,0 +1,781 @@
+/*
+ * Copyright (C) 2017 Denys Vlasenko
+ *
+ * Licensed under GPLv2, see file LICENSE in this source tree.
+ */
+#include "tls.h"
+
+/* The file is taken almost verbatim from matrixssl-3-7-2b-open/crypto/math/.
+ * Changes are flagged with //bbox
+ */
+
+/**
+ *	@file    pstm_mul_comba.c
+ *	@version 33ef80f (HEAD, tag: MATRIXSSL-3-7-2-OPEN, tag: MATRIXSSL-3-7-2-COMM, origin/master, origin/HEAD, master)
+ *
+ *	Multiprecision multiplication with Comba technique.
+ */
+/*
+ *	Copyright (c) 2013-2015 INSIDE Secure Corporation
+ *	Copyright (c) PeerSec Networks, 2002-2011
+ *	All Rights Reserved
+ *
+ *	The latest version of this code is available at http://www.matrixssl.org
+ *
+ *	This software is open source; you can redistribute it and/or modify
+ *	it under the terms of the GNU General Public License as published by
+ *	the Free Software Foundation; either version 2 of the License, or
+ *	(at your option) any later version.
+ *
+ *	This General Public License does NOT permit incorporating this software
+ *	into proprietary programs.  If you are unable to comply with the GPL, a
+ *	commercial license for this software may be purchased from INSIDE at
+ *	http://www.insidesecure.com/eng/Company/Locations
+ *
+ *	This program is distributed in WITHOUT ANY WARRANTY; without even the
+ *	implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
+ *	See the GNU General Public License for more details.
+ *
+ *	You should have received a copy of the GNU General Public License
+ *	along with this program; if not, write to the Free Software
+ *	Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+ *	http://www.gnu.org/copyleft/gpl.html
+ */
+/******************************************************************************/
+
+//bbox
+//#include "../cryptoApi.h"
+#ifndef DISABLE_PSTM
+
+/******************************************************************************/
+#if defined(PSTM_X86)
+/* x86-32 optimized for 32 bit platforms. For 64 bit mode use X86_64 instead */
+#if !defined(__GNUC__) || !defined(__i386__) || !defined(PSTM_32BIT)
+#error "PSTM_X86 option requires GCC and 32 bit mode x86 processor"
+#endif
+//#pragma message ("Using 32 bit x86 Assembly Optimizations")
+
+/* anything you need at the start */
+#define COMBA_START
+
+/* clear the chaining variables */
+#define COMBA_CLEAR \
+   c0 = c1 = c2 = 0;
+
+/* forward the carry to the next digit */
+#define COMBA_FORWARD \
+   do { c0 = c1; c1 = c2; c2 = 0; } while (0);
+
+/* store the first sum */
+#define COMBA_STORE(x) \
+   x = c0;
+
+/* store the second sum [carry] */
+#define COMBA_STORE2(x) \
+   x = c1;
+
+/* anything you need at the end */
+#define COMBA_FINI
+
+/* this should multiply i and j  */
+#define MULADD(i, j)                                      \
+asm(                                                      \
+	 "movl  %6,%%eax     \n\t"                            \
+	 "mull  %7           \n\t"                            \
+	 "addl  %%eax,%0     \n\t"                            \
+	 "adcl  %%edx,%1     \n\t"                            \
+	 "adcl  $0,%2        \n\t"                            \
+	 :"=r"(c0), "=r"(c1), "=r"(c2): "0"(c0), "1"(c1), "2"(c2), "m"(i), "m"(j)  :"%eax","%edx","%cc");
+
+/******************************************************************************/
+#elif defined(PSTM_X86_64)
+/* x86-64 optimized */
+#if !defined(__GNUC__) || !defined(__x86_64__) || !defined(PSTM_64BIT)
+#error "PSTM_X86_64 option requires PSTM_64BIT, GCC and 64 bit mode x86 processor"
+#endif
+//#pragma message ("Using 64 bit x86_64 Assembly Optimizations")
+
+/* anything you need at the start */
+#define COMBA_START
+
+/* clear the chaining variables */
+#define COMBA_CLEAR \
+c0 = c1 = c2 = 0;
+
+/* forward the carry to the next digit */
+#define COMBA_FORWARD \
+do { c0 = c1; c1 = c2; c2 = 0; } while (0);
+
+/* store the first sum */
+#define COMBA_STORE(x) \
+x = c0;
+
+/* store the second sum [carry] */
+#define COMBA_STORE2(x) \
+x = c1;
+
+/* anything you need at the end */
+#define COMBA_FINI
+
+/* this should multiply i and j  */
+#define MULADD(i, j)									\
+asm  (													\
+	"movq  %6,%%rax     \n\t"                            \
+	"mulq  %7           \n\t"                            \
+	"addq  %%rax,%0     \n\t"                            \
+	"adcq  %%rdx,%1     \n\t"                            \
+	"adcq  $0,%2        \n\t"                            \
+	:"=r"(c0), "=r"(c1), "=r"(c2): "0"(c0), "1"(c1), "2"(c2), "g"(i), "g"(j)  :"%rax","%rdx","cc");
+
+/******************************************************************************/
+#elif defined(PSTM_ARM)
+/* ARM code */
+//#pragma message ("Using 32 bit ARM Assembly Optimizations")
+
+#define COMBA_START
+
+#define COMBA_CLEAR \
+c0 = c1 = c2 = 0;
+
+#define COMBA_FORWARD \
+do { c0 = c1; c1 = c2; c2 = 0; } while (0);
+
+#define COMBA_STORE(x) \
+x = c0;
+
+#define COMBA_STORE2(x) \
+x = c1;
+
+#define COMBA_FINI
+
+#define MULADD(i, j)                                          \
+asm(                                                          \
+	"  UMULL  r0,r1,%6,%7           \n\t"                     \
+	"  ADDS   %0,%0,r0              \n\t"                     \
+	"  ADCS   %1,%1,r1              \n\t"                     \
+	"  ADC    %2,%2,#0              \n\t"                     \
+	:"=r"(c0), "=r"(c1), "=r"(c2) : "0"(c0), "1"(c1), "2"(c2), "r"(i), "r"(j) : "r0", "r1", "%cc");
+
+/******************************************************************************/
+#elif defined(PSTM_MIPS)
+/* MIPS32 code */
+//#pragma message ("Using 32 bit MIPS Assembly Optimizations")
+
+#define COMBA_START
+
+#define COMBA_CLEAR \
+c0 = c1 = c2 = 0;
+
+#define COMBA_FORWARD \
+do { c0 = c1; c1 = c2; c2 = 0; } while (0);
+
+#define COMBA_STORE(x) \
+x = c0;
+
+#define COMBA_STORE2(x) \
+x = c1;
+
+#define COMBA_FINI
+
+#define MULADD(i, j)               \
+asm(                               \
+	" multu  %6,%7          \n\t"  \
+	" mflo   $12            \n\t"  \
+	" mfhi   $13            \n\t"  \
+	" addu    %0,%0,$12     \n\t"  \
+	" sltu   $12,%0,$12     \n\t"  \
+	" addu    %1,%1,$13     \n\t"  \
+	" sltu   $13,%1,$13     \n\t"  \
+	" addu    %1,%1,$12     \n\t"  \
+	" sltu   $12,%1,$12     \n\t"  \
+	" addu    %2,%2,$13     \n\t"  \
+	" addu    %2,%2,$12     \n\t"  \
+	:"=r"(c0), "=r"(c1), "=r"(c2):"0"(c0), "1"(c1), "2"(c2), "r"(i), "r"(j):"$12","$13");
+
+/******************************************************************************/
+#else
+
+#define COMBA_START
+
+#define COMBA_CLEAR \
+   c0 = c1 = c2 = 0;
+
+#define COMBA_FORWARD \
+   do { c0 = c1; c1 = c2; c2 = 0; } while (0);
+
+#define COMBA_STORE(x) \
+   x = c0;
+
+#define COMBA_STORE2(x) \
+   x = c1;
+
+#define COMBA_FINI
+
+#define MULADD(i, j)														\
+   do { pstm_word t;														\
+   t = (pstm_word)c0 + ((pstm_word)i) * ((pstm_word)j); c0 = (pstm_digit)t;	\
+   t = (pstm_word)c1 + (t >> DIGIT_BIT);									\
+   c1 = (pstm_digit)t; c2 += (pstm_digit)(t >> DIGIT_BIT);					\
+   } while (0);
+
+#endif
+
+/******************************************************************************/
+/* generic PxQ multiplier */
+//bbox: pool unused
+#define pstm_mul_comba_gen(pool, A, B, C, paD, paDlen) \
+        pstm_mul_comba_gen(      A, B, C, paD, paDlen)
+static int32 pstm_mul_comba_gen(psPool_t *pool, pstm_int *A, pstm_int *B,
+			pstm_int *C, pstm_digit *paD, uint32 paDlen)
+{
+	int16		paDfail, pa;
+	int32       ix, iy, iz, tx, ty;
+	pstm_digit	c0, c1, c2, *tmpx, *tmpy, *dst;
+
+	COMBA_START;
+	COMBA_CLEAR;
+
+	paDfail = 0;
+	/* get size of output and trim */
+	pa = A->used + B->used;
+
+/*
+	If c is not large enough grow it and continue
+*/
+	if (C->alloc < pa) {
+		if (pstm_grow(C, pa) != PSTM_OKAY) {
+			return PS_MEM_FAIL;
+		}
+	}
+	if (paD != NULL) {
+		if (paDlen < (sizeof(pstm_digit) * pa)) {
+			paDfail = 1; /* have a paD but it's not large enough */
+			dst = xzalloc(sizeof(pstm_digit) * pa);//bbox
+		} else {
+			dst = paD;
+			memset(dst, 0x0, paDlen);
+		}
+	} else {
+		dst = xzalloc(sizeof(pstm_digit) * pa);//bbox
+	}
+
+	for (ix = 0; ix < pa; ix++) {
+		/* get offsets into the two bignums */
+		ty = min(ix, B->used-1);
+		tx = ix - ty;
+
+		/* setup temp aliases */
+		tmpx = A->dp + tx;
+		tmpy = B->dp + ty;
+/*
+		This is the number of times the loop will iterate, essentially it's
+			while (tx++ < a->used && ty-- >= 0) { ... }
+*/
+		iy = min(A->used-tx, ty+1);
+
+		/* execute loop */
+		COMBA_FORWARD;
+		for (iz = 0; iz < iy; ++iz) {
+			MULADD(*tmpx++, *tmpy--);
+		}
+
+		/* store term */
+		COMBA_STORE(dst[ix]);
+	}
+	COMBA_FINI;
+/*
+	setup dest
+ */
+	iy  = C->used;
+	C->used = pa;
+	C->sign = A->sign ^ B->sign;
+	{
+		pstm_digit *tmpc;
+		tmpc = C->dp;
+		for (ix = 0; ix < pa; ix++) {
+			*tmpc++ = dst[ix];
+		}
+/*
+		clear unused digits [that existed in the old copy of c]
+ */
+		for (; ix < iy; ix++) {
+			*tmpc++ = 0;
+		}
+	}
+	pstm_clamp(C);
+
+	if ((paD == NULL) || (paDfail == 1)) {
+		psFree(dst, pool);
+	}
+
+	return PS_SUCCESS;
+}
+
+/******************************************************************************/
+#ifdef USE_1024_KEY_SPEED_OPTIMIZATIONS
+static int32 pstm_mul_comba16(pstm_int *A, pstm_int *B, pstm_int *C)
+{
+	pstm_digit c0, c1, c2, at[32];
+
+	if (C->alloc < 32) {
+		if (pstm_grow(C, 32) != PSTM_OKAY) {
+			return PS_MEM_FAIL;
+		}
+	}
+	memcpy(at, A->dp, 16 * sizeof(pstm_digit));
+	memcpy(at+16, B->dp, 16 * sizeof(pstm_digit));
+
+   COMBA_START;
+
+   COMBA_CLEAR;
+   /* 0 */
+   MULADD(at[0], at[16]);
+   COMBA_STORE(C->dp[0]);
+   /* 1 */
+   COMBA_FORWARD;
+   MULADD(at[0], at[17]);    MULADD(at[1], at[16]);
+   COMBA_STORE(C->dp[1]);
+   /* 2 */
+   COMBA_FORWARD;
+   MULADD(at[0], at[18]);    MULADD(at[1], at[17]);    MULADD(at[2], at[16]);
+   COMBA_STORE(C->dp[2]);
+   /* 3 */
+   COMBA_FORWARD;
+   MULADD(at[0], at[19]);    MULADD(at[1], at[18]);    MULADD(at[2], at[17]);    MULADD(at[3], at[16]);
+   COMBA_STORE(C->dp[3]);
+   /* 4 */
+   COMBA_FORWARD;
+   MULADD(at[0], at[20]);    MULADD(at[1], at[19]);    MULADD(at[2], at[18]);    MULADD(at[3], at[17]);    MULADD(at[4], at[16]);
+   COMBA_STORE(C->dp[4]);
+   /* 5 */
+   COMBA_FORWARD;
+   MULADD(at[0], at[21]);    MULADD(at[1], at[20]);    MULADD(at[2], at[19]);    MULADD(at[3], at[18]);    MULADD(at[4], at[17]);    MULADD(at[5], at[16]);
+   COMBA_STORE(C->dp[5]);
+   /* 6 */
+   COMBA_FORWARD;
+   MULADD(at[0], at[22]);    MULADD(at[1], at[21]);    MULADD(at[2], at[20]);    MULADD(at[3], at[19]);    MULADD(at[4], at[18]);    MULADD(at[5], at[17]);    MULADD(at[6], at[16]);
+   COMBA_STORE(C->dp[6]);
+   /* 7 */
+   COMBA_FORWARD;
+   MULADD(at[0], at[23]);    MULADD(at[1], at[22]);    MULADD(at[2], at[21]);    MULADD(at[3], at[20]);    MULADD(at[4], at[19]);    MULADD(at[5], at[18]);    MULADD(at[6], at[17]);    MULADD(at[7], at[16]);
+   COMBA_STORE(C->dp[7]);
+   /* 8 */
+   COMBA_FORWARD;
+   MULADD(at[0], at[24]);    MULADD(at[1], at[23]);    MULADD(at[2], at[22]);    MULADD(at[3], at[21]);    MULADD(at[4], at[20]);    MULADD(at[5], at[19]);    MULADD(at[6], at[18]);    MULADD(at[7], at[17]);    MULADD(at[8], at[16]);
+   COMBA_STORE(C->dp[8]);
+   /* 9 */
+   COMBA_FORWARD;
+   MULADD(at[0], at[25]);    MULADD(at[1], at[24]);    MULADD(at[2], at[23]);    MULADD(at[3], at[22]);    MULADD(at[4], at[21]);    MULADD(at[5], at[20]);    MULADD(at[6], at[19]);    MULADD(at[7], at[18]);    MULADD(at[8], at[17]);    MULADD(at[9], at[16]);
+   COMBA_STORE(C->dp[9]);
+   /* 10 */
+   COMBA_FORWARD;
+   MULADD(at[0], at[26]);    MULADD(at[1], at[25]);    MULADD(at[2], at[24]);    MULADD(at[3], at[23]);    MULADD(at[4], at[22]);    MULADD(at[5], at[21]);    MULADD(at[6], at[20]);    MULADD(at[7], at[19]);    MULADD(at[8], at[18]);    MULADD(at[9], at[17]);    MULADD(at[10], at[16]);
+   COMBA_STORE(C->dp[10]);
+   /* 11 */
+   COMBA_FORWARD;
+   MULADD(at[0], at[27]);    MULADD(at[1], at[26]);    MULADD(at[2], at[25]);    MULADD(at[3], at[24]);    MULADD(at[4], at[23]);    MULADD(at[5], at[22]);    MULADD(at[6], at[21]);    MULADD(at[7], at[20]);    MULADD(at[8], at[19]);    MULADD(at[9], at[18]);    MULADD(at[10], at[17]);    MULADD(at[11], at[16]);
+   COMBA_STORE(C->dp[11]);
+   /* 12 */
+   COMBA_FORWARD;
+   MULADD(at[0], at[28]);    MULADD(at[1], at[27]);    MULADD(at[2], at[26]);    MULADD(at[3], at[25]);    MULADD(at[4], at[24]);    MULADD(at[5], at[23]);    MULADD(at[6], at[22]);    MULADD(at[7], at[21]);    MULADD(at[8], at[20]);    MULADD(at[9], at[19]);    MULADD(at[10], at[18]);    MULADD(at[11], at[17]);    MULADD(at[12], at[16]);
+   COMBA_STORE(C->dp[12]);
+   /* 13 */
+   COMBA_FORWARD;
+   MULADD(at[0], at[29]);    MULADD(at[1], at[28]);    MULADD(at[2], at[27]);    MULADD(at[3], at[26]);    MULADD(at[4], at[25]);    MULADD(at[5], at[24]);    MULADD(at[6], at[23]);    MULADD(at[7], at[22]);    MULADD(at[8], at[21]);    MULADD(at[9], at[20]);    MULADD(at[10], at[19]);    MULADD(at[11], at[18]);    MULADD(at[12], at[17]);    MULADD(at[13], at[16]);
+   COMBA_STORE(C->dp[13]);
+   /* 14 */
+   COMBA_FORWARD;
+   MULADD(at[0], at[30]);    MULADD(at[1], at[29]);    MULADD(at[2], at[28]);    MULADD(at[3], at[27]);    MULADD(at[4], at[26]);    MULADD(at[5], at[25]);    MULADD(at[6], at[24]);    MULADD(at[7], at[23]);    MULADD(at[8], at[22]);    MULADD(at[9], at[21]);    MULADD(at[10], at[20]);    MULADD(at[11], at[19]);    MULADD(at[12], at[18]);    MULADD(at[13], at[17]);    MULADD(at[14], at[16]);
+   COMBA_STORE(C->dp[14]);
+   /* 15 */
+   COMBA_FORWARD;
+   MULADD(at[0], at[31]);    MULADD(at[1], at[30]);    MULADD(at[2], at[29]);    MULADD(at[3], at[28]);    MULADD(at[4], at[27]);    MULADD(at[5], at[26]);    MULADD(at[6], at[25]);    MULADD(at[7], at[24]);    MULADD(at[8], at[23]);    MULADD(at[9], at[22]);    MULADD(at[10], at[21]);    MULADD(at[11], at[20]);    MULADD(at[12], at[19]);    MULADD(at[13], at[18]);    MULADD(at[14], at[17]);    MULADD(at[15], at[16]);
+   COMBA_STORE(C->dp[15]);
+   /* 16 */
+   COMBA_FORWARD;
+   MULADD(at[1], at[31]);    MULADD(at[2], at[30]);    MULADD(at[3], at[29]);    MULADD(at[4], at[28]);    MULADD(at[5], at[27]);    MULADD(at[6], at[26]);    MULADD(at[7], at[25]);    MULADD(at[8], at[24]);    MULADD(at[9], at[23]);    MULADD(at[10], at[22]);    MULADD(at[11], at[21]);    MULADD(at[12], at[20]);    MULADD(at[13], at[19]);    MULADD(at[14], at[18]);    MULADD(at[15], at[17]);
+   COMBA_STORE(C->dp[16]);
+   /* 17 */
+   COMBA_FORWARD;
+   MULADD(at[2], at[31]);    MULADD(at[3], at[30]);    MULADD(at[4], at[29]);    MULADD(at[5], at[28]);    MULADD(at[6], at[27]);    MULADD(at[7], at[26]);    MULADD(at[8], at[25]);    MULADD(at[9], at[24]);    MULADD(at[10], at[23]);    MULADD(at[11], at[22]);    MULADD(at[12], at[21]);    MULADD(at[13], at[20]);    MULADD(at[14], at[19]);    MULADD(at[15], at[18]);
+   COMBA_STORE(C->dp[17]);
+   /* 18 */
+   COMBA_FORWARD;
+   MULADD(at[3], at[31]);    MULADD(at[4], at[30]);    MULADD(at[5], at[29]);    MULADD(at[6], at[28]);    MULADD(at[7], at[27]);    MULADD(at[8], at[26]);    MULADD(at[9], at[25]);    MULADD(at[10], at[24]);    MULADD(at[11], at[23]);    MULADD(at[12], at[22]);    MULADD(at[13], at[21]);    MULADD(at[14], at[20]);    MULADD(at[15], at[19]);
+   COMBA_STORE(C->dp[18]);
+   /* 19 */
+   COMBA_FORWARD;
+   MULADD(at[4], at[31]);    MULADD(at[5], at[30]);    MULADD(at[6], at[29]);    MULADD(at[7], at[28]);    MULADD(at[8], at[27]);    MULADD(at[9], at[26]);    MULADD(at[10], at[25]);    MULADD(at[11], at[24]);    MULADD(at[12], at[23]);    MULADD(at[13], at[22]);    MULADD(at[14], at[21]);    MULADD(at[15], at[20]);
+   COMBA_STORE(C->dp[19]);
+   /* 20 */
+   COMBA_FORWARD;
+   MULADD(at[5], at[31]);    MULADD(at[6], at[30]);    MULADD(at[7], at[29]);    MULADD(at[8], at[28]);    MULADD(at[9], at[27]);    MULADD(at[10], at[26]);    MULADD(at[11], at[25]);    MULADD(at[12], at[24]);    MULADD(at[13], at[23]);    MULADD(at[14], at[22]);    MULADD(at[15], at[21]);
+   COMBA_STORE(C->dp[20]);
+   /* 21 */
+   COMBA_FORWARD;
+   MULADD(at[6], at[31]);    MULADD(at[7], at[30]);    MULADD(at[8], at[29]);    MULADD(at[9], at[28]);    MULADD(at[10], at[27]);    MULADD(at[11], at[26]);    MULADD(at[12], at[25]);    MULADD(at[13], at[24]);    MULADD(at[14], at[23]);    MULADD(at[15], at[22]);
+   COMBA_STORE(C->dp[21]);
+   /* 22 */
+   COMBA_FORWARD;
+   MULADD(at[7], at[31]);    MULADD(at[8], at[30]);    MULADD(at[9], at[29]);    MULADD(at[10], at[28]);    MULADD(at[11], at[27]);    MULADD(at[12], at[26]);    MULADD(at[13], at[25]);    MULADD(at[14], at[24]);    MULADD(at[15], at[23]);
+   COMBA_STORE(C->dp[22]);
+   /* 23 */
+   COMBA_FORWARD;
+   MULADD(at[8], at[31]);    MULADD(at[9], at[30]);    MULADD(at[10], at[29]);    MULADD(at[11], at[28]);    MULADD(at[12], at[27]);    MULADD(at[13], at[26]);    MULADD(at[14], at[25]);    MULADD(at[15], at[24]);
+   COMBA_STORE(C->dp[23]);
+   /* 24 */
+   COMBA_FORWARD;
+   MULADD(at[9], at[31]);    MULADD(at[10], at[30]);    MULADD(at[11], at[29]);    MULADD(at[12], at[28]);    MULADD(at[13], at[27]);    MULADD(at[14], at[26]);    MULADD(at[15], at[25]);
+   COMBA_STORE(C->dp[24]);
+   /* 25 */
+   COMBA_FORWARD;
+   MULADD(at[10], at[31]);    MULADD(at[11], at[30]);    MULADD(at[12], at[29]);    MULADD(at[13], at[28]);    MULADD(at[14], at[27]);    MULADD(at[15], at[26]);
+   COMBA_STORE(C->dp[25]);
+   /* 26 */
+   COMBA_FORWARD;
+   MULADD(at[11], at[31]);    MULADD(at[12], at[30]);    MULADD(at[13], at[29]);    MULADD(at[14], at[28]);    MULADD(at[15], at[27]);
+   COMBA_STORE(C->dp[26]);
+   /* 27 */
+   COMBA_FORWARD;
+   MULADD(at[12], at[31]);    MULADD(at[13], at[30]);    MULADD(at[14], at[29]);    MULADD(at[15], at[28]);
+   COMBA_STORE(C->dp[27]);
+   /* 28 */
+   COMBA_FORWARD;
+   MULADD(at[13], at[31]);    MULADD(at[14], at[30]);    MULADD(at[15], at[29]);
+   COMBA_STORE(C->dp[28]);
+   /* 29 */
+   COMBA_FORWARD;
+   MULADD(at[14], at[31]);    MULADD(at[15], at[30]);
+   COMBA_STORE(C->dp[29]);
+   /* 30 */
+   COMBA_FORWARD;
+   MULADD(at[15], at[31]);
+   COMBA_STORE(C->dp[30]);
+   COMBA_STORE2(C->dp[31]);
+   C->used = 32;
+   C->sign = A->sign ^ B->sign;
+   pstm_clamp(C);
+   COMBA_FINI;
+   return PSTM_OKAY;
+}
+#endif /* USE_1024_KEY_SPEED_OPTIMIZATIONS */
+
+
+#ifdef USE_2048_KEY_SPEED_OPTIMIZATIONS
+static int32 pstm_mul_comba32(pstm_int *A, pstm_int *B, pstm_int *C)
+{
+   pstm_digit c0, c1, c2, at[64];
+   int32 out_size;
+
+	if (C->alloc < 64) {
+		if (pstm_grow(C, 64) != PSTM_OKAY) {
+			return PS_MEM_FAIL;
+		}
+	}
+
+   out_size = A->used + B->used;
+   memcpy(at, A->dp, 32 * sizeof(pstm_digit));
+   memcpy(at+32, B->dp, 32 * sizeof(pstm_digit));
+   COMBA_START;
+
+   COMBA_CLEAR;
+   /* 0 */
+   MULADD(at[0], at[32]);
+   COMBA_STORE(C->dp[0]);
+   /* 1 */
+   COMBA_FORWARD;
+   MULADD(at[0], at[33]);    MULADD(at[1], at[32]);
+   COMBA_STORE(C->dp[1]);
+   /* 2 */
+   COMBA_FORWARD;
+   MULADD(at[0], at[34]);    MULADD(at[1], at[33]);    MULADD(at[2], at[32]);
+   COMBA_STORE(C->dp[2]);
+   /* 3 */
+   COMBA_FORWARD;
+   MULADD(at[0], at[35]);    MULADD(at[1], at[34]);    MULADD(at[2], at[33]);    MULADD(at[3], at[32]);
+   COMBA_STORE(C->dp[3]);
+   /* 4 */
+   COMBA_FORWARD;
+   MULADD(at[0], at[36]);    MULADD(at[1], at[35]);    MULADD(at[2], at[34]);    MULADD(at[3], at[33]);    MULADD(at[4], at[32]);
+   COMBA_STORE(C->dp[4]);
+   /* 5 */
+   COMBA_FORWARD;
+   MULADD(at[0], at[37]);    MULADD(at[1], at[36]);    MULADD(at[2], at[35]);    MULADD(at[3], at[34]);    MULADD(at[4], at[33]);    MULADD(at[5], at[32]);
+   COMBA_STORE(C->dp[5]);
+   /* 6 */
+   COMBA_FORWARD;
+   MULADD(at[0], at[38]);    MULADD(at[1], at[37]);    MULADD(at[2], at[36]);    MULADD(at[3], at[35]);    MULADD(at[4], at[34]);    MULADD(at[5], at[33]);    MULADD(at[6], at[32]);
+   COMBA_STORE(C->dp[6]);
+   /* 7 */
+   COMBA_FORWARD;
+   MULADD(at[0], at[39]);    MULADD(at[1], at[38]);    MULADD(at[2], at[37]);    MULADD(at[3], at[36]);    MULADD(at[4], at[35]);    MULADD(at[5], at[34]);    MULADD(at[6], at[33]);    MULADD(at[7], at[32]);
+   COMBA_STORE(C->dp[7]);
+   /* 8 */
+   COMBA_FORWARD;
+   MULADD(at[0], at[40]);    MULADD(at[1], at[39]);    MULADD(at[2], at[38]);    MULADD(at[3], at[37]);    MULADD(at[4], at[36]);    MULADD(at[5], at[35]);    MULADD(at[6], at[34]);    MULADD(at[7], at[33]);    MULADD(at[8], at[32]);
+   COMBA_STORE(C->dp[8]);
+   /* 9 */
+   COMBA_FORWARD;
+   MULADD(at[0], at[41]);    MULADD(at[1], at[40]);    MULADD(at[2], at[39]);    MULADD(at[3], at[38]);    MULADD(at[4], at[37]);    MULADD(at[5], at[36]);    MULADD(at[6], at[35]);    MULADD(at[7], at[34]);    MULADD(at[8], at[33]);    MULADD(at[9], at[32]);
+   COMBA_STORE(C->dp[9]);
+   /* 10 */
+   COMBA_FORWARD;
+   MULADD(at[0], at[42]);    MULADD(at[1], at[41]);    MULADD(at[2], at[40]);    MULADD(at[3], at[39]);    MULADD(at[4], at[38]);    MULADD(at[5], at[37]);    MULADD(at[6], at[36]);    MULADD(at[7], at[35]);    MULADD(at[8], at[34]);    MULADD(at[9], at[33]);    MULADD(at[10], at[32]);
+   COMBA_STORE(C->dp[10]);
+   /* 11 */
+   COMBA_FORWARD;
+   MULADD(at[0], at[43]);    MULADD(at[1], at[42]);    MULADD(at[2], at[41]);    MULADD(at[3], at[40]);    MULADD(at[4], at[39]);    MULADD(at[5], at[38]);    MULADD(at[6], at[37]);    MULADD(at[7], at[36]);    MULADD(at[8], at[35]);    MULADD(at[9], at[34]);    MULADD(at[10], at[33]);    MULADD(at[11], at[32]);
+   COMBA_STORE(C->dp[11]);
+   /* 12 */
+   COMBA_FORWARD;
+   MULADD(at[0], at[44]);    MULADD(at[1], at[43]);    MULADD(at[2], at[42]);    MULADD(at[3], at[41]);    MULADD(at[4], at[40]);    MULADD(at[5], at[39]);    MULADD(at[6], at[38]);    MULADD(at[7], at[37]);    MULADD(at[8], at[36]);    MULADD(at[9], at[35]);    MULADD(at[10], at[34]);    MULADD(at[11], at[33]);    MULADD(at[12], at[32]);
+   COMBA_STORE(C->dp[12]);
+   /* 13 */
+   COMBA_FORWARD;
+   MULADD(at[0], at[45]);    MULADD(at[1], at[44]);    MULADD(at[2], at[43]);    MULADD(at[3], at[42]);    MULADD(at[4], at[41]);    MULADD(at[5], at[40]);    MULADD(at[6], at[39]);    MULADD(at[7], at[38]);    MULADD(at[8], at[37]);    MULADD(at[9], at[36]);    MULADD(at[10], at[35]);    MULADD(at[11], at[34]);    MULADD(at[12], at[33]);    MULADD(at[13], at[32]);
+   COMBA_STORE(C->dp[13]);
+   /* 14 */
+   COMBA_FORWARD;
+   MULADD(at[0], at[46]);    MULADD(at[1], at[45]);    MULADD(at[2], at[44]);    MULADD(at[3], at[43]);    MULADD(at[4], at[42]);    MULADD(at[5], at[41]);    MULADD(at[6], at[40]);    MULADD(at[7], at[39]);    MULADD(at[8], at[38]);    MULADD(at[9], at[37]);    MULADD(at[10], at[36]);    MULADD(at[11], at[35]);    MULADD(at[12], at[34]);    MULADD(at[13], at[33]);    MULADD(at[14], at[32]);
+   COMBA_STORE(C->dp[14]);
+   /* 15 */
+   COMBA_FORWARD;
+   MULADD(at[0], at[47]);    MULADD(at[1], at[46]);    MULADD(at[2], at[45]);    MULADD(at[3], at[44]);    MULADD(at[4], at[43]);    MULADD(at[5], at[42]);    MULADD(at[6], at[41]);    MULADD(at[7], at[40]);    MULADD(at[8], at[39]);    MULADD(at[9], at[38]);    MULADD(at[10], at[37]);    MULADD(at[11], at[36]);    MULADD(at[12], at[35]);    MULADD(at[13], at[34]);    MULADD(at[14], at[33]);    MULADD(at[15], at[32]);
+   COMBA_STORE(C->dp[15]);
+   /* 16 */
+   COMBA_FORWARD;
+   MULADD(at[0], at[48]);    MULADD(at[1], at[47]);    MULADD(at[2], at[46]);    MULADD(at[3], at[45]);    MULADD(at[4], at[44]);    MULADD(at[5], at[43]);    MULADD(at[6], at[42]);    MULADD(at[7], at[41]);    MULADD(at[8], at[40]);    MULADD(at[9], at[39]);    MULADD(at[10], at[38]);    MULADD(at[11], at[37]);    MULADD(at[12], at[36]);    MULADD(at[13], at[35]);    MULADD(at[14], at[34]);    MULADD(at[15], at[33]);    MULADD(at[16], at[32]);
+   COMBA_STORE(C->dp[16]);
+   /* 17 */
+   COMBA_FORWARD;
+   MULADD(at[0], at[49]);    MULADD(at[1], at[48]);    MULADD(at[2], at[47]);    MULADD(at[3], at[46]);    MULADD(at[4], at[45]);    MULADD(at[5], at[44]);    MULADD(at[6], at[43]);    MULADD(at[7], at[42]);    MULADD(at[8], at[41]);    MULADD(at[9], at[40]);    MULADD(at[10], at[39]);    MULADD(at[11], at[38]);    MULADD(at[12], at[37]);    MULADD(at[13], at[36]);    MULADD(at[14], at[35]);    MULADD(at[15], at[34]);    MULADD(at[16], at[33]);    MULADD(at[17], at[32]);
+   COMBA_STORE(C->dp[17]);
+   /* 18 */
+   COMBA_FORWARD;
+   MULADD(at[0], at[50]);    MULADD(at[1], at[49]);    MULADD(at[2], at[48]);    MULADD(at[3], at[47]);    MULADD(at[4], at[46]);    MULADD(at[5], at[45]);    MULADD(at[6], at[44]);    MULADD(at[7], at[43]);    MULADD(at[8], at[42]);    MULADD(at[9], at[41]);    MULADD(at[10], at[40]);    MULADD(at[11], at[39]);    MULADD(at[12], at[38]);    MULADD(at[13], at[37]);    MULADD(at[14], at[36]);    MULADD(at[15], at[35]);    MULADD(at[16], at[34]);    MULADD(at[17], at[33]);    MULADD(at[18], at[32]);
+   COMBA_STORE(C->dp[18]);
+   /* 19 */
+   COMBA_FORWARD;
+   MULADD(at[0], at[51]);    MULADD(at[1], at[50]);    MULADD(at[2], at[49]);    MULADD(at[3], at[48]);    MULADD(at[4], at[47]);    MULADD(at[5], at[46]);    MULADD(at[6], at[45]);    MULADD(at[7], at[44]);    MULADD(at[8], at[43]);    MULADD(at[9], at[42]);    MULADD(at[10], at[41]);    MULADD(at[11], at[40]);    MULADD(at[12], at[39]);    MULADD(at[13], at[38]);    MULADD(at[14], at[37]);    MULADD(at[15], at[36]);    MULADD(at[16], at[35]);    MULADD(at[17], at[34]);    MULADD(at[18], at[33]);    MULADD(at[19], at[32]);
+   COMBA_STORE(C->dp[19]);
+   /* 20 */
+   COMBA_FORWARD;
+   MULADD(at[0], at[52]);    MULADD(at[1], at[51]);    MULADD(at[2], at[50]);    MULADD(at[3], at[49]);    MULADD(at[4], at[48]);    MULADD(at[5], at[47]);    MULADD(at[6], at[46]);    MULADD(at[7], at[45]);    MULADD(at[8], at[44]);    MULADD(at[9], at[43]);    MULADD(at[10], at[42]);    MULADD(at[11], at[41]);    MULADD(at[12], at[40]);    MULADD(at[13], at[39]);    MULADD(at[14], at[38]);    MULADD(at[15], at[37]);    MULADD(at[16], at[36]);    MULADD(at[17], at[35]);    MULADD(at[18], at[34]);    MULADD(at[19], at[33]);    MULADD(at[20], at[32]);
+   COMBA_STORE(C->dp[20]);
+   /* 21 */
+   COMBA_FORWARD;
+   MULADD(at[0], at[53]);    MULADD(at[1], at[52]);    MULADD(at[2], at[51]);    MULADD(at[3], at[50]);    MULADD(at[4], at[49]);    MULADD(at[5], at[48]);    MULADD(at[6], at[47]);    MULADD(at[7], at[46]);    MULADD(at[8], at[45]);    MULADD(at[9], at[44]);    MULADD(at[10], at[43]);    MULADD(at[11], at[42]);    MULADD(at[12], at[41]);    MULADD(at[13], at[40]);    MULADD(at[14], at[39]);    MULADD(at[15], at[38]);    MULADD(at[16], at[37]);    MULADD(at[17], at[36]);    MULADD(at[18], at[35]);    MULADD(at[19], at[34]);    MULADD(at[20], at[33]);    MULADD(at[21], at[32]);
+   COMBA_STORE(C->dp[21]);
+   /* 22 */
+   COMBA_FORWARD;
+   MULADD(at[0], at[54]);    MULADD(at[1], at[53]);    MULADD(at[2], at[52]);    MULADD(at[3], at[51]);    MULADD(at[4], at[50]);    MULADD(at[5], at[49]);    MULADD(at[6], at[48]);    MULADD(at[7], at[47]);    MULADD(at[8], at[46]);    MULADD(at[9], at[45]);    MULADD(at[10], at[44]);    MULADD(at[11], at[43]);    MULADD(at[12], at[42]);    MULADD(at[13], at[41]);    MULADD(at[14], at[40]);    MULADD(at[15], at[39]);    MULADD(at[16], at[38]);    MULADD(at[17], at[37]);    MULADD(at[18], at[36]);    MULADD(at[19], at[35]);    MULADD(at[20], at[34]);    MULADD(at[21], at[33]);    MULADD(at[22], at[32]);
+   COMBA_STORE(C->dp[22]);
+   /* 23 */
+   COMBA_FORWARD;
+   MULADD(at[0], at[55]);    MULADD(at[1], at[54]);    MULADD(at[2], at[53]);    MULADD(at[3], at[52]);    MULADD(at[4], at[51]);    MULADD(at[5], at[50]);    MULADD(at[6], at[49]);    MULADD(at[7], at[48]);    MULADD(at[8], at[47]);    MULADD(at[9], at[46]);    MULADD(at[10], at[45]);    MULADD(at[11], at[44]);    MULADD(at[12], at[43]);    MULADD(at[13], at[42]);    MULADD(at[14], at[41]);    MULADD(at[15], at[40]);    MULADD(at[16], at[39]);    MULADD(at[17], at[38]);    MULADD(at[18], at[37]);    MULADD(at[19], at[36]);    MULADD(at[20], at[35]);    MULADD(at[21], at[34]);    MULADD(at[22], at[33]);    MULADD(at[23], at[32]);
+   COMBA_STORE(C->dp[23]);
+   /* 24 */
+   COMBA_FORWARD;
+   MULADD(at[0], at[56]);    MULADD(at[1], at[55]);    MULADD(at[2], at[54]);    MULADD(at[3], at[53]);    MULADD(at[4], at[52]);    MULADD(at[5], at[51]);    MULADD(at[6], at[50]);    MULADD(at[7], at[49]);    MULADD(at[8], at[48]);    MULADD(at[9], at[47]);    MULADD(at[10], at[46]);    MULADD(at[11], at[45]);    MULADD(at[12], at[44]);    MULADD(at[13], at[43]);    MULADD(at[14], at[42]);    MULADD(at[15], at[41]);    MULADD(at[16], at[40]);    MULADD(at[17], at[39]);    MULADD(at[18], at[38]);    MULADD(at[19], at[37]);    MULADD(at[20], at[36]);    MULADD(at[21], at[35]);    MULADD(at[22], at[34]);    MULADD(at[23], at[33]);    MULADD(at[24], at[32]);
+   COMBA_STORE(C->dp[24]);
+   /* 25 */
+   COMBA_FORWARD;
+   MULADD(at[0], at[57]);    MULADD(at[1], at[56]);    MULADD(at[2], at[55]);    MULADD(at[3], at[54]);    MULADD(at[4], at[53]);    MULADD(at[5], at[52]);    MULADD(at[6], at[51]);    MULADD(at[7], at[50]);    MULADD(at[8], at[49]);    MULADD(at[9], at[48]);    MULADD(at[10], at[47]);    MULADD(at[11], at[46]);    MULADD(at[12], at[45]);    MULADD(at[13], at[44]);    MULADD(at[14], at[43]);    MULADD(at[15], at[42]);    MULADD(at[16], at[41]);    MULADD(at[17], at[40]);    MULADD(at[18], at[39]);    MULADD(at[19], at[38]);    MULADD(at[20], at[37]);    MULADD(at[21], at[36]);    MULADD(at[22], at[35]);    MULADD(at[23], at[34]);    MULADD(at[24], at[33]);    MULADD(at[25], at[32]);
+   COMBA_STORE(C->dp[25]);
+   /* 26 */
+   COMBA_FORWARD;
+   MULADD(at[0], at[58]);    MULADD(at[1], at[57]);    MULADD(at[2], at[56]);    MULADD(at[3], at[55]);    MULADD(at[4], at[54]);    MULADD(at[5], at[53]);    MULADD(at[6], at[52]);    MULADD(at[7], at[51]);    MULADD(at[8], at[50]);    MULADD(at[9], at[49]);    MULADD(at[10], at[48]);    MULADD(at[11], at[47]);    MULADD(at[12], at[46]);    MULADD(at[13], at[45]);    MULADD(at[14], at[44]);    MULADD(at[15], at[43]);    MULADD(at[16], at[42]);    MULADD(at[17], at[41]);    MULADD(at[18], at[40]);    MULADD(at[19], at[39]);    MULADD(at[20], at[38]);    MULADD(at[21], at[37]);    MULADD(at[22], at[36]);    MULADD(at[23], at[35]);    MULADD(at[24], at[34]);    MULADD(at[25], at[33]);    MULADD(at[26], at[32]);
+   COMBA_STORE(C->dp[26]);
+   /* 27 */
+   COMBA_FORWARD;
+   MULADD(at[0], at[59]);    MULADD(at[1], at[58]);    MULADD(at[2], at[57]);    MULADD(at[3], at[56]);    MULADD(at[4], at[55]);    MULADD(at[5], at[54]);    MULADD(at[6], at[53]);    MULADD(at[7], at[52]);    MULADD(at[8], at[51]);    MULADD(at[9], at[50]);    MULADD(at[10], at[49]);    MULADD(at[11], at[48]);    MULADD(at[12], at[47]);    MULADD(at[13], at[46]);    MULADD(at[14], at[45]);    MULADD(at[15], at[44]);    MULADD(at[16], at[43]);    MULADD(at[17], at[42]);    MULADD(at[18], at[41]);    MULADD(at[19], at[40]);    MULADD(at[20], at[39]);    MULADD(at[21], at[38]);    MULADD(at[22], at[37]);    MULADD(at[23], at[36]);    MULADD(at[24], at[35]);    MULADD(at[25], at[34]);    MULADD(at[26], at[33]);    MULADD(at[27], at[32]);
+   COMBA_STORE(C->dp[27]);
+   /* 28 */
+   COMBA_FORWARD;
+   MULADD(at[0], at[60]);    MULADD(at[1], at[59]);    MULADD(at[2], at[58]);    MULADD(at[3], at[57]);    MULADD(at[4], at[56]);    MULADD(at[5], at[55]);    MULADD(at[6], at[54]);    MULADD(at[7], at[53]);    MULADD(at[8], at[52]);    MULADD(at[9], at[51]);    MULADD(at[10], at[50]);    MULADD(at[11], at[49]);    MULADD(at[12], at[48]);    MULADD(at[13], at[47]);    MULADD(at[14], at[46]);    MULADD(at[15], at[45]);    MULADD(at[16], at[44]);    MULADD(at[17], at[43]);    MULADD(at[18], at[42]);    MULADD(at[19], at[41]);    MULADD(at[20], at[40]);    MULADD(at[21], at[39]);    MULADD(at[22], at[38]);    MULADD(at[23], at[37]);    MULADD(at[24], at[36]);    MULADD(at[25], at[35]);    MULADD(at[26], at[34]);    MULADD(at[27], at[33]);    MULADD(at[28], at[32]);
+   COMBA_STORE(C->dp[28]);
+   /* 29 */
+   COMBA_FORWARD;
+   MULADD(at[0], at[61]);    MULADD(at[1], at[60]);    MULADD(at[2], at[59]);    MULADD(at[3], at[58]);    MULADD(at[4], at[57]);    MULADD(at[5], at[56]);    MULADD(at[6], at[55]);    MULADD(at[7], at[54]);    MULADD(at[8], at[53]);    MULADD(at[9], at[52]);    MULADD(at[10], at[51]);    MULADD(at[11], at[50]);    MULADD(at[12], at[49]);    MULADD(at[13], at[48]);    MULADD(at[14], at[47]);    MULADD(at[15], at[46]);    MULADD(at[16], at[45]);    MULADD(at[17], at[44]);    MULADD(at[18], at[43]);    MULADD(at[19], at[42]);    MULADD(at[20], at[41]);    MULADD(at[21], at[40]);    MULADD(at[22], at[39]);    MULADD(at[23], at[38]);    MULADD(at[24], at[37]);    MULADD(at[25], at[36]);    MULADD(at[26], at[35]);    MULADD(at[27], at[34]);    MULADD(at[28], at[33]);    MULADD(at[29], at[32]);
+   COMBA_STORE(C->dp[29]);
+   /* 30 */
+   COMBA_FORWARD;
+   MULADD(at[0], at[62]);    MULADD(at[1], at[61]);    MULADD(at[2], at[60]);    MULADD(at[3], at[59]);    MULADD(at[4], at[58]);    MULADD(at[5], at[57]);    MULADD(at[6], at[56]);    MULADD(at[7], at[55]);    MULADD(at[8], at[54]);    MULADD(at[9], at[53]);    MULADD(at[10], at[52]);    MULADD(at[11], at[51]);    MULADD(at[12], at[50]);    MULADD(at[13], at[49]);    MULADD(at[14], at[48]);    MULADD(at[15], at[47]);    MULADD(at[16], at[46]);    MULADD(at[17], at[45]);    MULADD(at[18], at[44]);    MULADD(at[19], at[43]);    MULADD(at[20], at[42]);    MULADD(at[21], at[41]);    MULADD(at[22], at[40]);    MULADD(at[23], at[39]);    MULADD(at[24], at[38]);    MULADD(at[25], at[37]);    MULADD(at[26], at[36]);    MULADD(at[27], at[35]);    MULADD(at[28], at[34]);    MULADD(at[29], at[33]);    MULADD(at[30], at[32]);
+   COMBA_STORE(C->dp[30]);
+   /* 31 */
+   COMBA_FORWARD;
+   MULADD(at[0], at[63]);    MULADD(at[1], at[62]);    MULADD(at[2], at[61]);    MULADD(at[3], at[60]);    MULADD(at[4], at[59]);    MULADD(at[5], at[58]);    MULADD(at[6], at[57]);    MULADD(at[7], at[56]);    MULADD(at[8], at[55]);    MULADD(at[9], at[54]);    MULADD(at[10], at[53]);    MULADD(at[11], at[52]);    MULADD(at[12], at[51]);    MULADD(at[13], at[50]);    MULADD(at[14], at[49]);    MULADD(at[15], at[48]);    MULADD(at[16], at[47]);    MULADD(at[17], at[46]);    MULADD(at[18], at[45]);    MULADD(at[19], at[44]);    MULADD(at[20], at[43]);    MULADD(at[21], at[42]);    MULADD(at[22], at[41]);    MULADD(at[23], at[40]);    MULADD(at[24], at[39]);    MULADD(at[25], at[38]);    MULADD(at[26], at[37]);    MULADD(at[27], at[36]);    MULADD(at[28], at[35]);    MULADD(at[29], at[34]);    MULADD(at[30], at[33]);    MULADD(at[31], at[32]);
+   COMBA_STORE(C->dp[31]);
+   /* 32 */
+   COMBA_FORWARD;
+   MULADD(at[1], at[63]);    MULADD(at[2], at[62]);    MULADD(at[3], at[61]);    MULADD(at[4], at[60]);    MULADD(at[5], at[59]);    MULADD(at[6], at[58]);    MULADD(at[7], at[57]);    MULADD(at[8], at[56]);    MULADD(at[9], at[55]);    MULADD(at[10], at[54]);    MULADD(at[11], at[53]);    MULADD(at[12], at[52]);    MULADD(at[13], at[51]);    MULADD(at[14], at[50]);    MULADD(at[15], at[49]);    MULADD(at[16], at[48]);    MULADD(at[17], at[47]);    MULADD(at[18], at[46]);    MULADD(at[19], at[45]);    MULADD(at[20], at[44]);    MULADD(at[21], at[43]);    MULADD(at[22], at[42]);    MULADD(at[23], at[41]);    MULADD(at[24], at[40]);    MULADD(at[25], at[39]);    MULADD(at[26], at[38]);    MULADD(at[27], at[37]);    MULADD(at[28], at[36]);    MULADD(at[29], at[35]);    MULADD(at[30], at[34]);    MULADD(at[31], at[33]);
+   COMBA_STORE(C->dp[32]);
+   /* 33 */
+   COMBA_FORWARD;
+   MULADD(at[2], at[63]);    MULADD(at[3], at[62]);    MULADD(at[4], at[61]);    MULADD(at[5], at[60]);    MULADD(at[6], at[59]);    MULADD(at[7], at[58]);    MULADD(at[8], at[57]);    MULADD(at[9], at[56]);    MULADD(at[10], at[55]);    MULADD(at[11], at[54]);    MULADD(at[12], at[53]);    MULADD(at[13], at[52]);    MULADD(at[14], at[51]);    MULADD(at[15], at[50]);    MULADD(at[16], at[49]);    MULADD(at[17], at[48]);    MULADD(at[18], at[47]);    MULADD(at[19], at[46]);    MULADD(at[20], at[45]);    MULADD(at[21], at[44]);    MULADD(at[22], at[43]);    MULADD(at[23], at[42]);    MULADD(at[24], at[41]);    MULADD(at[25], at[40]);    MULADD(at[26], at[39]);    MULADD(at[27], at[38]);    MULADD(at[28], at[37]);    MULADD(at[29], at[36]);    MULADD(at[30], at[35]);    MULADD(at[31], at[34]);
+   COMBA_STORE(C->dp[33]);
+   /* 34 */
+   COMBA_FORWARD;
+   MULADD(at[3], at[63]);    MULADD(at[4], at[62]);    MULADD(at[5], at[61]);    MULADD(at[6], at[60]);    MULADD(at[7], at[59]);    MULADD(at[8], at[58]);    MULADD(at[9], at[57]);    MULADD(at[10], at[56]);    MULADD(at[11], at[55]);    MULADD(at[12], at[54]);    MULADD(at[13], at[53]);    MULADD(at[14], at[52]);    MULADD(at[15], at[51]);    MULADD(at[16], at[50]);    MULADD(at[17], at[49]);    MULADD(at[18], at[48]);    MULADD(at[19], at[47]);    MULADD(at[20], at[46]);    MULADD(at[21], at[45]);    MULADD(at[22], at[44]);    MULADD(at[23], at[43]);    MULADD(at[24], at[42]);    MULADD(at[25], at[41]);    MULADD(at[26], at[40]);    MULADD(at[27], at[39]);    MULADD(at[28], at[38]);    MULADD(at[29], at[37]);    MULADD(at[30], at[36]);    MULADD(at[31], at[35]);
+   COMBA_STORE(C->dp[34]);
+   /* 35 */
+   COMBA_FORWARD;
+   MULADD(at[4], at[63]);    MULADD(at[5], at[62]);    MULADD(at[6], at[61]);    MULADD(at[7], at[60]);    MULADD(at[8], at[59]);    MULADD(at[9], at[58]);    MULADD(at[10], at[57]);    MULADD(at[11], at[56]);    MULADD(at[12], at[55]);    MULADD(at[13], at[54]);    MULADD(at[14], at[53]);    MULADD(at[15], at[52]);    MULADD(at[16], at[51]);    MULADD(at[17], at[50]);    MULADD(at[18], at[49]);    MULADD(at[19], at[48]);    MULADD(at[20], at[47]);    MULADD(at[21], at[46]);    MULADD(at[22], at[45]);    MULADD(at[23], at[44]);    MULADD(at[24], at[43]);    MULADD(at[25], at[42]);    MULADD(at[26], at[41]);    MULADD(at[27], at[40]);    MULADD(at[28], at[39]);    MULADD(at[29], at[38]);    MULADD(at[30], at[37]);    MULADD(at[31], at[36]);
+   COMBA_STORE(C->dp[35]);
+   /* 36 */
+   COMBA_FORWARD;
+   MULADD(at[5], at[63]);    MULADD(at[6], at[62]);    MULADD(at[7], at[61]);    MULADD(at[8], at[60]);    MULADD(at[9], at[59]);    MULADD(at[10], at[58]);    MULADD(at[11], at[57]);    MULADD(at[12], at[56]);    MULADD(at[13], at[55]);    MULADD(at[14], at[54]);    MULADD(at[15], at[53]);    MULADD(at[16], at[52]);    MULADD(at[17], at[51]);    MULADD(at[18], at[50]);    MULADD(at[19], at[49]);    MULADD(at[20], at[48]);    MULADD(at[21], at[47]);    MULADD(at[22], at[46]);    MULADD(at[23], at[45]);    MULADD(at[24], at[44]);    MULADD(at[25], at[43]);    MULADD(at[26], at[42]);    MULADD(at[27], at[41]);    MULADD(at[28], at[40]);    MULADD(at[29], at[39]);    MULADD(at[30], at[38]);    MULADD(at[31], at[37]);
+   COMBA_STORE(C->dp[36]);
+   /* 37 */
+   COMBA_FORWARD;
+   MULADD(at[6], at[63]);    MULADD(at[7], at[62]);    MULADD(at[8], at[61]);    MULADD(at[9], at[60]);    MULADD(at[10], at[59]);    MULADD(at[11], at[58]);    MULADD(at[12], at[57]);    MULADD(at[13], at[56]);    MULADD(at[14], at[55]);    MULADD(at[15], at[54]);    MULADD(at[16], at[53]);    MULADD(at[17], at[52]);    MULADD(at[18], at[51]);    MULADD(at[19], at[50]);    MULADD(at[20], at[49]);    MULADD(at[21], at[48]);    MULADD(at[22], at[47]);    MULADD(at[23], at[46]);    MULADD(at[24], at[45]);    MULADD(at[25], at[44]);    MULADD(at[26], at[43]);    MULADD(at[27], at[42]);    MULADD(at[28], at[41]);    MULADD(at[29], at[40]);    MULADD(at[30], at[39]);    MULADD(at[31], at[38]);
+   COMBA_STORE(C->dp[37]);
+   /* 38 */
+   COMBA_FORWARD;
+   MULADD(at[7], at[63]);    MULADD(at[8], at[62]);    MULADD(at[9], at[61]);    MULADD(at[10], at[60]);    MULADD(at[11], at[59]);    MULADD(at[12], at[58]);    MULADD(at[13], at[57]);    MULADD(at[14], at[56]);    MULADD(at[15], at[55]);    MULADD(at[16], at[54]);    MULADD(at[17], at[53]);    MULADD(at[18], at[52]);    MULADD(at[19], at[51]);    MULADD(at[20], at[50]);    MULADD(at[21], at[49]);    MULADD(at[22], at[48]);    MULADD(at[23], at[47]);    MULADD(at[24], at[46]);    MULADD(at[25], at[45]);    MULADD(at[26], at[44]);    MULADD(at[27], at[43]);    MULADD(at[28], at[42]);    MULADD(at[29], at[41]);    MULADD(at[30], at[40]);    MULADD(at[31], at[39]);
+   COMBA_STORE(C->dp[38]);
+
+   /* early out at 40 digits, 40*32==1280, or two 640 bit operands */
+   if (out_size <= 40) { COMBA_STORE2(C->dp[39]); C->used = 40; C->sign = A->sign ^ B->sign; pstm_clamp(C); COMBA_FINI; return PSTM_OKAY; }
+
+   /* 39 */
+   COMBA_FORWARD;
+   MULADD(at[8], at[63]);    MULADD(at[9], at[62]);    MULADD(at[10], at[61]);    MULADD(at[11], at[60]);    MULADD(at[12], at[59]);    MULADD(at[13], at[58]);    MULADD(at[14], at[57]);    MULADD(at[15], at[56]);    MULADD(at[16], at[55]);    MULADD(at[17], at[54]);    MULADD(at[18], at[53]);    MULADD(at[19], at[52]);    MULADD(at[20], at[51]);    MULADD(at[21], at[50]);    MULADD(at[22], at[49]);    MULADD(at[23], at[48]);    MULADD(at[24], at[47]);    MULADD(at[25], at[46]);    MULADD(at[26], at[45]);    MULADD(at[27], at[44]);    MULADD(at[28], at[43]);    MULADD(at[29], at[42]);    MULADD(at[30], at[41]);    MULADD(at[31], at[40]);
+   COMBA_STORE(C->dp[39]);
+   /* 40 */
+   COMBA_FORWARD;
+   MULADD(at[9], at[63]);    MULADD(at[10], at[62]);    MULADD(at[11], at[61]);    MULADD(at[12], at[60]);    MULADD(at[13], at[59]);    MULADD(at[14], at[58]);    MULADD(at[15], at[57]);    MULADD(at[16], at[56]);    MULADD(at[17], at[55]);    MULADD(at[18], at[54]);    MULADD(at[19], at[53]);    MULADD(at[20], at[52]);    MULADD(at[21], at[51]);    MULADD(at[22], at[50]);    MULADD(at[23], at[49]);    MULADD(at[24], at[48]);    MULADD(at[25], at[47]);    MULADD(at[26], at[46]);    MULADD(at[27], at[45]);    MULADD(at[28], at[44]);    MULADD(at[29], at[43]);    MULADD(at[30], at[42]);    MULADD(at[31], at[41]);
+   COMBA_STORE(C->dp[40]);
+   /* 41 */
+   COMBA_FORWARD;
+   MULADD(at[10], at[63]);    MULADD(at[11], at[62]);    MULADD(at[12], at[61]);    MULADD(at[13], at[60]);    MULADD(at[14], at[59]);    MULADD(at[15], at[58]);    MULADD(at[16], at[57]);    MULADD(at[17], at[56]);    MULADD(at[18], at[55]);    MULADD(at[19], at[54]);    MULADD(at[20], at[53]);    MULADD(at[21], at[52]);    MULADD(at[22], at[51]);    MULADD(at[23], at[50]);    MULADD(at[24], at[49]);    MULADD(at[25], at[48]);    MULADD(at[26], at[47]);    MULADD(at[27], at[46]);    MULADD(at[28], at[45]);    MULADD(at[29], at[44]);    MULADD(at[30], at[43]);    MULADD(at[31], at[42]);
+   COMBA_STORE(C->dp[41]);
+   /* 42 */
+   COMBA_FORWARD;
+   MULADD(at[11], at[63]);    MULADD(at[12], at[62]);    MULADD(at[13], at[61]);    MULADD(at[14], at[60]);    MULADD(at[15], at[59]);    MULADD(at[16], at[58]);    MULADD(at[17], at[57]);    MULADD(at[18], at[56]);    MULADD(at[19], at[55]);    MULADD(at[20], at[54]);    MULADD(at[21], at[53]);    MULADD(at[22], at[52]);    MULADD(at[23], at[51]);    MULADD(at[24], at[50]);    MULADD(at[25], at[49]);    MULADD(at[26], at[48]);    MULADD(at[27], at[47]);    MULADD(at[28], at[46]);    MULADD(at[29], at[45]);    MULADD(at[30], at[44]);    MULADD(at[31], at[43]);
+   COMBA_STORE(C->dp[42]);
+   /* 43 */
+   COMBA_FORWARD;
+   MULADD(at[12], at[63]);    MULADD(at[13], at[62]);    MULADD(at[14], at[61]);    MULADD(at[15], at[60]);    MULADD(at[16], at[59]);    MULADD(at[17], at[58]);    MULADD(at[18], at[57]);    MULADD(at[19], at[56]);    MULADD(at[20], at[55]);    MULADD(at[21], at[54]);    MULADD(at[22], at[53]);    MULADD(at[23], at[52]);    MULADD(at[24], at[51]);    MULADD(at[25], at[50]);    MULADD(at[26], at[49]);    MULADD(at[27], at[48]);    MULADD(at[28], at[47]);    MULADD(at[29], at[46]);    MULADD(at[30], at[45]);    MULADD(at[31], at[44]);
+   COMBA_STORE(C->dp[43]);
+   /* 44 */
+   COMBA_FORWARD;
+   MULADD(at[13], at[63]);    MULADD(at[14], at[62]);    MULADD(at[15], at[61]);    MULADD(at[16], at[60]);    MULADD(at[17], at[59]);    MULADD(at[18], at[58]);    MULADD(at[19], at[57]);    MULADD(at[20], at[56]);    MULADD(at[21], at[55]);    MULADD(at[22], at[54]);    MULADD(at[23], at[53]);    MULADD(at[24], at[52]);    MULADD(at[25], at[51]);    MULADD(at[26], at[50]);    MULADD(at[27], at[49]);    MULADD(at[28], at[48]);    MULADD(at[29], at[47]);    MULADD(at[30], at[46]);    MULADD(at[31], at[45]);
+   COMBA_STORE(C->dp[44]);
+   /* 45 */
+   COMBA_FORWARD;
+   MULADD(at[14], at[63]);    MULADD(at[15], at[62]);    MULADD(at[16], at[61]);    MULADD(at[17], at[60]);    MULADD(at[18], at[59]);    MULADD(at[19], at[58]);    MULADD(at[20], at[57]);    MULADD(at[21], at[56]);    MULADD(at[22], at[55]);    MULADD(at[23], at[54]);    MULADD(at[24], at[53]);    MULADD(at[25], at[52]);    MULADD(at[26], at[51]);    MULADD(at[27], at[50]);    MULADD(at[28], at[49]);    MULADD(at[29], at[48]);    MULADD(at[30], at[47]);    MULADD(at[31], at[46]);
+   COMBA_STORE(C->dp[45]);
+   /* 46 */
+   COMBA_FORWARD;
+   MULADD(at[15], at[63]);    MULADD(at[16], at[62]);    MULADD(at[17], at[61]);    MULADD(at[18], at[60]);    MULADD(at[19], at[59]);    MULADD(at[20], at[58]);    MULADD(at[21], at[57]);    MULADD(at[22], at[56]);    MULADD(at[23], at[55]);    MULADD(at[24], at[54]);    MULADD(at[25], at[53]);    MULADD(at[26], at[52]);    MULADD(at[27], at[51]);    MULADD(at[28], at[50]);    MULADD(at[29], at[49]);    MULADD(at[30], at[48]);    MULADD(at[31], at[47]);
+   COMBA_STORE(C->dp[46]);
+
+   /* early out at 48 digits, 48*32==1536, or two 768 bit operands */
+   if (out_size <= 48) { COMBA_STORE2(C->dp[47]); C->used = 48; C->sign = A->sign ^ B->sign; pstm_clamp(C); COMBA_FINI; return PSTM_OKAY; }
+
+   /* 47 */
+   COMBA_FORWARD;
+   MULADD(at[16], at[63]);    MULADD(at[17], at[62]);    MULADD(at[18], at[61]);    MULADD(at[19], at[60]);    MULADD(at[20], at[59]);    MULADD(at[21], at[58]);    MULADD(at[22], at[57]);    MULADD(at[23], at[56]);    MULADD(at[24], at[55]);    MULADD(at[25], at[54]);    MULADD(at[26], at[53]);    MULADD(at[27], at[52]);    MULADD(at[28], at[51]);    MULADD(at[29], at[50]);    MULADD(at[30], at[49]);    MULADD(at[31], at[48]);
+   COMBA_STORE(C->dp[47]);
+   /* 48 */
+   COMBA_FORWARD;
+   MULADD(at[17], at[63]);    MULADD(at[18], at[62]);    MULADD(at[19], at[61]);    MULADD(at[20], at[60]);    MULADD(at[21], at[59]);    MULADD(at[22], at[58]);    MULADD(at[23], at[57]);    MULADD(at[24], at[56]);    MULADD(at[25], at[55]);    MULADD(at[26], at[54]);    MULADD(at[27], at[53]);    MULADD(at[28], at[52]);    MULADD(at[29], at[51]);    MULADD(at[30], at[50]);    MULADD(at[31], at[49]);
+   COMBA_STORE(C->dp[48]);
+   /* 49 */
+   COMBA_FORWARD;
+   MULADD(at[18], at[63]);    MULADD(at[19], at[62]);    MULADD(at[20], at[61]);    MULADD(at[21], at[60]);    MULADD(at[22], at[59]);    MULADD(at[23], at[58]);    MULADD(at[24], at[57]);    MULADD(at[25], at[56]);    MULADD(at[26], at[55]);    MULADD(at[27], at[54]);    MULADD(at[28], at[53]);    MULADD(at[29], at[52]);    MULADD(at[30], at[51]);    MULADD(at[31], at[50]);
+   COMBA_STORE(C->dp[49]);
+   /* 50 */
+   COMBA_FORWARD;
+   MULADD(at[19], at[63]);    MULADD(at[20], at[62]);    MULADD(at[21], at[61]);    MULADD(at[22], at[60]);    MULADD(at[23], at[59]);    MULADD(at[24], at[58]);    MULADD(at[25], at[57]);    MULADD(at[26], at[56]);    MULADD(at[27], at[55]);    MULADD(at[28], at[54]);    MULADD(at[29], at[53]);    MULADD(at[30], at[52]);    MULADD(at[31], at[51]);
+   COMBA_STORE(C->dp[50]);
+   /* 51 */
+   COMBA_FORWARD;
+   MULADD(at[20], at[63]);    MULADD(at[21], at[62]);    MULADD(at[22], at[61]);    MULADD(at[23], at[60]);    MULADD(at[24], at[59]);    MULADD(at[25], at[58]);    MULADD(at[26], at[57]);    MULADD(at[27], at[56]);    MULADD(at[28], at[55]);    MULADD(at[29], at[54]);    MULADD(at[30], at[53]);    MULADD(at[31], at[52]);
+   COMBA_STORE(C->dp[51]);
+   /* 52 */
+   COMBA_FORWARD;
+   MULADD(at[21], at[63]);    MULADD(at[22], at[62]);    MULADD(at[23], at[61]);    MULADD(at[24], at[60]);    MULADD(at[25], at[59]);    MULADD(at[26], at[58]);    MULADD(at[27], at[57]);    MULADD(at[28], at[56]);    MULADD(at[29], at[55]);    MULADD(at[30], at[54]);    MULADD(at[31], at[53]);
+   COMBA_STORE(C->dp[52]);
+   /* 53 */
+   COMBA_FORWARD;
+   MULADD(at[22], at[63]);    MULADD(at[23], at[62]);    MULADD(at[24], at[61]);    MULADD(at[25], at[60]);    MULADD(at[26], at[59]);    MULADD(at[27], at[58]);    MULADD(at[28], at[57]);    MULADD(at[29], at[56]);    MULADD(at[30], at[55]);    MULADD(at[31], at[54]);
+   COMBA_STORE(C->dp[53]);
+   /* 54 */
+   COMBA_FORWARD;
+   MULADD(at[23], at[63]);    MULADD(at[24], at[62]);    MULADD(at[25], at[61]);    MULADD(at[26], at[60]);    MULADD(at[27], at[59]);    MULADD(at[28], at[58]);    MULADD(at[29], at[57]);    MULADD(at[30], at[56]);    MULADD(at[31], at[55]);
+   COMBA_STORE(C->dp[54]);
+
+   /* early out at 56 digits, 56*32==1792, or two 896 bit operands */
+   if (out_size <= 56) { COMBA_STORE2(C->dp[55]); C->used = 56; C->sign = A->sign ^ B->sign; pstm_clamp(C); COMBA_FINI; return PSTM_OKAY; }
+
+   /* 55 */
+   COMBA_FORWARD;
+   MULADD(at[24], at[63]);    MULADD(at[25], at[62]);    MULADD(at[26], at[61]);    MULADD(at[27], at[60]);    MULADD(at[28], at[59]);    MULADD(at[29], at[58]);    MULADD(at[30], at[57]);    MULADD(at[31], at[56]);
+   COMBA_STORE(C->dp[55]);
+   /* 56 */
+   COMBA_FORWARD;
+   MULADD(at[25], at[63]);    MULADD(at[26], at[62]);    MULADD(at[27], at[61]);    MULADD(at[28], at[60]);    MULADD(at[29], at[59]);    MULADD(at[30], at[58]);    MULADD(at[31], at[57]);
+   COMBA_STORE(C->dp[56]);
+   /* 57 */
+   COMBA_FORWARD;
+   MULADD(at[26], at[63]);    MULADD(at[27], at[62]);    MULADD(at[28], at[61]);    MULADD(at[29], at[60]);    MULADD(at[30], at[59]);    MULADD(at[31], at[58]);
+   COMBA_STORE(C->dp[57]);
+   /* 58 */
+   COMBA_FORWARD;
+   MULADD(at[27], at[63]);    MULADD(at[28], at[62]);    MULADD(at[29], at[61]);    MULADD(at[30], at[60]);    MULADD(at[31], at[59]);
+   COMBA_STORE(C->dp[58]);
+   /* 59 */
+   COMBA_FORWARD;
+   MULADD(at[28], at[63]);    MULADD(at[29], at[62]);    MULADD(at[30], at[61]);    MULADD(at[31], at[60]);
+   COMBA_STORE(C->dp[59]);
+   /* 60 */
+   COMBA_FORWARD;
+   MULADD(at[29], at[63]);    MULADD(at[30], at[62]);    MULADD(at[31], at[61]);
+   COMBA_STORE(C->dp[60]);
+   /* 61 */
+   COMBA_FORWARD;
+   MULADD(at[30], at[63]);    MULADD(at[31], at[62]);
+   COMBA_STORE(C->dp[61]);
+   /* 62 */
+   COMBA_FORWARD;
+   MULADD(at[31], at[63]);
+   COMBA_STORE(C->dp[62]);
+   COMBA_STORE2(C->dp[63]);
+   C->used = 64;
+   C->sign = A->sign ^ B->sign;
+   pstm_clamp(C);
+   COMBA_FINI;
+	return PSTM_OKAY;
+}
+#endif /* USE_2048_KEY_SPEED_OPTIMIZATIONS */
+
+/******************************************************************************/
+
+int32 pstm_mul_comba(psPool_t *pool, pstm_int *A, pstm_int *B, pstm_int *C,
+			pstm_digit *paD, uint32 paDlen)
+{
+#ifdef USE_1024_KEY_SPEED_OPTIMIZATIONS
+	if (A->used == 16 && B->used == 16) {
+		return pstm_mul_comba16(A, B, C);
+	} else {
+#ifdef USE_2048_KEY_SPEED_OPTIMIZATIONS
+		if (A->used == 32 && B->used == 32) {
+			return pstm_mul_comba32(A, B, C);
+		}
+#endif /* USE_2048_KEY_SPEED_OPTIMIZATIONS */
+		return pstm_mul_comba_gen(pool, A, B, C, paD, paDlen);
+	}
+#else
+#ifdef USE_2048_KEY_SPEED_OPTIMIZATIONS
+	if (A->used == 32 && B->used == 32) {
+		return pstm_mul_comba32(A, B, C);
+	}
+#endif /* USE_2048_KEY_SPEED_OPTIMIZATIONS */
+	return pstm_mul_comba_gen(pool, A, B, C, paD, paDlen);
+#endif
+}
+
+#endif /* !DISABLE_PSTM */
+/******************************************************************************/
diff -urpN busybox-1.26.2/networking/tls_pstm_sqr_comba.c busybox-1.27.0/networking/tls_pstm_sqr_comba.c
--- busybox-1.26.2/networking/tls_pstm_sqr_comba.c	1970-01-01 01:00:00.000000000 +0100
+++ busybox-1.27.0/networking/tls_pstm_sqr_comba.c	2017-01-19 16:21:18.000000000 +0100
@@ -0,0 +1,1111 @@
+/*
+ * Copyright (C) 2017 Denys Vlasenko
+ *
+ * Licensed under GPLv2, see file LICENSE in this source tree.
+ */
+#include "tls.h"
+
+/* The file is taken almost verbatim from matrixssl-3-7-2b-open/crypto/math/.
+ * Changes are flagged with //bbox
+ */
+
+/**
+ *	@file    pstm_sqr_comba.c
+ *	@version 33ef80f (HEAD, tag: MATRIXSSL-3-7-2-OPEN, tag: MATRIXSSL-3-7-2-COMM, origin/master, origin/HEAD, master)
+ *
+ *	Multiprecision Squaring with Comba technique.
+ */
+/*
+ *	Copyright (c) 2013-2015 INSIDE Secure Corporation
+ *	Copyright (c) PeerSec Networks, 2002-2011
+ *	All Rights Reserved
+ *
+ *	The latest version of this code is available at http://www.matrixssl.org
+ *
+ *	This software is open source; you can redistribute it and/or modify
+ *	it under the terms of the GNU General Public License as published by
+ *	the Free Software Foundation; either version 2 of the License, or
+ *	(at your option) any later version.
+ *
+ *	This General Public License does NOT permit incorporating this software
+ *	into proprietary programs.  If you are unable to comply with the GPL, a
+ *	commercial license for this software may be purchased from INSIDE at
+ *	http://www.insidesecure.com/eng/Company/Locations
+ *
+ *	This program is distributed in WITHOUT ANY WARRANTY; without even the
+ *	implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
+ *	See the GNU General Public License for more details.
+ *
+ *	You should have received a copy of the GNU General Public License
+ *	along with this program; if not, write to the Free Software
+ *	Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+ *	http://www.gnu.org/copyleft/gpl.html
+ */
+/******************************************************************************/
+
+//bbox
+//#include "../cryptoApi.h"
+#ifndef DISABLE_PSTM
+
+/******************************************************************************/
+#if defined(PSTM_X86)
+/* x86-32 optimized for 32 bit platforms. For 64 bit mode use X86_64 instead */
+#if !defined(__GNUC__) || !defined(__i386__)
+#error "PSTM_X86 option requires GCC and 32 bit mode x86 processor"
+#endif
+//#pragma message ("Using 32 bit x86 Assembly Optimizations")
+
+#define COMBA_START
+
+#define CLEAR_CARRY \
+   c0 = c1 = c2 = 0;
+
+#define COMBA_STORE(x) \
+   x = c0;
+
+#define COMBA_STORE2(x) \
+   x = c1;
+
+#define CARRY_FORWARD \
+   do { c0 = c1; c1 = c2; c2 = 0; } while (0);
+
+#define COMBA_FINI
+
+#define SQRADD(i, j)                                      \
+asm(                                            \
+	 "movl  %6,%%eax     \n\t"                            \
+	 "mull  %%eax        \n\t"                            \
+	 "addl  %%eax,%0     \n\t"                            \
+	 "adcl  %%edx,%1     \n\t"                            \
+	 "adcl  $0,%2        \n\t"                            \
+	 :"=r"(c0), "=r"(c1), "=r"(c2): "0"(c0), "1"(c1), "2"(c2), "m"(i) :"%eax","%edx","%cc");
+
+#define SQRADD2(i, j)                                     \
+asm(                                            \
+	 "movl  %6,%%eax     \n\t"                            \
+	 "mull  %7           \n\t"                            \
+	 "addl  %%eax,%0     \n\t"                            \
+	 "adcl  %%edx,%1     \n\t"                            \
+	 "adcl  $0,%2        \n\t"                            \
+	 "addl  %%eax,%0     \n\t"                            \
+	 "adcl  %%edx,%1     \n\t"                            \
+	 "adcl  $0,%2        \n\t"                            \
+	 :"=r"(c0), "=r"(c1), "=r"(c2): "0"(c0), "1"(c1), "2"(c2), "m"(i), "m"(j)  :"%eax","%edx","%cc");
+
+#define SQRADDSC(i, j)                                    \
+asm(                                                     \
+	 "movl  %6,%%eax     \n\t"                            \
+	 "mull  %7           \n\t"                            \
+	 "movl  %%eax,%0     \n\t"                            \
+	 "movl  %%edx,%1     \n\t"                            \
+	 "xorl  %2,%2        \n\t"                            \
+	 :"=r"(sc0), "=r"(sc1), "=r"(sc2): "0"(sc0), "1"(sc1), "2"(sc2), "g"(i), "g"(j) :"%eax","%edx","%cc");
+
+#define SQRADDAC(i, j)                                    \
+asm(                                                     \
+	 "movl  %6,%%eax     \n\t"                            \
+	 "mull  %7           \n\t"                            \
+	 "addl  %%eax,%0     \n\t"                            \
+	 "adcl  %%edx,%1     \n\t"                            \
+	 "adcl  $0,%2        \n\t"                            \
+	 :"=r"(sc0), "=r"(sc1), "=r"(sc2): "0"(sc0), "1"(sc1), "2"(sc2), "g"(i), "g"(j) :"%eax","%edx","%cc");
+
+#define SQRADDDB                                          \
+asm(                                                     \
+	 "addl %6,%0         \n\t"                            \
+	 "adcl %7,%1         \n\t"                            \
+	 "adcl %8,%2         \n\t"                            \
+	 "addl %6,%0         \n\t"                            \
+	 "adcl %7,%1         \n\t"                            \
+	 "adcl %8,%2         \n\t"                            \
+	 :"=r"(c0), "=r"(c1), "=r"(c2) : "0"(c0), "1"(c1), "2"(c2), "r"(sc0), "r"(sc1), "r"(sc2) : "%cc");
+
+/******************************************************************************/
+#elif defined(PSTM_X86_64)
+/* x86-64 optimized */
+#if !defined(__GNUC__) || !defined(__x86_64__) || !defined(PSTM_64BIT)
+#error "PSTM_X86_64 option requires PSTM_64BIT, GCC and 64 bit mode x86 processor"
+#endif
+//#pragma message ("Using 64 bit x86_64 Assembly Optimizations")
+
+#define COMBA_START
+
+#define CLEAR_CARRY \
+c0 = c1 = c2 = 0;
+
+#define COMBA_STORE(x) \
+x = c0;
+
+#define COMBA_STORE2(x) \
+x = c1;
+
+#define CARRY_FORWARD \
+do { c0 = c1; c1 = c2; c2 = 0; } while (0);
+
+#define COMBA_FINI
+
+#define SQRADD(i, j)                                     \
+asm(                                                     \
+	"movq  %6,%%rax     \n\t"                            \
+	"mulq  %%rax        \n\t"                            \
+	"addq  %%rax,%0     \n\t"                            \
+	"adcq  %%rdx,%1     \n\t"                            \
+	"adcq  $0,%2        \n\t"                            \
+	:"=r"(c0), "=r"(c1), "=r"(c2): "0"(c0), "1"(c1), "2"(c2), "g"(i) :"%rax","%rdx","cc");
+
+#define SQRADD2(i, j)                                    \
+asm(                                                     \
+	"movq  %6,%%rax     \n\t"                            \
+	"mulq  %7           \n\t"                            \
+	"addq  %%rax,%0     \n\t"                            \
+	"adcq  %%rdx,%1     \n\t"                            \
+	"adcq  $0,%2        \n\t"                            \
+	"addq  %%rax,%0     \n\t"                            \
+	"adcq  %%rdx,%1     \n\t"                            \
+	"adcq  $0,%2        \n\t"                            \
+	:"=r"(c0), "=r"(c1), "=r"(c2): "0"(c0), "1"(c1), "2"(c2), "g"(i), "g"(j)  :"%rax","%rdx","cc");
+
+#define SQRADDSC(i, j)                                   \
+asm(                                                     \
+	"movq  %6,%%rax     \n\t"                            \
+	"mulq  %7           \n\t"                            \
+	"movq  %%rax,%0     \n\t"                            \
+	"movq  %%rdx,%1     \n\t"                            \
+	"xorq  %2,%2        \n\t"                            \
+	:"=r"(sc0), "=r"(sc1), "=r"(sc2): "0"(sc0), "1"(sc1), "2"(sc2), "g"(i), "g"(j) :"%rax","%rdx","cc");
+
+#define SQRADDAC(i, j)                                   \
+asm(                                                     \
+	"movq  %6,%%rax     \n\t"                            \
+	"mulq  %7           \n\t"                            \
+	"addq  %%rax,%0     \n\t"                            \
+	"adcq  %%rdx,%1     \n\t"                            \
+	"adcq  $0,%2        \n\t"                            \
+	:"=r"(sc0), "=r"(sc1), "=r"(sc2): "0"(sc0), "1"(sc1), "2"(sc2), "g"(i), "g"(j) :"%rax","%rdx","cc");
+
+#define SQRADDDB                                         \
+asm(                                                     \
+	"addq %6,%0         \n\t"                            \
+	"adcq %7,%1         \n\t"                            \
+	"adcq %8,%2         \n\t"                            \
+	"addq %6,%0         \n\t"                            \
+	"adcq %7,%1         \n\t"                            \
+	"adcq %8,%2         \n\t"                            \
+	:"=r"(c0), "=r"(c1), "=r"(c2) : "0"(c0), "1"(c1), "2"(c2), "r"(sc0), "r"(sc1), "r"(sc2) : "cc");
+
+/******************************************************************************/
+#elif defined(PSTM_ARM)
+/* ARM code */
+//#pragma message ("Using 32 bit ARM Assembly Optimizations")
+
+#define COMBA_START
+
+#define CLEAR_CARRY \
+c0 = c1 = c2 = 0;
+
+#define COMBA_STORE(x) \
+x = c0;
+
+#define COMBA_STORE2(x) \
+x = c1;
+
+#define CARRY_FORWARD \
+do { c0 = c1; c1 = c2; c2 = 0; } while (0);
+
+#define COMBA_FINI
+
+/* multiplies point i and j, updates carry "c1" and digit c2 */
+#define SQRADD(i, j)                                             \
+asm(                                                             \
+"  UMULL  r0,r1,%6,%6              \n\t"                         \
+"  ADDS   %0,%0,r0                 \n\t"                         \
+"  ADCS   %1,%1,r1                 \n\t"                         \
+"  ADC    %2,%2,#0                 \n\t"                         \
+:"=r"(c0), "=r"(c1), "=r"(c2) : "0"(c0), "1"(c1), "2"(c2), "r"(i) : "r0", "r1", "%cc");
+
+/* for squaring some of the terms are doubled... */
+#define SQRADD2(i, j)                                            \
+asm(                                                             \
+"  UMULL  r0,r1,%6,%7              \n\t"                         \
+"  ADDS   %0,%0,r0                 \n\t"                         \
+"  ADCS   %1,%1,r1                 \n\t"                         \
+"  ADC    %2,%2,#0                 \n\t"                         \
+"  ADDS   %0,%0,r0                 \n\t"                         \
+"  ADCS   %1,%1,r1                 \n\t"                         \
+"  ADC    %2,%2,#0                 \n\t"                         \
+:"=r"(c0), "=r"(c1), "=r"(c2) : "0"(c0), "1"(c1), "2"(c2), "r"(i), "r"(j) : "r0", "r1", "%cc");
+
+#define SQRADDSC(i, j)                                           \
+asm(                                                             \
+"  UMULL  %0,%1,%6,%7              \n\t"                         \
+"  SUB    %2,%2,%2                 \n\t"                         \
+:"=r"(sc0), "=r"(sc1), "=r"(sc2) : "0"(sc0), "1"(sc1), "2"(sc2), "r"(i), "r"(j) : "%cc");
+
+#define SQRADDAC(i, j)                                           \
+asm(                                                             \
+"  UMULL  r0,r1,%6,%7              \n\t"                         \
+"  ADDS   %0,%0,r0                 \n\t"                         \
+"  ADCS   %1,%1,r1                 \n\t"                         \
+"  ADC    %2,%2,#0                 \n\t"                         \
+:"=r"(sc0), "=r"(sc1), "=r"(sc2) : "0"(sc0), "1"(sc1), "2"(sc2), "r"(i), "r"(j) : "r0", "r1", "%cc");
+
+#define SQRADDDB                                                 \
+asm(                                                             \
+"  ADDS  %0,%0,%3                     \n\t"                      \
+"  ADCS  %1,%1,%4                     \n\t"                      \
+"  ADC   %2,%2,%5                     \n\t"                      \
+"  ADDS  %0,%0,%3                     \n\t"                      \
+"  ADCS  %1,%1,%4                     \n\t"                      \
+"  ADC   %2,%2,%5                     \n\t"                      \
+:"=r"(c0), "=r"(c1), "=r"(c2) : "r"(sc0), "r"(sc1), "r"(sc2), "0"(c0), "1"(c1), "2"(c2) : "%cc");
+
+/******************************************************************************/
+#elif defined(PSTM_MIPS)
+/* MIPS32 */
+//#pragma message ("Using 32 bit MIPS Assembly Optimizations")
+
+#define COMBA_START
+
+#define CLEAR_CARRY \
+c0 = c1 = c2 = 0;
+
+#define COMBA_STORE(x) \
+x = c0;
+
+#define COMBA_STORE2(x) \
+x = c1;
+
+#define CARRY_FORWARD \
+do { c0 = c1; c1 = c2; c2 = 0; } while (0);
+
+#define COMBA_FINI
+
+/* multiplies point i and j, updates carry "c1" and digit c2 */
+#define SQRADD(i, j)               \
+asm(                               \
+	" multu  %6,%6          \n\t"  \
+	" mflo   $12            \n\t"  \
+	" mfhi   $13            \n\t"  \
+	" addu    %0,%0,$12     \n\t"  \
+	" sltu   $12,%0,$12     \n\t"  \
+	" addu    %1,%1,$13     \n\t"  \
+	" sltu   $13,%1,$13     \n\t"  \
+	" addu    %1,%1,$12     \n\t"  \
+	" sltu   $12,%1,$12     \n\t"  \
+	" addu    %2,%2,$13     \n\t"  \
+	" addu    %2,%2,$12     \n\t"  \
+	:"=r"(c0), "=r"(c1), "=r"(c2):"0"(c0), "1"(c1), "2"(c2), "r"(i):"$12","$13");
+
+/* for squaring some of the terms are doubled... */
+#define SQRADD2(i, j)             \
+asm(                              \
+	" multu  %6,%7          \n\t" \
+	" mflo   $12            \n\t" \
+	" mfhi   $13            \n\t" \
+	\
+	" addu    %0,%0,$12     \n\t" \
+	" sltu   $14,%0,$12     \n\t" \
+	" addu    %1,%1,$13     \n\t" \
+	" sltu   $15,%1,$13     \n\t" \
+	" addu    %1,%1,$14     \n\t" \
+	" sltu   $14,%1,$14     \n\t" \
+	" addu    %2,%2,$15     \n\t" \
+	" addu    %2,%2,$14     \n\t" \
+	\
+	" addu    %0,%0,$12     \n\t" \
+	" sltu   $14,%0,$12     \n\t" \
+	" addu    %1,%1,$13     \n\t" \
+	" sltu   $15,%1,$13     \n\t" \
+	" addu    %1,%1,$14     \n\t" \
+	" sltu   $14,%1,$14     \n\t" \
+	" addu    %2,%2,$15     \n\t" \
+	" addu    %2,%2,$14     \n\t" \
+	:"=r"(c0), "=r"(c1), "=r"(c2):"0"(c0), "1"(c1), "2"(c2), "r"(i), "r"(j):"$12", "$13", "$14", "$15");
+
+#define SQRADDSC(i, j)             \
+asm(                               \
+	" multu  %6,%7          \n\t"  \
+	" mflo   %0             \n\t"  \
+	" mfhi   %1             \n\t"  \
+	" xor    %2,%2,%2       \n\t"  \
+	:"=r"(sc0), "=r"(sc1), "=r"(sc2):"0"(sc0), "1"(sc1), "2"(sc2), "r"(i),"r"(j) : "%cc");
+
+#define SQRADDAC(i, j)            \
+asm(                              \
+	" multu  %6,%7          \n\t" \
+	" mflo   $12            \n\t" \
+	" mfhi   $13            \n\t" \
+	" addu    %0,%0,$12     \n\t" \
+	" sltu   $12,%0,$12     \n\t" \
+	" addu    %1,%1,$13     \n\t" \
+	" sltu   $13,%1,$13     \n\t" \
+	" addu    %1,%1,$12     \n\t" \
+	" sltu   $12,%1,$12     \n\t" \
+	" addu    %2,%2,$13     \n\t" \
+	" addu    %2,%2,$12     \n\t" \
+	:"=r"(sc0), "=r"(sc1), "=r"(sc2):"0"(sc0), "1"(sc1), "2"(sc2), "r"(i), "r"(j):"$12", "$13", "$14");
+
+#define SQRADDDB                   \
+asm(                               \
+	" addu    %0,%0,%3       \n\t" \
+	" sltu   $10,%0,%3       \n\t" \
+	" addu    %1,%1,$10      \n\t" \
+	" sltu   $10,%1,$10      \n\t" \
+	" addu    %1,%1,%4       \n\t" \
+	" sltu   $11,%1,%4       \n\t" \
+	" addu    %2,%2,$10      \n\t" \
+	" addu    %2,%2,$11      \n\t" \
+	" addu    %2,%2,%5       \n\t" \
+	\
+	" addu    %0,%0,%3       \n\t" \
+	" sltu   $10,%0,%3       \n\t" \
+	" addu    %1,%1,$10      \n\t" \
+	" sltu   $10,%1,$10      \n\t" \
+	" addu    %1,%1,%4       \n\t" \
+	" sltu   $11,%1,%4       \n\t" \
+	" addu    %2,%2,$10      \n\t" \
+	" addu    %2,%2,$11      \n\t" \
+	" addu    %2,%2,%5       \n\t" \
+	:"=r"(c0), "=r"(c1), "=r"(c2) : "r"(sc0), "r"(sc1), "r"(sc2), "0"(c0), "1"(c1), "2"(c2) : "$10", "$11");
+
+#else
+/******************************************************************************/
+#define PSTM_ISO
+/* ISO C portable code */
+
+#define COMBA_START
+
+#define CLEAR_CARRY \
+   c0 = c1 = c2 = 0;
+
+#define COMBA_STORE(x) \
+   x = c0;
+
+#define COMBA_STORE2(x) \
+   x = c1;
+
+#define CARRY_FORWARD \
+   do { c0 = c1; c1 = c2; c2 = 0; } while (0);
+
+#define COMBA_FINI
+
+/* multiplies point i and j, updates carry "c1" and digit c2 */
+#define SQRADD(i, j)													\
+   do { pstm_word t;													\
+   t = c0 + ((pstm_word)i) * ((pstm_word)j);  c0 = (pstm_digit)t;		\
+   t = c1 + (t >> DIGIT_BIT);											\
+   c1 = (pstm_digit)t; c2 += (pstm_digit)(t >> DIGIT_BIT);				\
+   } while (0);
+
+
+/* for squaring some of the terms are doubled... */
+#define SQRADD2(i, j)											\
+   do { pstm_word t;											\
+   t  = ((pstm_word)i) * ((pstm_word)j);						\
+   tt = (pstm_word)c0 + t; c0 = (pstm_digit)tt;					\
+   tt = (pstm_word)c1 + (tt >> DIGIT_BIT);						\
+   c1 = (pstm_digit)tt; c2 += (pstm_digit)(tt >> DIGIT_BIT);	\
+   tt = (pstm_word)c0 + t; c0 = (pstm_digit)tt;					\
+   tt = (pstm_word)c1 + (tt >> DIGIT_BIT);						\
+   c1 = (pstm_digit)tt; c2 += (pstm_digit)(tt >> DIGIT_BIT);	\
+   } while (0);
+
+#define SQRADDSC(i, j)										\
+   do { pstm_word t;										\
+	  t =  ((pstm_word)i) * ((pstm_word)j);					\
+	  sc0 = (pstm_digit)t; sc1 = (pstm_digit)(t >> DIGIT_BIT); sc2 = 0;	\
+   } while (0);
+
+#define SQRADDAC(i, j)														\
+   do { pstm_word t;														\
+   t = ((pstm_word)sc0) + ((pstm_word)i) * ((pstm_word)j);					\
+   sc0 = (pstm_digit)t;														\
+   t = ((pstm_word)sc1) + (t >> DIGIT_BIT); sc1 = (pstm_digit)t;			\
+   sc2 += (pstm_digit)(t >> DIGIT_BIT);										\
+   } while (0);
+
+#define SQRADDDB															\
+   do { pstm_word t;														\
+   t = ((pstm_word)sc0) + ((pstm_word)sc0) + ((pstm_word)c0);				\
+   c0 = (pstm_digit)t;														\
+   t = ((pstm_word)sc1) + ((pstm_word)sc1) + c1 + (t >> DIGIT_BIT);			\
+   c1 = (pstm_digit)t;														\
+   c2 = c2 + sc2 + sc2 + (pstm_digit)(t >> DIGIT_BIT);						\
+   } while (0);
+
+#endif /* ISO_C */
+
+/******************************************************************************/
+/*
+	Non-unrolled comba squarer
+ */
+//bbox: pool unused
+#define pstm_sqr_comba_gen(pool, A, B, paD, paDlen) \
+        pstm_sqr_comba_gen(      A, B, paD, paDlen)
+static int32 pstm_sqr_comba_gen(psPool_t *pool, pstm_int *A, pstm_int *B,
+			pstm_digit *paD, uint32 paDlen)
+{
+	int16		paDfail, pa;
+	int32       ix, iz;
+	pstm_digit  c0, c1, c2, *dst;
+#ifdef PSTM_ISO
+	pstm_word   tt;
+#endif
+
+	paDfail = 0;
+	/* get size of output and trim */
+	pa = A->used + A->used;
+
+	/* number of output digits to produce */
+	COMBA_START;
+	CLEAR_CARRY;
+/*
+	If b is not large enough grow it and continue
+*/
+	if (B->alloc < pa) {
+		if (pstm_grow(B, pa) != PSTM_OKAY) {
+			return PS_MEM_FAIL;
+		}
+	}
+	if (paD != NULL) {
+		if (paDlen < (sizeof(pstm_digit) * pa)) {
+			paDfail = 1; /* have a paD, but it's not big enough */
+			dst = xzalloc(sizeof(pstm_digit) * pa);//bbox
+		} else {
+			dst = paD;
+			memset(dst, 0x0, paDlen);
+		}
+	} else {
+		dst = xzalloc(sizeof(pstm_digit) * pa);//bbox
+	}
+
+	for (ix = 0; ix < pa; ix++) {
+		int32      tx, ty, iy;
+		pstm_digit *tmpy, *tmpx;
+
+		/* get offsets into the two bignums */
+		ty = min(A->used-1, ix);
+		tx = ix - ty;
+
+		/* setup temp aliases */
+		tmpx = A->dp + tx;
+		tmpy = A->dp + ty;
+
+/*
+			This is the number of times the loop will iterate,
+				while (tx++ < a->used && ty-- >= 0) { ... }
+*/
+		iy = min(A->used-tx, ty+1);
+
+/*
+		now for squaring tx can never equal ty. We halve the distance since
+		they approach at a rate of 2x and we have to round because odd cases
+		need to be executed
+*/
+		iy = min(iy, (ty-tx+1)>>1);
+
+		/* forward carries */
+		CARRY_FORWARD;
+
+		/* execute loop */
+		for (iz = 0; iz < iy; iz++) {
+			SQRADD2(*tmpx++, *tmpy--);
+		}
+
+		/* even columns have the square term in them */
+		if ((ix&1) == 0) {
+			SQRADD(A->dp[ix>>1], A->dp[ix>>1]);
+		}
+
+		/* store it */
+		COMBA_STORE(dst[ix]);
+	}
+
+	COMBA_FINI;
+/*
+	setup dest
+ */
+	iz  = B->used;
+	B->used = pa;
+	{
+		pstm_digit *tmpc;
+		tmpc = B->dp;
+		for (ix = 0; ix < pa; ix++) {
+			*tmpc++ = dst[ix];
+		}
+		/*	clear unused digits (that existed in the old copy of c) */
+		for (; ix < iz; ix++) {
+			*tmpc++ = 0;
+		}
+	}
+	pstm_clamp(B);
+
+	if ((paD == NULL) || paDfail == 1) {
+		psFree(dst, pool);
+	}
+	return PS_SUCCESS;
+}
+
+/******************************************************************************/
+/*
+	Unrolled Comba loop for 1024 bit keys
+ */
+#ifdef USE_1024_KEY_SPEED_OPTIMIZATIONS
+static int32 pstm_sqr_comba16(pstm_int *A, pstm_int *B)
+{
+	pstm_digit *a, b[32], c0, c1, c2, sc0, sc1, sc2;
+#ifdef PSTM_ISO
+	pstm_word   tt;
+#endif
+
+	if (B->alloc < 32) {
+		if (pstm_grow(B, 32) != PSTM_OKAY) {
+			return PS_MEM_FAIL;
+		}
+	}
+	a = A->dp;
+	sc0 = sc1 = sc2 = 0;
+
+	COMBA_START;
+
+   /* clear carries */
+   CLEAR_CARRY;
+
+   /* output 0 */
+   SQRADD(a[0],a[0]);
+   COMBA_STORE(b[0]);
+
+   /* output 1 */
+   CARRY_FORWARD;
+   SQRADD2(a[0], a[1]);
+   COMBA_STORE(b[1]);
+
+   /* output 2 */
+   CARRY_FORWARD;
+   SQRADD2(a[0], a[2]); SQRADD(a[1], a[1]);
+   COMBA_STORE(b[2]);
+
+   /* output 3 */
+   CARRY_FORWARD;
+   SQRADD2(a[0], a[3]); SQRADD2(a[1], a[2]);
+   COMBA_STORE(b[3]);
+
+   /* output 4 */
+   CARRY_FORWARD;
+   SQRADD2(a[0], a[4]); SQRADD2(a[1], a[3]); SQRADD(a[2], a[2]);
+   COMBA_STORE(b[4]);
+
+   /* output 5 */
+   CARRY_FORWARD;
+   SQRADDSC(a[0], a[5]); SQRADDAC(a[1], a[4]); SQRADDAC(a[2], a[3]); SQRADDDB;
+   COMBA_STORE(b[5]);
+
+   /* output 6 */
+   CARRY_FORWARD;
+   SQRADDSC(a[0], a[6]); SQRADDAC(a[1], a[5]); SQRADDAC(a[2], a[4]); SQRADDDB; SQRADD(a[3], a[3]);
+   COMBA_STORE(b[6]);
+
+   /* output 7 */
+   CARRY_FORWARD;
+   SQRADDSC(a[0], a[7]); SQRADDAC(a[1], a[6]); SQRADDAC(a[2], a[5]); SQRADDAC(a[3], a[4]); SQRADDDB;
+   COMBA_STORE(b[7]);
+
+   /* output 8 */
+   CARRY_FORWARD;
+   SQRADDSC(a[0], a[8]); SQRADDAC(a[1], a[7]); SQRADDAC(a[2], a[6]); SQRADDAC(a[3], a[5]); SQRADDDB; SQRADD(a[4], a[4]);
+   COMBA_STORE(b[8]);
+
+   /* output 9 */
+   CARRY_FORWARD;
+   SQRADDSC(a[0], a[9]); SQRADDAC(a[1], a[8]); SQRADDAC(a[2], a[7]); SQRADDAC(a[3], a[6]); SQRADDAC(a[4], a[5]); SQRADDDB;
+   COMBA_STORE(b[9]);
+
+   /* output 10 */
+   CARRY_FORWARD;
+   SQRADDSC(a[0], a[10]); SQRADDAC(a[1], a[9]); SQRADDAC(a[2], a[8]); SQRADDAC(a[3], a[7]); SQRADDAC(a[4], a[6]); SQRADDDB; SQRADD(a[5], a[5]);
+   COMBA_STORE(b[10]);
+
+   /* output 11 */
+   CARRY_FORWARD;
+   SQRADDSC(a[0], a[11]); SQRADDAC(a[1], a[10]); SQRADDAC(a[2], a[9]); SQRADDAC(a[3], a[8]); SQRADDAC(a[4], a[7]); SQRADDAC(a[5], a[6]); SQRADDDB;
+   COMBA_STORE(b[11]);
+
+   /* output 12 */
+   CARRY_FORWARD;
+   SQRADDSC(a[0], a[12]); SQRADDAC(a[1], a[11]); SQRADDAC(a[2], a[10]); SQRADDAC(a[3], a[9]); SQRADDAC(a[4], a[8]); SQRADDAC(a[5], a[7]); SQRADDDB; SQRADD(a[6], a[6]);
+   COMBA_STORE(b[12]);
+
+   /* output 13 */
+   CARRY_FORWARD;
+   SQRADDSC(a[0], a[13]); SQRADDAC(a[1], a[12]); SQRADDAC(a[2], a[11]); SQRADDAC(a[3], a[10]); SQRADDAC(a[4], a[9]); SQRADDAC(a[5], a[8]); SQRADDAC(a[6], a[7]); SQRADDDB;
+   COMBA_STORE(b[13]);
+
+   /* output 14 */
+   CARRY_FORWARD;
+   SQRADDSC(a[0], a[14]); SQRADDAC(a[1], a[13]); SQRADDAC(a[2], a[12]); SQRADDAC(a[3], a[11]); SQRADDAC(a[4], a[10]); SQRADDAC(a[5], a[9]); SQRADDAC(a[6], a[8]); SQRADDDB; SQRADD(a[7], a[7]);
+   COMBA_STORE(b[14]);
+
+   /* output 15 */
+   CARRY_FORWARD;
+   SQRADDSC(a[0], a[15]); SQRADDAC(a[1], a[14]); SQRADDAC(a[2], a[13]); SQRADDAC(a[3], a[12]); SQRADDAC(a[4], a[11]); SQRADDAC(a[5], a[10]); SQRADDAC(a[6], a[9]); SQRADDAC(a[7], a[8]); SQRADDDB;
+   COMBA_STORE(b[15]);
+
+   /* output 16 */
+   CARRY_FORWARD;
+   SQRADDSC(a[1], a[15]); SQRADDAC(a[2], a[14]); SQRADDAC(a[3], a[13]); SQRADDAC(a[4], a[12]); SQRADDAC(a[5], a[11]); SQRADDAC(a[6], a[10]); SQRADDAC(a[7], a[9]); SQRADDDB; SQRADD(a[8], a[8]);
+   COMBA_STORE(b[16]);
+
+   /* output 17 */
+   CARRY_FORWARD;
+   SQRADDSC(a[2], a[15]); SQRADDAC(a[3], a[14]); SQRADDAC(a[4], a[13]); SQRADDAC(a[5], a[12]); SQRADDAC(a[6], a[11]); SQRADDAC(a[7], a[10]); SQRADDAC(a[8], a[9]); SQRADDDB;
+   COMBA_STORE(b[17]);
+
+   /* output 18 */
+   CARRY_FORWARD;
+   SQRADDSC(a[3], a[15]); SQRADDAC(a[4], a[14]); SQRADDAC(a[5], a[13]); SQRADDAC(a[6], a[12]); SQRADDAC(a[7], a[11]); SQRADDAC(a[8], a[10]); SQRADDDB; SQRADD(a[9], a[9]);
+   COMBA_STORE(b[18]);
+
+   /* output 19 */
+   CARRY_FORWARD;
+   SQRADDSC(a[4], a[15]); SQRADDAC(a[5], a[14]); SQRADDAC(a[6], a[13]); SQRADDAC(a[7], a[12]); SQRADDAC(a[8], a[11]); SQRADDAC(a[9], a[10]); SQRADDDB;
+   COMBA_STORE(b[19]);
+
+   /* output 20 */
+   CARRY_FORWARD;
+   SQRADDSC(a[5], a[15]); SQRADDAC(a[6], a[14]); SQRADDAC(a[7], a[13]); SQRADDAC(a[8], a[12]); SQRADDAC(a[9], a[11]); SQRADDDB; SQRADD(a[10], a[10]);
+   COMBA_STORE(b[20]);
+
+   /* output 21 */
+   CARRY_FORWARD;
+   SQRADDSC(a[6], a[15]); SQRADDAC(a[7], a[14]); SQRADDAC(a[8], a[13]); SQRADDAC(a[9], a[12]); SQRADDAC(a[10], a[11]); SQRADDDB;
+   COMBA_STORE(b[21]);
+
+   /* output 22 */
+   CARRY_FORWARD;
+   SQRADDSC(a[7], a[15]); SQRADDAC(a[8], a[14]); SQRADDAC(a[9], a[13]); SQRADDAC(a[10], a[12]); SQRADDDB; SQRADD(a[11], a[11]);
+   COMBA_STORE(b[22]);
+
+   /* output 23 */
+   CARRY_FORWARD;
+   SQRADDSC(a[8], a[15]); SQRADDAC(a[9], a[14]); SQRADDAC(a[10], a[13]); SQRADDAC(a[11], a[12]); SQRADDDB;
+   COMBA_STORE(b[23]);
+
+   /* output 24 */
+   CARRY_FORWARD;
+   SQRADDSC(a[9], a[15]); SQRADDAC(a[10], a[14]); SQRADDAC(a[11], a[13]); SQRADDDB; SQRADD(a[12], a[12]);
+   COMBA_STORE(b[24]);
+
+   /* output 25 */
+   CARRY_FORWARD;
+   SQRADDSC(a[10], a[15]); SQRADDAC(a[11], a[14]); SQRADDAC(a[12], a[13]); SQRADDDB;
+   COMBA_STORE(b[25]);
+
+   /* output 26 */
+   CARRY_FORWARD;
+   SQRADD2(a[11], a[15]); SQRADD2(a[12], a[14]); SQRADD(a[13], a[13]);
+   COMBA_STORE(b[26]);
+
+   /* output 27 */
+   CARRY_FORWARD;
+   SQRADD2(a[12], a[15]); SQRADD2(a[13], a[14]);
+   COMBA_STORE(b[27]);
+
+   /* output 28 */
+   CARRY_FORWARD;
+   SQRADD2(a[13], a[15]); SQRADD(a[14], a[14]);
+   COMBA_STORE(b[28]);
+
+   /* output 29 */
+   CARRY_FORWARD;
+   SQRADD2(a[14], a[15]);
+   COMBA_STORE(b[29]);
+
+   /* output 30 */
+   CARRY_FORWARD;
+   SQRADD(a[15], a[15]);
+   COMBA_STORE(b[30]);
+   COMBA_STORE2(b[31]);
+   COMBA_FINI;
+
+   B->used = 32;
+   B->sign = PSTM_ZPOS;
+   memcpy(B->dp, b, 32 * sizeof(pstm_digit));
+   pstm_clamp(B);
+   return PSTM_OKAY;
+}
+#endif /* USE_1024_KEY_SPEED_OPTIMIZATIONS */
+
+
+#ifdef USE_2048_KEY_SPEED_OPTIMIZATIONS
+static int32 pstm_sqr_comba32(pstm_int *A, pstm_int *B)
+{
+   pstm_digit *a, b[64], c0, c1, c2, sc0, sc1, sc2;
+#ifdef PSTM_ISO
+   pstm_word tt;
+#endif
+
+	if (B->alloc < 64) {
+		if (pstm_grow(B, 64) != PSTM_OKAY) {
+			return PS_MEM_FAIL;
+		}
+	}
+	sc0 = sc1 = sc2 = 0;
+   a = A->dp;
+   COMBA_START;
+
+   /* clear carries */
+   CLEAR_CARRY;
+
+   /* output 0 */
+   SQRADD(a[0],a[0]);
+   COMBA_STORE(b[0]);
+
+   /* output 1 */
+   CARRY_FORWARD;
+   SQRADD2(a[0], a[1]);
+   COMBA_STORE(b[1]);
+
+   /* output 2 */
+   CARRY_FORWARD;
+   SQRADD2(a[0], a[2]); SQRADD(a[1], a[1]);
+   COMBA_STORE(b[2]);
+
+   /* output 3 */
+   CARRY_FORWARD;
+   SQRADD2(a[0], a[3]); SQRADD2(a[1], a[2]);
+   COMBA_STORE(b[3]);
+
+   /* output 4 */
+   CARRY_FORWARD;
+   SQRADD2(a[0], a[4]); SQRADD2(a[1], a[3]); SQRADD(a[2], a[2]);
+   COMBA_STORE(b[4]);
+
+   /* output 5 */
+   CARRY_FORWARD;
+   SQRADDSC(a[0], a[5]); SQRADDAC(a[1], a[4]); SQRADDAC(a[2], a[3]); SQRADDDB;
+   COMBA_STORE(b[5]);
+
+   /* output 6 */
+   CARRY_FORWARD;
+   SQRADDSC(a[0], a[6]); SQRADDAC(a[1], a[5]); SQRADDAC(a[2], a[4]); SQRADDDB; SQRADD(a[3], a[3]);
+   COMBA_STORE(b[6]);
+
+   /* output 7 */
+   CARRY_FORWARD;
+   SQRADDSC(a[0], a[7]); SQRADDAC(a[1], a[6]); SQRADDAC(a[2], a[5]); SQRADDAC(a[3], a[4]); SQRADDDB;
+   COMBA_STORE(b[7]);
+
+   /* output 8 */
+   CARRY_FORWARD;
+   SQRADDSC(a[0], a[8]); SQRADDAC(a[1], a[7]); SQRADDAC(a[2], a[6]); SQRADDAC(a[3], a[5]); SQRADDDB; SQRADD(a[4], a[4]);
+   COMBA_STORE(b[8]);
+
+   /* output 9 */
+   CARRY_FORWARD;
+   SQRADDSC(a[0], a[9]); SQRADDAC(a[1], a[8]); SQRADDAC(a[2], a[7]); SQRADDAC(a[3], a[6]); SQRADDAC(a[4], a[5]); SQRADDDB;
+   COMBA_STORE(b[9]);
+
+   /* output 10 */
+   CARRY_FORWARD;
+   SQRADDSC(a[0], a[10]); SQRADDAC(a[1], a[9]); SQRADDAC(a[2], a[8]); SQRADDAC(a[3], a[7]); SQRADDAC(a[4], a[6]); SQRADDDB; SQRADD(a[5], a[5]);
+   COMBA_STORE(b[10]);
+
+   /* output 11 */
+   CARRY_FORWARD;
+   SQRADDSC(a[0], a[11]); SQRADDAC(a[1], a[10]); SQRADDAC(a[2], a[9]); SQRADDAC(a[3], a[8]); SQRADDAC(a[4], a[7]); SQRADDAC(a[5], a[6]); SQRADDDB;
+   COMBA_STORE(b[11]);
+
+   /* output 12 */
+   CARRY_FORWARD;
+   SQRADDSC(a[0], a[12]); SQRADDAC(a[1], a[11]); SQRADDAC(a[2], a[10]); SQRADDAC(a[3], a[9]); SQRADDAC(a[4], a[8]); SQRADDAC(a[5], a[7]); SQRADDDB; SQRADD(a[6], a[6]);
+   COMBA_STORE(b[12]);
+
+   /* output 13 */
+   CARRY_FORWARD;
+   SQRADDSC(a[0], a[13]); SQRADDAC(a[1], a[12]); SQRADDAC(a[2], a[11]); SQRADDAC(a[3], a[10]); SQRADDAC(a[4], a[9]); SQRADDAC(a[5], a[8]); SQRADDAC(a[6], a[7]); SQRADDDB;
+   COMBA_STORE(b[13]);
+
+   /* output 14 */
+   CARRY_FORWARD;
+   SQRADDSC(a[0], a[14]); SQRADDAC(a[1], a[13]); SQRADDAC(a[2], a[12]); SQRADDAC(a[3], a[11]); SQRADDAC(a[4], a[10]); SQRADDAC(a[5], a[9]); SQRADDAC(a[6], a[8]); SQRADDDB; SQRADD(a[7], a[7]);
+   COMBA_STORE(b[14]);
+
+   /* output 15 */
+   CARRY_FORWARD;
+   SQRADDSC(a[0], a[15]); SQRADDAC(a[1], a[14]); SQRADDAC(a[2], a[13]); SQRADDAC(a[3], a[12]); SQRADDAC(a[4], a[11]); SQRADDAC(a[5], a[10]); SQRADDAC(a[6], a[9]); SQRADDAC(a[7], a[8]); SQRADDDB;
+   COMBA_STORE(b[15]);
+
+   /* output 16 */
+   CARRY_FORWARD;
+   SQRADDSC(a[0], a[16]); SQRADDAC(a[1], a[15]); SQRADDAC(a[2], a[14]); SQRADDAC(a[3], a[13]); SQRADDAC(a[4], a[12]); SQRADDAC(a[5], a[11]); SQRADDAC(a[6], a[10]); SQRADDAC(a[7], a[9]); SQRADDDB; SQRADD(a[8], a[8]);
+   COMBA_STORE(b[16]);
+
+   /* output 17 */
+   CARRY_FORWARD;
+   SQRADDSC(a[0], a[17]); SQRADDAC(a[1], a[16]); SQRADDAC(a[2], a[15]); SQRADDAC(a[3], a[14]); SQRADDAC(a[4], a[13]); SQRADDAC(a[5], a[12]); SQRADDAC(a[6], a[11]); SQRADDAC(a[7], a[10]); SQRADDAC(a[8], a[9]); SQRADDDB;
+   COMBA_STORE(b[17]);
+
+   /* output 18 */
+   CARRY_FORWARD;
+   SQRADDSC(a[0], a[18]); SQRADDAC(a[1], a[17]); SQRADDAC(a[2], a[16]); SQRADDAC(a[3], a[15]); SQRADDAC(a[4], a[14]); SQRADDAC(a[5], a[13]); SQRADDAC(a[6], a[12]); SQRADDAC(a[7], a[11]); SQRADDAC(a[8], a[10]); SQRADDDB; SQRADD(a[9], a[9]);
+   COMBA_STORE(b[18]);
+
+   /* output 19 */
+   CARRY_FORWARD;
+   SQRADDSC(a[0], a[19]); SQRADDAC(a[1], a[18]); SQRADDAC(a[2], a[17]); SQRADDAC(a[3], a[16]); SQRADDAC(a[4], a[15]); SQRADDAC(a[5], a[14]); SQRADDAC(a[6], a[13]); SQRADDAC(a[7], a[12]); SQRADDAC(a[8], a[11]); SQRADDAC(a[9], a[10]); SQRADDDB;
+   COMBA_STORE(b[19]);
+
+   /* output 20 */
+   CARRY_FORWARD;
+   SQRADDSC(a[0], a[20]); SQRADDAC(a[1], a[19]); SQRADDAC(a[2], a[18]); SQRADDAC(a[3], a[17]); SQRADDAC(a[4], a[16]); SQRADDAC(a[5], a[15]); SQRADDAC(a[6], a[14]); SQRADDAC(a[7], a[13]); SQRADDAC(a[8], a[12]); SQRADDAC(a[9], a[11]); SQRADDDB; SQRADD(a[10], a[10]);
+   COMBA_STORE(b[20]);
+
+   /* output 21 */
+   CARRY_FORWARD;
+   SQRADDSC(a[0], a[21]); SQRADDAC(a[1], a[20]); SQRADDAC(a[2], a[19]); SQRADDAC(a[3], a[18]); SQRADDAC(a[4], a[17]); SQRADDAC(a[5], a[16]); SQRADDAC(a[6], a[15]); SQRADDAC(a[7], a[14]); SQRADDAC(a[8], a[13]); SQRADDAC(a[9], a[12]); SQRADDAC(a[10], a[11]); SQRADDDB;
+   COMBA_STORE(b[21]);
+
+   /* output 22 */
+   CARRY_FORWARD;
+   SQRADDSC(a[0], a[22]); SQRADDAC(a[1], a[21]); SQRADDAC(a[2], a[20]); SQRADDAC(a[3], a[19]); SQRADDAC(a[4], a[18]); SQRADDAC(a[5], a[17]); SQRADDAC(a[6], a[16]); SQRADDAC(a[7], a[15]); SQRADDAC(a[8], a[14]); SQRADDAC(a[9], a[13]); SQRADDAC(a[10], a[12]); SQRADDDB; SQRADD(a[11], a[11]);
+   COMBA_STORE(b[22]);
+
+   /* output 23 */
+   CARRY_FORWARD;
+   SQRADDSC(a[0], a[23]); SQRADDAC(a[1], a[22]); SQRADDAC(a[2], a[21]); SQRADDAC(a[3], a[20]); SQRADDAC(a[4], a[19]); SQRADDAC(a[5], a[18]); SQRADDAC(a[6], a[17]); SQRADDAC(a[7], a[16]); SQRADDAC(a[8], a[15]); SQRADDAC(a[9], a[14]); SQRADDAC(a[10], a[13]); SQRADDAC(a[11], a[12]); SQRADDDB;
+   COMBA_STORE(b[23]);
+
+   /* output 24 */
+   CARRY_FORWARD;
+   SQRADDSC(a[0], a[24]); SQRADDAC(a[1], a[23]); SQRADDAC(a[2], a[22]); SQRADDAC(a[3], a[21]); SQRADDAC(a[4], a[20]); SQRADDAC(a[5], a[19]); SQRADDAC(a[6], a[18]); SQRADDAC(a[7], a[17]); SQRADDAC(a[8], a[16]); SQRADDAC(a[9], a[15]); SQRADDAC(a[10], a[14]); SQRADDAC(a[11], a[13]); SQRADDDB; SQRADD(a[12], a[12]);
+   COMBA_STORE(b[24]);
+
+   /* output 25 */
+   CARRY_FORWARD;
+   SQRADDSC(a[0], a[25]); SQRADDAC(a[1], a[24]); SQRADDAC(a[2], a[23]); SQRADDAC(a[3], a[22]); SQRADDAC(a[4], a[21]); SQRADDAC(a[5], a[20]); SQRADDAC(a[6], a[19]); SQRADDAC(a[7], a[18]); SQRADDAC(a[8], a[17]); SQRADDAC(a[9], a[16]); SQRADDAC(a[10], a[15]); SQRADDAC(a[11], a[14]); SQRADDAC(a[12], a[13]); SQRADDDB;
+   COMBA_STORE(b[25]);
+
+   /* output 26 */
+   CARRY_FORWARD;
+   SQRADDSC(a[0], a[26]); SQRADDAC(a[1], a[25]); SQRADDAC(a[2], a[24]); SQRADDAC(a[3], a[23]); SQRADDAC(a[4], a[22]); SQRADDAC(a[5], a[21]); SQRADDAC(a[6], a[20]); SQRADDAC(a[7], a[19]); SQRADDAC(a[8], a[18]); SQRADDAC(a[9], a[17]); SQRADDAC(a[10], a[16]); SQRADDAC(a[11], a[15]); SQRADDAC(a[12], a[14]); SQRADDDB; SQRADD(a[13], a[13]);
+   COMBA_STORE(b[26]);
+
+   /* output 27 */
+   CARRY_FORWARD;
+   SQRADDSC(a[0], a[27]); SQRADDAC(a[1], a[26]); SQRADDAC(a[2], a[25]); SQRADDAC(a[3], a[24]); SQRADDAC(a[4], a[23]); SQRADDAC(a[5], a[22]); SQRADDAC(a[6], a[21]); SQRADDAC(a[7], a[20]); SQRADDAC(a[8], a[19]); SQRADDAC(a[9], a[18]); SQRADDAC(a[10], a[17]); SQRADDAC(a[11], a[16]); SQRADDAC(a[12], a[15]); SQRADDAC(a[13], a[14]); SQRADDDB;
+   COMBA_STORE(b[27]);
+
+   /* output 28 */
+   CARRY_FORWARD;
+   SQRADDSC(a[0], a[28]); SQRADDAC(a[1], a[27]); SQRADDAC(a[2], a[26]); SQRADDAC(a[3], a[25]); SQRADDAC(a[4], a[24]); SQRADDAC(a[5], a[23]); SQRADDAC(a[6], a[22]); SQRADDAC(a[7], a[21]); SQRADDAC(a[8], a[20]); SQRADDAC(a[9], a[19]); SQRADDAC(a[10], a[18]); SQRADDAC(a[11], a[17]); SQRADDAC(a[12], a[16]); SQRADDAC(a[13], a[15]); SQRADDDB; SQRADD(a[14], a[14]);
+   COMBA_STORE(b[28]);
+
+   /* output 29 */
+   CARRY_FORWARD;
+   SQRADDSC(a[0], a[29]); SQRADDAC(a[1], a[28]); SQRADDAC(a[2], a[27]); SQRADDAC(a[3], a[26]); SQRADDAC(a[4], a[25]); SQRADDAC(a[5], a[24]); SQRADDAC(a[6], a[23]); SQRADDAC(a[7], a[22]); SQRADDAC(a[8], a[21]); SQRADDAC(a[9], a[20]); SQRADDAC(a[10], a[19]); SQRADDAC(a[11], a[18]); SQRADDAC(a[12], a[17]); SQRADDAC(a[13], a[16]); SQRADDAC(a[14], a[15]); SQRADDDB;
+   COMBA_STORE(b[29]);
+
+   /* output 30 */
+   CARRY_FORWARD;
+   SQRADDSC(a[0], a[30]); SQRADDAC(a[1], a[29]); SQRADDAC(a[2], a[28]); SQRADDAC(a[3], a[27]); SQRADDAC(a[4], a[26]); SQRADDAC(a[5], a[25]); SQRADDAC(a[6], a[24]); SQRADDAC(a[7], a[23]); SQRADDAC(a[8], a[22]); SQRADDAC(a[9], a[21]); SQRADDAC(a[10], a[20]); SQRADDAC(a[11], a[19]); SQRADDAC(a[12], a[18]); SQRADDAC(a[13], a[17]); SQRADDAC(a[14], a[16]); SQRADDDB; SQRADD(a[15], a[15]);
+   COMBA_STORE(b[30]);
+
+   /* output 31 */
+   CARRY_FORWARD;
+   SQRADDSC(a[0], a[31]); SQRADDAC(a[1], a[30]); SQRADDAC(a[2], a[29]); SQRADDAC(a[3], a[28]); SQRADDAC(a[4], a[27]); SQRADDAC(a[5], a[26]); SQRADDAC(a[6], a[25]); SQRADDAC(a[7], a[24]); SQRADDAC(a[8], a[23]); SQRADDAC(a[9], a[22]); SQRADDAC(a[10], a[21]); SQRADDAC(a[11], a[20]); SQRADDAC(a[12], a[19]); SQRADDAC(a[13], a[18]); SQRADDAC(a[14], a[17]); SQRADDAC(a[15], a[16]); SQRADDDB;
+   COMBA_STORE(b[31]);
+
+   /* output 32 */
+   CARRY_FORWARD;
+   SQRADDSC(a[1], a[31]); SQRADDAC(a[2], a[30]); SQRADDAC(a[3], a[29]); SQRADDAC(a[4], a[28]); SQRADDAC(a[5], a[27]); SQRADDAC(a[6], a[26]); SQRADDAC(a[7], a[25]); SQRADDAC(a[8], a[24]); SQRADDAC(a[9], a[23]); SQRADDAC(a[10], a[22]); SQRADDAC(a[11], a[21]); SQRADDAC(a[12], a[20]); SQRADDAC(a[13], a[19]); SQRADDAC(a[14], a[18]); SQRADDAC(a[15], a[17]); SQRADDDB; SQRADD(a[16], a[16]);
+   COMBA_STORE(b[32]);
+
+   /* output 33 */
+   CARRY_FORWARD;
+   SQRADDSC(a[2], a[31]); SQRADDAC(a[3], a[30]); SQRADDAC(a[4], a[29]); SQRADDAC(a[5], a[28]); SQRADDAC(a[6], a[27]); SQRADDAC(a[7], a[26]); SQRADDAC(a[8], a[25]); SQRADDAC(a[9], a[24]); SQRADDAC(a[10], a[23]); SQRADDAC(a[11], a[22]); SQRADDAC(a[12], a[21]); SQRADDAC(a[13], a[20]); SQRADDAC(a[14], a[19]); SQRADDAC(a[15], a[18]); SQRADDAC(a[16], a[17]); SQRADDDB;
+   COMBA_STORE(b[33]);
+
+   /* output 34 */
+   CARRY_FORWARD;
+   SQRADDSC(a[3], a[31]); SQRADDAC(a[4], a[30]); SQRADDAC(a[5], a[29]); SQRADDAC(a[6], a[28]); SQRADDAC(a[7], a[27]); SQRADDAC(a[8], a[26]); SQRADDAC(a[9], a[25]); SQRADDAC(a[10], a[24]); SQRADDAC(a[11], a[23]); SQRADDAC(a[12], a[22]); SQRADDAC(a[13], a[21]); SQRADDAC(a[14], a[20]); SQRADDAC(a[15], a[19]); SQRADDAC(a[16], a[18]); SQRADDDB; SQRADD(a[17], a[17]);
+   COMBA_STORE(b[34]);
+
+   /* output 35 */
+   CARRY_FORWARD;
+   SQRADDSC(a[4], a[31]); SQRADDAC(a[5], a[30]); SQRADDAC(a[6], a[29]); SQRADDAC(a[7], a[28]); SQRADDAC(a[8], a[27]); SQRADDAC(a[9], a[26]); SQRADDAC(a[10], a[25]); SQRADDAC(a[11], a[24]); SQRADDAC(a[12], a[23]); SQRADDAC(a[13], a[22]); SQRADDAC(a[14], a[21]); SQRADDAC(a[15], a[20]); SQRADDAC(a[16], a[19]); SQRADDAC(a[17], a[18]); SQRADDDB;
+   COMBA_STORE(b[35]);
+
+   /* output 36 */
+   CARRY_FORWARD;
+   SQRADDSC(a[5], a[31]); SQRADDAC(a[6], a[30]); SQRADDAC(a[7], a[29]); SQRADDAC(a[8], a[28]); SQRADDAC(a[9], a[27]); SQRADDAC(a[10], a[26]); SQRADDAC(a[11], a[25]); SQRADDAC(a[12], a[24]); SQRADDAC(a[13], a[23]); SQRADDAC(a[14], a[22]); SQRADDAC(a[15], a[21]); SQRADDAC(a[16], a[20]); SQRADDAC(a[17], a[19]); SQRADDDB; SQRADD(a[18], a[18]);
+   COMBA_STORE(b[36]);
+
+   /* output 37 */
+   CARRY_FORWARD;
+   SQRADDSC(a[6], a[31]); SQRADDAC(a[7], a[30]); SQRADDAC(a[8], a[29]); SQRADDAC(a[9], a[28]); SQRADDAC(a[10], a[27]); SQRADDAC(a[11], a[26]); SQRADDAC(a[12], a[25]); SQRADDAC(a[13], a[24]); SQRADDAC(a[14], a[23]); SQRADDAC(a[15], a[22]); SQRADDAC(a[16], a[21]); SQRADDAC(a[17], a[20]); SQRADDAC(a[18], a[19]); SQRADDDB;
+   COMBA_STORE(b[37]);
+
+   /* output 38 */
+   CARRY_FORWARD;
+   SQRADDSC(a[7], a[31]); SQRADDAC(a[8], a[30]); SQRADDAC(a[9], a[29]); SQRADDAC(a[10], a[28]); SQRADDAC(a[11], a[27]); SQRADDAC(a[12], a[26]); SQRADDAC(a[13], a[25]); SQRADDAC(a[14], a[24]); SQRADDAC(a[15], a[23]); SQRADDAC(a[16], a[22]); SQRADDAC(a[17], a[21]); SQRADDAC(a[18], a[20]); SQRADDDB; SQRADD(a[19], a[19]);
+   COMBA_STORE(b[38]);
+
+   /* output 39 */
+   CARRY_FORWARD;
+   SQRADDSC(a[8], a[31]); SQRADDAC(a[9], a[30]); SQRADDAC(a[10], a[29]); SQRADDAC(a[11], a[28]); SQRADDAC(a[12], a[27]); SQRADDAC(a[13], a[26]); SQRADDAC(a[14], a[25]); SQRADDAC(a[15], a[24]); SQRADDAC(a[16], a[23]); SQRADDAC(a[17], a[22]); SQRADDAC(a[18], a[21]); SQRADDAC(a[19], a[20]); SQRADDDB;
+   COMBA_STORE(b[39]);
+
+   /* output 40 */
+   CARRY_FORWARD;
+   SQRADDSC(a[9], a[31]); SQRADDAC(a[10], a[30]); SQRADDAC(a[11], a[29]); SQRADDAC(a[12], a[28]); SQRADDAC(a[13], a[27]); SQRADDAC(a[14], a[26]); SQRADDAC(a[15], a[25]); SQRADDAC(a[16], a[24]); SQRADDAC(a[17], a[23]); SQRADDAC(a[18], a[22]); SQRADDAC(a[19], a[21]); SQRADDDB; SQRADD(a[20], a[20]);
+   COMBA_STORE(b[40]);
+
+   /* output 41 */
+   CARRY_FORWARD;
+   SQRADDSC(a[10], a[31]); SQRADDAC(a[11], a[30]); SQRADDAC(a[12], a[29]); SQRADDAC(a[13], a[28]); SQRADDAC(a[14], a[27]); SQRADDAC(a[15], a[26]); SQRADDAC(a[16], a[25]); SQRADDAC(a[17], a[24]); SQRADDAC(a[18], a[23]); SQRADDAC(a[19], a[22]); SQRADDAC(a[20], a[21]); SQRADDDB;
+   COMBA_STORE(b[41]);
+
+   /* output 42 */
+   CARRY_FORWARD;
+   SQRADDSC(a[11], a[31]); SQRADDAC(a[12], a[30]); SQRADDAC(a[13], a[29]); SQRADDAC(a[14], a[28]); SQRADDAC(a[15], a[27]); SQRADDAC(a[16], a[26]); SQRADDAC(a[17], a[25]); SQRADDAC(a[18], a[24]); SQRADDAC(a[19], a[23]); SQRADDAC(a[20], a[22]); SQRADDDB; SQRADD(a[21], a[21]);
+   COMBA_STORE(b[42]);
+
+   /* output 43 */
+   CARRY_FORWARD;
+   SQRADDSC(a[12], a[31]); SQRADDAC(a[13], a[30]); SQRADDAC(a[14], a[29]); SQRADDAC(a[15], a[28]); SQRADDAC(a[16], a[27]); SQRADDAC(a[17], a[26]); SQRADDAC(a[18], a[25]); SQRADDAC(a[19], a[24]); SQRADDAC(a[20], a[23]); SQRADDAC(a[21], a[22]); SQRADDDB;
+   COMBA_STORE(b[43]);
+
+   /* output 44 */
+   CARRY_FORWARD;
+   SQRADDSC(a[13], a[31]); SQRADDAC(a[14], a[30]); SQRADDAC(a[15], a[29]); SQRADDAC(a[16], a[28]); SQRADDAC(a[17], a[27]); SQRADDAC(a[18], a[26]); SQRADDAC(a[19], a[25]); SQRADDAC(a[20], a[24]); SQRADDAC(a[21], a[23]); SQRADDDB; SQRADD(a[22], a[22]);
+   COMBA_STORE(b[44]);
+
+   /* output 45 */
+   CARRY_FORWARD;
+   SQRADDSC(a[14], a[31]); SQRADDAC(a[15], a[30]); SQRADDAC(a[16], a[29]); SQRADDAC(a[17], a[28]); SQRADDAC(a[18], a[27]); SQRADDAC(a[19], a[26]); SQRADDAC(a[20], a[25]); SQRADDAC(a[21], a[24]); SQRADDAC(a[22], a[23]); SQRADDDB;
+   COMBA_STORE(b[45]);
+
+   /* output 46 */
+   CARRY_FORWARD;
+   SQRADDSC(a[15], a[31]); SQRADDAC(a[16], a[30]); SQRADDAC(a[17], a[29]); SQRADDAC(a[18], a[28]); SQRADDAC(a[19], a[27]); SQRADDAC(a[20], a[26]); SQRADDAC(a[21], a[25]); SQRADDAC(a[22], a[24]); SQRADDDB; SQRADD(a[23], a[23]);
+   COMBA_STORE(b[46]);
+
+   /* output 47 */
+   CARRY_FORWARD;
+   SQRADDSC(a[16], a[31]); SQRADDAC(a[17], a[30]); SQRADDAC(a[18], a[29]); SQRADDAC(a[19], a[28]); SQRADDAC(a[20], a[27]); SQRADDAC(a[21], a[26]); SQRADDAC(a[22], a[25]); SQRADDAC(a[23], a[24]); SQRADDDB;
+   COMBA_STORE(b[47]);
+
+   /* output 48 */
+   CARRY_FORWARD;
+   SQRADDSC(a[17], a[31]); SQRADDAC(a[18], a[30]); SQRADDAC(a[19], a[29]); SQRADDAC(a[20], a[28]); SQRADDAC(a[21], a[27]); SQRADDAC(a[22], a[26]); SQRADDAC(a[23], a[25]); SQRADDDB; SQRADD(a[24], a[24]);
+   COMBA_STORE(b[48]);
+
+   /* output 49 */
+   CARRY_FORWARD;
+   SQRADDSC(a[18], a[31]); SQRADDAC(a[19], a[30]); SQRADDAC(a[20], a[29]); SQRADDAC(a[21], a[28]); SQRADDAC(a[22], a[27]); SQRADDAC(a[23], a[26]); SQRADDAC(a[24], a[25]); SQRADDDB;
+   COMBA_STORE(b[49]);
+
+   /* output 50 */
+   CARRY_FORWARD;
+   SQRADDSC(a[19], a[31]); SQRADDAC(a[20], a[30]); SQRADDAC(a[21], a[29]); SQRADDAC(a[22], a[28]); SQRADDAC(a[23], a[27]); SQRADDAC(a[24], a[26]); SQRADDDB; SQRADD(a[25], a[25]);
+   COMBA_STORE(b[50]);
+
+   /* output 51 */
+   CARRY_FORWARD;
+   SQRADDSC(a[20], a[31]); SQRADDAC(a[21], a[30]); SQRADDAC(a[22], a[29]); SQRADDAC(a[23], a[28]); SQRADDAC(a[24], a[27]); SQRADDAC(a[25], a[26]); SQRADDDB;
+   COMBA_STORE(b[51]);
+
+   /* output 52 */
+   CARRY_FORWARD;
+   SQRADDSC(a[21], a[31]); SQRADDAC(a[22], a[30]); SQRADDAC(a[23], a[29]); SQRADDAC(a[24], a[28]); SQRADDAC(a[25], a[27]); SQRADDDB; SQRADD(a[26], a[26]);
+   COMBA_STORE(b[52]);
+
+   /* output 53 */
+   CARRY_FORWARD;
+   SQRADDSC(a[22], a[31]); SQRADDAC(a[23], a[30]); SQRADDAC(a[24], a[29]); SQRADDAC(a[25], a[28]); SQRADDAC(a[26], a[27]); SQRADDDB;
+   COMBA_STORE(b[53]);
+
+   /* output 54 */
+   CARRY_FORWARD;
+   SQRADDSC(a[23], a[31]); SQRADDAC(a[24], a[30]); SQRADDAC(a[25], a[29]); SQRADDAC(a[26], a[28]); SQRADDDB; SQRADD(a[27], a[27]);
+   COMBA_STORE(b[54]);
+
+   /* output 55 */
+   CARRY_FORWARD;
+   SQRADDSC(a[24], a[31]); SQRADDAC(a[25], a[30]); SQRADDAC(a[26], a[29]); SQRADDAC(a[27], a[28]); SQRADDDB;
+   COMBA_STORE(b[55]);
+
+   /* output 56 */
+   CARRY_FORWARD;
+   SQRADDSC(a[25], a[31]); SQRADDAC(a[26], a[30]); SQRADDAC(a[27], a[29]); SQRADDDB; SQRADD(a[28], a[28]);
+   COMBA_STORE(b[56]);
+
+   /* output 57 */
+   CARRY_FORWARD;
+   SQRADDSC(a[26], a[31]); SQRADDAC(a[27], a[30]); SQRADDAC(a[28], a[29]); SQRADDDB;
+   COMBA_STORE(b[57]);
+
+   /* output 58 */
+   CARRY_FORWARD;
+   SQRADD2(a[27], a[31]); SQRADD2(a[28], a[30]); SQRADD(a[29], a[29]);
+   COMBA_STORE(b[58]);
+
+   /* output 59 */
+   CARRY_FORWARD;
+   SQRADD2(a[28], a[31]); SQRADD2(a[29], a[30]);
+   COMBA_STORE(b[59]);
+
+   /* output 60 */
+   CARRY_FORWARD;
+   SQRADD2(a[29], a[31]); SQRADD(a[30], a[30]);
+   COMBA_STORE(b[60]);
+
+   /* output 61 */
+   CARRY_FORWARD;
+   SQRADD2(a[30], a[31]);
+   COMBA_STORE(b[61]);
+
+   /* output 62 */
+   CARRY_FORWARD;
+   SQRADD(a[31], a[31]);
+   COMBA_STORE(b[62]);
+   COMBA_STORE2(b[63]);
+   COMBA_FINI;
+
+   B->used = 64;
+   B->sign = PSTM_ZPOS;
+   memcpy(B->dp, b, 64 * sizeof(pstm_digit));
+   pstm_clamp(B);
+   return PSTM_OKAY;
+}
+#endif /* USE_2048_KEY_SPEED_OPTIMIZATIONS */
+
+/******************************************************************************/
+/*
+ */
+int32 pstm_sqr_comba(psPool_t *pool, pstm_int *A, pstm_int *B, pstm_digit *paD,
+		uint32 paDlen)
+{
+#ifdef USE_1024_KEY_SPEED_OPTIMIZATIONS
+	if (A->used == 16) {
+		return pstm_sqr_comba16(A, B);
+	} else {
+#ifdef USE_2048_KEY_SPEED_OPTIMIZATIONS
+		if (A->used == 32) {
+			return pstm_sqr_comba32(A, B);
+		}
+#endif /* USE_2048_KEY_SPEED_OPTIMIZATIONS */
+		return pstm_sqr_comba_gen(pool, A, B, paD, paDlen);
+	}
+#else
+#ifdef USE_2048_KEY_SPEED_OPTIMIZATIONS
+	if (A->used == 32) {
+		return pstm_sqr_comba32(A, B);
+	}
+#endif /* USE_2048_KEY_SPEED_OPTIMIZATIONS */
+	return pstm_sqr_comba_gen(pool, A, B, paD, paDlen);
+#endif
+}
+
+#endif /* DISABLE_PSTM */
+/******************************************************************************/
diff -urpN busybox-1.26.2/networking/tls_rsa.c busybox-1.27.0/networking/tls_rsa.c
--- busybox-1.26.2/networking/tls_rsa.c	1970-01-01 01:00:00.000000000 +0100
+++ busybox-1.27.0/networking/tls_rsa.c	2017-01-19 16:21:18.000000000 +0100
@@ -0,0 +1,211 @@
+/*
+ * Copyright (C) 2017 Denys Vlasenko
+ *
+ * Licensed under GPLv2, see file LICENSE in this source tree.
+ */
+#include "tls.h"
+
+/* The code below is taken from parts of
+ *  matrixssl-3-7-2b-open/crypto/pubkey/pkcs.c
+ *  matrixssl-3-7-2b-open/crypto/pubkey/rsa.c
+ * and (so far) almost not modified. Changes are flagged with //bbox
+ */
+
+#define pkcs1Pad(in, inlen, out, outlen, cryptType, userPtr) \
+        pkcs1Pad(in, inlen, out, outlen, cryptType)
+static //bbox
+int32 pkcs1Pad(unsigned char *in, uint32 inlen, unsigned char *out,
+					   uint32 outlen, int32 cryptType, void *userPtr)
+{
+	unsigned char   *c;
+	int32           randomLen;
+
+	randomLen = outlen - 3 - inlen;
+	if (randomLen < 8) {
+		psTraceCrypto("pkcs1Pad failure\n");
+		return PS_LIMIT_FAIL;
+	}
+	c = out;
+	*c = 0x00;
+	c++;
+	*c = (unsigned char)cryptType;
+	c++;
+	if (cryptType == PUBKEY_TYPE) {
+		while (randomLen-- > 0) {
+			*c++ = 0xFF;
+		}
+	} else {
+		if (matrixCryptoGetPrngData(c, (uint32)randomLen, userPtr) < 0) {
+			return PS_PLATFORM_FAIL;
+		}
+/*
+		SECURITY:  Read through the random data and change all 0x0 to 0x01.
+		This is per spec that no random bytes should be 0
+*/
+		while (randomLen-- > 0) {
+			if (*c == 0x0) {
+				*c = 0x01;
+			}
+			c++;
+		}
+	}
+	*c = 0x00;
+	c++;
+	memcpy(c, in, inlen);
+
+	return outlen;
+}
+
+#define psRsaCrypt(pool, in, inlen, out, outlen, key, type, data) \
+        psRsaCrypt(      in, inlen, out, outlen, key, type)
+static //bbox
+int32 psRsaCrypt(psPool_t *pool, const unsigned char *in, uint32 inlen,
+			unsigned char *out, uint32 *outlen,	psRsaKey_t *key, int32 type,
+			void *data)
+{
+	pstm_int		tmp, tmpa, tmpb;
+	int32			res;
+	uint32			x;
+
+//bbox
+//	if (in == NULL || out == NULL || outlen == NULL || key == NULL) {
+//		psTraceCrypto("NULL parameter error in psRsaCrypt\n");
+//		return PS_ARG_FAIL;
+//	}
+
+	tmp.dp = tmpa.dp = tmpb.dp = NULL;
+
+	/* Init and copy into tmp */
+	if (pstm_init_for_read_unsigned_bin(pool, &tmp, inlen + sizeof(pstm_digit))
+			!= PS_SUCCESS) {
+		return PS_FAILURE;
+	}
+	if (pstm_read_unsigned_bin(&tmp, (unsigned char *)in, inlen) != PS_SUCCESS){
+		pstm_clear(&tmp);
+		return PS_FAILURE;
+	}
+	/* Sanity check on the input */
+	if (pstm_cmp(&key->N, &tmp) == PSTM_LT) {
+		res = PS_LIMIT_FAIL;
+		goto done;
+	}
+	if (type == PRIVKEY_TYPE) {
+		if (key->optimized) {
+			if (pstm_init_size(pool, &tmpa, key->p.alloc) != PS_SUCCESS) {
+				res = PS_FAILURE;
+				goto done;
+			}
+			if (pstm_init_size(pool, &tmpb, key->q.alloc) != PS_SUCCESS) {
+				pstm_clear(&tmpa);
+				res = PS_FAILURE;
+				goto done;
+			}
+			if (pstm_exptmod(pool, &tmp, &key->dP, &key->p, &tmpa) !=
+					PS_SUCCESS) {
+				psTraceCrypto("decrypt error: pstm_exptmod dP, p\n");
+				goto error;
+			}
+			if (pstm_exptmod(pool, &tmp, &key->dQ, &key->q, &tmpb) !=
+					PS_SUCCESS) {
+				psTraceCrypto("decrypt error: pstm_exptmod dQ, q\n");
+				goto error;
+			}
+			if (pstm_sub(&tmpa, &tmpb, &tmp) != PS_SUCCESS) {
+				psTraceCrypto("decrypt error: sub tmpb, tmp\n");
+				goto error;
+			}
+			if (pstm_mulmod(pool, &tmp, &key->qP, &key->p, &tmp) != PS_SUCCESS) {
+				psTraceCrypto("decrypt error: pstm_mulmod qP, p\n");
+				goto error;
+			}
+			if (pstm_mul_comba(pool, &tmp, &key->q, &tmp, NULL, 0)
+					!= PS_SUCCESS){
+				psTraceCrypto("decrypt error: pstm_mul q \n");
+				goto error;
+			}
+			if (pstm_add(&tmp, &tmpb, &tmp) != PS_SUCCESS) {
+				psTraceCrypto("decrypt error: pstm_add tmp \n");
+				goto error;
+			}
+		} else {
+			if (pstm_exptmod(pool, &tmp, &key->d, &key->N, &tmp) !=
+					PS_SUCCESS) {
+				psTraceCrypto("psRsaCrypt error: pstm_exptmod\n");
+				goto error;
+			}
+		}
+	} else if (type == PUBKEY_TYPE) {
+		if (pstm_exptmod(pool, &tmp, &key->e, &key->N, &tmp) != PS_SUCCESS) {
+			psTraceCrypto("psRsaCrypt error: pstm_exptmod\n");
+			goto error;
+		}
+	} else {
+		psTraceCrypto("psRsaCrypt error: invalid type param\n");
+		goto error;
+	}
+	/* Read it back */
+	x = pstm_unsigned_bin_size(&key->N);
+
+	if ((uint32)x > *outlen) {
+		res = -1;
+		psTraceCrypto("psRsaCrypt error: pstm_unsigned_bin_size\n");
+		goto done;
+	}
+	/* We want the encrypted value to always be the key size.  Pad with 0x0 */
+	while ((uint32)x < (unsigned long)key->size) {
+		*out++ = 0x0;
+		x++;
+	}
+
+	*outlen = x;
+	/* Convert it */
+	memset(out, 0x0, x);
+
+	if (pstm_to_unsigned_bin(pool, &tmp, out+(x-pstm_unsigned_bin_size(&tmp)))
+			!= PS_SUCCESS) {
+		psTraceCrypto("psRsaCrypt error: pstm_to_unsigned_bin\n");
+		goto error;
+	}
+	/* Clean up and return */
+	res = PS_SUCCESS;
+	goto done;
+error:
+	res = PS_FAILURE;
+done:
+	if (type == PRIVKEY_TYPE && key->optimized) {
+		pstm_clear_multi(&tmpa, &tmpb, NULL, NULL, NULL, NULL, NULL, NULL);
+	}
+	pstm_clear(&tmp);
+	return res;
+}
+
+int32 psRsaEncryptPub(psPool_t *pool, psRsaKey_t *key,
+						unsigned char *in, uint32 inlen,
+						unsigned char *out, uint32 outlen, void *data)
+{
+	int32	err;
+	uint32	size;
+
+	size = key->size;
+	if (outlen < size) {
+//bbox		psTraceCrypto("Error on bad outlen parameter to psRsaEncryptPub\n");
+		bb_error_msg_and_die("RSA crypt outlen:%d < size:%d", outlen, size);
+		return PS_ARG_FAIL;
+	}
+
+	if ((err = pkcs1Pad(in, inlen, out, size, PRIVKEY_TYPE, data))
+			< PS_SUCCESS) {
+		psTraceCrypto("Error padding psRsaEncryptPub. Likely data too long\n");
+		return err;
+	}
+	if ((err = psRsaCrypt(pool, out, size, out, (uint32*)&outlen, key,
+			PUBKEY_TYPE, data)) < PS_SUCCESS) {
+		psTraceCrypto("Error performing psRsaEncryptPub\n");
+		return err;
+	}
+	if (outlen != size) {
+		psTraceCrypto("Encrypted size error in psRsaEncryptPub\n");
+		return PS_FAILURE;
+	}
+	return size;
+}
diff -urpN busybox-1.26.2/networking/tls_rsa.h busybox-1.27.0/networking/tls_rsa.h
--- busybox-1.26.2/networking/tls_rsa.h	1970-01-01 01:00:00.000000000 +0100
+++ busybox-1.27.0/networking/tls_rsa.h	2017-01-19 16:21:18.000000000 +0100
@@ -0,0 +1,20 @@
+/*
+ * Copyright (C) 2017 Denys Vlasenko
+ *
+ * Licensed under GPLv2, see file LICENSE in this source tree.
+ *
+ * Selected few declarations for RSA.
+ */
+
+typedef struct {
+	pstm_int    e, d, N, qP, dP, dQ, p, q;
+	uint32      size;   /* Size of the key in bytes */
+	int32       optimized; /* 1 for optimized */
+//bbox	psPool_t *pool;
+} psRsaKey_t;
+
+#define psRsaEncryptPub(pool, key, in, inlen, out, outlen, data) \
+        psRsaEncryptPub(      key, in, inlen, out, outlen)
+int32 psRsaEncryptPub(psPool_t *pool, psRsaKey_t *key,
+                                                unsigned char *in, uint32 inlen,
+                                                unsigned char *out, uint32 outlen, void *data);
diff -urpN busybox-1.26.2/networking/tls_symmetric.h busybox-1.27.0/networking/tls_symmetric.h
--- busybox-1.26.2/networking/tls_symmetric.h	1970-01-01 01:00:00.000000000 +0100
+++ busybox-1.27.0/networking/tls_symmetric.h	2017-01-24 18:44:48.000000000 +0100
@@ -0,0 +1,511 @@
+/*
+ * Copyright (C) 2017 Denys Vlasenko
+ *
+ * Licensed under GPLv2, see file LICENSE in this source tree.
+ */
+
+
+/* The part below is a section of matrixssl-3-7-2b-open/crypto/cryptolib.h
+ * Changes are flagged with //bbox
+ */
+
+/******************************************************************************/
+/* 32-bit Rotates */
+/******************************************************************************/
+#if defined(_MSC_VER)
+/******************************************************************************/
+
+/* instrinsic rotate */
+#include <stdlib.h>
+#pragma intrinsic(_lrotr,_lrotl)
+#define ROR(x,n) _lrotr(x,n)
+#define ROL(x,n) _lrotl(x,n)
+
+/******************************************************************************/
+#elif defined(__GNUC__) && (defined(__i386__) || defined(__x86_64__)) && \
+		!defined(INTEL_CC) && !defined(PS_NO_ASM)
+
+static ALWAYS_INLINE unsigned ROL(unsigned word, int i)
+{
+ if (__builtin_constant_p(i)) { //box
+   // Rotates by constant use fewer registers,
+   // and on many Intel CPUs rotates by %cl take 2 cycles, not 1.
+   asm ("roll %2,%0"
+	  :"=r" (word)
+	  :"0" (word),"i" (i));
+   return word;
+ } //box
+ asm ("roll %%cl,%0"
+	  :"=r" (word)
+	  :"0" (word),"c" (i));
+ return word;
+}
+
+static ALWAYS_INLINE unsigned ROR(unsigned word, int i)
+{
+ if (__builtin_constant_p(i)) { //box
+   asm ("rorl %2,%0"
+	  :"=r" (word)
+	  :"0" (word),"i" (i));
+   return word;
+ } //box
+ asm ("rorl %%cl,%0"
+	  :"=r" (word)
+	  :"0" (word),"c" (i));
+ return word;
+}
+
+/******************************************************************************/
+#else
+
+/* rotates the hard way */
+#define ROL(x, y) \
+	( (((unsigned long)(x)<<(unsigned long)((y)&31)) | \
+	(((unsigned long)(x)&0xFFFFFFFFUL)>>(unsigned long)(32-((y)&31)))) & \
+	0xFFFFFFFFUL)
+#define ROR(x, y) \
+	( ((((unsigned long)(x)&0xFFFFFFFFUL)>>(unsigned long)((y)&31)) | \
+	((unsigned long)(x)<<(unsigned long)(32-((y)&31)))) & 0xFFFFFFFFUL)
+
+#endif /* 32-bit Rotates */
+/******************************************************************************/
+
+#ifdef HAVE_NATIVE_INT64
+#ifdef _MSC_VER
+	#define CONST64(n) n ## ui64
+#else
+	#define CONST64(n) n ## ULL
+#endif
+#endif
+
+/******************************************************************************/
+/*
+	Endian helper macros
+ */
+#if defined (ENDIAN_NEUTRAL)
+#define STORE32L(x, y) { \
+(y)[3] = (unsigned char)(((x)>>24)&255); \
+(y)[2] = (unsigned char)(((x)>>16)&255);  \
+(y)[1] = (unsigned char)(((x)>>8)&255); \
+(y)[0] = (unsigned char)((x)&255); \
+}
+
+#define LOAD32L(x, y) { \
+x = ((unsigned long)((y)[3] & 255)<<24) | \
+((unsigned long)((y)[2] & 255)<<16) | \
+((unsigned long)((y)[1] & 255)<<8)  | \
+((unsigned long)((y)[0] & 255)); \
+}
+
+#define STORE64L(x, y) { \
+(y)[7] = (unsigned char)(((x)>>56)&255); \
+(y)[6] = (unsigned char)(((x)>>48)&255); \
+(y)[5] = (unsigned char)(((x)>>40)&255); \
+(y)[4] = (unsigned char)(((x)>>32)&255); \
+(y)[3] = (unsigned char)(((x)>>24)&255); \
+(y)[2] = (unsigned char)(((x)>>16)&255); \
+(y)[1] = (unsigned char)(((x)>>8)&255); \
+(y)[0] = (unsigned char)((x)&255); \
+}
+
+#define LOAD64L(x, y) { \
+x = (((uint64)((y)[7] & 255))<<56)|(((uint64)((y)[6] & 255))<<48)| \
+(((uint64)((y)[5] & 255))<<40)|(((uint64)((y)[4] & 255))<<32)| \
+(((uint64)((y)[3] & 255))<<24)|(((uint64)((y)[2] & 255))<<16)| \
+(((uint64)((y)[1] & 255))<<8)|(((uint64)((y)[0] & 255))); \
+}
+
+#define STORE32H(x, y) { \
+(y)[0] = (unsigned char)(((x)>>24)&255); \
+(y)[1] = (unsigned char)(((x)>>16)&255); \
+(y)[2] = (unsigned char)(((x)>>8)&255); \
+(y)[3] = (unsigned char)((x)&255); \
+}
+
+#define LOAD32H(x, y) { \
+x = ((unsigned long)((y)[0] & 255)<<24) | \
+((unsigned long)((y)[1] & 255)<<16) | \
+((unsigned long)((y)[2] & 255)<<8)  | \
+((unsigned long)((y)[3] & 255)); \
+}
+
+#define STORE64H(x, y) { \
+(y)[0] = (unsigned char)(((x)>>56)&255); \
+(y)[1] = (unsigned char)(((x)>>48)&255); \
+(y)[2] = (unsigned char)(((x)>>40)&255); \
+(y)[3] = (unsigned char)(((x)>>32)&255); \
+(y)[4] = (unsigned char)(((x)>>24)&255); \
+(y)[5] = (unsigned char)(((x)>>16)&255); \
+(y)[6] = (unsigned char)(((x)>>8)&255); \
+(y)[7] = (unsigned char)((x)&255); \
+}
+
+#define LOAD64H(x, y) { \
+x = (((uint64)((y)[0] & 255))<<56)|(((uint64)((y)[1] & 255))<<48) | \
+(((uint64)((y)[2] & 255))<<40)|(((uint64)((y)[3] & 255))<<32) | \
+(((uint64)((y)[4] & 255))<<24)|(((uint64)((y)[5] & 255))<<16) | \
+(((uint64)((y)[6] & 255))<<8)|(((uint64)((y)[7] & 255))); \
+}
+
+#endif /* ENDIAN_NEUTRAL */
+
+#ifdef ENDIAN_LITTLE
+#define STORE32H(x, y) { \
+(y)[0] = (unsigned char)(((x)>>24)&255); \
+(y)[1] = (unsigned char)(((x)>>16)&255); \
+(y)[2] = (unsigned char)(((x)>>8)&255); \
+(y)[3] = (unsigned char)((x)&255); \
+}
+
+#define LOAD32H(x, y) { \
+x = ((unsigned long)((y)[0] & 255)<<24) | \
+((unsigned long)((y)[1] & 255)<<16) | \
+((unsigned long)((y)[2] & 255)<<8)  | \
+((unsigned long)((y)[3] & 255)); \
+}
+
+#define STORE64H(x, y) { \
+(y)[0] = (unsigned char)(((x)>>56)&255); \
+(y)[1] = (unsigned char)(((x)>>48)&255); \
+(y)[2] = (unsigned char)(((x)>>40)&255); \
+(y)[3] = (unsigned char)(((x)>>32)&255); \
+(y)[4] = (unsigned char)(((x)>>24)&255); \
+(y)[5] = (unsigned char)(((x)>>16)&255); \
+(y)[6] = (unsigned char)(((x)>>8)&255); \
+(y)[7] = (unsigned char)((x)&255); \
+}
+
+#define LOAD64H(x, y) { \
+x = (((uint64)((y)[0] & 255))<<56)|(((uint64)((y)[1] & 255))<<48) | \
+(((uint64)((y)[2] & 255))<<40)|(((uint64)((y)[3] & 255))<<32) | \
+(((uint64)((y)[4] & 255))<<24)|(((uint64)((y)[5] & 255))<<16) | \
+(((uint64)((y)[6] & 255))<<8)|(((uint64)((y)[7] & 255))); }
+
+#ifdef ENDIAN_32BITWORD
+#define STORE32L(x, y) { \
+unsigned long __t = (x); memcpy(y, &__t, 4); \
+}
+
+#define LOAD32L(x, y)  memcpy(&(x), y, 4);
+
+#define STORE64L(x, y) { \
+(y)[7] = (unsigned char)(((x)>>56)&255); \
+(y)[6] = (unsigned char)(((x)>>48)&255); \
+(y)[5] = (unsigned char)(((x)>>40)&255); \
+(y)[4] = (unsigned char)(((x)>>32)&255); \
+(y)[3] = (unsigned char)(((x)>>24)&255); \
+(y)[2] = (unsigned char)(((x)>>16)&255); \
+(y)[1] = (unsigned char)(((x)>>8)&255); \
+(y)[0] = (unsigned char)((x)&255); \
+}
+
+#define LOAD64L(x, y) { \
+x = (((uint64)((y)[7] & 255))<<56)|(((uint64)((y)[6] & 255))<<48)| \
+(((uint64)((y)[5] & 255))<<40)|(((uint64)((y)[4] & 255))<<32)| \
+(((uint64)((y)[3] & 255))<<24)|(((uint64)((y)[2] & 255))<<16)| \
+(((uint64)((y)[1] & 255))<<8)|(((uint64)((y)[0] & 255))); \
+}
+
+#else /* 64-bit words then  */
+#define STORE32L(x, y) \
+{ unsigned long __t = (x); memcpy(y, &__t, 4); }
+
+#define LOAD32L(x, y) \
+{ memcpy(&(x), y, 4); x &= 0xFFFFFFFF; }
+
+#define STORE64L(x, y) \
+{ uint64 __t = (x); memcpy(y, &__t, 8); }
+
+#define LOAD64L(x, y) \
+{ memcpy(&(x), y, 8); }
+
+#endif /* ENDIAN_64BITWORD */
+#endif /* ENDIAN_LITTLE */
+
+#ifdef ENDIAN_BIG
+#define STORE32L(x, y) { \
+(y)[3] = (unsigned char)(((x)>>24)&255); \
+(y)[2] = (unsigned char)(((x)>>16)&255); \
+(y)[1] = (unsigned char)(((x)>>8)&255); \
+(y)[0] = (unsigned char)((x)&255); \
+}
+
+#define LOAD32L(x, y) { \
+x = ((unsigned long)((y)[3] & 255)<<24) | \
+((unsigned long)((y)[2] & 255)<<16) | \
+((unsigned long)((y)[1] & 255)<<8)  | \
+((unsigned long)((y)[0] & 255)); \
+}
+
+#define STORE64L(x, y) { \
+(y)[7] = (unsigned char)(((x)>>56)&255); \
+(y)[6] = (unsigned char)(((x)>>48)&255); \
+(y)[5] = (unsigned char)(((x)>>40)&255); \
+(y)[4] = (unsigned char)(((x)>>32)&255); \
+(y)[3] = (unsigned char)(((x)>>24)&255); \
+(y)[2] = (unsigned char)(((x)>>16)&255); \
+(y)[1] = (unsigned char)(((x)>>8)&255); \
+(y)[0] = (unsigned char)((x)&255); \
+}
+
+#define LOAD64L(x, y) { \
+x = (((uint64)((y)[7] & 255))<<56)|(((uint64)((y)[6] & 255))<<48) | \
+(((uint64)((y)[5] & 255))<<40)|(((uint64)((y)[4] & 255))<<32) | \
+(((uint64)((y)[3] & 255))<<24)|(((uint64)((y)[2] & 255))<<16) | \
+(((uint64)((y)[1] & 255))<<8)|(((uint64)((y)[0] & 255))); \
+}
+
+#ifdef ENDIAN_32BITWORD
+#define STORE32H(x, y) \
+{ unsigned int __t = (x); memcpy(y, &__t, 4); }
+
+#define LOAD32H(x, y) memcpy(&(x), y, 4);
+
+#define STORE64H(x, y) { \
+(y)[0] = (unsigned char)(((x)>>56)&255); \
+(y)[1] = (unsigned char)(((x)>>48)&255); \
+(y)[2] = (unsigned char)(((x)>>40)&255); \
+(y)[3] = (unsigned char)(((x)>>32)&255); \
+(y)[4] = (unsigned char)(((x)>>24)&255); \
+(y)[5] = (unsigned char)(((x)>>16)&255); \
+(y)[6] = (unsigned char)(((x)>>8)&255); \
+(y)[7] = (unsigned char)((x)&255); \
+}
+
+#define LOAD64H(x, y) { \
+x = (((uint64)((y)[0] & 255))<<56)|(((uint64)((y)[1] & 255))<<48)| \
+(((uint64)((y)[2] & 255))<<40)|(((uint64)((y)[3] & 255))<<32)| \
+(((uint64)((y)[4] & 255))<<24)|(((uint64)((y)[5] & 255))<<16)| \
+(((uint64)((y)[6] & 255))<<8)| (((uint64)((y)[7] & 255))); \
+}
+
+#else /* 64-bit words then  */
+
+#define STORE32H(x, y) \
+{ unsigned long __t = (x); memcpy(y, &__t, 4); }
+
+#define LOAD32H(x, y) \
+{ memcpy(&(x), y, 4); x &= 0xFFFFFFFF; }
+
+#define STORE64H(x, y) \
+{ uint64 __t = (x); memcpy(y, &__t, 8); }
+
+#define LOAD64H(x, y) \
+{ memcpy(&(x), y, 8); }
+
+#endif /* ENDIAN_64BITWORD */
+#endif /* ENDIAN_BIG */
+
+#ifdef HAVE_NATIVE_INT64
+#define ROL64c(x, y) \
+( (((x)<<((uint64)(y)&63)) | \
+(((x)&CONST64(0xFFFFFFFFFFFFFFFF))>>((uint64)64-((y)&63)))) & CONST64(0xFFFFFFFFFFFFFFFF))
+
+#define ROR64c(x, y) \
+( ((((x)&CONST64(0xFFFFFFFFFFFFFFFF))>>((uint64)(y)&CONST64(63))) | \
+((x)<<((uint64)(64-((y)&CONST64(63)))))) & CONST64(0xFFFFFFFFFFFFFFFF))
+#endif /* HAVE_NATIVE_INT64 */
+/******************************************************************************/
+
+
+
+/* The part below is taken almost verbatim from matrixssl-3-7-2b-open/crypto/symmetric/.
+ * Changes are flagged with //bbox
+ */
+
+/**
+ *	@file    symmetric.h
+ *	@version 33ef80f (HEAD, tag: MATRIXSSL-3-7-2-OPEN, tag: MATRIXSSL-3-7-2-COMM, origin/master, origin/HEAD, master)
+ *
+ *	Header for internal symmetric key cryptography support.
+ */
+/*
+ *	Copyright (c) 2013-2015 INSIDE Secure Corporation
+ *	Copyright (c) PeerSec Networks, 2002-2011
+ *	All Rights Reserved
+ *
+ *	The latest version of this code is available at http://www.matrixssl.org
+ *
+ *	This software is open source; you can redistribute it and/or modify
+ *	it under the terms of the GNU General Public License as published by
+ *	the Free Software Foundation; either version 2 of the License, or
+ *	(at your option) any later version.
+ *
+ *	This General Public License does NOT permit incorporating this software
+ *	into proprietary programs.  If you are unable to comply with the GPL, a
+ *	commercial license for this software may be purchased from INSIDE at
+ *	http://www.insidesecure.com/eng/Company/Locations
+ *
+ *	This program is distributed in WITHOUT ANY WARRANTY; without even the
+ *	implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
+ *	See the GNU General Public License for more details.
+ *
+ *	You should have received a copy of the GNU General Public License
+ *	along with this program; if not, write to the Free Software
+ *	Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+ *	http://www.gnu.org/copyleft/gpl.html
+ */
+/******************************************************************************/
+
+#ifndef _h_PS_SYMMETRIC
+#define _h_PS_SYMMETRIC
+
+/******************************************************************************/
+#ifdef USE_AES
+/******************************************************************************/
+
+
+#ifndef USE_AES_CBC_EXTERNAL
+typedef struct {
+	uint32 eK[64], dK[64];
+	int32 Nr;
+} psAesKey_t;
+
+typedef struct {
+	int32			blocklen;
+	unsigned char	IV[16];
+	psAesKey_t		key;
+#if defined(USE_AES_GCM) || defined(USE_AES_CCM)
+	unsigned char	EncCtr[16];
+	unsigned char	CtrBlock[16];
+#endif
+#ifdef USE_AES_GCM
+	unsigned char	gInit[16];
+	uint32			TagTemp[4];
+	unsigned char	Hash_SubKey[16];
+	uint32			ProcessedBitCount[4];
+	uint32			InputBufferCount;
+	uint32			OutputBufferCount;
+	union
+	{
+		unsigned char Buffer[128];
+		uint32 BufferAlignment;
+	} Input;
+#endif /* USE_AES_GCM */
+#ifdef USE_AES_CCM
+	uint32_t ccmTagTemp[16 / sizeof(uint32_t)]; /* 32 */
+	union
+	{
+		/* Used for formatting IV. */
+		uint8_t Temporary[16];
+		/* Used for processing Mac. */
+		uint8_t Y0[16];
+	} u; /* 48 */
+#endif /* USE_AES_CCM */
+} psAesCipher_t;
+#endif /* USE_AES_CBC_EXTERNAL */
+
+#endif /* USE_AES */
+
+#ifdef USE_IDEA
+#define SSL_IDEA_KEY_LEN	16
+#define SSL_IDEA_IV_LEN		8
+#define SSL_IDEA_BLOCK_LEN	8
+
+typedef struct {
+	uint16	key_schedule[52];
+} psIdeaKey_t;
+
+typedef struct {
+	psIdeaKey_t		key;
+	uint32			IV[2];
+	short			for_encryption;
+	short			inverted;
+} idea_CBC;
+#endif
+/******************************************************************************/
+
+/******************************************************************************/
+#ifdef USE_SEED
+/******************************************************************************/
+#define SSL_SEED_KEY_LEN	16
+#define SSL_SEED_IV_LEN		16
+
+
+typedef struct {
+	uint32 K[32], dK[32];
+} psSeedKey_t;
+
+typedef struct {
+	int32			blocklen;
+	unsigned char	IV[16];
+	psSeedKey_t		key;
+} seed_CBC;
+
+#endif /* USE_SEED */
+/******************************************************************************/
+
+/******************************************************************************/
+#if defined(USE_3DES) || defined(USE_DES)
+/******************************************************************************/
+#define DES3_KEY_LEN	24
+#define DES3_IV_LEN		8
+#define DES_KEY_LEN		8
+
+typedef struct {
+	uint32 ek[3][32], dk[3][32];
+} psDes3Key_t;
+
+/*
+	A block cipher CBC structure
+ */
+typedef struct {
+	int32				blocklen;
+	unsigned char		IV[8];
+	psDes3Key_t			key;
+} des3_CBC;
+
+#endif /* USE_3DES || USE_DES */
+/******************************************************************************/
+
+/******************************************************************************/
+#ifdef USE_ARC4
+typedef struct {
+	unsigned char	state[256];
+	uint32	byteCount;
+	unsigned char	x;
+	unsigned char	y;
+} psRc4Key_t;
+#endif /* USE_ARC4 */
+/******************************************************************************/
+#ifdef USE_RC2
+typedef struct {
+	unsigned xkey[64];
+} psRc2Key_t;
+
+typedef struct {
+	int32				blocklen;
+	unsigned char		IV[8];
+	psRc2Key_t			key;
+} rc2_CBC;
+#endif /* USE_RC2 */
+/******************************************************************************/
+/*	Universal types and defines */
+/******************************************************************************/
+#define MAXBLOCKSIZE	24
+
+typedef union {
+#ifdef USE_RC2
+	rc2_CBC		rc2;
+#endif
+#ifdef USE_ARC4
+	psRc4Key_t	arc4;
+#endif
+#ifdef USE_3DES
+	des3_CBC	des3;
+#endif
+#ifdef USE_AES
+	psAesCipher_t	aes;
+#endif
+#ifdef USE_SEED
+	seed_CBC	seed;
+#endif
+#ifdef USE_IDEA
+	idea_CBC	idea;
+#endif
+} psCipherContext_t;
+
+#define byte(x, n) (((x) >> (8 * (n))) & 255)
+
+#endif /* _h_PS_SYMMETRIC */
+/******************************************************************************/
diff -urpN busybox-1.26.2/networking/traceroute.c busybox-1.27.0/networking/traceroute.c
--- busybox-1.26.2/networking/traceroute.c	2016-12-10 18:46:36.000000000 +0100
+++ busybox-1.27.0/networking/traceroute.c	2017-01-10 16:31:40.000000000 +0100
@@ -235,8 +235,6 @@
 //config:	bool "Enable -I option (use ICMP instead of UDP)"
 //config:	default y
 //config:	depends on TRACEROUTE || TRACEROUTE6
-//config:	help
-//config:	  Add option -I to use ICMP ECHO instead of UDP datagrams.
 
 /* Needs socket(AF_INET, SOCK_RAW, IPPROTO_ICMP), therefore BB_SUID_MAYBE: */
 //applet:IF_TRACEROUTE(APPLET(traceroute, BB_DIR_USR_BIN, BB_SUID_MAYBE))
diff -urpN busybox-1.26.2/networking/udhcp/Config.src busybox-1.27.0/networking/udhcp/Config.src
--- busybox-1.26.2/networking/udhcp/Config.src	2017-01-01 13:01:04.000000000 +0100
+++ busybox-1.27.0/networking/udhcp/Config.src	2017-01-10 16:31:40.000000000 +0100
@@ -6,29 +6,13 @@
 INSERT
 
 config UDHCPD
-	bool "udhcp server (udhcpd)"
+	bool "udhcpd (DHCP server)"
 	default y
 	select PLATFORM_LINUX
 	help
 	  udhcpd is a DHCP server geared primarily toward embedded systems,
 	  while striving to be fully functional and RFC compliant.
 
-config DHCPRELAY
-	bool "dhcprelay"
-	default y
-	help
-	  dhcprelay listens for dhcp requests on one or more interfaces
-	  and forwards these requests to a different interface or dhcp
-	  server.
-
-config DUMPLEASES
-	bool "Lease display utility (dumpleases)"
-	default y
-	help
-	  dumpleases displays the leases written out by the udhcpd server.
-	  Lease times are stored in the file by time remaining in lease, or
-	  by the absolute time that it expires in seconds from epoch.
-
 config FEATURE_UDHCPD_WRITE_LEASES_EARLY
 	bool "Rewrite the lease file at every new acknowledge"
 	default y
@@ -61,8 +45,24 @@ config DHCPD_LEASES_FILE
 	  udhcpd stores addresses in a lease file. This is the absolute path
 	  of the file. Normally it is safe to leave it untouched.
 
+config DUMPLEASES
+	bool "dumpleases"
+	default y
+	help
+	  dumpleases displays the leases written out by the udhcpd.
+	  Lease times are stored in the file by time remaining in lease, or
+	  by the absolute time that it expires in seconds from epoch.
+
+config DHCPRELAY
+	bool "dhcprelay"
+	default y
+	help
+	  dhcprelay listens for dhcp requests on one or more interfaces
+	  and forwards these requests to a different interface or dhcp
+	  server.
+
 config UDHCPC
-	bool "udhcp client (udhcpc)"
+	bool "udhcpc (DHCP client)"
 	default y
 	select PLATFORM_LINUX
 	help
@@ -93,6 +93,15 @@ config FEATURE_UDHCPC_SANITIZEOPT
 	  they will be replaced with string "bad" when exporting
 	  to the environment.
 
+config UDHCPC_DEFAULT_SCRIPT
+	string "Absolute path to config script"
+	default "/usr/share/udhcpc/default.script"
+	depends on UDHCPC
+	help
+	  This script is called after udhcpc receives an answer. See
+	  examples/udhcp for a working example. Normally it is safe
+	  to leave this untouched.
+
 config FEATURE_UDHCP_PORT
 	bool "Enable '-P port' option for udhcpd and udhcpc"
 	default n
@@ -114,7 +123,7 @@ config UDHCP_DEBUG
 	  are very verbose and useful for debugging only.
 
 config FEATURE_UDHCP_RFC3397
-	bool "Support for RFC3397 domain search (experimental)"
+	bool "Support RFC3397 domain search (experimental)"
 	default y
 	depends on UDHCPD || UDHCPC
 	help
@@ -123,22 +132,13 @@ config FEATURE_UDHCP_RFC3397
 	  and SIP servers option 120, specified in RFC 3361.
 
 config FEATURE_UDHCP_8021Q
-	bool "Support for 802.1Q VLAN parameters"
+	bool "Support 802.1Q VLAN parameters"
 	default y
 	depends on UDHCPD || UDHCPC
 	help
 	  If selected, both client and server will support passing of VLAN
 	  ID and priority via options 132 and 133 as per 802.1Q.
 
-config UDHCPC_DEFAULT_SCRIPT
-	string "Absolute path to config script"
-	default "/usr/share/udhcpc/default.script"
-	depends on UDHCPC
-	help
-	  This script is called after udhcpc receives an answer. See
-	  examples/udhcp for a working example. Normally it is safe
-	  to leave this untouched.
-
 config UDHCPC_SLACK_FOR_BUGGY_SERVERS
 	int "DHCP options slack buffer size"
 	default 80
diff -urpN busybox-1.26.2/networking/udhcp/common.c busybox-1.27.0/networking/udhcp/common.c
--- busybox-1.26.2/networking/udhcp/common.c	2016-12-10 18:46:36.000000000 +0100
+++ busybox-1.27.0/networking/udhcp/common.c	2017-07-01 22:51:12.000000000 +0200
@@ -14,6 +14,7 @@ const uint8_t MAC_BCAST_ADDR[6] ALIGN2 =
 	0xff, 0xff, 0xff, 0xff, 0xff, 0xff
 };
 
+#if ENABLE_UDHCPC || ENABLE_UDHCPD
 /* Supported options are easily added here.
  * See RFC2132 for more options.
  * OPTION_REQ: these options are requested by udhcpc (unless -o).
@@ -86,7 +87,7 @@ const struct dhcp_optflag dhcp_optflags[
 };
 
 /* Used for converting options from incoming packets to env variables
- * for udhcpc stript, and for setting options for udhcpd via
+ * for udhcpc script, and for setting options for udhcpd via
  * "opt OPTION_NAME OPTION_VALUE" directives in udhcpd.conf file.
  */
 /* Must match dhcp_optflags[] order */
@@ -136,6 +137,7 @@ const char dhcp_option_strings[] ALIGN1
 	"msstaticroutes""\0"/* DHCP_MS_STATIC_ROUTES */
 	"wpad" "\0"        /* DHCP_WPAD           */
 	;
+#endif
 
 /* Lengths of the option types in binary form.
  * Used by:
@@ -190,21 +192,26 @@ static void log_option(const char *pfx,
 # define log_option(pfx, opt) ((void)0)
 #endif
 
-unsigned FAST_FUNC udhcp_option_idx(const char *name)
+unsigned FAST_FUNC udhcp_option_idx(const char *name, const char *option_strings)
 {
-	int n = index_in_strings(dhcp_option_strings, name);
+	int n = index_in_strings(option_strings, name);
 	if (n >= 0)
 		return n;
 
 	{
-		char buf[sizeof(dhcp_option_strings)];
-		char *d = buf;
-		const char *s = dhcp_option_strings;
-		while (s < dhcp_option_strings + sizeof(dhcp_option_strings) - 2) {
+		char *buf, *d;
+		const char *s;
+
+		s = option_strings;
+		while (*s)
+			s += strlen(s) + 1;
+
+		d = buf = xzalloc(s - option_strings);
+		s = option_strings;
+		while (!(*s == '\0' && s[1] == '\0')) {
 			*d++ = (*s == '\0' ? ' ' : *s);
 			s++;
 		}
-		*d = '\0';
 		bb_error_msg_and_die("unknown option '%s', known options: %s", name, buf);
 	}
 }
@@ -315,6 +322,7 @@ void FAST_FUNC udhcp_add_binary_option(s
 	optionptr[end + len] = DHCP_END;
 }
 
+#if ENABLE_UDHCPC || ENABLE_UDHCPD
 /* Add an one to four byte option to a packet */
 void FAST_FUNC udhcp_add_simple_option(struct dhcp_packet *packet, uint8_t code, uint32_t data)
 {
@@ -338,6 +346,7 @@ void FAST_FUNC udhcp_add_simple_option(s
 
 	bb_error_msg("can't add option 0x%02x", code);
 }
+#endif
 
 /* Find option 'code' in opt_list */
 struct option_set* FAST_FUNC udhcp_find_option(struct option_set *opt_list, uint8_t code)
@@ -451,7 +460,7 @@ static NOINLINE void attach_option(
 	free(allocated);
 }
 
-int FAST_FUNC udhcp_str2optset(const char *const_str, void *arg)
+int FAST_FUNC udhcp_str2optset(const char *const_str, void *arg, const struct dhcp_optflag *optflags, const char *option_strings)
 {
 	struct option_set **opt_list = arg;
 	char *opt, *val;
@@ -478,7 +487,7 @@ int FAST_FUNC udhcp_str2optset(const cha
 		bin_optflag.code = optcode;
 		optflag = &bin_optflag;
 	} else {
-		optflag = &dhcp_optflags[udhcp_option_idx(opt)];
+		optflag = &optflags[udhcp_option_idx(opt, option_strings)];
 	}
 
 	retval = 0;
diff -urpN busybox-1.26.2/networking/udhcp/common.h busybox-1.27.0/networking/udhcp/common.h
--- busybox-1.26.2/networking/udhcp/common.h	2016-09-27 18:53:50.000000000 +0200
+++ busybox-1.27.0/networking/udhcp/common.h	2017-07-02 21:32:47.000000000 +0200
@@ -93,8 +93,10 @@ enum {
 	OPTION_BIN,
 	OPTION_STATIC_ROUTES,
 	OPTION_6RD,
-#if ENABLE_FEATURE_UDHCP_RFC3397
+#if ENABLE_FEATURE_UDHCP_RFC3397 || ENABLE_FEATURE_UDHCPC6_RFC3646 || ENABLE_FEATURE_UDHCPC6_RFC4704
 	OPTION_DNS_STRING,  /* RFC1035 compressed domain name list */
+#endif
+#if ENABLE_FEATURE_UDHCP_RFC3397
 	OPTION_SIP_SERVERS,
 #endif
 
@@ -189,17 +191,21 @@ struct option_set {
 	struct option_set *next;
 };
 
+#if ENABLE_UDHCPC || ENABLE_UDHCPD
 extern const struct dhcp_optflag dhcp_optflags[];
 extern const char dhcp_option_strings[] ALIGN1;
+#endif
 extern const uint8_t dhcp_option_lengths[] ALIGN1;
 
-unsigned FAST_FUNC udhcp_option_idx(const char *name);
+unsigned FAST_FUNC udhcp_option_idx(const char *name, const char *option_strings);
 
 uint8_t *udhcp_get_option(struct dhcp_packet *packet, int code) FAST_FUNC;
 int udhcp_end_option(uint8_t *optionptr) FAST_FUNC;
 void udhcp_add_binary_option(struct dhcp_packet *packet, uint8_t *addopt) FAST_FUNC;
+#if ENABLE_UDHCPC || ENABLE_UDHCPD
 void udhcp_add_simple_option(struct dhcp_packet *packet, uint8_t code, uint32_t data) FAST_FUNC;
-#if ENABLE_FEATURE_UDHCP_RFC3397
+#endif
+#if ENABLE_FEATURE_UDHCP_RFC3397 || ENABLE_FEATURE_UDHCPC6_RFC3646 || ENABLE_FEATURE_UDHCPC6_RFC4704
 char *dname_dec(const uint8_t *cstr, int clen, const char *pre) FAST_FUNC;
 uint8_t *dname_enc(const uint8_t *cstr, int clen, const char *src, int *retlen) FAST_FUNC;
 #endif
@@ -284,9 +290,14 @@ void udhcp_dump_packet(struct dhcp_packe
 /* 2nd param is "uint32_t*" */
 int FAST_FUNC udhcp_str2nip(const char *str, void *arg);
 /* 2nd param is "struct option_set**" */
-int FAST_FUNC udhcp_str2optset(const char *str, void *arg);
+int FAST_FUNC udhcp_str2optset(const char *str,
+		void *arg,
+		const struct dhcp_optflag *optflags,
+		const char *option_strings);
 
+#if ENABLE_UDHCPC || ENABLE_UDHCPD
 void udhcp_init_header(struct dhcp_packet *packet, char type) FAST_FUNC;
+#endif
 
 int udhcp_recv_kernel_packet(struct dhcp_packet *packet, int fd) FAST_FUNC;
 
@@ -300,8 +311,8 @@ int udhcp_send_kernel_packet(struct dhcp
 		uint32_t dest_nip, int dest_port) FAST_FUNC;
 
 void udhcp_sp_setup(void) FAST_FUNC;
-int udhcp_sp_fd_set(fd_set *rfds, int extra_fd) FAST_FUNC;
-int udhcp_sp_read(const fd_set *rfds) FAST_FUNC;
+void udhcp_sp_fd_set(struct pollfd *pfds, int extra_fd) FAST_FUNC;
+int udhcp_sp_read(struct pollfd *pfds) FAST_FUNC;
 
 int udhcp_read_interface(const char *interface, int *ifindex, uint32_t *nip, uint8_t *mac) FAST_FUNC;
 
diff -urpN busybox-1.26.2/networking/udhcp/d6_common.h busybox-1.27.0/networking/udhcp/d6_common.h
--- busybox-1.26.2/networking/udhcp/d6_common.h	2016-09-27 18:53:50.000000000 +0200
+++ busybox-1.27.0/networking/udhcp/d6_common.h	2017-07-01 22:51:12.000000000 +0200
@@ -81,9 +81,53 @@ struct d6_option {
 #define D6_OPT_RECONF_MSG    19
 #define D6_OPT_RECONF_ACCEPT 20
 
+#define D6_OPT_DNS_SERVERS   23
+#define D6_OPT_DOMAIN_LIST   24
+
 #define D6_OPT_IA_PD         25
 #define D6_OPT_IAPREFIX      26
 
+/* RFC 4704 "The DHCPv6 Client FQDN Option"
+ * uint16	option-code	OPTION_CLIENT_FQDN (39)
+ * uint16	option-len	1 + length of domain name
+ * uint8	flags
+ * char[]	domain-name	partial or fully qualified domain name
+ *
+ * Flags format is |MBZ|N|O|S|
+ * The "S" bit indicates whether the server SHOULD or SHOULD NOT perform
+ * the AAAA RR (FQDN-to-address) DNS updates.  A client sets the bit to
+ * 0 to indicate that the server SHOULD NOT perform the updates and 1 to
+ * indicate that the server SHOULD perform the updates.  The state of
+ * the bit in the reply from the server indicates the action to be taken
+ * by the server; if it is 1, the server has taken responsibility for
+ * AAAA RR updates for the FQDN.
+ * The "O" bit indicates whether the server has overridden the client's
+ * preference for the "S" bit.  A client MUST set this bit to 0.  A
+ * server MUST set this bit to 1 if the "S" bit in its reply to the
+ * client does not match the "S" bit received from the client.
+ * The "N" bit indicates whether the server SHOULD NOT perform any DNS
+ * updates.  A client sets this bit to 0 to request that the server
+ * SHOULD perform updates (the PTR RR and possibly the AAAA RR based on
+ * the "S" bit) or to 1 to request that the server SHOULD NOT perform
+ * any DNS updates.  A server sets the "N" bit to indicate whether the
+ * server SHALL (0) or SHALL NOT (1) perform DNS updates.  If the "N"
+ * bit is 1, the "S" bit MUST be 0.
+ *
+ * If a client knows only part of its name, it MAY send a name that is not
+ * fully qualified, indicating that it knows part of the name but does not
+ * necessarily know the zone in which the name is to be embedded.
+ * To send a fully qualified domain name, the Domain Name field is set
+ * to the DNS-encoded domain name including the terminating zero-length
+ * label.  To send a partial name, the Domain Name field is set to the
+ * DNS-encoded domain name without the terminating zero-length label.
+ * A client MAY also leave the Domain Name field empty if it desires the
+ * server to provide a name.
+ */
+#define D6_OPT_CLIENT_FQDN   39
+
+#define D6_OPT_TZ_POSIX      41
+#define D6_OPT_TZ_NAME       42
+
 /*** Other shared functions ***/
 
 struct client6_data_t {
@@ -91,10 +135,14 @@ struct client6_data_t {
 	struct d6_option *ia_na;
 	char **env_ptr;
 	unsigned env_idx;
+	/* link-local IPv6 address */
+	struct in6_addr ll_ip6;
 };
 
 #define client6_data (*(struct client6_data_t*)(&bb_common_bufsiz1[COMMON_BUFSIZE - sizeof(struct client6_data_t)]))
 
+int FAST_FUNC d6_read_interface(const char *interface, int *ifindex, struct in6_addr *nip6, uint8_t *mac);
+
 int FAST_FUNC d6_listen_socket(int port, const char *inf);
 
 int FAST_FUNC d6_recv_kernel_packet(
@@ -112,7 +160,8 @@ int FAST_FUNC d6_send_raw_packet(
 int FAST_FUNC d6_send_kernel_packet(
 		struct d6_packet *d6_pkt, unsigned d6_pkt_size,
 		struct in6_addr *src_ipv6, int source_port,
-		struct in6_addr *dst_ipv6, int dest_port
+		struct in6_addr *dst_ipv6, int dest_port,
+		int ifindex
 );
 
 #if defined CONFIG_UDHCP_DEBUG && CONFIG_UDHCP_DEBUG >= 2
diff -urpN busybox-1.26.2/networking/udhcp/d6_dhcpc.c busybox-1.27.0/networking/udhcp/d6_dhcpc.c
--- busybox-1.26.2/networking/udhcp/d6_dhcpc.c	2016-09-27 18:53:50.000000000 +0200
+++ busybox-1.27.0/networking/udhcp/d6_dhcpc.c	2017-07-01 22:51:12.000000000 +0200
@@ -2,26 +2,49 @@
 /*
  * DHCPv6 client.
  *
- * 2011-11.
- * WARNING: THIS CODE IS INCOMPLETE. IT IS NOWHERE NEAR
- * TO BE READY FOR PRODUCTION USE.
+ * WARNING: THIS CODE IS INCOMPLETE.
  *
- * Copyright (C) 2011 Denys Vlasenko.
+ * Copyright (C) 2011-2017 Denys Vlasenko.
  *
  * Licensed under GPLv2, see file LICENSE in this source tree.
  */
 
 //config:config UDHCPC6
-//config:	bool "udhcp client for DHCPv6 (udhcpc6)"
+//config:	bool "udhcpc6 (DHCPv6 client, EXPERIMENTAL)"
 //config:	default n  # not yet ready
 //config:	depends on FEATURE_IPV6
 //config:	help
 //config:	  udhcpc6 is a DHCPv6 client
+//config:
+//config:config FEATURE_UDHCPC6_RFC3646
+//config:	bool "Support RFC 3646 (DNS server and search list)"
+//config:	default y
+//config:	depends on UDHCPC6
+//config:	help
+//config:	  List of DNS servers and domain search list can be requested with
+//config:	  "-O dns" and "-O search". If server gives these values,
+//config:	  they will be set in environment variables "dns" and "search".
+//config:
+//config:config FEATURE_UDHCPC6_RFC4704
+//config:	bool "Support RFC 4704 (Client FQDN)"
+//config:	default y
+//config:	depends on UDHCPC6
+//config:	help
+//config:	  You can request FQDN to be given by server using "-O fqdn".
+//config:
+//config:config FEATURE_UDHCPC6_RFC4833
+//config:	bool "Support RFC 4833 (Timezones)"
+//config:	default y
+//config:	depends on UDHCPC6
+//config:	help
+//config:	  You can request POSIX timezone with "-O tz" and timezone name
+//config:	  with "-O timezone".
 
 //applet:IF_UDHCPC6(APPLET(udhcpc6, BB_DIR_USR_BIN, BB_SUID_DROP))
 
 //kbuild:lib-$(CONFIG_UDHCPC6) += d6_dhcpc.o d6_packet.o d6_socket.o common.o socket.o signalpipe.o
-
+//kbuild:lib-$(CONFIG_FEATURE_UDHCPC6_RFC3646) += domain_codec.o
+//kbuild:lib-$(CONFIG_FEATURE_UDHCPC6_RFC4704) += domain_codec.o
 
 #include <syslog.h>
 /* Override ENABLE_FEATURE_PIDFILE - ifupdown needs our pidfile to always exist */
@@ -37,6 +60,34 @@
 
 /* "struct client_config_t client_config" is in bb_common_bufsiz1 */
 
+static const struct dhcp_optflag d6_optflags[] = {
+#if ENABLE_FEATURE_UDHCPC6_RFC3646
+	{ OPTION_6RD | OPTION_LIST        | OPTION_REQ, D6_OPT_DNS_SERVERS },
+	{ OPTION_DNS_STRING | OPTION_LIST | OPTION_REQ, D6_OPT_DOMAIN_LIST },
+#endif
+#if ENABLE_FEATURE_UDHCPC6_RFC4704
+	{ OPTION_DNS_STRING,                            D6_OPT_CLIENT_FQDN },
+#endif
+#if ENABLE_FEATURE_UDHCPC6_RFC4833
+	{ OPTION_STRING,                                D6_OPT_TZ_POSIX },
+	{ OPTION_STRING,                                D6_OPT_TZ_NAME },
+#endif
+	{ 0, 0 }
+};
+/* Must match d6_optflags[] order */
+static const char d6_option_strings[] ALIGN1 =
+#if ENABLE_FEATURE_UDHCPC6_RFC3646
+	"dns" "\0"      /* D6_OPT_DNS_SERVERS */
+	"search" "\0"   /* D6_OPT_DOMAIN_LIST */
+#endif
+#if ENABLE_FEATURE_UDHCPC6_RFC4704
+	"fqdn" "\0"     /* D6_OPT_CLIENT_FQDN */
+#endif
+#if ENABLE_FEATURE_UDHCPC6_RFC4833
+	"tz" "\0"       /* D6_OPT_TZ_POSIX */
+	"timezone" "\0" /* D6_OPT_TZ_NAME */
+#endif
+	"\0";
 
 #if ENABLE_LONG_OPTS
 static const char udhcpc6_longopts[] ALIGN1 =
@@ -54,7 +105,9 @@ static const char udhcpc6_longopts[] ALI
 	"request-option\0" Required_argument "O"
 	"no-default-options\0" No_argument   "o"
 	"foreground\0"     No_argument       "f"
+	USE_FOR_MMU(
 	"background\0"     No_argument       "b"
+	)
 ///	IF_FEATURE_UDHCPC_ARPING("arping\0"	No_argument       "a")
 	IF_FEATURE_UDHCP_PORT("client-port\0"	Required_argument "P")
 	;
@@ -86,6 +139,17 @@ enum {
 	IF_FEATURE_UDHCP_PORT(   OPT_P = 1 << OPTBIT_P,)
 };
 
+#if ENABLE_FEATURE_UDHCPC6_RFC4704
+static const char opt_fqdn_req[] = {
+	(D6_OPT_CLIENT_FQDN >> 8), (D6_OPT_CLIENT_FQDN & 0xff),
+	0, 2, /* optlen */
+	0, /* flags: */
+	/* S=0: server SHOULD NOT perform AAAA RR updates */
+	/* O=0: client MUST set this bit to 0 */
+	/* N=0: server SHOULD perform updates (PTR RR only in our case, since S=0) */
+	0 /* empty DNS-encoded name */
+};
+#endif
 
 /*** Utility functions ***/
 
@@ -107,8 +171,8 @@ static void *d6_find_option(uint8_t *opt
 		/* Does its code match? */
 		if (option[1] == code)
 			return option; /* yes! */
-		option += option[3] + 4;
 		len_m4 -= option[3] + 4;
+		option += option[3] + 4;
 	}
 	return NULL;
 }
@@ -121,12 +185,6 @@ static void *d6_copy_option(uint8_t *opt
 	return xmemdup(opt, opt[3] + 4);
 }
 
-static void *d6_store_blob(void *dst, const void *src, unsigned len)
-{
-	memcpy(dst, src, len);
-	return dst + len;
-}
-
 
 /*** Script execution code ***/
 
@@ -139,8 +197,12 @@ static char** new_env(void)
 /* put all the parameters into the environment */
 static void option_to_env(uint8_t *option, uint8_t *option_end)
 {
+#if ENABLE_FEATURE_UDHCPC6_RFC3646
+	int addrs, option_offset;
+#endif
 	/* "length minus 4" */
 	int len_m4 = option_end - option - 4;
+
 	while (len_m4 >= 0) {
 		uint32_t v32;
 		char ipv6str[sizeof("ffff:ffff:ffff:ffff:ffff:ffff:ffff:ffff")];
@@ -148,6 +210,10 @@ static void option_to_env(uint8_t *optio
 		if (option[0] != 0 || option[2] != 0)
 			break;
 
+		/* Check if option-length exceeds size of option */
+		if (option[3] > len_m4)
+			break;
+
 		switch (option[1]) {
 		//case D6_OPT_CLIENTID:
 		//case D6_OPT_SERVERID:
@@ -157,7 +223,7 @@ static void option_to_env(uint8_t *optio
 			break;
 		//case D6_OPT_IA_TA:
 		case D6_OPT_IAADDR:
-/*   0                   1                   2                   3
+/*  0                   1                   2                   3
  *  0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
  * +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
  * |          OPTION_IAADDR        |          option-len           |
@@ -217,9 +283,79 @@ static void option_to_env(uint8_t *optio
 
 			sprint_nip6(ipv6str, option + 4 + 4 + 1);
 			*new_env() = xasprintf("ipv6prefix=%s/%u", ipv6str, (unsigned)(option[4 + 4]));
+			break;
+#if ENABLE_FEATURE_UDHCPC6_RFC3646
+		case D6_OPT_DNS_SERVERS: {
+			char *dlist;
+
+			/* Make sure payload-size is a multiple of 16 */
+			if ((option[3] & 0x0f) != 0)
+				break;
+
+			/* Get the number of addresses on the option */
+			addrs = option[3] >> 4;
+
+			/* Setup environment variable */
+			*new_env() = dlist = xmalloc(4 + addrs * 40 - 1);
+			dlist = stpcpy(dlist, "dns=");
+			option_offset = 0;
+
+			while (addrs--) {
+				sprint_nip6(dlist, option + 4 + option_offset);
+				dlist += 39;
+				option_offset += 16;
+				if (addrs)
+					*dlist++ = ' ';
+			}
+
+			break;
+		}
+		case D6_OPT_DOMAIN_LIST: {
+			char *dlist;
+
+			dlist = dname_dec(option + 4, (option[2] << 8) | option[3], "search=");
+			if (!dlist)
+				break;
+			*new_env() = dlist;
+			break;
+		}
+#endif
+#if ENABLE_FEATURE_UDHCPC6_RFC4704
+		case D6_OPT_CLIENT_FQDN: {
+			char *dlist;
+
+			if (option[3] == 0)
+				break;
+			/* Work around broken ISC DHCPD6.
+			 * ISC DHCPD6 does not implement RFC 4704 correctly: It says the first
+			 * byte of option-payload should contain flags where the bits 7-3 are
+			 * reserved for future use and MUST be zero. Instead ISC DHCPD6 just
+			 * writes the entire FQDN as string to option-payload. We assume a
+			 * broken server here if any of the reserved bits are set.
+			 */
+			if (option[4] & 0xf8) {
+				*new_env() = xasprintf("fqdn=%.*s", (int)option[3], (char*)option + 4);
+				break;
+			}
+			dlist = dname_dec(option + 5, (/*(option[2] << 8) |*/ option[3]) - 1, "fqdn=");
+			if (!dlist)
+				break;
+			*new_env() = dlist;
+			break;
+		}
+#endif
+#if ENABLE_FEATURE_UDHCPC6_RFC4833
+		/* RFC 4833 Timezones */
+		case D6_OPT_TZ_POSIX:
+			*new_env() = xasprintf("tz=%.*s", (int)option[3], (char*)option + 4);
+			break;
+		case D6_OPT_TZ_NAME:
+			*new_env() = xasprintf("tz_name=%.*s", (int)option[3], (char*)option + 4);
+			break;
+#endif
 		}
-		option += 4 + option[3];
 		len_m4 -= 4 + option[3];
+		option += 4 + option[3];
 	}
 }
 
@@ -284,22 +420,38 @@ static uint8_t *init_d6_packet(struct d6
 	packet->d6_msg_type = type;
 
 	clientid = (void*)client_config.clientid;
-	return d6_store_blob(packet->d6_options, clientid, clientid->len + 2+2);
+	return mempcpy(packet->d6_options, clientid, clientid->len + 2+2);
 }
 
 static uint8_t *add_d6_client_options(uint8_t *ptr)
 {
-	return ptr;
-	//uint8_t c;
-	//int i, end, len;
+	uint8_t *start = ptr;
+	unsigned option;
 
-	/* Add a "param req" option with the list of options we'd like to have
-	 * from stubborn DHCP servers. Pull the data from the struct in common.c.
-	 * No bounds checking because it goes towards the head of the packet. */
-	//...
+	ptr += 4;
+	for (option = 1; option < 256; option++) {
+		if (client_config.opt_mask[option >> 3] & (1 << (option & 7))) {
+			ptr[0] = (option >> 8);
+			ptr[1] = option;
+			ptr += 2;
+		}
+	}
+
+	if ((ptr - start - 4) != 0) {
+		start[0] = (D6_OPT_ORO >> 8);
+		start[1] = D6_OPT_ORO;
+		start[2] = ((ptr - start - 4) >> 8);
+		start[3] = (ptr - start - 4);
+	} else
+		ptr = start;
 
+#if ENABLE_FEATURE_UDHCPC6_RFC4704
+	ptr = mempcpy(ptr, &opt_fqdn_req, sizeof(opt_fqdn_req));
+#endif
 	/* Add -x options if any */
 	//...
+
+	return ptr;
 }
 
 static int d6_mcast_from_client_config_ifindex(struct d6_packet *packet, uint8_t *end)
@@ -311,7 +463,7 @@ static int d6_mcast_from_client_config_i
 
 	return d6_send_raw_packet(
 		packet, (end - (uint8_t*) packet),
-		/*src*/ NULL, CLIENT_PORT6,
+		/*src*/ &client6_data.ll_ip6, CLIENT_PORT6,
 		/*dst*/ (struct in6_addr*)FF02__1_2, SERVER_PORT6, MAC_BCAST_ADDR,
 		client_config.ifindex
 	);
@@ -421,7 +573,7 @@ static NOINLINE int send_d6_discover(uin
 		iaaddr->len = 16+4+4;
 		memcpy(iaaddr->data, requested_ipv6, 16);
 	}
-	opt_ptr = d6_store_blob(opt_ptr, client6_data.ia_na, len);
+	opt_ptr = mempcpy(opt_ptr, client6_data.ia_na, len);
 
 	/* Add options:
 	 * "param req" option according to -O, options specified with -x
@@ -472,9 +624,9 @@ static NOINLINE int send_d6_select(uint3
 	opt_ptr = init_d6_packet(&packet, D6_MSG_REQUEST, xid);
 
 	/* server id */
-	opt_ptr = d6_store_blob(opt_ptr, client6_data.server_id, client6_data.server_id->len + 2+2);
+	opt_ptr = mempcpy(opt_ptr, client6_data.server_id, client6_data.server_id->len + 2+2);
 	/* IA NA (contains requested IP) */
-	opt_ptr = d6_store_blob(opt_ptr, client6_data.ia_na, client6_data.ia_na->len + 2+2);
+	opt_ptr = mempcpy(opt_ptr, client6_data.ia_na, client6_data.ia_na->len + 2+2);
 
 	/* Add options:
 	 * "param req" option according to -O, options specified with -x
@@ -541,9 +693,9 @@ static NOINLINE int send_d6_renew(uint32
 	opt_ptr = init_d6_packet(&packet, DHCPREQUEST, xid);
 
 	/* server id */
-	opt_ptr = d6_store_blob(opt_ptr, client6_data.server_id, client6_data.server_id->len + 2+2);
+	opt_ptr = mempcpy(opt_ptr, client6_data.server_id, client6_data.server_id->len + 2+2);
 	/* IA NA (contains requested IP) */
-	opt_ptr = d6_store_blob(opt_ptr, client6_data.ia_na, client6_data.ia_na->len + 2+2);
+	opt_ptr = mempcpy(opt_ptr, client6_data.ia_na, client6_data.ia_na->len + 2+2);
 
 	/* Add options:
 	 * "param req" option according to -O, options specified with -x
@@ -555,7 +707,8 @@ static NOINLINE int send_d6_renew(uint32
 		return d6_send_kernel_packet(
 			&packet, (opt_ptr - (uint8_t*) &packet),
 			our_cur_ipv6, CLIENT_PORT6,
-			server_ipv6, SERVER_PORT6
+			server_ipv6, SERVER_PORT6,
+			client_config.ifindex
 		);
 	return d6_mcast_from_client_config_ifindex(&packet, opt_ptr);
 }
@@ -569,23 +722,22 @@ static int send_d6_release(struct in6_ad
 	/* Fill in: msg type, client id */
 	opt_ptr = init_d6_packet(&packet, D6_MSG_RELEASE, random_xid());
 	/* server id */
-	opt_ptr = d6_store_blob(opt_ptr, client6_data.server_id, client6_data.server_id->len + 2+2);
+	opt_ptr = mempcpy(opt_ptr, client6_data.server_id, client6_data.server_id->len + 2+2);
 	/* IA NA (contains our current IP) */
-	opt_ptr = d6_store_blob(opt_ptr, client6_data.ia_na, client6_data.ia_na->len + 2+2);
+	opt_ptr = mempcpy(opt_ptr, client6_data.ia_na, client6_data.ia_na->len + 2+2);
 
 	bb_error_msg("sending %s", "release");
 	return d6_send_kernel_packet(
 		&packet, (opt_ptr - (uint8_t*) &packet),
 		our_cur_ipv6, CLIENT_PORT6,
-		server_ipv6, SERVER_PORT6
+		server_ipv6, SERVER_PORT6,
+		client_config.ifindex
 	);
 }
 
 /* Returns -1 on errors that are fatal for the socket, -2 for those that aren't */
 /* NOINLINE: limit stack usage in caller */
-static NOINLINE int d6_recv_raw_packet(struct in6_addr *peer_ipv6
-	UNUSED_PARAM
-	, struct d6_packet *d6_pkt, int fd)
+static NOINLINE int d6_recv_raw_packet(struct in6_addr *peer_ipv6, struct d6_packet *d6_pkt, int fd)
 {
 	int bytes;
 	struct ip6_udp_d6_packet packet;
@@ -634,6 +786,9 @@ static NOINLINE int d6_recv_raw_packet(s
 //		return -2;
 //	}
 
+	if (peer_ipv6)
+		*peer_ipv6 = packet.ip6.ip6_src; /* struct copy */
+
 	log1("received %s", "a packet");
 	d6_dump_packet(&packet.data);
 
@@ -935,9 +1090,7 @@ int udhcpc6_main(int argc UNUSED_PARAM,
 	int timeout; /* must be signed */
 	unsigned already_waited_sec;
 	unsigned opt;
-	int max_fd;
 	int retval;
-	fd_set rfds;
 
 	setup_common_bufsiz();
 
@@ -980,20 +1133,18 @@ int udhcpc6_main(int argc UNUSED_PARAM,
 		char *optstr = llist_pop(&list_O);
 		unsigned n = bb_strtou(optstr, NULL, 0);
 		if (errno || n > 254) {
-			n = udhcp_option_idx(optstr);
-			n = dhcp_optflags[n].code;
+			n = udhcp_option_idx(optstr, d6_option_strings);
+			n = d6_optflags[n].code;
 		}
 		client_config.opt_mask[n >> 3] |= 1 << (n & 7);
 	}
 	if (!(opt & OPT_o)) {
-		/*
 		unsigned i, n;
-		for (i = 0; (n = dhcp_optflags[i].code) != 0; i++) {
-			if (dhcp_optflags[i].flags & OPTION_REQ) {
+		for (i = 0; (n = d6_optflags[i].code) != 0; i++) {
+			if (d6_optflags[i].flags & OPTION_REQ) {
 				client_config.opt_mask[n >> 3] |= 1 << (n & 7);
 			}
 		}
-		*/
 	}
 	while (list_x) {
 		char *optstr = llist_pop(&list_x);
@@ -1002,12 +1153,14 @@ int udhcpc6_main(int argc UNUSED_PARAM,
 			*colon = ' ';
 		/* now it looks similar to udhcpd's config file line:
 		 * "optname optval", using the common routine: */
-		udhcp_str2optset(optstr, &client_config.options);
+		udhcp_str2optset(optstr, &client_config.options, d6_optflags, d6_option_strings);
+		if (colon)
+			*colon = ':'; /* restore it for NOMMU reexec */
 	}
 
-	if (udhcp_read_interface(client_config.interface,
+	if (d6_read_interface(client_config.interface,
 			&client_config.ifindex,
-			NULL,
+			&client6_data.ll_ip6,
 			client_config.client_mac)
 	) {
 		return 1;
@@ -1063,7 +1216,8 @@ int udhcpc6_main(int argc UNUSED_PARAM,
 	 * "continue" statements in code below jump to the top of the loop.
 	 */
 	for (;;) {
-		struct timeval tv;
+		int tv;
+		struct pollfd pfds[2];
 		struct d6_packet packet;
 		uint8_t *packet_end;
 		/* silence "uninitialized!" warning */
@@ -1078,16 +1232,15 @@ int udhcpc6_main(int argc UNUSED_PARAM,
 		 * to change_listen_mode(). Thus we open listen socket
 		 * BEFORE we send renew request (see "case BOUND:"). */
 
-		max_fd = udhcp_sp_fd_set(&rfds, sockfd);
+		udhcp_sp_fd_set(pfds, sockfd);
 
-		tv.tv_sec = timeout - already_waited_sec;
-		tv.tv_usec = 0;
+		tv = timeout - already_waited_sec;
 		retval = 0;
 		/* If we already timed out, fall through with retval = 0, else... */
-		if ((int)tv.tv_sec > 0) {
-			log1("waiting on select %u seconds", (int)tv.tv_sec);
+		if (tv > 0) {
+			log1("waiting on select %u seconds", tv);
 			timestamp_before_wait = (unsigned)monotonic_sec();
-			retval = select(max_fd + 1, &rfds, NULL, NULL, &tv);
+			retval = poll(pfds, 2, tv < INT_MAX/1000 ? tv * 1000 : INT_MAX);
 			if (retval < 0) {
 				/* EINTR? A signal was caught, don't panic */
 				if (errno == EINTR) {
@@ -1108,13 +1261,14 @@ int udhcpc6_main(int argc UNUSED_PARAM,
 			 * or if the status of the bridge changed).
 			 * Refresh ifindex and client_mac:
 			 */
-			if (udhcp_read_interface(client_config.interface,
+			if (d6_read_interface(client_config.interface,
 					&client_config.ifindex,
-					NULL,
+					&client6_data.ll_ip6,
 					client_config.client_mac)
 			) {
 				goto ret0; /* iface is gone? */
 			}
+
 			memcpy(clientid_mac_ptr, client_config.client_mac, 6);
 
 			/* We will restart the wait in any case */
@@ -1222,8 +1376,8 @@ int udhcpc6_main(int argc UNUSED_PARAM,
 		/* select() didn't timeout, something happened */
 
 		/* Is it a signal? */
-		/* note: udhcp_sp_read checks FD_ISSET before reading */
-		switch (udhcp_sp_read(&rfds)) {
+		/* note: udhcp_sp_read checks poll result before reading */
+		switch (udhcp_sp_read(pfds)) {
 		case SIGUSR1:
 			client_config.first_secs = 0; /* make secs field count from 0 */
 			already_waited_sec = 0;
@@ -1258,7 +1412,7 @@ int udhcpc6_main(int argc UNUSED_PARAM,
 		}
 
 		/* Is it a packet? */
-		if (listen_mode == LISTEN_NONE || !FD_ISSET(sockfd, &rfds))
+		if (listen_mode == LISTEN_NONE || !pfds[1].revents)
 			continue; /* no */
 
 		{
@@ -1307,7 +1461,7 @@ int udhcpc6_main(int argc UNUSED_PARAM,
 				struct d6_option *option, *iaaddr;
  type_is_ok:
 				option = d6_find_option(packet.d6_options, packet_end, D6_OPT_STATUS_CODE);
-				if (option && option->data[4] != 0) {
+				if (option && (option->data[0] | option->data[1]) != 0) {
 					/* return to init state */
 					bb_error_msg("received DHCP NAK (%u)", option->data[4]);
 					d6_run_script(&packet, "nak");
@@ -1460,8 +1614,8 @@ int udhcpc6_main(int argc UNUSED_PARAM,
 				if (lease_seconds < 0x10)
 					lease_seconds = 0x10;
 /// TODO: check for 0 lease time?
-				if (lease_seconds >= 0x10000000)
-					lease_seconds = 0x0fffffff;
+				if (lease_seconds > 0x7fffffff / 1000)
+					lease_seconds = 0x7fffffff / 1000;
 				/* enter bound state */
 				timeout = lease_seconds / 2;
 				bb_error_msg("lease obtained, lease time %u",
diff -urpN busybox-1.26.2/networking/udhcp/d6_packet.c busybox-1.27.0/networking/udhcp/d6_packet.c
--- busybox-1.26.2/networking/udhcp/d6_packet.c	2016-09-27 18:53:50.000000000 +0200
+++ busybox-1.27.0/networking/udhcp/d6_packet.c	2017-04-05 18:27:36.000000000 +0200
@@ -127,7 +127,8 @@ int FAST_FUNC d6_send_raw_packet(
 int FAST_FUNC d6_send_kernel_packet(
 		struct d6_packet *d6_pkt, unsigned d6_pkt_size,
 		struct in6_addr *src_ipv6, int source_port,
-		struct in6_addr *dst_ipv6, int dest_port)
+		struct in6_addr *dst_ipv6, int dest_port,
+		int ifindex)
 {
 	struct sockaddr_in6 sa;
 	int fd;
@@ -154,6 +155,7 @@ int FAST_FUNC d6_send_kernel_packet(
 	sa.sin6_family = AF_INET6;
 	sa.sin6_port = htons(dest_port);
 	sa.sin6_addr = *dst_ipv6; /* struct copy */
+	sa.sin6_scope_id = ifindex;
 	if (connect(fd, (struct sockaddr *)&sa, sizeof(sa)) == -1) {
 		msg = "connect";
 		goto ret_close;
diff -urpN busybox-1.26.2/networking/udhcp/d6_socket.c busybox-1.27.0/networking/udhcp/d6_socket.c
--- busybox-1.26.2/networking/udhcp/d6_socket.c	2016-09-27 18:53:50.000000000 +0200
+++ busybox-1.27.0/networking/udhcp/d6_socket.c	2017-04-05 18:27:36.000000000 +0200
@@ -7,6 +7,67 @@
 #include "common.h"
 #include "d6_common.h"
 #include <net/if.h>
+#include <ifaddrs.h>
+#include <netpacket/packet.h>
+
+int FAST_FUNC d6_read_interface(const char *interface, int *ifindex, struct in6_addr *nip6, uint8_t *mac)
+{
+	int retval = 3;
+	struct ifaddrs *ifap, *ifa;
+
+	getifaddrs(&ifap);
+
+	for (ifa = ifap; ifa; ifa = ifa->ifa_next) {
+		struct sockaddr_in6 *sip6;
+
+		if (!ifa->ifa_addr || (strcmp(ifa->ifa_name, interface) != 0))
+			continue;
+
+		sip6 = (struct sockaddr_in6*)(ifa->ifa_addr);
+
+		if (ifa->ifa_addr->sa_family == AF_PACKET) {
+			struct sockaddr_ll *sll = (struct sockaddr_ll*)(ifa->ifa_addr);
+			memcpy(mac, sll->sll_addr, 6);
+			log1("MAC %02x:%02x:%02x:%02x:%02x:%02x", mac[0], mac[1], mac[2], mac[3], mac[4], mac[5]);
+			log1("adapter index %d", sll->sll_ifindex);
+			*ifindex = sll->sll_ifindex;
+			retval &= (0xf - (1<<0));
+		}
+#if 0
+		if (ifa->ifa_addr->sa_family == AF_INET) {
+			*nip = ((struct sockaddr_in *)ifa->ifa_addr)->sin_addr.s_addr;
+			log1("IP %s", inet_ntoa(((struct sockaddr_in *)ifa->ifa_addr)->sin_addr));
+		}
+#endif
+		if (ifa->ifa_addr->sa_family == AF_INET6
+		 && IN6_IS_ADDR_LINKLOCAL(&sip6->sin6_addr)
+		) {
+			*nip6 = sip6->sin6_addr; /* struct copy */
+			log1(
+				"IPv6 %02x%02x:%02x%02x:%02x%02x:%02x%02x:%02x%02x:%02x%02x:%02x%02x:%02x%02x",
+				nip6->s6_addr[0], nip6->s6_addr[1],
+				nip6->s6_addr[2], nip6->s6_addr[3],
+				nip6->s6_addr[4], nip6->s6_addr[5],
+				nip6->s6_addr[6], nip6->s6_addr[7],
+				nip6->s6_addr[8], nip6->s6_addr[9],
+				nip6->s6_addr[10], nip6->s6_addr[11],
+				nip6->s6_addr[12], nip6->s6_addr[13],
+				nip6->s6_addr[14], nip6->s6_addr[15]
+			);
+			retval &= (0xf - (1<<1));
+		}
+	}
+
+	freeifaddrs(ifap);
+	if (retval == 0)
+		return retval;
+
+	if (retval & (1<<0))
+		bb_error_msg("can't get %s", "MAC");
+	if (retval & (1<<1))
+		bb_error_msg("can't get %s", "link-local IPv6 address");
+	return -1;
+}
 
 int FAST_FUNC d6_listen_socket(int port, const char *inf)
 {
diff -urpN busybox-1.26.2/networking/udhcp/dhcpc.c busybox-1.27.0/networking/udhcp/dhcpc.c
--- busybox-1.26.2/networking/udhcp/dhcpc.c	2016-12-10 18:46:36.000000000 +0100
+++ busybox-1.27.0/networking/udhcp/dhcpc.c	2017-07-01 22:51:12.000000000 +0200
@@ -73,7 +73,9 @@ static const char udhcpc_longopts[] ALIG
 	"request-option\0" Required_argument "O"
 	"no-default-options\0" No_argument   "o"
 	"foreground\0"     No_argument       "f"
+	USE_FOR_MMU(
 	"background\0"     No_argument       "b"
+	)
 	"broadcast\0"      No_argument       "B"
 	IF_FEATURE_UDHCPC_ARPING("arping\0"	Optional_argument "a")
 	IF_FEATURE_UDHCP_PORT("client-port\0"	Required_argument "P")
@@ -1281,9 +1283,7 @@ int udhcpc_main(int argc UNUSED_PARAM, c
 	unsigned already_waited_sec;
 	unsigned opt;
 	IF_FEATURE_UDHCPC_ARPING(unsigned arpping_ms;)
-	int max_fd;
 	int retval;
-	fd_set rfds;
 
 	setup_common_bufsiz();
 
@@ -1346,7 +1346,7 @@ int udhcpc_main(int argc UNUSED_PARAM, c
 		char *optstr = llist_pop(&list_O);
 		unsigned n = bb_strtou(optstr, NULL, 0);
 		if (errno || n > 254) {
-			n = udhcp_option_idx(optstr);
+			n = udhcp_option_idx(optstr, dhcp_option_strings);
 			n = dhcp_optflags[n].code;
 		}
 		client_config.opt_mask[n >> 3] |= 1 << (n & 7);
@@ -1366,7 +1366,9 @@ int udhcpc_main(int argc UNUSED_PARAM, c
 			*colon = ' ';
 		/* now it looks similar to udhcpd's config file line:
 		 * "optname optval", using the common routine: */
-		udhcp_str2optset(optstr, &client_config.options);
+		udhcp_str2optset(optstr, &client_config.options, dhcp_optflags, dhcp_option_strings);
+		if (colon)
+			*colon = ':'; /* restore it for NOMMU reexec */
 	}
 
 	if (udhcp_read_interface(client_config.interface,
@@ -1432,7 +1434,8 @@ int udhcpc_main(int argc UNUSED_PARAM, c
 	 * "continue" statements in code below jump to the top of the loop.
 	 */
 	for (;;) {
-		struct timeval tv;
+		int tv;
+		struct pollfd pfds[2];
 		struct dhcp_packet packet;
 		/* silence "uninitialized!" warning */
 		unsigned timestamp_before_wait = timestamp_before_wait;
@@ -1446,23 +1449,22 @@ int udhcpc_main(int argc UNUSED_PARAM, c
 		 * to change_listen_mode(). Thus we open listen socket
 		 * BEFORE we send renew request (see "case BOUND:"). */
 
-		max_fd = udhcp_sp_fd_set(&rfds, sockfd);
+		udhcp_sp_fd_set(pfds, sockfd);
 
-		tv.tv_sec = timeout - already_waited_sec;
-		tv.tv_usec = 0;
+		tv = timeout - already_waited_sec;
 		retval = 0;
 		/* If we already timed out, fall through with retval = 0, else... */
-		if ((int)tv.tv_sec > 0) {
-			log1("waiting on select %u seconds", (int)tv.tv_sec);
+		if (tv > 0) {
+			log1("waiting on select %u seconds", tv);
 			timestamp_before_wait = (unsigned)monotonic_sec();
-			retval = select(max_fd + 1, &rfds, NULL, NULL, &tv);
+			retval = poll(pfds, 2, tv < INT_MAX/1000 ? tv * 1000 : INT_MAX);
 			if (retval < 0) {
 				/* EINTR? A signal was caught, don't panic */
 				if (errno == EINTR) {
 					already_waited_sec += (unsigned)monotonic_sec() - timestamp_before_wait;
 					continue;
 				}
-				/* Else: an error occured, panic! */
+				/* Else: an error occurred, panic! */
 				bb_perror_msg_and_die("select");
 			}
 		}
@@ -1591,8 +1593,8 @@ int udhcpc_main(int argc UNUSED_PARAM, c
 		/* select() didn't timeout, something happened */
 
 		/* Is it a signal? */
-		/* note: udhcp_sp_read checks FD_ISSET before reading */
-		switch (udhcp_sp_read(&rfds)) {
+		/* note: udhcp_sp_read checks poll result before reading */
+		switch (udhcp_sp_read(pfds)) {
 		case SIGUSR1:
 			client_config.first_secs = 0; /* make secs field count from 0 */
 			already_waited_sec = 0;
@@ -1627,7 +1629,7 @@ int udhcpc_main(int argc UNUSED_PARAM, c
 		}
 
 		/* Is it a packet? */
-		if (listen_mode == LISTEN_NONE || !FD_ISSET(sockfd, &rfds))
+		if (listen_mode == LISTEN_NONE || !pfds[1].revents)
 			continue; /* no */
 
 		{
@@ -1742,8 +1744,8 @@ int udhcpc_main(int argc UNUSED_PARAM, c
 					/* paranoia: must not be too small and not prone to overflows */
 					if (lease_seconds < 0x10)
 						lease_seconds = 0x10;
-					if (lease_seconds >= 0x10000000)
-						lease_seconds = 0x0fffffff;
+					if (lease_seconds > 0x7fffffff / 1000)
+						lease_seconds = 0x7fffffff / 1000;
 				}
 #if ENABLE_FEATURE_UDHCPC_ARPING
 				if (opt & OPT_a) {
diff -urpN busybox-1.26.2/networking/udhcp/dhcpc.h busybox-1.27.0/networking/udhcp/dhcpc.h
--- busybox-1.26.2/networking/udhcp/dhcpc.h	2016-09-27 18:53:50.000000000 +0200
+++ busybox-1.27.0/networking/udhcp/dhcpc.h	2017-07-01 22:51:12.000000000 +0200
@@ -12,6 +12,7 @@ struct client_config_t {
 	IF_FEATURE_UDHCP_PORT(uint16_t port;)
 	int ifindex;                    /* Index number of the interface to use */
 	uint8_t opt_mask[256 / 8];      /* Bitmask of options to send (-O option) */
+// ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ TODO: DHCPv6 has 16-bit option numbers
 	const char *interface;          /* The name of the interface to use */
 	char *pidfile;                  /* Optionally store the process ID */
 	const char *script;             /* User script to run at dhcp events */
diff -urpN busybox-1.26.2/networking/udhcp/dhcpd.c busybox-1.27.0/networking/udhcp/dhcpd.c
--- busybox-1.26.2/networking/udhcp/dhcpd.c	2016-12-10 18:46:36.000000000 +0100
+++ busybox-1.27.0/networking/udhcp/dhcpd.c	2017-07-01 22:51:12.000000000 +0200
@@ -361,6 +361,10 @@ static int FAST_FUNC read_staticlease(co
 	return 1;
 }
 
+static int FAST_FUNC read_optset(const char *line, void *arg) {
+	return udhcp_str2optset(line, arg, dhcp_optflags, dhcp_option_strings);
+}
+
 struct config_keyword {
 	const char *keyword;
 	int (*handler)(const char *line, void *var) FAST_FUNC;
@@ -387,8 +391,8 @@ static const struct config_keyword keywo
 	{"pidfile"      , read_str        , OFS(pidfile      ), "/var/run/udhcpd.pid"},
 	{"siaddr"       , udhcp_str2nip   , OFS(siaddr_nip   ), "0.0.0.0"},
 	/* keywords with no defaults must be last! */
-	{"option"       , udhcp_str2optset, OFS(options      ), ""},
-	{"opt"          , udhcp_str2optset, OFS(options      ), ""},
+	{"option"       , read_optset     , OFS(options      ), ""},
+	{"opt"          , read_optset     , OFS(options      ), ""},
 	{"notify_file"  , read_str        , OFS(notify_file  ), NULL},
 	{"sname"        , read_str        , OFS(sname        ), NULL},
 	{"boot_file"    , read_str        , OFS(boot_file    ), NULL},
@@ -794,7 +798,7 @@ static NOINLINE void send_inform(struct
 int udhcpd_main(int argc, char **argv) MAIN_EXTERNALLY_VISIBLE;
 int udhcpd_main(int argc UNUSED_PARAM, char **argv)
 {
-	int server_socket = -1, retval, max_sock;
+	int server_socket = -1, retval;
 	uint8_t *state;
 	unsigned timeout_end;
 	unsigned num_ips;
@@ -891,10 +895,10 @@ int udhcpd_main(int argc UNUSED_PARAM, c
  continue_with_autotime:
 	timeout_end = monotonic_sec() + server_config.auto_time;
 	while (1) { /* loop until universe collapses */
-		fd_set rfds;
+		struct pollfd pfds[2];
 		struct dhcp_packet packet;
 		int bytes;
-		struct timeval tv;
+		int tv;
 		uint8_t *server_id_opt;
 		uint8_t *requested_ip_opt;
 		uint32_t requested_nip = requested_nip; /* for compiler */
@@ -906,16 +910,11 @@ int udhcpd_main(int argc UNUSED_PARAM, c
 					server_config.interface);
 		}
 
-		max_sock = udhcp_sp_fd_set(&rfds, server_socket);
-		if (server_config.auto_time) {
-			/* cast to signed is essential if tv_sec is wider than int */
-			tv.tv_sec = (int)(timeout_end - monotonic_sec());
-			tv.tv_usec = 0;
-		}
+		udhcp_sp_fd_set(pfds, server_socket);
+		tv = timeout_end - monotonic_sec();
 		retval = 0;
-		if (!server_config.auto_time || tv.tv_sec > 0) {
-			retval = select(max_sock + 1, &rfds, NULL, NULL,
-					server_config.auto_time ? &tv : NULL);
+		if (!server_config.auto_time || tv > 0) {
+			retval = poll(pfds, 2, server_config.auto_time ? tv * 1000 : -1);
 		}
 		if (retval == 0) {
 			write_leases();
@@ -926,7 +925,7 @@ int udhcpd_main(int argc UNUSED_PARAM, c
 			continue;
 		}
 
-		switch (udhcp_sp_read(&rfds)) {
+		switch (udhcp_sp_read(pfds)) {
 		case SIGUSR1:
 			bb_error_msg("received %s", "SIGUSR1");
 			write_leases();
diff -urpN busybox-1.26.2/networking/udhcp/dhcprelay.c busybox-1.27.0/networking/udhcp/dhcprelay.c
--- busybox-1.26.2/networking/udhcp/dhcprelay.c	2016-12-10 18:46:36.000000000 +0100
+++ busybox-1.27.0/networking/udhcp/dhcprelay.c	2017-07-01 22:51:12.000000000 +0200
@@ -361,7 +361,7 @@ int dhcprelay_main(int argc, char **argv
 //   which the reply must be sent (i.e., the host or router interface
 //   connected to the same network as the BOOTP client).  If the content
 //   of the 'giaddr' field does not match one of the relay agent's
-//   directly-connected logical interfaces, the BOOTREPLY messsage MUST be
+//   directly-connected logical interfaces, the BOOTREPLY message MUST be
 //   silently discarded.
 				if (udhcp_read_interface(iface_list[i], NULL, &dhcp_msg.gateway_nip, NULL)) {
 					/* Fall back to our IP on server iface */
diff -urpN busybox-1.26.2/networking/udhcp/dumpleases.c busybox-1.27.0/networking/udhcp/dumpleases.c
--- busybox-1.26.2/networking/udhcp/dumpleases.c	2016-12-10 18:46:36.000000000 +0100
+++ busybox-1.27.0/networking/udhcp/dumpleases.c	2017-01-23 01:09:41.000000000 +0100
@@ -11,7 +11,7 @@
 //usage:#define dumpleases_full_usage "\n\n"
 //usage:       "Display DHCP leases granted by udhcpd\n"
 //usage:	IF_LONG_OPTS(
-//usage:     "\n	-f,--file=FILE	Lease file"
+//usage:     "\n	-f,--file FILE	Lease file"
 //usage:     "\n	-r,--remaining	Show remaining time"
 //usage:     "\n	-a,--absolute	Show expiration time"
 //usage:     "\n	-d,--decimal	Show time in seconds"
diff -urpN busybox-1.26.2/networking/udhcp/packet.c busybox-1.27.0/networking/udhcp/packet.c
--- busybox-1.26.2/networking/udhcp/packet.c	2016-09-27 18:53:50.000000000 +0200
+++ busybox-1.27.0/networking/udhcp/packet.c	2017-07-02 21:32:47.000000000 +0200
@@ -12,6 +12,7 @@
 #include <netinet/if_ether.h>
 #include <netpacket/packet.h>
 
+#if ENABLE_UDHCPC || ENABLE_UDHCPD
 void FAST_FUNC udhcp_init_header(struct dhcp_packet *packet, char type)
 {
 	memset(packet, 0, sizeof(*packet));
@@ -29,6 +30,7 @@ void FAST_FUNC udhcp_init_header(struct
 		packet->options[0] = DHCP_END;
 	udhcp_add_simple_option(packet, DHCP_MESSAGE_TYPE, type);
 }
+#endif
 
 #if defined CONFIG_UDHCP_DEBUG && CONFIG_UDHCP_DEBUG >= 2
 void FAST_FUNC udhcp_dump_packet(struct dhcp_packet *packet)
diff -urpN busybox-1.26.2/networking/udhcp/signalpipe.c busybox-1.27.0/networking/udhcp/signalpipe.c
--- busybox-1.26.2/networking/udhcp/signalpipe.c	2016-09-27 18:53:50.000000000 +0200
+++ busybox-1.27.0/networking/udhcp/signalpipe.c	2017-04-05 18:27:36.000000000 +0200
@@ -25,9 +25,11 @@ static struct fd_pair signal_pipe;
 
 static void signal_handler(int sig)
 {
+	int sv = errno;
 	unsigned char ch = sig; /* use char, avoid dealing with partial writes */
 	if (write(signal_pipe.wr, &ch, 1) != 1)
 		bb_perror_msg("can't send signal");
+	errno = sv;
 }
 
 /* Call this before doing anything else. Sets up the socket pair
@@ -46,28 +48,29 @@ void FAST_FUNC udhcp_sp_setup(void)
 		, signal_handler);
 }
 
-/* Quick little function to setup the rfds. Will return the
- * max_fd for use with select. Limited in that you can only pass
- * one extra fd */
-int FAST_FUNC udhcp_sp_fd_set(fd_set *rfds, int extra_fd)
+/* Quick little function to setup the pfds.
+ * Limited in that you can only pass one extra fd.
+ */
+void FAST_FUNC udhcp_sp_fd_set(struct pollfd pfds[2], int extra_fd)
 {
-	FD_ZERO(rfds);
-	FD_SET(signal_pipe.rd, rfds);
+	pfds[0].fd = signal_pipe.rd;
+	pfds[0].events = POLLIN;
+	pfds[1].fd = -1;
 	if (extra_fd >= 0) {
 		close_on_exec_on(extra_fd);
-		FD_SET(extra_fd, rfds);
+		pfds[1].fd = extra_fd;
+		pfds[1].events = POLLIN;
 	}
-	return signal_pipe.rd > extra_fd ? signal_pipe.rd : extra_fd;
 }
 
 /* Read a signal from the signal pipe. Returns 0 if there is
  * no signal, -1 on error (and sets errno appropriately), and
  * your signal on success */
-int FAST_FUNC udhcp_sp_read(const fd_set *rfds)
+int FAST_FUNC udhcp_sp_read(struct pollfd pfds[2])
 {
 	unsigned char sig;
 
-	if (!FD_ISSET(signal_pipe.rd, rfds))
+	if (!pfds[0].revents)
 		return 0;
 
 	if (safe_read(signal_pipe.rd, &sig, 1) != 1)
diff -urpN busybox-1.26.2/networking/vconfig.c busybox-1.27.0/networking/vconfig.c
--- busybox-1.26.2/networking/vconfig.c	2016-12-10 18:46:36.000000000 +0100
+++ busybox-1.27.0/networking/vconfig.c	2017-07-01 22:51:12.000000000 +0200
@@ -138,7 +138,7 @@ int vconfig_main(int argc, char **argv)
 		/* I suppose one could try to combine some of the function calls below,
 		 * since ifr.u.flag, ifr.u.VID, and ifr.u.skb_priority are all same-sized
 		 * (unsigned) int members of a unions.  But because of the range checking,
-		 * doing so wouldn't save that much space and would also make maintainence
+		 * doing so wouldn't save that much space and would also make maintenance
 		 * more of a pain.
 		 */
 		if (ifr.cmd == SET_VLAN_FLAG_CMD) {
diff -urpN busybox-1.26.2/networking/wget.c busybox-1.27.0/networking/wget.c
--- busybox-1.26.2/networking/wget.c	2016-10-07 16:47:12.000000000 +0200
+++ busybox-1.27.0/networking/wget.c	2017-01-30 21:57:30.000000000 +0100
@@ -16,12 +16,15 @@
 //config:	  wget is a utility for non-interactive download of files from HTTP
 //config:	  and FTP servers.
 //config:
+//config:config FEATURE_WGET_LONG_OPTIONS
+//config:	bool "Enable long options"
+//config:	default y
+//config:	depends on WGET && LONG_OPTS
+//config:
 //config:config FEATURE_WGET_STATUSBAR
-//config:	bool "Enable a nifty process meter (+2k)"
+//config:	bool "Enable progress bar (+2k)"
 //config:	default y
 //config:	depends on WGET
-//config:	help
-//config:	  Enable the transfer progress bar for wget transfers.
 //config:
 //config:config FEATURE_WGET_AUTHENTICATION
 //config:	bool "Enable HTTP authentication"
@@ -30,13 +33,6 @@
 //config:	help
 //config:	  Support authenticated HTTP transfers.
 //config:
-//config:config FEATURE_WGET_LONG_OPTIONS
-//config:	bool "Enable long options"
-//config:	default y
-//config:	depends on WGET && LONG_OPTS
-//config:	help
-//config:	  Support long options for the wget applet.
-//config:
 //config:config FEATURE_WGET_TIMEOUT
 //config:	bool "Enable timeout option -T SEC"
 //config:	default y
@@ -51,18 +47,59 @@
 //config:	  FEATURE_WGET_LONG_OPTIONS is also enabled, the --timeout option
 //config:	  will work in addition to -T.
 //config:
+//config:config FEATURE_WGET_HTTPS
+//config:	bool "Support HTTPS using internal TLS code"
+//config:	default y
+//config:	depends on WGET
+//config:	select TLS
+//config:	help
+//config:	  wget will use internal TLS code to connect to https:// URLs.
+//config:	  Note:
+//config:	  On NOMMU machines, ssl_helper applet should be available
+//config:	  in the $PATH for this to work. Make sure to select that applet.
+//config:
+//config:	  Note: currently, TLS code only makes TLS I/O work, it
+//config:	  does *not* check that the peer is who it claims to be, etc.
+//config:	  IOW: it uses peer-supplied public keys to establish encryption
+//config:	  and signing keys, then encrypts and signs outgoing data and
+//config:	  decrypts incoming data.
+//config:	  It does not check signature hashes on the incoming data:
+//config:	  this means that attackers manipulating TCP packets can
+//config:	  send altered data and we unknowingly receive garbage.
+//config:	  (This check might be relatively easy to add).
+//config:	  It does not check public key's certificate:
+//config:	  this means that the peer may be an attacker impersonating
+//config:	  the server we think we are talking to.
+//config:
+//config:	  If you think this is unacceptable, consider this. As more and more
+//config:	  servers switch to HTTPS-only operation, without such "crippled"
+//config:	  TLS code it is *impossible* to simply download a kernel source
+//config:	  from kernel.org. Which can in real world translate into
+//config:	  "my small automatic tooling to build cross-compilers from sources
+//config:	  no longer works, I need to additionally keep a local copy
+//config:	  of ~4 megabyte source tarball of a SSL library and ~2 megabyte
+//config:	  source of wget, need to compile and built both before I can
+//config:	  download anything. All this despite the fact that the build
+//config:	  is done in a QEMU sandbox on a machine with absolutely nothing
+//config:	  worth stealing, so I don't care if someone would go to a lot
+//config:	  of trouble to intercept my HTTPS download to send me an altered
+//config:	  kernel tarball".
+//config:
+//config:	  If you still think this is unacceptable, send patches.
+//config:
+//config:	  If you still think this is unacceptable, do not want to send
+//config:	  patches, but do want to waste bandwidth expaining how wrong
+//config:	  it is, you will be ignored.
+//config:
 //config:config FEATURE_WGET_OPENSSL
 //config:	bool "Try to connect to HTTPS using openssl"
 //config:	default y
 //config:	depends on WGET
 //config:	help
-//config:	  Choose how wget establishes SSL connection for https:// URLs.
-//config:
-//config:	  Busybox itself contains no SSL code. wget will spawn
-//config:	  a helper program to talk over HTTPS.
+//config:	  Try to use openssl to handle HTTPS.
 //config:
 //config:	  OpenSSL has a simple SSL client for debug purposes.
-//config:	  If you select "openssl" helper, wget will effectively run:
+//config:	  If you select this option, wget will effectively run:
 //config:	  "openssl s_client -quiet -connect hostname:443
 //config:	  -servername hostname 2>/dev/null" and pipe its data
 //config:	  through it. -servername is not used if hostname is numeric.
@@ -75,24 +112,9 @@
 //config:	  openssl is also a big binary, often dynamically linked
 //config:	  against ~15 libraries.
 //config:
-//config:config FEATURE_WGET_SSL_HELPER
-//config:	bool "Try to connect to HTTPS using ssl_helper"
-//config:	default y
-//config:	depends on WGET
-//config:	help
-//config:	  Choose how wget establishes SSL connection for https:// URLs.
-//config:
-//config:	  Busybox itself contains no SSL code. wget will spawn
-//config:	  a helper program to talk over HTTPS.
-//config:
-//config:	  ssl_helper is a tool which can be built statically
-//config:	  from busybox sources against a small embedded SSL library.
-//config:	  Please see networking/ssl_helper/README.
-//config:	  It does not require double host resolution and emits
-//config:	  error messages to stderr.
-//config:
-//config:	  Precompiled static binary may be available at
-//config:	  http://busybox.net/downloads/binaries/
+//config:	  If openssl can't be executed, internal TLS code will be used
+//config:	  (if you enabled it); if openssl can be executed but fails later,
+//config:	  wget can't detect this, and download will fail.
 
 //applet:IF_WGET(APPLET(wget, BB_DIR_USR_BIN, BB_SUID_DROP))
 
@@ -105,20 +127,21 @@
 /* Since we ignore these opts, we don't show them in --help */
 /* //usage:    "	[--no-check-certificate] [--no-cache] [--passive-ftp] [-t TRIES]" */
 /* //usage:    "	[-nv] [-nc] [-nH] [-np]" */
-//usage:       "	[-U|--user-agent AGENT]" IF_FEATURE_WGET_TIMEOUT(" [-T SEC]") " URL..."
+//usage:       "	[-S|--server-response] [-U|--user-agent AGENT]" IF_FEATURE_WGET_TIMEOUT(" [-T SEC]") " URL..."
 //usage:	)
 //usage:	IF_NOT_FEATURE_WGET_LONG_OPTIONS(
-//usage:       "[-cq] [-O FILE] [-Y on/off] [-P DIR] [-U AGENT]"
+//usage:       "[-cq] [-O FILE] [-Y on/off] [-P DIR] [-S] [-U AGENT]"
 //usage:			IF_FEATURE_WGET_TIMEOUT(" [-T SEC]") " URL..."
 //usage:	)
 //usage:#define wget_full_usage "\n\n"
 //usage:       "Retrieve files via HTTP or FTP\n"
 //usage:	IF_FEATURE_WGET_LONG_OPTIONS(
-//usage:     "\n	--spider	Spider mode - only check file existence"
+//usage:     "\n	--spider	Only check URL existence: $? is 0 if exists"
 //usage:	)
 //usage:     "\n	-c		Continue retrieval of aborted transfer"
 //usage:     "\n	-q		Quiet"
 //usage:     "\n	-P DIR		Save to DIR (default .)"
+//usage:     "\n	-S    		Show server response"
 //usage:	IF_FEATURE_WGET_TIMEOUT(
 //usage:     "\n	-T SEC		Network read timeout is SEC seconds"
 //usage:	)
@@ -141,6 +164,8 @@
 #endif
 
 
+#define SSL_SUPPORTED (ENABLE_FEATURE_WGET_OPENSSL || ENABLE_FEATURE_WGET_HTTPS)
+
 struct host_info {
 	char *allocated;
 	const char *path;
@@ -151,7 +176,7 @@ struct host_info {
 };
 static const char P_FTP[] ALIGN1 = "ftp";
 static const char P_HTTP[] ALIGN1 = "http";
-#if ENABLE_FEATURE_WGET_OPENSSL || ENABLE_FEATURE_WGET_SSL_HELPER
+#if SSL_SUPPORTED
 static const char P_HTTPS[] ALIGN1 = "https";
 #endif
 
@@ -232,16 +257,17 @@ struct globals {
 enum {
 	WGET_OPT_CONTINUE   = (1 << 0),
 	WGET_OPT_QUIET      = (1 << 1),
-	WGET_OPT_OUTNAME    = (1 << 2),
-	WGET_OPT_PREFIX     = (1 << 3),
-	WGET_OPT_PROXY      = (1 << 4),
-	WGET_OPT_USER_AGENT = (1 << 5),
-	WGET_OPT_NETWORK_READ_TIMEOUT = (1 << 6),
-	WGET_OPT_RETRIES    = (1 << 7),
-	WGET_OPT_nsomething = (1 << 8),
-	WGET_OPT_HEADER     = (1 << 9) * ENABLE_FEATURE_WGET_LONG_OPTIONS,
-	WGET_OPT_POST_DATA  = (1 << 10) * ENABLE_FEATURE_WGET_LONG_OPTIONS,
-	WGET_OPT_SPIDER     = (1 << 11) * ENABLE_FEATURE_WGET_LONG_OPTIONS,
+	WGET_OPT_SERVER_RESPONSE = (1 << 2),
+	WGET_OPT_OUTNAME    = (1 << 3),
+	WGET_OPT_PREFIX     = (1 << 4),
+	WGET_OPT_PROXY      = (1 << 5),
+	WGET_OPT_USER_AGENT = (1 << 6),
+	WGET_OPT_NETWORK_READ_TIMEOUT = (1 << 7),
+	WGET_OPT_RETRIES    = (1 << 8),
+	WGET_OPT_nsomething = (1 << 9),
+	WGET_OPT_HEADER     = (1 << 10) * ENABLE_FEATURE_WGET_LONG_OPTIONS,
+	WGET_OPT_POST_DATA  = (1 << 11) * ENABLE_FEATURE_WGET_LONG_OPTIONS,
+	WGET_OPT_SPIDER     = (1 << 12) * ENABLE_FEATURE_WGET_LONG_OPTIONS,
 };
 
 enum {
@@ -395,7 +421,7 @@ static FILE *open_socket(len_and_sockadd
 }
 
 /* Returns '\n' if it was seen, else '\0'. Trims at first '\r' or '\n' */
-static char fgets_and_trim(FILE *fp)
+static char fgets_and_trim(FILE *fp, const char *fmt)
 {
 	char c;
 	char *buf_ptr;
@@ -413,6 +439,9 @@ static char fgets_and_trim(FILE *fp)
 
 	log_io("< %s", G.wget_buf);
 
+	if (fmt && (option_mask32 & WGET_OPT_SERVER_RESPONSE))
+		fprintf(stderr, fmt, G.wget_buf);
+
 	return c;
 }
 
@@ -423,12 +452,15 @@ static int ftpcmd(const char *s1, const
 		if (!s2)
 			s2 = "";
 		fprintf(fp, "%s%s\r\n", s1, s2);
+		/* With --server-response, wget also shows its ftp commands */
+		if (option_mask32 & WGET_OPT_SERVER_RESPONSE)
+			fprintf(stderr, "--> %s%s\n\n", s1, s2);
 		fflush(fp);
 		log_io("> %s%s", s1, s2);
 	}
 
 	do {
-		fgets_and_trim(fp);
+		fgets_and_trim(fp, "%s\n");
 	} while (!isdigit(G.wget_buf[0]) || G.wget_buf[3] != ' ');
 
 	G.wget_buf[3] = '\0';
@@ -452,7 +484,7 @@ static void parse_url(const char *src_ur
 		if (strcmp(url, P_FTP) == 0) {
 			h->port = bb_lookup_port(P_FTP, "tcp", 21);
 		} else
-#if ENABLE_FEATURE_WGET_OPENSSL || ENABLE_FEATURE_WGET_SSL_HELPER
+#if SSL_SUPPORTED
 		if (strcmp(url, P_HTTPS) == 0) {
 			h->port = bb_lookup_port(P_HTTPS, "tcp", 443);
 			h->protocol = P_HTTPS;
@@ -474,7 +506,7 @@ static void parse_url(const char *src_ur
 
 	// FYI:
 	// "Real" wget 'http://busybox.net?var=a/b' sends this request:
-	//   'GET /?var=a/b HTTP 1.0'
+	//   'GET /?var=a/b HTTP/1.0'
 	//   and saves 'index.html?var=a%2Fb' (we save 'b')
 	// wget 'http://busybox.net?login=john@doe':
 	//   request: 'GET /?login=john@doe HTTP/1.0'
@@ -525,7 +557,7 @@ static char *gethdr(FILE *fp)
 	int c;
 
 	/* retrieve header line */
-	c = fgets_and_trim(fp);
+	c = fgets_and_trim(fp, "  %s\n");
 
 	/* end of the headers? */
 	if (G.wget_buf[0] == '\0')
@@ -659,7 +691,7 @@ static int spawn_https_helper_openssl(co
 	char *servername;
 	int sp[2];
 	int pid;
-	IF_FEATURE_WGET_SSL_HELPER(volatile int child_failed = 0;)
+	IF_FEATURE_WGET_HTTPS(volatile int child_failed = 0;)
 
 	if (socketpair(AF_UNIX, SOCK_STREAM, 0, sp) != 0)
 		/* Kernel can have AF_UNIX support disabled */
@@ -704,7 +736,7 @@ static int spawn_https_helper_openssl(co
 
 		BB_EXECVP(argv[0], argv);
 		xmove_fd(3, 2);
-# if ENABLE_FEATURE_WGET_SSL_HELPER
+# if ENABLE_FEATURE_WGET_HTTPS
 		child_failed = 1;
 		xfunc_die();
 # else
@@ -717,7 +749,7 @@ static int spawn_https_helper_openssl(co
 	free(servername);
 	free(allocated);
 	close(sp[1]);
-# if ENABLE_FEATURE_WGET_SSL_HELPER
+# if ENABLE_FEATURE_WGET_HTTPS
 	if (child_failed) {
 		close(sp[0]);
 		return -1;
@@ -727,38 +759,51 @@ static int spawn_https_helper_openssl(co
 }
 #endif
 
-/* See networking/ssl_helper/README how to build one */
-#if ENABLE_FEATURE_WGET_SSL_HELPER
-static void spawn_https_helper_small(int network_fd)
+#if ENABLE_FEATURE_WGET_HTTPS
+static void spawn_ssl_client(const char *host, int network_fd)
 {
 	int sp[2];
 	int pid;
+	char *servername, *p;
+
+	servername = xstrdup(host);
+	p = strrchr(servername, ':');
+	if (p) *p = '\0';
 
 	if (socketpair(AF_UNIX, SOCK_STREAM, 0, sp) != 0)
 		/* Kernel can have AF_UNIX support disabled */
 		bb_perror_msg_and_die("socketpair");
 
+	fflush_all();
 	pid = BB_MMU ? xfork() : xvfork();
 	if (pid == 0) {
 		/* Child */
-		char *argv[3];
-
 		close(sp[0]);
 		xmove_fd(sp[1], 0);
 		xdup2(0, 1);
-		xmove_fd(network_fd, 3);
-		/*
-		 * A simple ssl/tls helper
-		 */
-		argv[0] = (char*)"ssl_helper";
-		argv[1] = (char*)"-d3";
-		argv[2] = NULL;
-		BB_EXECVP(argv[0], argv);
-		bb_perror_msg_and_die("can't execute '%s'", argv[0]);
+		if (BB_MMU) {
+			tls_state_t *tls = new_tls_state();
+			tls->ifd = tls->ofd = network_fd;
+			tls_handshake(tls, servername);
+			tls_run_copy_loop(tls);
+			exit(0);
+		} else {
+			char *argv[5];
+			xmove_fd(network_fd, 3);
+			argv[0] = (char*)"ssl_client";
+			argv[1] = (char*)"-s3";
+			//TODO: if (!is_ip_address(servername))...
+			argv[2] = (char*)"-n";
+			argv[3] = servername;
+			argv[4] = NULL;
+			BB_EXECVP(argv[0], argv);
+			bb_perror_msg_and_die("can't execute '%s'", argv[0]);
+		}
 		/* notreached */
 	}
 
 	/* Parent */
+	free(servername);
 	close(sp[1]);
 	xmove_fd(sp[0], network_fd);
 }
@@ -880,9 +925,9 @@ static void NOINLINE retrieve_file_data(
 		if (!G.chunked)
 			break;
 
-		fgets_and_trim(dfp); /* Eat empty line */
+		fgets_and_trim(dfp, NULL); /* Eat empty line */
  get_clen:
-		fgets_and_trim(dfp);
+		fgets_and_trim(dfp, NULL);
 		G.content_len = STRTOOFF(G.wget_buf, NULL, 16);
 		/* FIXME: error check? */
 		if (G.content_len == 0)
@@ -1007,16 +1052,16 @@ static void download_one_url(const char
 
 		/* Open socket to http(s) server */
 #if ENABLE_FEATURE_WGET_OPENSSL
-		/* openssl (and maybe ssl_helper) support is configured */
+		/* openssl (and maybe internal TLS) support is configured */
 		if (target.protocol == P_HTTPS) {
 			/* openssl-based helper
 			 * Inconvenient API since we can't give it an open fd
 			 */
 			int fd = spawn_https_helper_openssl(server.host, server.port);
-# if ENABLE_FEATURE_WGET_SSL_HELPER
-			if (fd < 0) { /* no openssl? try ssl_helper */
+# if ENABLE_FEATURE_WGET_HTTPS
+			if (fd < 0) { /* no openssl? try internal */
 				sfp = open_socket(lsa);
-				spawn_https_helper_small(fileno(sfp));
+				spawn_ssl_client(server.host, fileno(sfp));
 				goto socket_opened;
 			}
 # else
@@ -1029,11 +1074,11 @@ static void download_one_url(const char
 		}
 		sfp = open_socket(lsa);
  socket_opened:
-#elif ENABLE_FEATURE_WGET_SSL_HELPER
-		/* Only ssl_helper support is configured */
+#elif ENABLE_FEATURE_WGET_HTTPS
+		/* Only internal TLS support is configured */
 		sfp = open_socket(lsa);
 		if (target.protocol == P_HTTPS)
-			spawn_https_helper_small(fileno(sfp));
+			spawn_ssl_client(server.host, fileno(sfp));
 #else
 		/* ssl (https) support is not configured */
 		sfp = open_socket(lsa);
@@ -1093,18 +1138,26 @@ static void download_one_url(const char
 		}
 
 		fflush(sfp);
-		/* If we use SSL helper, keeping our end of the socket open for writing
-		 * makes our end (i.e. the same fd!) readable (EAGAIN instead of EOF)
-		 * even after child closes its copy of the fd.
-		 * This helps:
-		 */
-		shutdown(fileno(sfp), SHUT_WR);
+
+/* Tried doing this unconditionally.
+ * Cloudflare and nginx/1.11.5 are shocked to see SHUT_WR on non-HTTPS.
+ */
+#if SSL_SUPPORTED
+		if (target.protocol == P_HTTPS) {
+			/* If we use SSL helper, keeping our end of the socket open for writing
+			 * makes our end (i.e. the same fd!) readable (EAGAIN instead of EOF)
+			 * even after child closes its copy of the fd.
+			 * This helps:
+			 */
+			shutdown(fileno(sfp), SHUT_WR);
+		}
+#endif
 
 		/*
 		 * Retrieve HTTP response line and check for "200" status code.
 		 */
  read_response:
-		fgets_and_trim(sfp);
+		fgets_and_trim(sfp, "  %s\n");
 
 		str = G.wget_buf;
 		str = skip_non_whitespace(str);
@@ -1289,6 +1342,7 @@ int wget_main(int argc UNUSED_PARAM, cha
 		/* name, has_arg, val */
 		"continue\0"         No_argument       "c"
 		"quiet\0"            No_argument       "q"
+		"server-response\0"  No_argument       "S"
 		"output-document\0"  Required_argument "O"
 		"directory-prefix\0" Required_argument "P"
 		"proxy\0"            Required_argument "Y"
@@ -1331,7 +1385,7 @@ IF_DESKTOP(	"no-parent\0"        No_argu
 #endif
 	opt_complementary = "-1" /* at least one URL */
 		IF_FEATURE_WGET_LONG_OPTIONS(":\xff::"); /* --header is a list */
-	getopt32(argv, "cqO:P:Y:U:T:+"
+	getopt32(argv, "cqSO:P:Y:U:T:+"
 		/*ignored:*/ "t:"
 		/*ignored:*/ "n::"
 		/* wget has exactly four -n<letter> opts, all of which we can ignore:
diff -urpN busybox-1.26.2/printutils/lpr.c busybox-1.27.0/printutils/lpr.c
--- busybox-1.26.2/printutils/lpr.c	2016-09-27 18:53:50.000000000 +0200
+++ busybox-1.27.0/printutils/lpr.c	2017-01-30 21:57:30.000000000 +0100
@@ -23,6 +23,7 @@
 //config:	help
 //config:	  lpq is a print spool queue examination and manipulation program.
 
+//              APPLET_ODDNAME:name main  location        suid_type     help
 //applet:IF_LPQ(APPLET_ODDNAME(lpq, lpqr, BB_DIR_USR_BIN, BB_SUID_DROP, lpq))
 //applet:IF_LPR(APPLET_ODDNAME(lpr, lpqr, BB_DIR_USR_BIN, BB_SUID_DROP, lpr))
 
diff -urpN busybox-1.26.2/procps/Config.src busybox-1.27.0/procps/Config.src
--- busybox-1.26.2/procps/Config.src	2016-12-10 18:46:36.000000000 +0100
+++ busybox-1.27.0/procps/Config.src	2017-01-10 16:31:40.000000000 +0100
@@ -8,7 +8,7 @@ menu "Process Utilities"
 INSERT
 
 config FEATURE_SHOW_THREADS
-	bool "Support for showing threads in ps/pstree/top"
+	bool "Support thread display in ps/pstree/top"
 	default y
 	depends on PS || TOP || PSTREE
 	help
diff -urpN busybox-1.26.2/procps/Kbuild.src busybox-1.27.0/procps/Kbuild.src
--- busybox-1.26.2/procps/Kbuild.src	2017-01-01 13:01:05.000000000 +0100
+++ busybox-1.27.0/procps/Kbuild.src	2017-01-10 16:31:40.000000000 +0100
@@ -7,7 +7,3 @@
 lib-y:=
 
 INSERT
-
-lib-$(CONFIG_ASH) += kill.o  # used for built-in kill by ash
-lib-$(CONFIG_SH_IS_ASH) += kill.o  # used for built-in kill by ash
-lib-$(CONFIG_BASH_IS_ASH) += kill.o  # used for built-in kill by ash
diff -urpN busybox-1.26.2/procps/kill.c busybox-1.27.0/procps/kill.c
--- busybox-1.26.2/procps/kill.c	2016-12-10 18:46:36.000000000 +0100
+++ busybox-1.27.0/procps/kill.c	2017-07-01 22:51:12.000000000 +0200
@@ -33,7 +33,8 @@
 //config:	  the script it was called from.
 
 //applet:IF_KILL(APPLET(kill, BB_DIR_BIN, BB_SUID_DROP))
-//applet:IF_KILLALL(APPLET_ODDNAME(killall, kill, BB_DIR_USR_BIN, BB_SUID_DROP, killall))
+//                   APPLET_ODDNAME:name      main  location         suid_type     help
+//applet:IF_KILLALL( APPLET_ODDNAME(killall,  kill, BB_DIR_USR_BIN,  BB_SUID_DROP, killall))
 //applet:IF_KILLALL5(APPLET_ODDNAME(killall5, kill, BB_DIR_USR_SBIN, BB_SUID_DROP, killall5))
 
 //kbuild:lib-$(CONFIG_KILL) += kill.o
@@ -92,28 +93,34 @@
  * This is needed to avoid collision with kill -9 ... syntax
  */
 
+//kbuild:lib-$(CONFIG_ASH_JOB_CONTROL) += kill.o
+//kbuild:lib-$(CONFIG_HUSH_KILL) += kill.o
+
+#define SH_KILL (ENABLE_ASH_JOB_CONTROL || ENABLE_HUSH_KILL)
+/* If shells want to have "kill", for ifdefs it's like ENABLE_KILL=1 */
+#if SH_KILL
+# undef  ENABLE_KILL
+# define ENABLE_KILL 1
+#endif
+#define KILL_APPLET_CNT (ENABLE_KILL + ENABLE_KILLALL + ENABLE_KILLALL5)
+
 int kill_main(int argc UNUSED_PARAM, char **argv)
 {
 	char *arg;
 	pid_t pid;
 	int signo = SIGTERM, errors = 0, quiet = 0;
-#if ENABLE_KILL && !ENABLE_KILLALL && !ENABLE_KILLALL5
-# define killall  0
-# define killall5 0
-#elif !ENABLE_KILL && ENABLE_KILLALL && !ENABLE_KILLALL5
-# define killall  1
-# define killall5 0
-#elif !ENABLE_KILL && !ENABLE_KILLALL && ENABLE_KILLALL5
-# define killall  0
-# define killall5 1
+
+#if KILL_APPLET_CNT == 1
+# define is_killall  ENABLE_KILLALL
+# define is_killall5 ENABLE_KILLALL5
 #else
 /* How to determine who we are? find 3rd char from the end:
  * kill, killall, killall5
  *  ^i       ^a        ^l  - it's unique
  * (checking from the start is complicated by /bin/kill... case) */
 	const char char3 = argv[0][strlen(argv[0]) - 3];
-# define killall  (ENABLE_KILLALL && char3 == 'a')
-# define killall5 (ENABLE_KILLALL5 && char3 == 'l')
+# define is_killall  (ENABLE_KILLALL  && char3 == 'a')
+# define is_killall5 (ENABLE_KILLALL5 && char3 == 'l')
 #endif
 
 	/* Parse any options */
@@ -162,7 +169,7 @@ int kill_main(int argc UNUSED_PARAM, cha
 	}
 
 	/* The -q quiet option */
-	if (killall && arg[1] == 'q' && arg[2] == '\0') {
+	if (is_killall && arg[1] == 'q' && arg[2] == '\0') {
 		quiet = 1;
 		arg = *++argv;
 		if (!arg)
@@ -174,7 +181,7 @@ int kill_main(int argc UNUSED_PARAM, cha
 	arg++; /* skip '-' */
 
 	/* -o PID? (if present, it always is at the end of command line) */
-	if (killall5 && arg[0] == 'o')
+	if (is_killall5 && arg[0] == 'o')
 		goto do_it_now;
 
 	if (argv[1] && arg[0] == 's' && arg[1] == '\0') { /* -s SIG? */
@@ -190,11 +197,11 @@ int kill_main(int argc UNUSED_PARAM, cha
  do_it_now:
 	pid = getpid();
 
-	if (killall5) {
+	if (is_killall5) {
 		pid_t sid;
 		procps_status_t* p = NULL;
 		/* compat: exitcode 2 is "no one was signaled" */
-		int ret = 2;
+		errors = 2;
 
 		/* Find out our session id */
 		sid = getsid(pid);
@@ -222,7 +229,7 @@ int kill_main(int argc UNUSED_PARAM, cha
 				arg = *args++;
 				if (arg[0] != '-' || arg[1] != 'o') {
 					bb_error_msg("bad option '%s'", arg);
-					ret = 1;
+					errors = 1;
 					goto resume;
 				}
 				arg += 2;
@@ -231,30 +238,31 @@ int kill_main(int argc UNUSED_PARAM, cha
 				omit = bb_strtoi(arg, NULL, 10);
 				if (errno) {
 					bb_error_msg("invalid number '%s'", arg);
-					ret = 1;
+					errors = 1;
 					goto resume;
 				}
 				if (p->pid == omit)
 					goto dont_kill;
 			}
 			kill(p->pid, signo);
-			ret = 0;
+			errors = 0;
  dont_kill: ;
 		}
  resume:
 		/* And let them continue */
 		if (signo != SIGSTOP && signo != SIGCONT)
 			kill(-1, SIGCONT);
-		return ret;
+		return errors;
 	}
 
+#if ENABLE_KILL || ENABLE_KILLALL
 	/* Pid or name is required for kill/killall */
 	if (!arg) {
 		bb_error_msg("you need to specify whom to kill");
 		return EXIT_FAILURE;
 	}
 
-	if (killall) {
+	if (!ENABLE_KILL || is_killall) {
 		/* Looks like they want to do a killall.  Do that */
 		do {
 			pid_t* pidList;
@@ -282,10 +290,12 @@ int kill_main(int argc UNUSED_PARAM, cha
 		} while (arg);
 		return errors;
 	}
+#endif
 
+#if ENABLE_KILL
 	/* Looks like they want to do a kill. Do that */
 	while (arg) {
-#if ENABLE_ASH || ENABLE_HUSH
+# if SH_KILL
 		/*
 		 * We need to support shell's "hack formats" of
 		 * " -PRGP_ID" (yes, with a leading space)
@@ -307,7 +317,7 @@ int kill_main(int argc UNUSED_PARAM, cha
 			}
 			arg = end; /* can only point to ' ' or '\0' now */
 		}
-#else
+# else /* ENABLE_KILL but !SH_KILL */
 		pid = bb_strtoi(arg, NULL, 10);
 		if (errno) {
 			bb_error_msg("invalid number '%s'", arg);
@@ -316,8 +326,9 @@ int kill_main(int argc UNUSED_PARAM, cha
 			bb_perror_msg("can't kill pid %d", (int)pid);
 			errors++;
 		}
-#endif
+# endif
 		arg = *++argv;
 	}
 	return errors;
+#endif
 }
diff -urpN busybox-1.26.2/procps/nmeter.c busybox-1.27.0/procps/nmeter.c
--- busybox-1.26.2/procps/nmeter.c	2016-09-27 18:53:50.000000000 +0200
+++ busybox-1.27.0/procps/nmeter.c	2017-01-23 01:09:41.000000000 +0100
@@ -24,7 +24,7 @@
 //usage:     "\n -d MSEC	Milliseconds between updates, default:1000, none:-1"
 //usage:     "\n"
 //usage:     "\nFormat specifiers:"
-//usage:     "\n %Nc or %[cN]	CPU. N - bar size (default:10)"
+//usage:     "\n %Nc or %[cN]	CPU. N - bar size (default 10)"
 //usage:     "\n		(displays: S:system U:user N:niced D:iowait I:irq i:softirq)"
 //usage:     "\n %[nINTERFACE]	Network INTERFACE"
 //usage:     "\n %m		Allocated memory"
diff -urpN busybox-1.26.2/procps/pgrep.c busybox-1.27.0/procps/pgrep.c
--- busybox-1.26.2/procps/pgrep.c	2016-12-10 18:46:36.000000000 +0100
+++ busybox-1.27.0/procps/pgrep.c	2017-07-01 22:51:12.000000000 +0200
@@ -19,16 +19,18 @@
 //config:	  Send signals to processes by name.
 
 //applet:IF_PGREP(APPLET(pgrep, BB_DIR_USR_BIN, BB_SUID_DROP))
+//                APPLET_ODDNAME:name   main   location        suid_type     help
 //applet:IF_PKILL(APPLET_ODDNAME(pkill, pgrep, BB_DIR_USR_BIN, BB_SUID_DROP, pkill))
 
 //kbuild:lib-$(CONFIG_PGREP) += pgrep.o
 //kbuild:lib-$(CONFIG_PKILL) += pgrep.o
 
 //usage:#define pgrep_trivial_usage
-//usage:       "[-flnovx] [-s SID|-P PPID|PATTERN]"
+//usage:       "[-flanovx] [-s SID|-P PPID|PATTERN]"
 //usage:#define pgrep_full_usage "\n\n"
 //usage:       "Display process(es) selected by regex PATTERN\n"
 //usage:     "\n	-l	Show command name too"
+//usage:     "\n	-a	Show command line too"
 //usage:     "\n	-f	Match against entire command line"
 //usage:     "\n	-n	Show the newest process only"
 //usage:     "\n	-o	Show the oldest process only"
@@ -54,13 +56,14 @@
 #include "xregex.h"
 
 /* Idea taken from kill.c */
-#define pgrep (ENABLE_PGREP && applet_name[1] == 'g')
-#define pkill (ENABLE_PKILL && applet_name[1] == 'k')
+#define pgrep (ENABLE_PGREP && (!ENABLE_PKILL || applet_name[1] == 'g'))
+#define pkill (ENABLE_PKILL && (!ENABLE_PGREP || applet_name[1] == 'k'))
 
 enum {
-	/* "vlfxons:P:" */
+	/* "vlafxons:+P:+" */
 	OPTBIT_V = 0, /* must be first, we need OPT_INVERT = 0/1 */
 	OPTBIT_L,
+	OPTBIT_A,
 	OPTBIT_F,
 	OPTBIT_X,
 	OPTBIT_O,
@@ -71,6 +74,7 @@ enum {
 
 #define OPT_INVERT	(opt & (1 << OPTBIT_V))
 #define OPT_LIST	(opt & (1 << OPTBIT_L))
+#define OPT_LISTFULL	(opt & (1 << OPTBIT_A))
 #define OPT_FULL	(opt & (1 << OPTBIT_F))
 #define OPT_ANCHOR	(opt & (1 << OPTBIT_X))
 #define OPT_FIRST	(opt & (1 << OPTBIT_O))
@@ -81,7 +85,7 @@ enum {
 static void act(unsigned pid, char *cmd, int signo)
 {
 	if (pgrep) {
-		if (option_mask32 & (1 << OPTBIT_L)) /* OPT_LIST */
+		if (option_mask32 & ((1 << OPTBIT_L)|(1 << OPTBIT_A))) /* -l or -a */
 			printf("%u %s\n", pid, cmd);
 		else
 			printf("%u\n", pid);
@@ -123,7 +127,7 @@ int pgrep_main(int argc UNUSED_PARAM, ch
 	/* Parse remaining options */
 	ppid2match = -1;
 	sid2match = -1;
-	opt = getopt32(argv, "vlfxons:+P:+", &sid2match, &ppid2match);
+	opt = getopt32(argv, "vlafxons:+P:+", &sid2match, &ppid2match);
 	argv += optind;
 
 	if (pkill && OPT_LIST) { /* -l: print the whole signal list */
@@ -151,26 +155,37 @@ int pgrep_main(int argc UNUSED_PARAM, ch
 	proc = NULL;
 	while ((proc = procps_scan(proc, scan_mask)) != NULL) {
 		char *cmd;
+		int cmdlen;
 
 		if (proc->pid == pid)
 			continue;
 
+		if (ppid2match >= 0 && ppid2match != proc->ppid)
+			continue;
+		if (sid2match >= 0 && sid2match != proc->sid)
+			continue;
+
+		cmdlen = -1;
 		cmd = proc->argv0;
 		if (!cmd) {
 			cmd = proc->comm;
 		} else {
 			int i = proc->argv_len;
+
+			if (!OPT_LISTFULL)
+				cmdlen = strlen(cmd); /* not -a: find first NUL */
+			/*
+			 * "sleep 11" looks like "sleep""\0""11""\0" in argv0.
+			 * Make sure last "\0" does not get converted to " ":
+			 */
+			if (i && cmd[i-1] == '\0')
+				i--;
 			while (--i >= 0) {
 				if ((unsigned char)cmd[i] < ' ')
 					cmd[i] = ' ';
 			}
 		}
 
-		if (ppid2match >= 0 && ppid2match != proc->ppid)
-			continue;
-		if (sid2match >= 0 && sid2match != proc->sid)
-			continue;
-
 		/* NB: OPT_INVERT is always 0 or 1 */
 		if (!argv[0]
 		 || (regexec(&re_buffer, cmd, 1, re_match, 0) == 0 /* match found */
@@ -183,6 +198,8 @@ int pgrep_main(int argc UNUSED_PARAM, ch
 				cmd_last = xstrdup(cmd);
 				continue;
 			}
+			if (cmdlen >= 0)
+				cmd[cmdlen] = '\0';
 			act(proc->pid, cmd, signo);
 			if (OPT_FIRST)
 				break;
diff -urpN busybox-1.26.2/procps/pidof.c busybox-1.27.0/procps/pidof.c
--- busybox-1.26.2/procps/pidof.c	2016-12-10 18:46:36.000000000 +0100
+++ busybox-1.27.0/procps/pidof.c	2017-01-10 16:31:40.000000000 +0100
@@ -14,18 +14,18 @@
 //config:	  those id's on the standard output.
 //config:
 //config:config FEATURE_PIDOF_SINGLE
-//config:	bool "Enable argument for single shot (-s)"
+//config:	bool "Enable single shot (-s)"
 //config:	default y
 //config:	depends on PIDOF
 //config:	help
-//config:	  Support argument '-s' for returning only the first pid found.
+//config:	  Support '-s' for returning only the first pid found.
 //config:
 //config:config FEATURE_PIDOF_OMIT
-//config:	bool "Enable argument for omitting pids (-o)"
+//config:	bool "Enable omitting pids (-o PID)"
 //config:	default y
 //config:	depends on PIDOF
 //config:	help
-//config:	  Support argument '-o' for omitting the given pids in output.
+//config:	  Support '-o PID' for omitting the given pid(s) in output.
 //config:	  The special pid %PPID can be used to name the parent process
 //config:	  of the pidof, in other words the calling shell or shell script.
 
diff -urpN busybox-1.26.2/procps/powertop.c busybox-1.27.0/procps/powertop.c
--- busybox-1.26.2/procps/powertop.c	2016-09-27 18:53:50.000000000 +0200
+++ busybox-1.27.0/procps/powertop.c	2017-01-15 00:18:53.000000000 +0100
@@ -18,6 +18,14 @@
 //config:	default y
 //config:	help
 //config:	  Analyze power consumption on Intel-based laptops
+//config:
+//config:config FEATURE_POWERTOP_INTERACTIVE
+//config:	bool "Accept keyboard commands"
+//config:	default y
+//config:	depends on POWERTOP
+//config:	help
+//config:	  Without this, powertop will only refresh display every 10 seconds.
+//config:	  No keyboard commands will work, only ^C to terminate.
 
 // XXX This should be configurable
 #define ENABLE_FEATURE_POWERTOP_PROCIRQ 1
@@ -82,7 +90,7 @@ struct globals {
 	ullong last_usage[MAX_CSTATE_COUNT];
 	ullong start_duration[MAX_CSTATE_COUNT];
 	ullong last_duration[MAX_CSTATE_COUNT];
-#if ENABLE_FEATURE_USE_TERMIOS
+#if ENABLE_FEATURE_POWERTOP_INTERACTIVE
 	struct termios init_settings;
 #endif
 };
@@ -91,7 +99,7 @@ struct globals {
 	SET_PTR_TO_GLOBALS(xzalloc(sizeof(G))); \
 } while (0)
 
-#if ENABLE_FEATURE_USE_TERMIOS
+#if ENABLE_FEATURE_POWERTOP_INTERACTIVE
 static void reset_term(void)
 {
 	tcsetattr_stdin_TCSANOW(&G.init_settings);
@@ -682,8 +690,7 @@ int powertop_main(int UNUSED_PARAM argc,
 	ullong cur_usage[MAX_CSTATE_COUNT];
 	ullong cur_duration[MAX_CSTATE_COUNT];
 	char cstate_lines[MAX_CSTATE_COUNT + 2][64];
-#if ENABLE_FEATURE_USE_TERMIOS
-	struct termios new_settings;
+#if ENABLE_FEATURE_POWERTOP_INTERACTIVE
 	struct pollfd pfd[1];
 
 	pfd[0].fd = 0;
@@ -706,15 +713,12 @@ int powertop_main(int UNUSED_PARAM argc,
 
 	puts("Collecting data for "DEFAULT_SLEEP_STR" seconds");
 
-#if ENABLE_FEATURE_USE_TERMIOS
-	tcgetattr(0, (void *)&G.init_settings);
-	memcpy(&new_settings, &G.init_settings, sizeof(new_settings));
-	/* Turn on unbuffered input, turn off echoing */
-	new_settings.c_lflag &= ~(ISIG | ICANON | ECHO | ECHONL);
+#if ENABLE_FEATURE_POWERTOP_INTERACTIVE
+	/* Turn on unbuffered input; turn off echoing, ^C ^Z etc */
+	set_termios_to_raw(STDIN_FILENO, &G.init_settings, TERMIOS_CLEAR_ISIG);
+	bb_signals(BB_FATAL_SIGS, sig_handler);
 	/* So we don't forget to reset term settings */
 	atexit(reset_term);
-	bb_signals(BB_FATAL_SIGS, sig_handler);
-	tcsetattr_stdin_TCSANOW(&new_settings);
 #endif
 
 	/* Collect initial data */
@@ -739,7 +743,7 @@ int powertop_main(int UNUSED_PARAM argc,
 		int i;
 
 		G.cant_enable_timer_stats |= start_timer(); /* 1 on error */
-#if !ENABLE_FEATURE_USE_TERMIOS
+#if !ENABLE_FEATURE_POWERTOP_INTERACTIVE
 		sleep(DEFAULT_SLEEP);
 #else
 		if (safe_poll(pfd, 1, DEFAULT_SLEEP * 1000) > 0) {
diff -urpN busybox-1.26.2/procps/ps.c busybox-1.27.0/procps/ps.c
--- busybox-1.26.2/procps/ps.c	2016-12-10 18:46:36.000000000 +0100
+++ busybox-1.27.0/procps/ps.c	2017-01-16 17:32:02.000000000 +0100
@@ -32,19 +32,10 @@
 //config:	  Adds fields PPID, RSS, START, TIME & TTY
 //config:
 //config:config FEATURE_PS_TIME
-//config:	bool "Enable time and elapsed time output"
+//config:	bool "Support -o time and -o etime output specifiers"
 //config:	default y
 //config:	depends on PS && DESKTOP
 //config:	select PLATFORM_LINUX
-//config:	help
-//config:	  Support -o time and -o etime output specifiers.
-//config:
-//config:config FEATURE_PS_ADDITIONAL_COLUMNS
-//config:	bool "Enable additional ps columns"
-//config:	default y
-//config:	depends on PS && DESKTOP
-//config:	help
-//config:	  Support -o rgroup, -o ruser, -o nice output specifiers.
 //config:
 //config:config FEATURE_PS_UNUSUAL_SYSTEMS
 //config:	bool "Support Linux prior to 2.4.0 and non-ELF systems"
@@ -53,6 +44,11 @@
 //config:	help
 //config:	  Include support for measuring HZ on old kernels and non-ELF systems
 //config:	  (if you are on Linux 2.4.0+ and use ELF, you don't need this)
+//config:
+//config:config FEATURE_PS_ADDITIONAL_COLUMNS
+//config:	bool "Support -o rgroup, -o ruser, -o nice specifiers"
+//config:	default y
+//config:	depends on PS && DESKTOP
 
 //applet:IF_PS(APPLET(ps, BB_DIR_BIN, BB_SUID_DROP))
 
@@ -612,7 +608,9 @@ int ps_main(int argc UNUSED_PARAM, char
 	procps_status_t *p;
 	llist_t* opt_o = NULL;
 	char default_o[sizeof(DEFAULT_O_STR)];
+#if ENABLE_SELINUX || ENABLE_FEATURE_SHOW_THREADS
 	int opt;
+#endif
 	enum {
 		OPT_Z = (1 << 0),
 		OPT_o = (1 << 1),
@@ -642,7 +640,11 @@ int ps_main(int argc UNUSED_PARAM, char
 	 * procps v3.2.7 supports -T and shows tids as SPID column,
 	 * it also supports -L where it shows tids as LWP column.
 	 */
-	opt = getopt32(argv, "Zo:*aAdefl"IF_FEATURE_SHOW_THREADS("T"), &opt_o);
+#if ENABLE_SELINUX || ENABLE_FEATURE_SHOW_THREADS
+	opt =
+#endif
+		getopt32(argv, "Zo:*aAdefl"IF_FEATURE_SHOW_THREADS("T"), &opt_o);
+
 	if (opt_o) {
 		do {
 			parse_o(llist_pop(&opt_o));
diff -urpN busybox-1.26.2/procps/pstree.c busybox-1.27.0/procps/pstree.c
--- busybox-1.26.2/procps/pstree.c	2016-09-27 18:53:50.000000000 +0200
+++ busybox-1.27.0/procps/pstree.c	2017-07-01 22:51:12.000000000 +0200
@@ -34,7 +34,7 @@
 
 struct child;
 
-#ifdef ENABLE_FEATURE_SHOW_THREADS
+#if ENABLE_FEATURE_SHOW_THREADS
 /* For threads, we add {...} around the comm, so we need two extra bytes */
 # define COMM_DISP_LEN (COMM_LEN + 2)
 #else
@@ -357,7 +357,9 @@ static void handle_thread(const char *co
 static void mread_proc(void)
 {
 	procps_status_t *p = NULL;
+#if ENABLE_FEATURE_SHOW_THREADS
 	pid_t parent = 0;
+#endif
 	int flags = PSSCAN_COMM | PSSCAN_PID | PSSCAN_PPID | PSSCAN_UIDGID | PSSCAN_TASKS;
 
 	while ((p = procps_scan(p, flags)) != NULL) {
@@ -368,7 +370,9 @@ static void mread_proc(void)
 #endif
 		{
 			add_proc(p->comm, p->pid, p->ppid, p->uid/*, 0*/);
+#if ENABLE_FEATURE_SHOW_THREADS
 			parent = p->pid;
+#endif
 		}
 	}
 }
diff -urpN busybox-1.26.2/procps/renice.c busybox-1.27.0/procps/renice.c
--- busybox-1.26.2/procps/renice.c	2016-12-10 18:46:36.000000000 +0100
+++ busybox-1.27.0/procps/renice.c	1970-01-01 01:00:00.000000000 +0100
@@ -1,148 +0,0 @@
-/* vi: set sw=4 ts=4: */
-/*
- * renice implementation for busybox
- *
- * Copyright (C) 2005  Manuel Novoa III  <mjn3@codepoet.org>
- *
- * Licensed under GPLv2 or later, see file LICENSE in this source tree.
- */
-
-/* Notes:
- *   Setting an absolute priority was obsoleted in SUSv2 and removed
- *   in SUSv3.  However, the common linux version of renice does
- *   absolute and not relative.  So we'll continue supporting absolute,
- *   although the stdout logging has been removed since both SUSv2 and
- *   SUSv3 specify that stdout isn't used.
- *
- *   This version is lenient in that it doesn't require any IDs.  The
- *   options -p, -g, and -u are treated as mode switches for the
- *   following IDs (if any).  Multiple switches are allowed.
- */
-//config:config RENICE
-//config:	bool "renice"
-//config:	default y
-//config:	help
-//config:	  Renice alters the scheduling priority of one or more running
-//config:	  processes.
-
-//applet:IF_RENICE(APPLET(renice, BB_DIR_USR_BIN, BB_SUID_DROP))
-
-//kbuild:lib-$(CONFIG_RENICE) += renice.o
-
-//usage:#define renice_trivial_usage
-//usage:       "[-n] PRIORITY [[-p | -g | -u] ID...]..."
-//usage:#define renice_full_usage "\n\n"
-//usage:       "Change scheduling priority of a running process\n"
-//usage:     "\n	-n	Add PRIORITY to current nice value"
-//usage:     "\n		Without -n, nice value is set to PRIORITY"
-//usage:     "\n	-p	Process ids (default)"
-//usage:     "\n	-g	Process group ids"
-//usage:     "\n	-u	Process user names"
-
-#include "libbb.h"
-#include <sys/resource.h>
-
-void BUG_bad_PRIO_PROCESS(void);
-void BUG_bad_PRIO_PGRP(void);
-void BUG_bad_PRIO_USER(void);
-
-int renice_main(int argc, char **argv) MAIN_EXTERNALLY_VISIBLE;
-int renice_main(int argc UNUSED_PARAM, char **argv)
-{
-	static const char Xetpriority_msg[] ALIGN1 = "%cetpriority";
-
-	int retval = EXIT_SUCCESS;
-	int which = PRIO_PROCESS;  /* Default 'which' value. */
-	int use_relative = 0;
-	int adjustment, new_priority;
-	unsigned who;
-	char *arg;
-
-	/* Yes, they are not #defines in glibc 2.4! #if won't work */
-	if (PRIO_PROCESS < CHAR_MIN || PRIO_PROCESS > CHAR_MAX)
-		BUG_bad_PRIO_PROCESS();
-	if (PRIO_PGRP < CHAR_MIN || PRIO_PGRP > CHAR_MAX)
-		BUG_bad_PRIO_PGRP();
-	if (PRIO_USER < CHAR_MIN || PRIO_USER > CHAR_MAX)
-		BUG_bad_PRIO_USER();
-
-	arg = *++argv;
-
-	/* Check if we are using a relative adjustment. */
-	if (arg && arg[0] == '-' && arg[1] == 'n') {
-		use_relative = 1;
-		if (!arg[2])
-			arg = *++argv;
-		else
-			arg += 2;
-	}
-
-	if (!arg) {  /* No args?  Then show usage. */
-		bb_show_usage();
-	}
-
-	/* Get the priority adjustment (absolute or relative). */
-	adjustment = xatoi_range(arg, INT_MIN/2, INT_MAX/2);
-
-	while ((arg = *++argv) != NULL) {
-		/* Check for a mode switch. */
-		if (arg[0] == '-' && arg[1]) {
-			static const char opts[] ALIGN1 = {
-				'p', 'g', 'u', 0, PRIO_PROCESS, PRIO_PGRP, PRIO_USER
-			};
-			const char *p = strchr(opts, arg[1]);
-			if (p) {
-				which = p[4];
-				if (!arg[2])
-					continue;
-				arg += 2;
-			}
-		}
-
-		/* Process an ID arg. */
-		if (which == PRIO_USER) {
-			struct passwd *p;
-			p = getpwnam(arg);
-			if (!p) {
-				bb_error_msg("unknown user %s", arg);
-				goto HAD_ERROR;
-			}
-			who = p->pw_uid;
-		} else {
-			who = bb_strtou(arg, NULL, 10);
-			if (errno) {
-				bb_error_msg("invalid number '%s'", arg);
-				goto HAD_ERROR;
-			}
-		}
-
-		/* Get priority to use, and set it. */
-		if (use_relative) {
-			int old_priority;
-
-			errno = 0;  /* Needed for getpriority error detection. */
-			old_priority = getpriority(which, who);
-			if (errno) {
-				bb_perror_msg(Xetpriority_msg, 'g');
-				goto HAD_ERROR;
-			}
-
-			new_priority = old_priority + adjustment;
-		} else {
-			new_priority = adjustment;
-		}
-
-		if (setpriority(which, who, new_priority) == 0) {
-			continue;
-		}
-
-		bb_perror_msg(Xetpriority_msg, 's');
- HAD_ERROR:
-		retval = EXIT_FAILURE;
-	}
-
-	/* No need to check for errors outputing to stderr since, if it
-	 * was used, the HAD_ERROR label was reached and retval was set. */
-
-	return retval;
-}
diff -urpN busybox-1.26.2/procps/top.c busybox-1.27.0/procps/top.c
--- busybox-1.26.2/procps/top.c	2016-12-10 18:46:36.000000000 +0100
+++ busybox-1.27.0/procps/top.c	2017-01-15 00:18:53.000000000 +0100
@@ -56,6 +56,14 @@
 //config:	  The top program provides a dynamic real-time view of a running
 //config:	  system.
 //config:
+//config:config FEATURE_TOP_INTERACTIVE
+//config:	bool "Accept keyboard commands"
+//config:	default y
+//config:	depends on TOP
+//config:	help
+//config:	  Without this, top will only refresh display every 5 seconds.
+//config:	  No keyboard commands will work, only ^C to terminate.
+//config:
 //config:config FEATURE_TOP_CPU_USAGE_PERCENTAGE
 //config:	bool "Show CPU per-process usage percentage"
 //config:	default y
@@ -158,7 +166,7 @@ struct globals {
 	smallint smp_cpu_info; /* one/many cpu info lines? */
 #endif
 	unsigned lines;  /* screen height */
-#if ENABLE_FEATURE_USE_TERMIOS
+#if ENABLE_FEATURE_TOP_INTERACTIVE
 	struct termios initial_settings;
 	int scroll_ofs;
 #define G_scroll_ofs G.scroll_ofs
@@ -181,7 +189,7 @@ struct globals {
 	jiffy_counts_t *cpu_jif, *cpu_prev_jif;
 	int num_cpus;
 #endif
-#if ENABLE_FEATURE_USE_TERMIOS
+#if ENABLE_FEATURE_TOP_INTERACTIVE
 	char kbd_input[KEYCODE_BUFFER_SIZE];
 #endif
 	char line_buf[80];
@@ -220,7 +228,7 @@ enum {
 #define OPT_BATCH_MODE (option_mask32 & OPT_b)
 
 
-#if ENABLE_FEATURE_USE_TERMIOS
+#if ENABLE_FEATURE_TOP_INTERACTIVE
 static int pid_sort(top_status_t *P, top_status_t *Q)
 {
 	/* Buggy wrt pids with high bit set */
@@ -725,8 +733,7 @@ static void clearmems(void)
 	top = NULL;
 }
 
-#if ENABLE_FEATURE_USE_TERMIOS
-
+#if ENABLE_FEATURE_TOP_INTERACTIVE
 static void reset_term(void)
 {
 	if (!OPT_BATCH_MODE)
@@ -738,8 +745,7 @@ static void sig_catcher(int sig)
 	reset_term();
 	kill_myself_with_sig(sig);
 }
-
-#endif /* FEATURE_USE_TERMIOS */
+#endif /* FEATURE_TOP_INTERACTIVE */
 
 /*
  * TOPMEM support
@@ -894,7 +900,7 @@ enum {
 	EXIT_MASK = (unsigned)-1,
 };
 
-#if ENABLE_FEATURE_USE_TERMIOS
+#if ENABLE_FEATURE_TOP_INTERACTIVE
 static unsigned handle_input(unsigned scan_mask, unsigned interval)
 {
 	if (option_mask32 & OPT_EOF) {
@@ -1043,7 +1049,7 @@ static unsigned handle_input(unsigned sc
 //usage:   "\n""Read the status of all processes from /proc each SECONDS"
 //usage:   "\n""and display a screenful of them."
 //usage:   "\n"
-//usage:	IF_FEATURE_USE_TERMIOS(
+//usage:	IF_FEATURE_TOP_INTERACTIVE(
 //usage:       "Keys:"
 //usage:   "\n""	N/M"
 //usage:                IF_FEATURE_TOP_CPU_USAGE_PERCENTAGE("/P")
@@ -1091,9 +1097,6 @@ int top_main(int argc UNUSED_PARAM, char
 	unsigned interval;
 	char *str_interval, *str_iterations;
 	unsigned scan_mask = TOP_MASK;
-#if ENABLE_FEATURE_USE_TERMIOS
-	struct termios new_settings;
-#endif
 
 	INIT_G();
 
@@ -1141,13 +1144,10 @@ int top_main(int argc UNUSED_PARAM, char
 	if (OPT_BATCH_MODE) {
 		option_mask32 |= OPT_EOF;
 	}
-#if ENABLE_FEATURE_USE_TERMIOS
+#if ENABLE_FEATURE_TOP_INTERACTIVE
 	else {
-		tcgetattr(0, (void *) &initial_settings);
-		memcpy(&new_settings, &initial_settings, sizeof(new_settings));
-		/* unbuffered input, turn off echo */
-		new_settings.c_lflag &= ~(ISIG | ICANON | ECHO | ECHONL);
-		tcsetattr_stdin_TCSANOW(&new_settings);
+		/* Turn on unbuffered input; turn off echoing, ^C ^Z etc */
+		set_termios_to_raw(STDIN_FILENO, &initial_settings, TERMIOS_CLEAR_ISIG);
 	}
 
 	bb_signals(BB_FATAL_SIGS, sig_catcher);
@@ -1165,14 +1165,12 @@ int top_main(int argc UNUSED_PARAM, char
 		} else {
 			G.lines = 24; /* default */
 			col = 79;
-#if ENABLE_FEATURE_USE_TERMIOS
 			/* We output to stdout, we need size of stdout (not stdin)! */
 			get_terminal_width_height(STDOUT_FILENO, &col, &G.lines);
 			if (G.lines < 5 || col < 10) {
 				sleep(interval);
 				continue;
 			}
-#endif
 			if (col > LINE_BUF_SIZE - 2)
 				col = LINE_BUF_SIZE - 2;
 		}
@@ -1247,7 +1245,7 @@ int top_main(int argc UNUSED_PARAM, char
 		clearmems();
 		if (iterations >= 0 && !--iterations)
 			break;
-#if !ENABLE_FEATURE_USE_TERMIOS
+#if !ENABLE_FEATURE_TOP_INTERACTIVE
 		sleep(interval);
 #else
 		scan_mask = handle_input(scan_mask, interval);
@@ -1255,7 +1253,7 @@ int top_main(int argc UNUSED_PARAM, char
 	} /* end of "while (not Q)" */
 
 	bb_putchar('\n');
-#if ENABLE_FEATURE_USE_TERMIOS
+#if ENABLE_FEATURE_TOP_INTERACTIVE
 	reset_term();
 #endif
 	if (ENABLE_FEATURE_CLEAN_UP) {
diff -urpN busybox-1.26.2/procps/uptime.c busybox-1.27.0/procps/uptime.c
--- busybox-1.26.2/procps/uptime.c	2016-12-10 18:46:36.000000000 +0100
+++ busybox-1.27.0/procps/uptime.c	2017-01-10 16:31:40.000000000 +0100
@@ -21,11 +21,11 @@
 //config:	  on, and the system load averages for the past 1, 5, and 15 minutes.
 //config:
 //config:config FEATURE_UPTIME_UTMP_SUPPORT
-//config:	bool "Support for showing the number of users"
+//config:	bool "Show the number of users"
 //config:	default y
 //config:	depends on UPTIME && FEATURE_UTMP
 //config:	help
-//config:	  Makes uptime display the number of users currently logged on.
+//config:	  Display the number of users currently logged on.
 
 //applet:IF_UPTIME(APPLET(uptime, BB_DIR_USR_BIN, BB_SUID_DROP))
 
diff -urpN busybox-1.26.2/qemu_multiarch_testing/extract_uuencoded_binary.sh busybox-1.27.0/qemu_multiarch_testing/extract_uuencoded_binary.sh
--- busybox-1.26.2/qemu_multiarch_testing/extract_uuencoded_binary.sh	1970-01-01 01:00:00.000000000 +0100
+++ busybox-1.27.0/qemu_multiarch_testing/extract_uuencoded_binary.sh	2017-01-02 12:49:37.000000000 +0100
@@ -0,0 +1,17 @@
+#!/bin/sh
+# Extract uuencoded and bzipped busybox binaries
+# from system-image-*.log files
+
+for logfile in system-image-*.log; do
+	grep -q '^begin 744 busybox.bz2' "$logfile" \
+	|| { echo "No busybox.bz2 in $logfile"; continue; }
+
+	arch=${logfile%.log}
+	arch=${arch#system-image-}
+
+	test -e "busybox-$arch" \
+	&& { echo "busybox-$arch exists, not overwriting"; continue; }
+
+	uudecode -o - "$logfile" | bunzip2 >"busybox-$arch" \
+	&& chmod 755 "busybox-$arch"
+done
diff -urpN busybox-1.26.2/qemu_multiarch_testing/hdc.dir/build busybox-1.27.0/qemu_multiarch_testing/hdc.dir/build
--- busybox-1.26.2/qemu_multiarch_testing/hdc.dir/build	2016-09-27 18:53:50.000000000 +0200
+++ busybox-1.27.0/qemu_multiarch_testing/hdc.dir/build	2017-01-02 12:56:07.000000000 +0100
@@ -29,12 +29,13 @@ test -x "bin/busybox-$HOST" && {
 		sed 's/^.*CONFIG_EXTRA_CFLAGS.*$/CONFIG_EXTRA_CFLAGS="-mips32"/' -i .config
 	}
 	# These won't build because of toolchain/libc breakage:
-	sed 's/^.*CONFIG_FEATURE_SYNC_FANCY.*$/# CONFIG_FEATURE_SYNC_FANCY is not set/' -i .config # no syncfs()
+	sed 's/^.*CONFIG_FEATURE_SYNC_FANCY.*$/# CONFIG_FEATURE_SYNC_FANCY is not set/' -i .config # no syncfs() on armv4l, sparc
 	sed 's/^.*CONFIG_FEATURE_WTMP.*$/# CONFIG_FEATURE_WTMP is not set/' -i .config
 	sed 's/^.*CONFIG_FEATURE_UTMP.*$/# CONFIG_FEATURE_UTMP is not set/' -i .config
 	sed 's/^.*CONFIG_FEATURE_INETD_RPC.*$/# CONFIG_FEATURE_INETD_RPC is not set/' -i .config
 
 	make #V=1 || sh
+	test -f busybox || exit 1
 	size busybox
 	./busybox || echo "Exit code: $?"
 	if uuencode TEST </dev/null >/dev/null && bzip2 </dev/null >/dev/null; then
diff -urpN busybox-1.26.2/runit/chpst.c busybox-1.27.0/runit/chpst.c
--- busybox-1.26.2/runit/chpst.c	2016-09-27 18:53:50.000000000 +0200
+++ busybox-1.27.0/runit/chpst.c	2017-04-05 18:27:36.000000000 +0200
@@ -60,7 +60,8 @@ ADVISED OF THE POSSIBILITY OF SUCH DAMAG
 //config:	  Sets soft resource limits as specified by options
 
 //applet:IF_CHPST(APPLET(chpst, BB_DIR_USR_BIN, BB_SUID_DROP))
-//applet:IF_ENVDIR(APPLET_ODDNAME(envdir, chpst, BB_DIR_USR_BIN, BB_SUID_DROP, envdir))
+//                    APPLET_ODDNAME:name       main   location        suid_type     help
+//applet:IF_ENVDIR(   APPLET_ODDNAME(envdir,    chpst, BB_DIR_USR_BIN, BB_SUID_DROP, envdir))
 //applet:IF_ENVUIDGID(APPLET_ODDNAME(envuidgid, chpst, BB_DIR_USR_BIN, BB_SUID_DROP, envuidgid))
 //applet:IF_SETUIDGID(APPLET_ODDNAME(setuidgid, chpst, BB_DIR_USR_BIN, BB_SUID_DROP, setuidgid))
 //applet:IF_SOFTLIMIT(APPLET_ODDNAME(softlimit, chpst, BB_DIR_USR_BIN, BB_SUID_DROP, softlimit))
@@ -462,6 +463,13 @@ int chpst_main(int argc UNUSED_PARAM, ch
 		xchroot(root);
 	}
 
+	/* nice should be done before xsetuid */
+	if (opt & OPT_n) {
+		errno = 0;
+		if (nice(xatoi(nicestr)) == -1)
+			bb_perror_msg_and_die("nice");
+	}
+
 	if (opt & OPT_u) {
 		if (setgroups(1, &ugid.gid) == -1)
 			bb_perror_msg_and_die("setgroups");
@@ -469,12 +477,6 @@ int chpst_main(int argc UNUSED_PARAM, ch
 		xsetuid(ugid.uid);
 	}
 
-	if (opt & OPT_n) {
-		errno = 0;
-		if (nice(xatoi(nicestr)) == -1)
-			bb_perror_msg_and_die("nice");
-	}
-
 	if (opt & OPT_0)
 		close(STDIN_FILENO);
 	if (opt & OPT_1)
diff -urpN busybox-1.26.2/runit/runsv.c busybox-1.27.0/runit/runsv.c
--- busybox-1.26.2/runit/runsv.c	2016-09-27 18:53:50.000000000 +0200
+++ busybox-1.27.0/runit/runsv.c	2017-07-01 22:51:12.000000000 +0200
@@ -134,9 +134,13 @@ static void fatal2x_cannot(const char *m
 	bb_error_msg_and_die("%s: fatal: can't %s%s", dir, m1, m2);
 	/* was exiting 111 */
 }
+static void warn2_cannot(const char *m1, const char *m2)
+{
+	bb_perror_msg("%s: warning: can't %s%s", dir, m1, m2);
+}
 static void warn_cannot(const char *m)
 {
-	bb_perror_msg("%s: warning: cannot %s", dir, m);
+	warn2_cannot(m, "");
 }
 
 static void s_child(int sig_no UNUSED_PARAM)
@@ -165,10 +169,25 @@ static void update_status(struct svdir *
 	ssize_t sz;
 	int fd;
 	svstatus_t status;
+	const char *fstatus ="log/supervise/status";
+	const char *fstatusnew ="log/supervise/status.new";
+	const char *f_stat ="log/supervise/stat";
+	const char *fstatnew ="log/supervise/stat.new";
+	const char *fpid ="log/supervise/pid";
+	const char *fpidnew ="log/supervise/pid.new";
+
+	if (!s->islog) {
+		fstatus += 4;
+		fstatusnew += 4;
+		f_stat += 4;
+		fstatnew += 4;
+		fpid += 4;
+		fpidnew += 4;
+	}
 
 	/* pid */
 	if (pidchanged) {
-		fd = open_trunc_or_warn("supervise/pid.new");
+		fd = open_trunc_or_warn(fpidnew);
 		if (fd < 0)
 			return;
 		if (s->pid) {
@@ -177,14 +196,13 @@ static void update_status(struct svdir *
 			write(fd, spid, size);
 		}
 		close(fd);
-		if (rename_or_warn("supervise/pid.new",
-				s->islog ? "log/supervise/pid" : "log/supervise/pid"+4))
+		if (rename_or_warn(fpidnew, fpid))
 			return;
 		pidchanged = 0;
 	}
 
 	/* stat */
-	fd = open_trunc_or_warn("supervise/stat.new");
+	fd = open_trunc_or_warn(fstatnew);
 	if (fd < -1)
 		return;
 
@@ -220,8 +238,7 @@ static void update_status(struct svdir *
 		close(fd);
 	}
 
-	rename_or_warn("supervise/stat.new",
-		s->islog ? "log/supervise/stat" : "log/supervise/stat"+4);
+	rename_or_warn(fstatnew, f_stat);
 
 	/* supervise compatibility */
 	memset(&status, 0, sizeof(status));
@@ -237,18 +254,17 @@ static void update_status(struct svdir *
 	if (s->ctrl & C_TERM)
 		status.got_term = 1;
 	status.run_or_finish = s->state;
-	fd = open_trunc_or_warn("supervise/status.new");
+	fd = open_trunc_or_warn(fstatusnew);
 	if (fd < 0)
 		return;
 	sz = write(fd, &status, sizeof(status));
 	close(fd);
 	if (sz != sizeof(status)) {
-		warn_cannot("write supervise/status.new");
-		unlink("supervise/status.new");
+		warn2_cannot("write ", fstatusnew);
+		unlink(fstatusnew);
 		return;
 	}
-	rename_or_warn("supervise/status.new",
-		s->islog ? "log/supervise/status" : "log/supervise/status"+4);
+	rename_or_warn(fstatusnew, fstatus);
 }
 
 static unsigned custom(struct svdir *s, char c)
@@ -266,26 +282,26 @@ static unsigned custom(struct svdir *s,
 		if (st.st_mode & S_IXUSR) {
 			pid = vfork();
 			if (pid == -1) {
-				warn_cannot("vfork for control/?");
+				warn2_cannot("vfork for ", a);
 				return 0;
 			}
 			if (pid == 0) {
 				/* child */
 				if (haslog && dup2(logpipe.wr, 1) == -1)
-					warn_cannot("setup stdout for control/?");
+					warn2_cannot("setup stdout for ", a);
 				execl(a, a, (char *) NULL);
-				fatal_cannot("run control/?");
+				fatal2_cannot("run ", a);
 			}
 			/* parent */
 			if (safe_waitpid(pid, &w, 0) == -1) {
-				warn_cannot("wait for child control/?");
+				warn2_cannot("wait for child ", a);
 				return 0;
 			}
 			return WEXITSTATUS(w) == 0;
 		}
 	} else {
 		if (errno != ENOENT)
-			warn_cannot("stat control/?");
+			warn2_cannot("stat ", a);
 	}
 	return 0;
 }
@@ -387,13 +403,13 @@ static int ctrl(struct svdir *s, char c)
 	case 'd': /* down */
 		s->sd_want = W_DOWN;
 		update_status(s);
-		if (s->pid && s->state != S_FINISH)
+		if (s->state == S_RUN)
 			stopservice(s);
 		break;
 	case 'u': /* up */
 		s->sd_want = W_UP;
 		update_status(s);
-		if (s->pid == 0)
+		if (s->state == S_DOWN)
 			startservice(s);
 		break;
 	case 'x': /* exit */
@@ -403,22 +419,22 @@ static int ctrl(struct svdir *s, char c)
 		update_status(s);
 		/* FALLTHROUGH */
 	case 't': /* sig term */
-		if (s->pid && s->state != S_FINISH)
+		if (s->state == S_RUN)
 			stopservice(s);
 		break;
 	case 'k': /* sig kill */
-		if (s->pid && !custom(s, c))
+		if ((s->state == S_RUN) && !custom(s, c))
 			kill(s->pid, SIGKILL);
 		s->state = S_DOWN;
 		break;
 	case 'p': /* sig pause */
-		if (s->pid && !custom(s, c))
+		if ((s->state == S_RUN) && !custom(s, c))
 			kill(s->pid, SIGSTOP);
 		s->ctrl |= C_PAUSE;
 		update_status(s);
 		break;
 	case 'c': /* sig cont */
-		if (s->pid && !custom(s, c))
+		if ((s->state == S_RUN) && !custom(s, c))
 			kill(s->pid, SIGCONT);
 		s->ctrl &= ~C_PAUSE;
 		update_status(s);
@@ -426,7 +442,7 @@ static int ctrl(struct svdir *s, char c)
 	case 'o': /* once */
 		s->sd_want = W_DOWN;
 		update_status(s);
-		if (!s->pid)
+		if (s->state == S_DOWN)
 			startservice(s);
 		break;
 	case 'a': /* sig alarm */
@@ -450,11 +466,26 @@ static int ctrl(struct svdir *s, char c)
 	}
 	return 1;
  sendsig:
-	if (s->pid && !custom(s, c))
+	if ((s->state == S_RUN) && !custom(s, c))
 		kill(s->pid, sig);
 	return 1;
 }
 
+static void open_control(const char *f, struct svdir *s)
+{
+	struct stat st;
+	mkfifo(f, 0600);
+	if (stat(f, &st) == -1)
+		fatal2_cannot("stat ", f);
+	if (!S_ISFIFO(st.st_mode))
+		bb_error_msg_and_die("%s: fatal: %s exists but is not a fifo", dir, f);
+	s->fdcontrol = xopen(f, O_RDONLY|O_NDELAY);
+	close_on_exec_on(s->fdcontrol);
+	s->fdcontrolwrite = xopen(f, O_WRONLY|O_NDELAY);
+	close_on_exec_on(s->fdcontrolwrite);
+	update_status(s);
+}
+
 int runsv_main(int argc, char **argv) MAIN_EXTERNALLY_VISIBLE;
 int runsv_main(int argc UNUSED_PARAM, char **argv)
 {
@@ -554,19 +585,9 @@ int runsv_main(int argc UNUSED_PARAM, ch
 		close_on_exec_on(svd[1].fdlock);
 	}
 
-	mkfifo("log/supervise/control"+4, 0600);
-	svd[0].fdcontrol = xopen("log/supervise/control"+4, O_RDONLY|O_NDELAY);
-	close_on_exec_on(svd[0].fdcontrol);
-	svd[0].fdcontrolwrite = xopen("log/supervise/control"+4, O_WRONLY|O_NDELAY);
-	close_on_exec_on(svd[0].fdcontrolwrite);
-	update_status(&svd[0]);
+	open_control("log/supervise/control"+4, &svd[0]);
 	if (haslog) {
-		mkfifo("log/supervise/control", 0600);
-		svd[1].fdcontrol = xopen("log/supervise/control", O_RDONLY|O_NDELAY);
-		close_on_exec_on(svd[1].fdcontrol);
-		svd[1].fdcontrolwrite = xopen("log/supervise/control", O_WRONLY|O_NDELAY);
-		close_on_exec_on(svd[1].fdcontrolwrite);
-		update_status(&svd[1]);
+		open_control("log/supervise/control", &svd[1]);
 	}
 	mkfifo("log/supervise/ok"+4, 0600);
 	fd = xopen("log/supervise/ok"+4, O_RDONLY|O_NDELAY);
diff -urpN busybox-1.26.2/runit/sv.c busybox-1.27.0/runit/sv.c
--- busybox-1.26.2/runit/sv.c	2016-12-10 18:46:36.000000000 +0100
+++ busybox-1.27.0/runit/sv.c	2017-07-01 22:51:12.000000000 +0200
@@ -25,7 +25,7 @@ OTHERWISE) ARISING IN ANY WAY OUT OF THE
 ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */
 
-/* Taken from http://smarden.sunsite.dk/runit/sv.8.html:
+/* Taken from http://smarden.org/runit/sv.8.html:
 
 sv - control and manage services monitored by runsv
 
@@ -36,17 +36,13 @@ The sv program reports the current statu
 monitored by the runsv(8) supervisor.
 
 services consists of one or more arguments, each argument naming a directory
-service used by runsv(8). If service doesn't start with a dot or slash,
-it is searched in the default services directory /var/service/, otherwise
-relative to the current directory.
+service used by runsv(8). If service doesn't start with a dot or slash and
+doesn't end with a slash, it is searched in the default services directory
+/var/service/, otherwise relative to the current directory.
 
 command is one of up, down, status, once, pause, cont, hup, alarm, interrupt,
-1, 2, term, kill, or exit, or start, stop, restart, shutdown, force-stop,
-force-reload, force-restart, force-shutdown.
-
-The sv program can be sym-linked to /etc/init.d/ to provide an LSB init
-script interface. The service to be controlled then is specified by the
-base name of the "init script".
+1, 2, term, kill, or exit, or start, stop, reload, restart, shutdown,
+force-stop, force-reload, force-restart, force-shutdown, try-restart.
 
 status
     Report the current status of the service, and the appendant log service
@@ -66,9 +62,9 @@ exit
     If the service is running, send it the TERM signal, and the CONT signal.
     Do not restart the service. If the service is down, and no log service
     exists, runsv(8) exits. If the service is down and a log service exists,
-    send the TERM signal to the log service. If the log service is down,
-    runsv(8) exits. This command is ignored if it is given to an appendant
-    log service.
+    runsv(8) closes the standard input of the log service and waits for it to
+    terminate. If the log service is down, runsv(8) exits. This command is
+    ignored if it is given to an appendant log service.
 
 sv actually looks only at the first character of above commands.
 
@@ -85,6 +81,8 @@ start
 stop
     Same as down, but wait up to 7 seconds for the service to become down.
     Then report the status or timeout.
+reload
+    Same as hup, and additionally report the status afterwards.
 restart
     Send the commands term, cont, and up to the service, and wait up to
     7 seconds for the service to restart. Then report the status or timeout.
@@ -112,6 +110,9 @@ force-shutdown
     Same as exit, but wait up to 7 seconds for the runsv(8) process to
     terminate. Then report the status, and on timeout send the service
     the kill command.
+try-restart
+    if the service is running, send it the term and cont commands, and wait up to
+    7 seconds for the service to restart. Then report the status or timeout.
 
 Additional Commands
 
@@ -126,8 +127,8 @@ check
 Options
 
 -v
-    wait up to 7 seconds for the command to take effect.
-    Then report the status or timeout.
+    If the command is up, down, term, once, cont, or exit, then wait up to 7
+    seconds for the command to take effect. Then report the status or timeout.
 -w sec
     Override the default timeout of 7 seconds with sec seconds. Implies -v.
 
@@ -192,6 +193,7 @@ struct globals {
 /* "Bernstein" time format: unix + 0x400000000000000aULL */
 	uint64_t tstart, tnow;
 	svstatus_t svstatus;
+	unsigned islog;
 } FIX_ALIASING;
 #define G (*(struct globals*)bb_common_bufsiz1)
 #define acts         (G.acts        )
@@ -200,6 +202,7 @@ struct globals {
 #define tstart       (G.tstart      )
 #define tnow         (G.tnow        )
 #define svstatus     (G.svstatus    )
+#define islog        (G.islog       )
 #define INIT_G() do { setup_common_bufsiz(); } while (0)
 
 
@@ -215,7 +218,7 @@ static void fatal_cannot(const char *m1)
 
 static void out(const char *p, const char *m1)
 {
-	printf("%s%s: %s", p, *service, m1);
+	printf("%s%s%s: %s", p, *service, islog ? "/log" : "", m1);
 	if (errno) {
 		printf(": %s", strerror(errno));
 	}
@@ -300,15 +303,14 @@ static unsigned svstatus_print(const cha
 	}
 	pid = SWAP_LE32(svstatus.pid_le32);
 	timestamp = SWAP_BE64(svstatus.time_be64);
-	if (pid) {
-		switch (svstatus.run_or_finish) {
+	switch (svstatus.run_or_finish) {
+		case 0: printf("down: "); break;
 		case 1: printf("run: "); break;
 		case 2: printf("finish: "); break;
-		}
-		printf("%s: (pid %d) ", m, pid);
-	} else {
-		printf("down: %s: ", m);
 	}
+	printf("%s: ", m);
+	if (svstatus.run_or_finish)
+		printf("(pid %d) ", pid);
 	diff = tnow - timestamp;
 	printf("%us", (diff < 0 ? 0 : diff));
 	if (pid) {
@@ -331,16 +333,21 @@ static int status(const char *unused UNU
 		return 0;
 
 	r = svstatus_print(*service);
+	islog = 1;
 	if (chdir("log") == -1) {
 		if (errno != ENOENT) {
-			printf("; log: "WARN"can't change to log service directory: %s",
-					strerror(errno));
-		}
-	} else if (svstatus_get()) {
+			printf("; ");
+			warn("can't change directory");
+		} else
+			bb_putchar('\n');
+	} else {
 		printf("; ");
-		svstatus_print("log");
+		if (svstatus_get()) {
+			r = svstatus_print("log");
+			bb_putchar('\n');
+		}
 	}
-	bb_putchar('\n'); /* will also flush the output */
+	islog = 0;
 	return r;
 }
 
@@ -379,35 +386,53 @@ static int check(const char *a)
 	r = svstatus_get();
 	if (r == -1)
 		return -1;
-	if (r == 0) {
-		if (*a == 'x')
-			return 1;
-		return -1;
-	}
-	pid_le32 = svstatus.pid_le32;
-	switch (*a) {
-	case 'x':
-		return 0;
-	case 'u':
-		if (!pid_le32 || svstatus.run_or_finish != 1) return 0;
-		if (!checkscript()) return 0;
-		break;
-	case 'd':
-		if (pid_le32) return 0;
-		break;
-	case 'c':
-		if (pid_le32 && !checkscript()) return 0;
-		break;
-	case 't':
-		if (!pid_le32 && svstatus.want == 'd') break;
-		timestamp = SWAP_BE64(svstatus.time_be64);
-		if ((tstart > timestamp) || !pid_le32 || svstatus.got_term || !checkscript())
-			return 0;
-		break;
-	case 'o':
-		timestamp = SWAP_BE64(svstatus.time_be64);
-		if ((!pid_le32 && tstart > timestamp) || (pid_le32 && svstatus.want != 'd'))
+	while (*a) {
+		if (r == 0) {
+			if (*a == 'x')
+				return 1;
+			return -1;
+		}
+		pid_le32 = svstatus.pid_le32;
+		switch (*a) {
+		case 'x':
 			return 0;
+		case 'u':
+			if (!pid_le32 || svstatus.run_or_finish != 1)
+				return 0;
+			if (!checkscript())
+				return 0;
+			break;
+		case 'd':
+			if (pid_le32 || svstatus.run_or_finish != 0)
+				return 0;
+			break;
+		case 'C':
+			if (pid_le32 && !checkscript())
+				return 0;
+			break;
+		case 't':
+		case 'k':
+			if (!pid_le32 && svstatus.want == 'd')
+				break;
+			timestamp = SWAP_BE64(svstatus.time_be64);
+			if ((tstart > timestamp) || !pid_le32 || svstatus.got_term || !checkscript())
+				return 0;
+			break;
+		case 'o':
+			timestamp = SWAP_BE64(svstatus.time_be64);
+			if ((!pid_le32 && tstart > timestamp) || (pid_le32 && svstatus.want != 'd'))
+				return 0;
+			break;
+		case 'p':
+			if (pid_le32 && !svstatus.paused)
+				return 0;
+			break;
+		case 'c':
+			if (pid_le32 && svstatus.paused)
+				return 0;
+			break;
+		}
+		++a;
 	}
 	printf(OK);
 	svstatus_print(*service);
@@ -419,14 +444,10 @@ static int control(const char *a)
 {
 	int fd, r, l;
 
-/* Is it an optimization?
-   It causes problems with "sv o SRV; ...; sv d SRV"
-   ('d' is not passed to SRV because its .want == 'd'):
 	if (svstatus_get() <= 0)
 		return -1;
-	if (svstatus.want == *a)
+	if (svstatus.want == *a && (*a != 'd' || svstatus.got_term == 1))
 		return 0;
-*/
 	fd = open("supervise/control", O_WRONLY|O_NDELAY);
 	if (fd == -1) {
 		if (errno != ENODEV)
@@ -516,17 +537,23 @@ static int sv(char **argv)
 		acts = "tc";
 		kll = 1;
 		break;
+	case 't':
+		if (str_equal(action, "try-restart")) {
+			acts = "tc";
+			break;
+		}
 	case 'c':
 		if (str_equal(action, "check")) {
 			act = NULL;
-			acts = "c";
+			acts = "C";
 			break;
 		}
-	case 'u': case 'd': case 'o': case 't': case 'p': case 'h':
+	case 'u': case 'd': case 'o': case 'p': case 'h':
 	case 'a': case 'i': case 'k': case 'q': case '1': case '2':
 		action[1] = '\0';
 		acts = action;
-		if (!verbose) cbk = NULL;
+		if (!verbose)
+			cbk = NULL;
 		break;
 	case 's':
 		if (str_equal(action, "shutdown")) {
@@ -550,6 +577,10 @@ static int sv(char **argv)
 			acts = "tcu";
 			break;
 		}
+		if (str_equal(action, "reload")) {
+			acts = "h";
+			break;
+		}
 		bb_show_usage();
 	case 'f':
 		if (str_equal(action, "force-reload")) {
@@ -578,7 +609,9 @@ static int sv(char **argv)
 
 	service = argv;
 	while ((x = *service) != NULL) {
-		if (x[0] != '/' && x[0] != '.') {
+		if (x[0] != '/' && x[0] != '.'
+		 && x[0] != '\0' && x[strlen(x) - 1] != '/'
+		) {
 			if (chdir(varservice) == -1)
 				goto chdir_failed_0;
 		}
@@ -688,12 +721,7 @@ int svc_main(int argc UNUSED_PARAM, char
 	/* getopt32() was already called:
 	 * reset the libc getopt() function, which keeps internal state.
 	 */
-#ifdef __GLIBC__
-	optind = 0;
-#else /* BSD style */
-	optind = 1;
-	/* optreset = 1; */
-#endif
+	GETOPT_RESET();
 
 	do {
 		if (opts & 1) {
diff -urpN busybox-1.26.2/runit/svlogd.c busybox-1.27.0/runit/svlogd.c
--- busybox-1.26.2/runit/svlogd.c	2016-09-27 18:53:50.000000000 +0200
+++ busybox-1.27.0/runit/svlogd.c	2017-07-01 22:51:12.000000000 +0200
@@ -137,9 +137,9 @@ log message, you can use a pattern like
 //kbuild:lib-$(CONFIG_SVLOGD) += svlogd.o
 
 //usage:#define svlogd_trivial_usage
-//usage:       "[-ttv] [-r C] [-R CHARS] [-l MATCHLEN] [-b BUFLEN] DIR..."
+//usage:       "[-tttv] [-r C] [-R CHARS] [-l MATCHLEN] [-b BUFLEN] DIR..."
 //usage:#define svlogd_full_usage "\n\n"
-//usage:       "Continuously read log data from stdin and write to rotated log files in DIRs"
+//usage:       "Read log data from stdin and write to rotated log files in DIRs"
 //usage:   "\n"
 //usage:   "\n""DIR/config file modifies behavior:"
 //usage:   "\n""sSIZE - when to rotate logs"
@@ -339,17 +339,18 @@ static unsigned pmatch(const char *p, co
 /*** ex fmt_ptime.[ch] ***/
 
 /* NUL terminated */
-static void fmt_time_human_30nul(char *s)
+static void fmt_time_human_30nul(char *s, char dt_delim)
 {
 	struct tm *ptm;
 	struct timeval tv;
 
 	gettimeofday(&tv, NULL);
 	ptm = gmtime(&tv.tv_sec);
-	sprintf(s, "%04u-%02u-%02u_%02u:%02u:%02u.%06u000",
+	sprintf(s, "%04u-%02u-%02u%c%02u:%02u:%02u.%06u000",
 		(unsigned)(1900 + ptm->tm_year),
 		(unsigned)(ptm->tm_mon + 1),
 		(unsigned)(ptm->tm_mday),
+		dt_delim,
 		(unsigned)(ptm->tm_hour),
 		(unsigned)(ptm->tm_min),
 		(unsigned)(ptm->tm_sec),
@@ -1160,8 +1161,8 @@ int svlogd_main(int argc, char **argv)
 		if (timestamp) {
 			if (timestamp == 1)
 				fmt_time_bernstein_25(stamp);
-			else /* 2: */
-				fmt_time_human_30nul(stamp);
+			else /* 2+: */
+				fmt_time_human_30nul(stamp, timestamp == 2 ? '_' : 'T');
 			printlen += 26;
 			printptr -= 26;
 			memcpy(printptr, stamp, 25);
diff -urpN busybox-1.26.2/scripts/gen_build_files.sh busybox-1.27.0/scripts/gen_build_files.sh
--- busybox-1.26.2/scripts/gen_build_files.sh	2016-09-27 18:53:50.000000000 +0200
+++ busybox-1.27.0/scripts/gen_build_files.sh	2017-01-25 01:56:57.000000000 +0100
@@ -20,7 +20,9 @@ chk() { status "CHK" "$@"; }
 generate()
 {
 	# NB: data to be inserted at INSERT line is coming on stdin
-	local src="$1" dst="$2" header="$3"
+	src="$1"
+	dst="$2"
+	header="$3"
 	#chk "${dst}"
 	{
 		# Need to use printf: different shells have inconsistent
diff -urpN busybox-1.26.2/scripts/randomtest busybox-1.27.0/scripts/randomtest
--- busybox-1.26.2/scripts/randomtest	2016-09-27 18:53:50.000000000 +0200
+++ busybox-1.27.0/scripts/randomtest	2017-07-03 11:14:04.000000000 +0200
@@ -82,6 +82,9 @@ if test x"$LIBC" = x"uclibc"; then
 	| grep -v CONFIG_BLKDISCARD \
 	| grep -v CONFIG_NSENTER \
 	| grep -v CONFIG_UNSHARE \
+	| grep -v CONFIG_FALLOCATE \
+	| grep -v CONFIG_UDHCPC6 \
+	| grep -v CONFIG_ASH_INTERNAL_GLOB \
 	>.config.new
 	mv .config.new .config
 	echo 'CONFIG_STATIC=y' >>.config
@@ -96,6 +99,9 @@ if test x"$LIBC" = x"uclibc"; then
 	echo '# CONFIG_BLKDISCARD is not set' >>.config
 	echo '# CONFIG_NSENTER is not set' >>.config
 	echo '# CONFIG_UNSHARE is not set' >>.config
+	echo '# CONFIG_FALLOCATE is not set' >>.config
+	echo '# CONFIG_UDHCPC6 is not set' >>.config
+	echo 'CONFIG_ASH_INTERNAL_GLOB=y' >>.config
 fi
 
 # If STATIC, remove some things.
diff -urpN busybox-1.26.2/scripts/trylink busybox-1.27.0/scripts/trylink
--- busybox-1.26.2/scripts/trylink	2016-09-27 18:53:50.000000000 +0200
+++ busybox-1.27.0/scripts/trylink	2017-01-25 01:56:57.000000000 +0100
@@ -46,8 +46,7 @@ try() {
 }
 
 check_cc() {
-    local tempname="$(mktemp tmp.XXXXXXXXXX)"
-    local r
+    tempname="$(mktemp tmp.XXXXXXXXXX)"
     echo "int main(int argc,char**argv){return argv?argc:0;}" >"$tempname".c
     # Can use "-o /dev/null", but older gcc tend to *unlink it* on failure! :(
     # Was using "-xc /dev/null", but we need a valid C program.
@@ -55,14 +54,13 @@ check_cc() {
     # '... -D"BB_VER=KBUILD_STR(1.N.M)" ...'
     # and we need shell to process quotes!
     $CC $CFLAGS $LDFLAGS $1 "$tempname".c -o "$tempname" >/dev/null 2>&1
-    r=$?
+    exitcode=$?
     rm -f "$tempname" "$tempname".c "$tempname".o
-    return $r
+    return $exitcode
 }
 
 check_libc_is_glibc() {
-    local tempname="$(mktemp tmp.XXXXXXXXXX)"
-    local r
+    tempname="$(mktemp tmp.XXXXXXXXXX)"
     echo "\
 	#include <stdlib.h>
 	/* Apparently uclibc defines __GLIBC__ (compat trick?). Oh well. */
@@ -71,9 +69,9 @@ check_libc_is_glibc() {
 	#endif
 	" >"$tempname".c
     ! $CC $CFLAGS "$tempname".c -c -o "$tempname".o >/dev/null 2>&1
-    r=$?
+    exitcode=$?
     rm -f "$tempname" "$tempname".c "$tempname".o
-    return $r
+    return $exitcode
 }
 
 EXE="$1"
diff -urpN busybox-1.26.2/selinux/chcon.c busybox-1.27.0/selinux/chcon.c
--- busybox-1.26.2/selinux/chcon.c	2016-12-10 18:46:36.000000000 +0100
+++ busybox-1.27.0/selinux/chcon.c	2017-01-23 01:09:41.000000000 +0100
@@ -18,8 +18,6 @@
 //config:	bool "Enable long options"
 //config:	default y
 //config:	depends on CHCON && LONG_OPTS
-//config:	help
-//config:	  Support long options for the chcon applet.
 
 //applet:IF_CHCON(APPLET(chcon, BB_DIR_USR_BIN, BB_SUID_DROP))
 
@@ -38,11 +36,11 @@
 //usage:     "\n	-c,--changes		Report changes made"
 //usage:     "\n	-h,--no-dereference	Affect symlinks instead of their targets"
 //usage:     "\n	-f,--silent,--quiet	Suppress most error messages"
-//usage:     "\n	--reference=RFILE	Use RFILE's group instead of using a CONTEXT value"
-//usage:     "\n	-u,--user=USER		Set user/role/type/range in the target"
-//usage:     "\n	-r,--role=ROLE		security context"
-//usage:     "\n	-t,--type=TYPE"
-//usage:     "\n	-l,--range=RANGE"
+//usage:     "\n	--reference RFILE	Use RFILE's group instead of using a CONTEXT value"
+//usage:     "\n	-u,--user USER		Set user/role/type/range in the target"
+//usage:     "\n	-r,--role ROLE		security context"
+//usage:     "\n	-t,--type TYPE"
+//usage:     "\n	-l,--range RANGE"
 //usage:     "\n	-R,--recursive		Recurse"
 //usage:	)
 //usage:	IF_NOT_FEATURE_CHCON_LONG_OPTIONS(
diff -urpN busybox-1.26.2/selinux/runcon.c busybox-1.27.0/selinux/runcon.c
--- busybox-1.26.2/selinux/runcon.c	2017-01-01 13:01:04.000000000 +0100
+++ busybox-1.27.0/selinux/runcon.c	2017-01-23 01:09:41.000000000 +0100
@@ -39,8 +39,6 @@
 //config:	bool "Enable long options"
 //config:	default y
 //config:	depends on RUNCON && LONG_OPTS
-//config:	help
-//config:	  Support long options for the runcon applet.
 
 //applet:IF_RUNCON(APPLET(runcon, BB_DIR_USR_BIN, BB_SUID_DROP))
 
@@ -54,10 +52,10 @@
 //usage:     "\n	CONTEXT		Complete security context\n"
 //usage:	IF_FEATURE_RUNCON_LONG_OPTIONS(
 //usage:     "\n	-c,--compute	Compute process transition context before modifying"
-//usage:     "\n	-t,--type=TYPE	Type (for same role as parent)"
-//usage:     "\n	-u,--user=USER	User identity"
-//usage:     "\n	-r,--role=ROLE	Role"
-//usage:     "\n	-l,--range=RNG	Levelrange"
+//usage:     "\n	-t,--type TYPE	Type (for same role as parent)"
+//usage:     "\n	-u,--user USER	User identity"
+//usage:     "\n	-r,--role ROLE	Role"
+//usage:     "\n	-l,--range RNG	Levelrange"
 //usage:	)
 //usage:	IF_NOT_FEATURE_RUNCON_LONG_OPTIONS(
 //usage:     "\n	-c	Compute process transition context before modifying"
diff -urpN busybox-1.26.2/selinux/setfiles.c busybox-1.27.0/selinux/setfiles.c
--- busybox-1.26.2/selinux/setfiles.c	2016-12-10 18:46:36.000000000 +0100
+++ busybox-1.27.0/selinux/setfiles.c	2017-01-30 21:57:30.000000000 +0100
@@ -30,6 +30,7 @@
 //config:	  the same as setfiles, but usage is a little different.
 
 //applet:IF_SETFILES(APPLET(setfiles, BB_DIR_SBIN, BB_SUID_DROP))
+//                     APPLET_ODDNAME:name        main      location     suid_type     help
 //applet:IF_RESTORECON(APPLET_ODDNAME(restorecon, setfiles, BB_DIR_SBIN, BB_SUID_DROP, restorecon))
 
 //kbuild:lib-$(CONFIG_SETFILES) += setfiles.o
diff -urpN busybox-1.26.2/shell/Config.src busybox-1.27.0/shell/Config.src
--- busybox-1.26.2/shell/Config.src	2017-01-01 13:01:05.000000000 +0100
+++ busybox-1.27.0/shell/Config.src	2017-01-30 21:57:30.000000000 +0100
@@ -17,9 +17,19 @@ choice
 config SH_IS_ASH
 	depends on !NOMMU
 	bool "ash"
+	help
+	  Choose ash to be the shell executed by 'sh' name.
+	  The ash code will be built into busybox. If you don't select
+	  "ash" choice (CONFIG_ASH), this shell may only be invoked by
+	  the name 'sh' (and not 'ash').
 
 config SH_IS_HUSH
 	bool "hush"
+	help
+	  Choose hush to be the shell executed by 'sh' name.
+	  The hush code will be built into busybox. If you don't select
+	  "hush" choice (CONFIG_HUSH), this shell may only be invoked by
+	  the name 'sh' (and not 'hush').
 
 config SH_IS_NONE
 	bool "none"
@@ -31,7 +41,8 @@ choice
 	default BASH_IS_NONE
 	help
 	  Choose which shell you want to be executed by 'bash' alias.
-	  The ash shell is the most bash compatible and full featured one.
+	  The ash shell is the most bash compatible and full featured one,
+	  although compatibility is far from being complete.
 
 	  Note that selecting this option does not switch on any bash
 	  compatibility code. It merely makes it possible to install
@@ -46,9 +57,19 @@ choice
 config BASH_IS_ASH
 	depends on !NOMMU
 	bool "ash"
+	help
+	  Choose ash to be the shell executed by 'bash' name.
+	  The ash code will be built into busybox. If you don't select
+	  "ash" choice (CONFIG_ASH), this shell may only be invoked by
+	  the name 'bash' (and not 'ash').
 
 config BASH_IS_HUSH
 	bool "hush"
+	help
+	  Choose hush to be the shell executed by 'bash' name.
+	  The hush code will be built into busybox. If you don't select
+	  "hush" choice (CONFIG_HUSH), this shell may only be invoked by
+	  the name 'bash' (and not 'hush').
 
 config BASH_IS_NONE
 	bool "none"
@@ -59,6 +80,9 @@ endchoice
 INSERT
 
 
+comment "Options common to all shells"
+if ASH || HUSH || SH_IS_ASH || BASH_IS_ASH || SH_IS_HUSH || BASH_IS_HUSH
+
 config FEATURE_SH_MATH
 	bool "POSIX math support"
 	default y
@@ -97,23 +121,11 @@ config FEATURE_SH_STANDALONE
 	  for use as a rescue shell, in the event that you screw up your system.
 
 	  This is implemented by re-execing /proc/self/exe (typically)
-	  with right parameters. Some selected applets ("NOFORK" applets)
-	  can even be executed without creating new process.
-	  Instead, busybox will call <applet>_main() internally.
-
-	  However, this causes problems in chroot jails without mounted /proc
-	  and with ps/top (command name can be shown as 'exe' for applets
-	  started this way).
-# untrue?
-#	  Note that this will *also* cause applets to take precedence
-#	  over shell builtins of the same name. So turning this on will
-#	  eliminate any performance gained by turning on the builtin "echo"
-#	  and "test" commands in ash.
-# untrue?
-#	  Note that when using this option, the shell will attempt to directly
-#	  run '/bin/busybox'. If you do not have the busybox binary sitting in
-#	  that exact location with that exact name, this option will not work at
-#	  all.
+	  with right parameters.
+
+	  However, there are drawbacks: it is problematic in chroot jails
+	  without mounted /proc, and ps/top may show command name as 'exe'
+	  for applets started this way.
 
 config FEATURE_SH_NOFORK
 	bool "Run 'nofork' applets directly"
@@ -142,5 +154,6 @@ config FEATURE_SH_HISTFILESIZE
 	  to set shell history size. Note that its max value is capped
 	  by "History size" setting in library tuning section.
 
+endif # Options common to all shells
 
 endmenu
diff -urpN busybox-1.26.2/shell/ash.c busybox-1.27.0/shell/ash.c
--- busybox-1.26.2/shell/ash.c	2017-01-10 16:55:51.000000000 +0100
+++ busybox-1.27.0/shell/ash.c	2017-07-01 23:26:12.000000000 +0200
@@ -26,12 +26,15 @@
 //config:	  shell (by Herbert Xu), which was created by porting the 'ash' shell
 //config:	  (written by Kenneth Almquist) from NetBSD.
 //config:
+//config:# ash options
+//config:# note: Don't remove !NOMMU part in the next line; it would break
+//config:# menuconfig's indenting.
+//config:if !NOMMU && (ASH || SH_IS_ASH || BASH_IS_ASH)
+//config:
 //config:config ASH_OPTIMIZE_FOR_SIZE
 //config:	bool "Optimize for size instead of speed"
 //config:	default y
 //config:	depends on ASH || SH_IS_ASH || BASH_IS_ASH
-//config:	help
-//config:	  Compile ash for reduced size at the price of speed.
 //config:
 //config:config ASH_INTERNAL_GLOB
 //config:	bool "Use internal glob() implementation"
@@ -41,6 +44,23 @@
 //config:	  Do not use glob() function from libc, use internal implementation.
 //config:	  Use this if you are getting "glob.h: No such file or directory"
 //config:	  or similar build errors.
+//config:	  Note that as of now (2017-01), uclibc and musl glob() both have bugs
+//config:	  which would break ash if you select N here.
+//config:
+//config:config ASH_BASH_COMPAT
+//config:	bool "bash-compatible extensions"
+//config:	default y
+//config:	depends on ASH || SH_IS_ASH || BASH_IS_ASH
+//config:
+//config:config ASH_JOB_CONTROL
+//config:	bool "Job control"
+//config:	default y
+//config:	depends on ASH || SH_IS_ASH || BASH_IS_ASH
+//config:
+//config:config ASH_ALIAS
+//config:	bool "Alias support"
+//config:	default y
+//config:	depends on ASH || SH_IS_ASH || BASH_IS_ASH
 //config:
 //config:config ASH_RANDOM_SUPPORT
 //config:	bool "Pseudorandom generator and $RANDOM variable"
@@ -58,91 +78,66 @@
 //config:	default y
 //config:	depends on ASH || SH_IS_ASH || BASH_IS_ASH
 //config:	help
-//config:	  "PS#" may contain volatile content, such as backquote commands.
+//config:	  $PS# may contain volatile content, such as backquote commands.
 //config:	  This option recreates the prompt string from the environment
 //config:	  variable each time it is displayed.
 //config:
-//config:config ASH_BASH_COMPAT
-//config:	bool "bash-compatible extensions"
-//config:	default y
-//config:	depends on ASH || SH_IS_ASH || BASH_IS_ASH
-//config:	help
-//config:	  Enable bash-compatible extensions.
-//config:
 //config:config ASH_IDLE_TIMEOUT
-//config:	bool "Idle timeout variable"
-//config:	default n
-//config:	depends on ASH || SH_IS_ASH || BASH_IS_ASH
-//config:	help
-//config:	  Enables bash-like auto-logout after $TMOUT seconds of idle time.
-//config:
-//config:config ASH_JOB_CONTROL
-//config:	bool "Job control"
-//config:	default y
-//config:	depends on ASH || SH_IS_ASH || BASH_IS_ASH
-//config:	help
-//config:	  Enable job control in the ash shell.
-//config:
-//config:config ASH_ALIAS
-//config:	bool "Alias support"
+//config:	bool "Idle timeout variable $TMOUT"
 //config:	default y
 //config:	depends on ASH || SH_IS_ASH || BASH_IS_ASH
 //config:	help
-//config:	  Enable alias support in the ash shell.
+//config:	  Enable bash-like auto-logout after $TMOUT seconds of idle time.
 //config:
-//config:config ASH_GETOPTS
-//config:	bool "Builtin getopt to parse positional parameters"
+//config:config ASH_MAIL
+//config:	bool "Check for new mail in interactive shell"
 //config:	default y
 //config:	depends on ASH || SH_IS_ASH || BASH_IS_ASH
 //config:	help
-//config:	  Enable support for getopts builtin in ash.
+//config:	  Enable "check for new mail" function:
+//config:	  if set, $MAIL file and $MAILPATH list of files
+//config:	  are checked for mtime changes, and "you have mail"
+//config:	  message is printed if change is detected.
 //config:
-//config:config ASH_BUILTIN_ECHO
-//config:	bool "Builtin version of 'echo'"
+//config:config ASH_ECHO
+//config:	bool "echo builtin"
 //config:	default y
 //config:	depends on ASH || SH_IS_ASH || BASH_IS_ASH
-//config:	help
-//config:	  Enable support for echo builtin in ash.
 //config:
-//config:config ASH_BUILTIN_PRINTF
-//config:	bool "Builtin version of 'printf'"
+//config:config ASH_PRINTF
+//config:	bool "printf builtin"
 //config:	default y
 //config:	depends on ASH || SH_IS_ASH || BASH_IS_ASH
-//config:	help
-//config:	  Enable support for printf builtin in ash.
 //config:
-//config:config ASH_BUILTIN_TEST
-//config:	bool "Builtin version of 'test'"
+//config:config ASH_TEST
+//config:	bool "test builtin"
 //config:	default y
 //config:	depends on ASH || SH_IS_ASH || BASH_IS_ASH
-//config:	help
-//config:	  Enable support for test builtin in ash.
 //config:
 //config:config ASH_HELP
 //config:	bool "help builtin"
 //config:	default y
 //config:	depends on ASH || SH_IS_ASH || BASH_IS_ASH
-//config:	help
-//config:	  Enable help builtin in ash.
 //config:
-//config:config ASH_CMDCMD
-//config:	bool "'command' command to override shell builtins"
+//config:config ASH_GETOPTS
+//config:	bool "getopts builtin"
 //config:	default y
 //config:	depends on ASH || SH_IS_ASH || BASH_IS_ASH
-//config:	help
-//config:	  Enable support for the ash 'command' builtin, which allows
-//config:	  you to run the specified command with the specified arguments,
-//config:	  even when there is an ash builtin command with the same name.
 //config:
-//config:config ASH_MAIL
-//config:	bool "Check for new mail on interactive shells"
+//config:config ASH_CMDCMD
+//config:	bool "command builtin"
 //config:	default y
 //config:	depends on ASH || SH_IS_ASH || BASH_IS_ASH
 //config:	help
-//config:	  Enable "check for new mail" function in the ash shell.
+//config:	  Enable support for the 'command' builtin, which allows
+//config:	  you to run the specified command or builtin,
+//config:	  even when there is a function with the same name.
+//config:
+//config:endif # ash options
 
 //applet:IF_ASH(APPLET(ash, BB_DIR_BIN, BB_SUID_DROP))
-//applet:IF_SH_IS_ASH(APPLET_ODDNAME(sh, ash, BB_DIR_BIN, BB_SUID_DROP, ash))
+//                      APPLET_ODDNAME:name  main location    suid_type     help
+//applet:IF_SH_IS_ASH(  APPLET_ODDNAME(sh,   ash, BB_DIR_BIN, BB_SUID_DROP, ash))
 //applet:IF_BASH_IS_ASH(APPLET_ODDNAME(bash, ash, BB_DIR_BIN, BB_SUID_DROP, ash))
 
 //kbuild:lib-$(CONFIG_ASH) += ash.o ash_ptr_hack.o shell_common.o
@@ -151,15 +146,10 @@
 //kbuild:lib-$(CONFIG_ASH_RANDOM_SUPPORT) += random.o
 
 /*
- * The following should be set to reflect the type of system you have:
- *      JOBS -> 1 if you have Berkeley job control, 0 otherwise.
- *      define SYSV if you are running under System V.
- *      define DEBUG=1 to compile in debugging ('set -o debug' to turn on)
- *      define DEBUG=2 to compile in and turn on debugging.
- *
- * When debugging is on (DEBUG is 1 and "set -o debug" was executed),
- * debugging info will be written to ./trace and a quit signal
- * will generate a core dump.
+ * DEBUG=1 to compile in debugging ('set -o debug' turns on)
+ * DEBUG=2 to compile in and turn on debugging.
+ * When debugging is on ("set -o debug" was executed, or DEBUG=2),
+ * debugging info is written to ./trace, quit signal generates core dump.
  */
 #define DEBUG 0
 /* Tweak debug output verbosity here */
@@ -176,9 +166,30 @@
 #include <fnmatch.h>
 #include <sys/times.h>
 #include <sys/utsname.h> /* for setting $HOSTNAME */
-
 #include "busybox.h" /* for applet_names */
 
+/* So far, all bash compat is controlled by one config option */
+/* Separate defines document which part of code implements what */
+/* function keyword */
+#define    BASH_FUNCTION        ENABLE_ASH_BASH_COMPAT
+#define IF_BASH_FUNCTION            IF_ASH_BASH_COMPAT
+/* &>file */
+#define    BASH_REDIR_OUTPUT    ENABLE_ASH_BASH_COMPAT
+#define IF_BASH_REDIR_OUTPUT        IF_ASH_BASH_COMPAT
+/* $'...' */
+#define    BASH_DOLLAR_SQUOTE   ENABLE_ASH_BASH_COMPAT
+#define IF_BASH_DOLLAR_SQUOTE       IF_ASH_BASH_COMPAT
+#define    BASH_PATTERN_SUBST   ENABLE_ASH_BASH_COMPAT
+#define IF_BASH_PATTERN_SUBST       IF_ASH_BASH_COMPAT
+#define    BASH_SUBSTR          ENABLE_ASH_BASH_COMPAT
+#define IF_BASH_SUBSTR              IF_ASH_BASH_COMPAT
+/* [[ EXPR ]] */
+#define    BASH_TEST2           (ENABLE_ASH_BASH_COMPAT * ENABLE_ASH_TEST)
+#define    BASH_SOURCE          ENABLE_ASH_BASH_COMPAT
+#define    BASH_PIPEFAIL        ENABLE_ASH_BASH_COMPAT
+#define    BASH_HOSTNAME_VAR    ENABLE_ASH_BASH_COMPAT
+#define    BASH_SHLVL_VAR       ENABLE_ASH_BASH_COMPAT
+
 #if defined(__ANDROID_API__) && __ANDROID_API__ <= 24
 /* Bionic at least up to version 24 has no glob() */
 # undef  ENABLE_ASH_INTERNAL_GLOB
@@ -256,7 +267,7 @@ static const char *const optletters_optn
 	"b"   "notify",
 	"u"   "nounset",
 	"\0"  "vi"
-#if ENABLE_ASH_BASH_COMPAT
+#if BASH_PIPEFAIL
 	,"\0"  "pipefail"
 #endif
 #if DEBUG
@@ -333,14 +344,14 @@ struct globals_misc {
 #define bflag optlist[11]
 #define uflag optlist[12]
 #define viflag optlist[13]
-#if ENABLE_ASH_BASH_COMPAT
+#if BASH_PIPEFAIL
 # define pipefail optlist[14]
 #else
 # define pipefail 0
 #endif
 #if DEBUG
-# define nolog optlist[14 + ENABLE_ASH_BASH_COMPAT]
-# define debug optlist[15 + ENABLE_ASH_BASH_COMPAT]
+# define nolog optlist[14 + BASH_PIPEFAIL]
+# define debug optlist[15 + BASH_PIPEFAIL]
 #endif
 
 	/* trap handler commands */
@@ -661,8 +672,10 @@ out2str(const char *p)
 #define VSTRIMLEFT      0x8     /* ${var#pattern} */
 #define VSTRIMLEFTMAX   0x9     /* ${var##pattern} */
 #define VSLENGTH        0xa     /* ${#var} */
-#if ENABLE_ASH_BASH_COMPAT
+#if BASH_SUBSTR
 #define VSSUBSTR        0xc     /* ${var:position:length} */
+#endif
+#if BASH_PATTERN_SUBST
 #define VSREPLACE       0xd     /* ${var/pattern/replacement} */
 #define VSREPLACEALL    0xe     /* ${var//pattern/replacement} */
 #endif
@@ -689,7 +702,7 @@ static const char dolatstr[] ALIGN1 = {
 #define NDEFUN   14
 #define NARG     15
 #define NTO      16
-#if ENABLE_ASH_BASH_COMPAT
+#if BASH_REDIR_OUTPUT
 #define NTO2     17
 #endif
 #define NCLOBBER 18
@@ -1099,7 +1112,7 @@ shcmd(union node *cmd, FILE *fp)
 		case NTO:      s = ">>"+1; dftfd = 1; break;
 		case NCLOBBER: s = ">|"; dftfd = 1; break;
 		case NAPPEND:  s = ">>"; dftfd = 1; break;
-#if ENABLE_ASH_BASH_COMPAT
+#if BASH_REDIR_OUTPUT
 		case NTO2:
 #endif
 		case NTOFD:    s = ">&"; dftfd = 1; break;
@@ -2445,12 +2458,8 @@ putprompt(const char *s)
 }
 #endif
 
-#if ENABLE_ASH_EXPAND_PRMT
 /* expandstr() needs parsing machinery, so it is far away ahead... */
 static const char *expandstr(const char *ps);
-#else
-#define expandstr(s) s
-#endif
 
 static void
 setprompt_if(smallint do_set, int whichprompt)
@@ -2475,10 +2484,10 @@ setprompt_if(smallint do_set, int whichp
 	}
 #if ENABLE_ASH_EXPAND_PRMT
 	pushstackmark(&smark, stackblocksize());
-#endif
 	putprompt(expandstr(prompt));
-#if ENABLE_ASH_EXPAND_PRMT
 	popstackmark(&smark);
+#else
+	putprompt(prompt);
 #endif
 }
 
@@ -3332,11 +3341,9 @@ unaliascmd(int argc UNUSED_PARAM, char *
 {
 	int i;
 
-	while ((i = nextopt("a")) != '\0') {
-		if (i == 'a') {
-			rmaliases();
-			return 0;
-		}
+	while (nextopt("a") != '\0') {
+		rmaliases();
+		return 0;
 	}
 	for (i = 0; *argptr; argptr++) {
 		if (unalias(*argptr)) {
@@ -3380,12 +3387,13 @@ struct job {
 #if JOBS
 	int stopstatus;         /* status of a stopped job */
 #endif
-	uint32_t
-		nprocs: 16,     /* number of processes */
-		state: 8,
+	unsigned nprocs;        /* number of processes */
+
 #define JOBRUNNING      0       /* at least one proc running */
 #define JOBSTOPPED      1       /* all procs are stopped */
 #define JOBDONE         2       /* all procs are completed */
+	unsigned
+		state: 8,
 #if JOBS
 		sigint: 1,      /* job was killed by SIGINT */
 		jobctl: 1,      /* job running under job control */
@@ -3566,6 +3574,72 @@ static struct job *curjob; //lots
 /* number of presumed living untracked jobs */
 static int jobless; //4
 
+#if 0
+/* Bash has a feature: it restores termios after a successful wait for
+ * a foreground job which had at least one stopped or sigkilled member.
+ * The probable rationale is that SIGSTOP and SIGKILL can preclude task from
+ * properly restoring tty state. Should we do this too?
+ * A reproducer: ^Z an interactive python:
+ *
+ * # python
+ * Python 2.7.12 (...)
+ * >>> ^Z
+ *	{ python leaves tty in -icanon -echo state. We do survive that... }
+ *  [1]+  Stopped                    python
+ *	{ ...however, next program (python #2) does not survive it well: }
+ * # python
+ * Python 2.7.12 (...)
+ * >>> Traceback (most recent call last):
+ *	{ above, I typed "qwerty<CR>", but -echo state is still in effect }
+ *   File "<stdin>", line 1, in <module>
+ * NameError: name 'qwerty' is not defined
+ *
+ * The implementation below is modeled on bash code and seems to work.
+ * However, I'm not sure we should do this. For one: what if I'd fg
+ * the stopped python instead? It'll be confused by "restored" tty state.
+ */
+static struct termios shell_tty_info;
+static void
+get_tty_state(void)
+{
+	if (rootshell && ttyfd >= 0)
+		tcgetattr(ttyfd, &shell_tty_info);
+}
+static void
+set_tty_state(void)
+{
+	/* if (rootshell) - caller ensures this */
+	if (ttyfd >= 0)
+		tcsetattr(ttyfd, TCSADRAIN, &shell_tty_info);
+}
+static int
+job_signal_status(struct job *jp)
+{
+	int status;
+	unsigned i;
+	struct procstat *ps = jp->ps;
+	for (i = 0; i < jp->nprocs; i++) {
+		status = ps[i].ps_status;
+		if (WIFSIGNALED(status) || WIFSTOPPED(status))
+			return status;
+	}
+	return 0;
+}
+static void
+restore_tty_if_stopped_or_signaled(struct job *jp)
+{
+//TODO: check what happens if we come from waitforjob() in expbackq()
+	if (rootshell) {
+		int s = job_signal_status(jp);
+		if (s) /* WIFSIGNALED(s) || WIFSTOPPED(s) */
+			set_tty_state();
+	}
+}
+#else
+# define get_tty_state() ((void)0)
+# define restore_tty_if_stopped_or_signaled(jp) ((void)0)
+#endif
+
 static void
 set_curjob(struct job *jp, unsigned mode)
 {
@@ -3771,7 +3845,7 @@ setjobctl(int on)
 		}
 		/* fd is a tty at this point */
 		fd = fcntl(fd, F_DUPFD, 10);
-		if (ofd >= 0) /* if it is "/dev/tty", close. If 0/1/2, dont */
+		if (ofd >= 0) /* if it is "/dev/tty", close. If 0/1/2, don't */
 			close(ofd);
 		if (fd < 0)
 			goto out; /* F_DUPFD failed */
@@ -3897,8 +3971,10 @@ restartjob(struct job *jp, int mode)
 		goto out;
 	jp->state = JOBRUNNING;
 	pgid = jp->ps[0].ps_pid;
-	if (mode == FORK_FG)
+	if (mode == FORK_FG) {
+		get_tty_state();
 		xtcsetpgrp(ttyfd, pgid);
+	}
 	killpg(pgid, SIGCONT);
 	ps = jp->ps;
 	i = jp->nprocs;
@@ -4432,7 +4508,7 @@ makejob(/*union node *node,*/ int nprocs
 	memset(jp, 0, sizeof(*jp));
 #if JOBS
 	/* jp->jobctl is a bitfield.
-	 * "jp->jobctl |= jobctl" likely to give awful code */
+	 * "jp->jobctl |= doing_jobctl" likely to give awful code */
 	if (doing_jobctl)
 		jp->jobctl = 1;
 #endif
@@ -4461,7 +4537,8 @@ cmdputs(const char *s)
 	static const char vstype[VSTYPE + 1][3] = {
 		"", "}", "-", "+", "?", "=",
 		"%", "%%", "#", "##"
-		IF_ASH_BASH_COMPAT(, ":", "/", "//")
+		IF_BASH_SUBSTR(, ":")
+		IF_BASH_PATTERN_SUBST(, "/", "//")
 	};
 
 	const char *p, *str;
@@ -4688,7 +4765,7 @@ cmdtxt(union node *n)
 	case NAPPEND:
 		p = ">>";
 		goto redir;
-#if ENABLE_ASH_BASH_COMPAT
+#if BASH_REDIR_OUTPUT
 	case NTO2:
 #endif
 	case NTOFD:
@@ -5026,6 +5103,8 @@ waitforjob(struct job *jp)
 #if JOBS
 	if (jp->jobctl) {
 		xtcsetpgrp(ttyfd, rootpid);
+		restore_tty_if_stopped_or_signaled(jp);
+
 		/*
 		 * This is truly gross.
 		 * If we're doing job control, then we did a TIOCSPGRP which
@@ -5215,7 +5294,7 @@ openredirect(union node *redir)
 			goto ecreate;
 		break;
 	case NTO:
-#if ENABLE_ASH_BASH_COMPAT
+#if BASH_REDIR_OUTPUT
 	case NTO2:
 #endif
 		/* Take care of noclobber mode. */
@@ -5376,7 +5455,7 @@ redirect(union node *redir, int flags)
 		union node *tmp = redir;
 		do {
 			sv_pos++;
-#if ENABLE_ASH_BASH_COMPAT
+#if BASH_REDIR_OUTPUT
 			if (tmp->nfile.type == NTO2)
 				sv_pos++;
 #endif
@@ -5418,7 +5497,7 @@ redirect(union node *redir, int flags)
 				continue;
 			}
 		}
-#if ENABLE_ASH_BASH_COMPAT
+#if BASH_REDIR_OUTPUT
  redirect_more:
 #endif
 		if (need_to_remember(sv, fd)) {
@@ -5471,12 +5550,12 @@ redirect(union node *redir, int flags)
 			}
 		} else if (fd != newfd) { /* move newfd to fd */
 			dup2_or_raise(newfd, fd);
-#if ENABLE_ASH_BASH_COMPAT
+#if BASH_REDIR_OUTPUT
 			if (!(redir->nfile.type == NTO2 && fd == 2))
 #endif
 				close(newfd);
 		}
-#if ENABLE_ASH_BASH_COMPAT
+#if BASH_REDIR_OUTPUT
 		if (redir->nfile.type == NTO2 && fd == 1) {
 			/* We already redirected it to fd 1, now copy it to 2 */
 			newfd = 1;
@@ -5793,15 +5872,15 @@ static char *
 rmescapes(char *str, int flag)
 {
 	static const char qchars[] ALIGN1 = {
-		IF_ASH_BASH_COMPAT('/',) CTLESC, CTLQUOTEMARK, '\0' };
+		IF_BASH_PATTERN_SUBST('/',) CTLESC, CTLQUOTEMARK, '\0' };
 
 	char *p, *q, *r;
 	unsigned inquotes;
 	unsigned protect_against_glob;
 	unsigned globbing;
-	IF_ASH_BASH_COMPAT(unsigned slash = flag & RMESCAPE_SLASH;)
+	IF_BASH_PATTERN_SUBST(unsigned slash = flag & RMESCAPE_SLASH;)
 
-	p = strpbrk(str, qchars IF_ASH_BASH_COMPAT(+ !slash));
+	p = strpbrk(str, qchars IF_BASH_PATTERN_SUBST(+ !slash));
 	if (!p)
 		return str;
 
@@ -5853,7 +5932,7 @@ rmescapes(char *str, int flag)
 			protect_against_glob = 0;
 			goto copy;
 		}
-#if ENABLE_ASH_BASH_COMPAT
+#if BASH_PATTERN_SUBST
 		else if (*p == '/' && slash) {
 			/* stop handling globbing and mark location of slash */
 			globbing = slash = 0;
@@ -6227,7 +6306,7 @@ static char *evalvar(char *p, int flags,
  * $@ like $* since no splitting will be performed.
  *
  * var_str_list (can be NULL) is a list of "VAR=val" strings which take precedence
- * over shell varables. Needed for "A=a B=$A; echo $B" case - we use it
+ * over shell variables. Needed for "A=a B=$A; echo $B" case - we use it
  * for correct expansion of "B=$A" word.
  */
 static void
@@ -6437,8 +6516,8 @@ scanright(char *startp, char *rmesc, cha
 		if (try2optimize) {
 			/* Maybe we can optimize this:
 			 * if pattern ends with unescaped *, we can avoid checking
-			 * shorter strings: if "foo*" doesnt match "raw_value_of_v",
-			 * it wont match truncated "raw_value_of_" strings too.
+			 * shorter strings: if "foo*" doesn't match "raw_value_of_v",
+			 * it won't match truncated "raw_value_of_" strings too.
 			 */
 			unsigned plen = strlen(pattern);
 			/* Does it end with "*"? */
@@ -6500,10 +6579,10 @@ subevalvar(char *p, char *varname, int s
 	char *loc;
 	char *rmesc, *rmescend;
 	char *str;
-	IF_ASH_BASH_COMPAT(char *repl = NULL;)
-	IF_ASH_BASH_COMPAT(int pos, len, orig_len;)
+	IF_BASH_SUBSTR(int pos, len, orig_len;)
 	int amount, resetloc;
-	IF_ASH_BASH_COMPAT(int workloc;)
+	IF_BASH_PATTERN_SUBST(int workloc;)
+	IF_BASH_PATTERN_SUBST(char *repl = NULL;)
 	int zero;
 	char *(*scan)(char*, char*, char*, char*, int, int);
 
@@ -6528,7 +6607,7 @@ subevalvar(char *p, char *varname, int s
 		varunset(p, varname, startp, varflags);
 		/* NOTREACHED */
 
-#if ENABLE_ASH_BASH_COMPAT
+#if BASH_SUBSTR
 	case VSSUBSTR:
 //TODO: support more general format ${v:EXPR:EXPR},
 // where EXPR follows $(()) rules
@@ -6597,17 +6676,19 @@ subevalvar(char *p, char *varname, int s
 		amount = loc - expdest;
 		STADJUST(amount, expdest);
 		return loc;
-#endif
+#endif /* BASH_SUBSTR */
 	}
 
 	resetloc = expdest - (char *)stackblock();
 
+#if BASH_PATTERN_SUBST
 	/* We'll comeback here if we grow the stack while handling
 	 * a VSREPLACE or VSREPLACEALL, since our pointers into the
 	 * stack will need rebasing, and we'll need to remove our work
 	 * areas each time
 	 */
- IF_ASH_BASH_COMPAT(restart:)
+ restart:
+#endif
 
 	amount = expdest - ((char *)stackblock() + resetloc);
 	STADJUST(-amount, expdest);
@@ -6632,11 +6713,11 @@ subevalvar(char *p, char *varname, int s
 	 * RMESCAPE_SLASH causes preglob to work differently on the pattern
 	 * and string.  It's only used on the first call.
 	 */
-	preglob(str, IF_ASH_BASH_COMPAT(
+	preglob(str, IF_BASH_PATTERN_SUBST(
 		(subtype == VSREPLACE || subtype == VSREPLACEALL) && !repl ?
-			RMESCAPE_SLASH :) 0);
+			RMESCAPE_SLASH : ) 0);
 
-#if ENABLE_ASH_BASH_COMPAT
+#if BASH_PATTERN_SUBST
 	workloc = expdest - (char *)stackblock();
 	if (subtype == VSREPLACE || subtype == VSREPLACEALL) {
 		char *idx, *end;
@@ -6737,7 +6818,7 @@ subevalvar(char *p, char *varname, int s
 		STADJUST(-amount, expdest);
 		return startp;
 	}
-#endif /* ENABLE_ASH_BASH_COMPAT */
+#endif /* BASH_PATTERN_SUBST */
 
 	subtype -= VSTRIMRIGHT;
 #if DEBUG
@@ -7005,8 +7086,10 @@ evalvar(char *p, int flag, struct strlis
 	case VSTRIMLEFTMAX:
 	case VSTRIMRIGHT:
 	case VSTRIMRIGHTMAX:
-#if ENABLE_ASH_BASH_COMPAT
+#if BASH_SUBSTR
 	case VSSUBSTR:
+#endif
+#if BASH_PATTERN_SUBST
 	case VSREPLACE:
 	case VSREPLACEALL:
 #endif
@@ -7071,6 +7154,57 @@ addfname(const char *name)
 	exparg.lastp = &sp->next;
 }
 
+/* Avoid glob() (and thus, stat() et al) for words like "echo" */
+static int
+hasmeta(const char *p)
+{
+	static const char chars[] ALIGN1 = {
+		'*', '?', '[', '\\', CTLQUOTEMARK, CTLESC, 0
+	};
+
+	for (;;) {
+		p = strpbrk(p, chars);
+		if (!p)
+			break;
+		switch ((unsigned char) *p) {
+		case CTLQUOTEMARK:
+			for (;;) {
+				p++;
+				if (*p == CTLQUOTEMARK)
+					break;
+				if (*p == CTLESC)
+					p++;
+				if (*p == '\0') /* huh? */
+					return 0;
+			}
+			break;
+		case '\\':
+		case CTLESC:
+			p++;
+			if (*p == '\0')
+				return 0;
+			break;
+		case '[':
+			if (!strchr(p + 1, ']')) {
+				/* It's not a properly closed [] pattern,
+				 * but other metas may follow. Continue checking.
+				 * my[file* _is_ globbed by bash
+				 * and matches filenames like "my[file1".
+				 */
+				break;
+			}
+			/* fallthrough */
+		default:
+		/* case '*': */
+		/* case '?': */
+			return 1;
+		}
+		p++;
+	}
+
+	return 0;
+}
+
 /* If we want to use glob() from libc... */
 #if !ENABLE_ASH_INTERNAL_GLOB
 
@@ -7097,20 +7231,9 @@ expandmeta(struct strlist *str /*, int f
 		if (fflag)
 			goto nometa;
 
-		/* Avoid glob() (and thus, stat() et al) for words like "echo" */
-		p = str->text;
-		while (*p) {
-			if (*p == '*')
-				goto need_glob;
-			if (*p == '?')
-				goto need_glob;
-			if (*p == '[')
-				goto need_glob;
-			p++;
-		}
-		goto nometa;
+		if (!hasmeta(str->text))
+			goto nometa;
 
- need_glob:
 		INT_OFF;
 		p = preglob(str->text, RMESCAPE_ALLOC | RMESCAPE_HEAP);
 // GLOB_NOMAGIC (GNU): if no *?[ chars in pattern, return it even if no match
@@ -7121,7 +7244,7 @@ expandmeta(struct strlist *str /*, int f
 // Which means you need to unescape the string, right? Not so fast:
 // if there _is_ a file named "file\?" (with backslash), it is returned
 // as "file\?" too (whichever pattern you used to find it, say, "file*").
-// You DONT KNOW by looking at the result whether you need to unescape it.
+// You DON'T KNOW by looking at the result whether you need to unescape it.
 //
 // Worse, globbing of "file\?" in a directory with two files, "file?" and "file\?",
 // returns "file\?" - which is WRONG: "file\?" pattern matches "file?" file.
@@ -7347,9 +7470,6 @@ expsort(struct strlist *str)
 static void
 expandmeta(struct strlist *str /*, int flag*/)
 {
-	static const char metachars[] ALIGN1 = {
-		'*', '?', '[', 0
-	};
 	/* TODO - EXP_REDIR */
 
 	while (str) {
@@ -7360,7 +7480,7 @@ expandmeta(struct strlist *str /*, int f
 
 		if (fflag)
 			goto nometa;
-		if (!strpbrk(str->text, metachars))
+		if (!hasmeta(str->text))
 			goto nometa;
 		savelastp = exparg.lastp;
 
@@ -7618,9 +7738,8 @@ tryexec(IF_FEATURE_SH_STANDALONE(int app
  * have to change the find_command routine as well.
  * argv[-1] must exist and be writable! See tryexec() for why.
  */
-static void shellexec(char **, const char *, int) NORETURN;
-static void
-shellexec(char **argv, const char *path, int idx)
+static void shellexec(char *prog, char **argv, const char *path, int idx) NORETURN;
+static void shellexec(char *prog, char **argv, const char *path, int idx)
 {
 	char *cmdname;
 	int e;
@@ -7629,12 +7748,12 @@ shellexec(char **argv, const char *path,
 	int applet_no = -1; /* used only by FEATURE_SH_STANDALONE */
 
 	envp = listvars(VEXPORT, VUNSET, /*end:*/ NULL);
-	if (strchr(argv[0], '/') != NULL
+	if (strchr(prog, '/') != NULL
 #if ENABLE_FEATURE_SH_STANDALONE
-	 || (applet_no = find_applet_by_name(argv[0])) >= 0
+	 || (applet_no = find_applet_by_name(prog)) >= 0
 #endif
 	) {
-		tryexec(IF_FEATURE_SH_STANDALONE(applet_no,) argv[0], argv, envp);
+		tryexec(IF_FEATURE_SH_STANDALONE(applet_no,) prog, argv, envp);
 		if (applet_no >= 0) {
 			/* We tried execing ourself, but it didn't work.
 			 * Maybe /proc/self/exe doesn't exist?
@@ -7646,7 +7765,7 @@ shellexec(char **argv, const char *path,
 	} else {
  try_PATH:
 		e = ENOENT;
-		while ((cmdname = path_advance(&path, argv[0])) != NULL) {
+		while ((cmdname = path_advance(&path, prog)) != NULL) {
 			if (--idx < 0 && pathopt == NULL) {
 				tryexec(IF_FEATURE_SH_STANDALONE(-1,) cmdname, argv, envp);
 				if (errno != ENOENT && errno != ENOTDIR)
@@ -7670,8 +7789,8 @@ shellexec(char **argv, const char *path,
 	}
 	exitstatus = exerrno;
 	TRACE(("shellexec failed for %s, errno %d, suppress_int %d\n",
-		argv[0], e, suppress_int));
-	ash_msg_and_raise(EXEXIT, "%s: %s", argv[0], errmsg(e, "not found"));
+		prog, e, suppress_int));
+	ash_msg_and_raise(EXEXIT, "%s: %s", prog, errmsg(e, "not found"));
 	/* NOTREACHED */
 }
 
@@ -7930,7 +8049,7 @@ enum {
 	TESAC,
 	TFI,
 	TFOR,
-#if ENABLE_ASH_BASH_COMPAT
+#if BASH_FUNCTION
 	TFUNCTION,
 #endif
 	TIF,
@@ -7968,7 +8087,7 @@ enum {
 	/* 19 */ | (1u << TESAC)
 	/* 20 */ | (1u << TFI)
 	/* 21 */ | (0u << TFOR)
-#if ENABLE_ASH_BASH_COMPAT
+#if BASH_FUNCTION
 	/* 22 */ | (0u << TFUNCTION)
 #endif
 	/* 23 */ | (0u << TIF)
@@ -8006,7 +8125,7 @@ static const char *const tokname_array[]
 	"esac",
 	"fi",
 	"for",
-#if ENABLE_ASH_BASH_COMPAT
+#if BASH_FUNCTION
 	"function",
 #endif
 	"if",
@@ -8040,7 +8159,6 @@ static int
 describe_command(char *command, const char *path, int describe_command_verbose)
 {
 	struct cmdentry entry;
-	struct tblentry *cmdp;
 #if ENABLE_ASH_ALIAS
 	const struct alias *ap;
 #endif
@@ -8070,15 +8188,8 @@ describe_command(char *command, const ch
 		goto out;
 	}
 #endif
-	/* Then check if it is a tracked alias */
-	cmdp = cmdlookup(command, 0);
-	if (cmdp != NULL) {
-		entry.cmdtype = cmdp->cmdtype;
-		entry.u = cmdp->param;
-	} else {
-		/* Finally use brute force */
-		find_command(command, &entry, DO_ABS, path);
-	}
+	/* Brute force */
+	find_command(command, &entry, DO_ABS, path);
 
 	switch (entry.cmdtype) {
 	case CMDNORMAL: {
@@ -8093,9 +8204,7 @@ describe_command(char *command, const ch
 			} while (--j >= 0);
 		}
 		if (describe_command_verbose) {
-			out1fmt(" is%s %s",
-				(cmdp ? " a tracked alias for" : nullstr), p
-			);
+			out1fmt(" is %s", p);
 		} else {
 			out1str(p);
 		}
@@ -8250,7 +8359,7 @@ static const uint8_t nodesize[N_NUMBER]
 	[NDEFUN   ] = SHELL_ALIGN(sizeof(struct narg)),
 	[NARG     ] = SHELL_ALIGN(sizeof(struct narg)),
 	[NTO      ] = SHELL_ALIGN(sizeof(struct nfile)),
-#if ENABLE_ASH_BASH_COMPAT
+#if BASH_REDIR_OUTPUT
 	[NTO2     ] = SHELL_ALIGN(sizeof(struct nfile)),
 #endif
 	[NCLOBBER ] = SHELL_ALIGN(sizeof(struct nfile)),
@@ -8332,7 +8441,7 @@ calcsize(int funcblocksize, union node *
 		funcblocksize = calcsize(funcblocksize, n->narg.next);
 		break;
 	case NTO:
-#if ENABLE_ASH_BASH_COMPAT
+#if BASH_REDIR_OUTPUT
 	case NTO2:
 #endif
 	case NCLOBBER:
@@ -8446,7 +8555,7 @@ copynode(union node *n)
 		new->narg.next = copynode(n->narg.next);
 		break;
 	case NTO:
-#if ENABLE_ASH_BASH_COMPAT
+#if BASH_REDIR_OUTPUT
 	case NTO2:
 #endif
 	case NCLOBBER:
@@ -8834,13 +8943,15 @@ static int
 evalsubshell(union node *n, int flags)
 {
 	struct job *jp;
-	int backgnd = (n->type == NBACKGND);
+	int backgnd = (n->type == NBACKGND); /* FORK_BG(1) if yes, else FORK_FG(0) */
 	int status;
 
 	expredir(n->nredir.redirect);
 	if (!backgnd && (flags & EV_EXIT) && !may_have_traps)
 		goto nofork;
 	INT_OFF;
+	if (backgnd == FORK_FG)
+		get_tty_state();
 	jp = makejob(/*n,*/ 1);
 	if (forkshell(jp, n, backgnd) == 0) {
 		/* child */
@@ -8855,7 +8966,7 @@ evalsubshell(union node *n, int flags)
 	}
 	/* parent */
 	status = 0;
-	if (!backgnd)
+	if (backgnd == FORK_FG)
 		status = waitforjob(jp);
 	INT_ON;
 	return status;
@@ -8879,14 +8990,14 @@ expredir(union node *n)
 		case NFROMTO:
 		case NFROM:
 		case NTO:
-#if ENABLE_ASH_BASH_COMPAT
+#if BASH_REDIR_OUTPUT
 		case NTO2:
 #endif
 		case NCLOBBER:
 		case NAPPEND:
 			expandarg(redir->nfile.fname, &fn, EXP_TILDE | EXP_REDIR);
 			TRACE(("expredir expanded to '%s'\n", fn.list->text));
-#if ENABLE_ASH_BASH_COMPAT
+#if BASH_REDIR_OUTPUT
  store_expfname:
 #endif
 #if 0
@@ -8908,7 +9019,7 @@ expredir(union node *n)
 				expandarg(redir->ndup.vname, &fn, EXP_FULL | EXP_TILDE);
 				if (fn.list == NULL)
 					ash_msg_and_raise_error("redir error");
-#if ENABLE_ASH_BASH_COMPAT
+#if BASH_REDIR_OUTPUT
 //FIXME: we used expandarg with different args!
 				if (!isdigit_str9(fn.list->text)) {
 					/* >&file, not >&fd */
@@ -8947,6 +9058,8 @@ evalpipe(union node *n, int flags)
 		pipelen++;
 	flags |= EV_EXIT;
 	INT_OFF;
+	if (n->npipe.pipe_backgnd == 0)
+		get_tty_state();
 	jp = makejob(/*n,*/ pipelen);
 	prevfd = -1;
 	for (lp = n->npipe.cmdlist; lp; lp = lp->next) {
@@ -9225,7 +9338,14 @@ truecmd(int argc UNUSED_PARAM, char **ar
 static int FAST_FUNC
 execcmd(int argc UNUSED_PARAM, char **argv)
 {
-	if (argv[1]) {
+	optionarg = NULL;
+	while (nextopt("a:") != '\0')
+		/* nextopt() sets optionarg to "-a ARGV0" */;
+
+	argv = argptr;
+	if (argv[0]) {
+		char *prog;
+
 		iflag = 0;              /* exit on error */
 		mflag = 0;
 		optschanged();
@@ -9241,7 +9361,10 @@ execcmd(int argc UNUSED_PARAM, char **ar
 		/*setsignal(SIGTSTP); - unnecessary because of mflag=0 */
 		/*setsignal(SIGTTOU); - unnecessary because of mflag=0 */
 
-		shellexec(argv + 1, pathval(), 0);
+		prog = argv[0];
+		if (optionarg)
+			argv[0] = optionarg;
+		shellexec(prog, argv, pathval(), 0);
 		/* NOTREACHED */
 	}
 	return 0;
@@ -9298,13 +9421,13 @@ static int ulimitcmd(int, char **) FAST_
 #define BUILTIN_SPEC_REG_ASSG   "7"
 
 /* Stubs for calling non-FAST_FUNC's */
-#if ENABLE_ASH_BUILTIN_ECHO
+#if ENABLE_ASH_ECHO
 static int FAST_FUNC echocmd(int argc, char **argv)   { return echo_main(argc, argv); }
 #endif
-#if ENABLE_ASH_BUILTIN_PRINTF
+#if ENABLE_ASH_PRINTF
 static int FAST_FUNC printfcmd(int argc, char **argv) { return printf_main(argc, argv); }
 #endif
-#if ENABLE_ASH_BUILTIN_TEST
+#if ENABLE_ASH_TEST || BASH_TEST2
 static int FAST_FUNC testcmd(int argc, char **argv)   { return test_main(argc, argv); }
 #endif
 
@@ -9312,11 +9435,11 @@ static int FAST_FUNC testcmd(int argc, c
 static const struct builtincmd builtintab[] = {
 	{ BUILTIN_SPEC_REG      "."       , dotcmd     },
 	{ BUILTIN_SPEC_REG      ":"       , truecmd    },
-#if ENABLE_ASH_BUILTIN_TEST
+#if ENABLE_ASH_TEST
 	{ BUILTIN_REGULAR       "["       , testcmd    },
-# if ENABLE_ASH_BASH_COMPAT
+#endif
+#if BASH_TEST2
 	{ BUILTIN_REGULAR       "[["      , testcmd    },
-# endif
 #endif
 #if ENABLE_ASH_ALIAS
 	{ BUILTIN_REG_ASSG      "alias"   , aliascmd   },
@@ -9331,7 +9454,7 @@ static const struct builtincmd builtinta
 	{ BUILTIN_REGULAR       "command" , commandcmd },
 #endif
 	{ BUILTIN_SPEC_REG      "continue", breakcmd   },
-#if ENABLE_ASH_BUILTIN_ECHO
+#if ENABLE_ASH_ECHO
 	{ BUILTIN_REGULAR       "echo"    , echocmd    },
 #endif
 	{ BUILTIN_SPEC_REG      "eval"    , NULL       }, /*evalcmd() has a differing prototype*/
@@ -9360,7 +9483,7 @@ static const struct builtincmd builtinta
 	{ BUILTIN_NOSPEC        "let"     , letcmd     },
 #endif
 	{ BUILTIN_ASSIGN        "local"   , localcmd   },
-#if ENABLE_ASH_BUILTIN_PRINTF
+#if ENABLE_ASH_PRINTF
 	{ BUILTIN_REGULAR       "printf"  , printfcmd  },
 #endif
 	{ BUILTIN_NOSPEC        "pwd"     , pwdcmd     },
@@ -9369,10 +9492,10 @@ static const struct builtincmd builtinta
 	{ BUILTIN_SPEC_REG      "return"  , returncmd  },
 	{ BUILTIN_SPEC_REG      "set"     , setcmd     },
 	{ BUILTIN_SPEC_REG      "shift"   , shiftcmd   },
-#if ENABLE_ASH_BASH_COMPAT
+#if BASH_SOURCE
 	{ BUILTIN_SPEC_REG      "source"  , dotcmd     },
 #endif
-#if ENABLE_ASH_BUILTIN_TEST
+#if ENABLE_ASH_TEST
 	{ BUILTIN_REGULAR       "test"    , testcmd    },
 #endif
 	{ BUILTIN_SPEC_REG      "times"   , timescmd   },
@@ -9391,15 +9514,15 @@ static const struct builtincmd builtinta
 /* Should match the above table! */
 #define COMMANDCMD (builtintab + \
 	/* . : */	2 + \
-	/* [ */		1 * ENABLE_ASH_BUILTIN_TEST + \
-	/* [[ */	1 * ENABLE_ASH_BUILTIN_TEST * ENABLE_ASH_BASH_COMPAT + \
+	/* [ */		1 * ENABLE_ASH_TEST + \
+	/* [[ */	1 * BASH_TEST2 + \
 	/* alias */	1 * ENABLE_ASH_ALIAS + \
 	/* bg */	1 * ENABLE_ASH_JOB_CONTROL + \
 	/* break cd cddir  */	3)
 #define EVALCMD (COMMANDCMD + \
 	/* command */	1 * ENABLE_ASH_CMDCMD + \
 	/* continue */	1 + \
-	/* echo */	1 * ENABLE_ASH_BUILTIN_ECHO + \
+	/* echo */	1 * ENABLE_ASH_ECHO + \
 	0)
 #define EXECCMD (EVALCMD + \
 	/* eval */	1)
@@ -9629,6 +9752,7 @@ evalcommand(union node *cmd, int flags)
 		if (!(flags & EV_EXIT) || may_have_traps) {
 			/* No, forking off a child is necessary */
 			INT_OFF;
+			get_tty_state();
 			jp = makejob(/*cmd,*/ 1);
 			if (forkshell(jp, cmd, FORK_FG) != 0) {
 				/* parent */
@@ -9642,7 +9766,7 @@ evalcommand(union node *cmd, int flags)
 			/* fall through to exec'ing external program */
 		}
 		listsetvar(varlist.list, VEXPORT|VSTACK);
-		shellexec(argv, path, cmdentry.u.index);
+		shellexec(argv[0], argv, path, cmdentry.u.index);
 		/* NOTREACHED */
 	} /* default */
 	case CMDBUILTIN:
@@ -11014,10 +11138,10 @@ simplecmd(void)
 	union node *vars, **vpp;
 	union node **rpp, *redir;
 	int savecheckkwd;
-#if ENABLE_ASH_BASH_COMPAT
+#if BASH_TEST2
 	smallint double_brackets_flag = 0;
-	smallint function_flag = 0;
 #endif
+	IF_BASH_FUNCTION(smallint function_flag = 0;)
 
 	args = NULL;
 	app = &args;
@@ -11032,12 +11156,14 @@ simplecmd(void)
 		checkkwd = savecheckkwd;
 		t = readtoken();
 		switch (t) {
-#if ENABLE_ASH_BASH_COMPAT
+#if BASH_FUNCTION
 		case TFUNCTION:
 			if (peektoken() != TWORD)
 				raise_error_unexpected_syntax(TWORD);
 			function_flag = 1;
 			break;
+#endif
+#if BASH_TEST2
 		case TAND: /* "&&" */
 		case TOR: /* "||" */
 			if (!double_brackets_flag) {
@@ -11051,7 +11177,7 @@ simplecmd(void)
 			n->type = NARG;
 			/*n->narg.next = NULL; - stzalloc did it */
 			n->narg.text = wordtext;
-#if ENABLE_ASH_BASH_COMPAT
+#if BASH_TEST2
 			if (strcmp("[[", wordtext) == 0)
 				double_brackets_flag = 1;
 			else if (strcmp("]]", wordtext) == 0)
@@ -11066,7 +11192,7 @@ simplecmd(void)
 				app = &n->narg.next;
 				savecheckkwd = 0;
 			}
-#if ENABLE_ASH_BASH_COMPAT
+#if BASH_FUNCTION
 			if (function_flag) {
 				checkkwd = CHKNL | CHKKWD;
 				switch (peektoken()) {
@@ -11096,7 +11222,7 @@ simplecmd(void)
 			parsefname();   /* read name of redirection file */
 			break;
 		case TLP:
- IF_ASH_BASH_COMPAT(do_func:)
+ IF_BASH_FUNCTION(do_func:)
 			if (args && app == &args->narg.next
 			 && !vars && !redir
 			) {
@@ -11104,7 +11230,7 @@ simplecmd(void)
 				const char *name;
 
 				/* We have a function */
-				if (IF_ASH_BASH_COMPAT(!function_flag &&) readtoken() != TRP)
+				if (IF_BASH_FUNCTION(!function_flag &&) readtoken() != TRP)
 					raise_error_unexpected_syntax(TRP);
 				name = n->narg.text;
 				if (!goodname(name)
@@ -11117,7 +11243,7 @@ simplecmd(void)
 				n->narg.next = parse_command();
 				return n;
 			}
-			IF_ASH_BASH_COMPAT(function_flag = 0;)
+			IF_BASH_FUNCTION(function_flag = 0;)
 			/* fall through */
 		default:
 			tokpushback = 1;
@@ -11298,7 +11424,7 @@ parse_command(void)
 		n1 = list(0);
 		t = TEND;
 		break;
-	IF_ASH_BASH_COMPAT(case TFUNCTION:)
+	IF_BASH_FUNCTION(case TFUNCTION:)
 	case TWORD:
 	case TREDIR:
 		tokpushback = 1;
@@ -11331,7 +11457,7 @@ parse_command(void)
 	return n1;
 }
 
-#if ENABLE_ASH_BASH_COMPAT
+#if BASH_DOLLAR_SQUOTE
 static int
 decode_dollar_squote(void)
 {
@@ -11408,25 +11534,21 @@ readtoken1(int c, int syntax, char *eofm
 	smallint dblquote;
 	smallint oldstyle;
 	IF_FEATURE_SH_MATH(smallint prevsyntax;) /* syntax before arithmetic */
-#if ENABLE_ASH_EXPAND_PRMT
 	smallint pssyntax;   /* we are expanding a prompt string */
-#endif
 	int varnest;         /* levels of variables expansion */
 	IF_FEATURE_SH_MATH(int arinest;)    /* levels of arithmetic expansion */
 	IF_FEATURE_SH_MATH(int parenlevel;) /* levels of parens in arithmetic */
 	int dqvarnest;       /* levels of variables expansion within double quotes */
 
-	IF_ASH_BASH_COMPAT(smallint bash_dollar_squote = 0;)
+	IF_BASH_DOLLAR_SQUOTE(smallint bash_dollar_squote = 0;)
 
 	startlinno = g_parsefile->linno;
 	bqlist = NULL;
 	quotef = 0;
 	IF_FEATURE_SH_MATH(prevsyntax = 0;)
-#if ENABLE_ASH_EXPAND_PRMT
 	pssyntax = (syntax == PSSYNTAX);
 	if (pssyntax)
 		syntax = DQSYNTAX;
-#endif
 	dblquote = (syntax == DQSYNTAX);
 	varnest = 0;
 	IF_FEATURE_SH_MATH(arinest = 0;)
@@ -11451,7 +11573,7 @@ readtoken1(int c, int syntax, char *eofm
 			USTPUTC(c, out);
 			break;
 		case CCTL:
-#if ENABLE_ASH_BASH_COMPAT
+#if BASH_DOLLAR_SQUOTE
 			if (c == '\\' && bash_dollar_squote) {
 				c = decode_dollar_squote();
 				if (c == '\0') {
@@ -11480,12 +11602,10 @@ readtoken1(int c, int syntax, char *eofm
 			} else if (c == '\n') {
 				nlprompt();
 			} else {
-#if ENABLE_ASH_EXPAND_PRMT
 				if (c == '$' && pssyntax) {
 					USTPUTC(CTLESC, out);
 					USTPUTC('\\', out);
 				}
-#endif
 				/* Backslash is retained if we are in "str" and next char isn't special */
 				if (dblquote
 				 && c != '\\'
@@ -11512,7 +11632,7 @@ readtoken1(int c, int syntax, char *eofm
 			dblquote = 1;
 			goto quotemark;
 		case CENDQUOTE:
-			IF_ASH_BASH_COMPAT(bash_dollar_squote = 0;)
+			IF_BASH_DOLLAR_SQUOTE(bash_dollar_squote = 0;)
 			if (eofmark != NULL && varnest == 0) {
 				USTPUTC(c, out);
 			} else {
@@ -11571,7 +11691,7 @@ readtoken1(int c, int syntax, char *eofm
 			break;
 		default:
 			if (varnest == 0) {
-#if ENABLE_ASH_BASH_COMPAT
+#if BASH_REDIR_OUTPUT
 				if (c == '&') {
 //Can't call pgetc_eatbnl() here, this requires three-deep pungetc()
 					if (pgetc() == '>')
@@ -11603,7 +11723,7 @@ readtoken1(int c, int syntax, char *eofm
 	len = out - (char *)stackblock();
 	out = stackblock();
 	if (eofmark == NULL) {
-		if ((c == '>' || c == '<' IF_ASH_BASH_COMPAT( || c == 0x100 + '>'))
+		if ((c == '>' || c == '<' IF_BASH_REDIR_OUTPUT( || c == 0x100 + '>'))
 		 && quotef == 0
 		) {
 			if (isdigit_str9(out)) {
@@ -11691,7 +11811,7 @@ parseredir: {
 			pungetc();
 		}
 	}
-#if ENABLE_ASH_BASH_COMPAT
+#if BASH_REDIR_OUTPUT
 	else if (c == 0x100 + '>') { /* this flags &> redirection */
 		np->nfile.fd = 1;
 		pgetc(); /* this is '>', no need to check */
@@ -11757,7 +11877,7 @@ parsesub: {
 	if (c > 255 /* PEOA or PEOF */
 	 || (c != '(' && c != '{' && !is_name(c) && !is_special(c))
 	) {
-#if ENABLE_ASH_BASH_COMPAT
+#if BASH_DOLLAR_SQUOTE
 		if (syntax != DQSYNTAX && c == '\'')
 			bash_dollar_squote = 1;
 		else
@@ -11833,7 +11953,7 @@ parsesub: {
 			switch (c) {
 			case ':':
 				c = pgetc_eatbnl();
-#if ENABLE_ASH_BASH_COMPAT
+#if BASH_SUBSTR
 				/* This check is only needed to not misinterpret
 				 * ${VAR:-WORD}, ${VAR:+WORD}, ${VAR:=WORD}, ${VAR:?WORD}
 				 * constructs.
@@ -11863,7 +11983,7 @@ parsesub: {
 				subtype++;
 				break;
 			}
-#if ENABLE_ASH_BASH_COMPAT
+#if BASH_PATTERN_SUBST
 			case '/':
 				/* ${v/[/]pattern/repl} */
 //TODO: encode pattern and repl separately.
@@ -12118,7 +12238,7 @@ xxreadtoken(void)
 						p += xxreadtoken_doubles + 1;
 					} else {
 						pungetc();
-#if ENABLE_ASH_BASH_COMPAT
+#if BASH_REDIR_OUTPUT
 						if (c == '&' && cc == '>') /* &> */
 							break; /* return readtoken1(...) */
 #endif
@@ -12319,7 +12439,6 @@ parseheredoc(void)
 /*
  * called by editline -- any expansions to the prompt should be added here.
  */
-#if ENABLE_ASH_EXPAND_PRMT
 static const char *
 expandstr(const char *ps)
 {
@@ -12345,7 +12464,6 @@ expandstr(const char *ps)
 	expandarg(&n, NULL, EXP_QUOTED);
 	return stackblock();
 }
-#endif
 
 /*
  * Execute a command or commands contained in a string.
@@ -12508,16 +12626,7 @@ find_dot_file(char *name)
 	if (strchr(name, '/'))
 		return name;
 
-	/* IIRC standards do not say whether . is to be searched.
-	 * And it is even smaller this way, making it unconditional for now:
-	 */
-	if (1) { /* ENABLE_ASH_BASH_COMPAT */
-		fullname = name;
-		goto try_cur_dir;
-	}
-
 	while ((fullname = path_advance(&path, name)) != NULL) {
- try_cur_dir:
 		if ((stat(fullname, &statb) == 0) && S_ISREG(statb.st_mode)) {
 			/*
 			 * Don't bother freeing here, since it will
@@ -12541,6 +12650,7 @@ dotcmd(int argc_ UNUSED_PARAM, char **ar
 	int status = 0;
 	char *fullname;
 	char **argv;
+	char *args_need_save;
 	struct strlist *sp;
 	volatile struct shparam saveparam;
 
@@ -12560,7 +12670,8 @@ dotcmd(int argc_ UNUSED_PARAM, char **ar
 	 */
 	fullname = find_dot_file(argv[0]);
 	argv++;
-	if (argv[0]) { /* . FILE ARGS, ARGS exist */
+	args_need_save = argv[0];
+	if (args_need_save) { /* ". FILE ARGS", and ARGS are not empty */
 		int argc;
 		saveparam = shellparam;
 		shellparam.malloced = 0;
@@ -12579,7 +12690,7 @@ dotcmd(int argc_ UNUSED_PARAM, char **ar
 	status = cmdloop(0);
 	popfile();
 
-	if (argv[0]) {
+	if (args_need_save) {
 		freeparam(&shellparam);
 		shellparam = saveparam;
 	};
@@ -12850,7 +12961,7 @@ trapcmd(int argc UNUSED_PARAM, char **ar
 	exitcode = 0;
 	while (*ap) {
 		signo = get_signum(*ap);
-		if (signo < 0) {
+		if (signo < 0 || signo >= NSIG) {
 			/* Mimic bash message exactly */
 			ash_msg("%s: invalid signal specification", *ap);
 			exitcode = 1;
@@ -12955,7 +13066,7 @@ exportcmd(int argc UNUSED_PARAM, char **
 	}
 	flag_off = ~flag_off;
 
-	/*if (opt_p_not_specified) - bash doesnt check this. Try "export -p NAME" */
+	/*if (opt_p_not_specified) - bash doesn't check this. Try "export -p NAME" */
 	{
 		aptr = argptr;
 		name = *aptr;
@@ -13135,6 +13246,7 @@ readcmd(int argc UNUSED_PARAM, char **ar
 	/* "read -s" needs to save/restore termios, can't allow ^C
 	 * to jump out of it.
 	 */
+ again:
 	INT_OFF;
 	r = shell_builtin_read(setvar0,
 		argptr,
@@ -13147,6 +13259,12 @@ readcmd(int argc UNUSED_PARAM, char **ar
 	);
 	INT_ON;
 
+	if ((uintptr_t)r == 1 && errno == EINTR) {
+		/* to get SIGCHLD: sleep 1 & read x; echo $x */
+		if (pending_sig == 0)
+			goto again;
+	}
+
 	if ((uintptr_t)r > 1)
 		ash_msg_and_raise_error(r);
 
@@ -13287,9 +13405,11 @@ init(void)
 		setvareq((char*)defoptindvar, VTEXTFIXED);
 
 		setvar0("PPID", utoa(getppid()));
-#if ENABLE_ASH_BASH_COMPAT
+#if BASH_SHLVL_VAR
 		p = lookupvar("SHLVL");
 		setvar("SHLVL", utoa((p ? atoi(p) : 0) + 1), VEXPORT);
+#endif
+#if BASH_HOSTNAME_VAR
 		if (!lookupvar("HOSTNAME")) {
 			struct utsname uts;
 			uname(&uts);
@@ -13352,7 +13472,7 @@ procargs(char **argv)
 #if DEBUG == 2
 	debug = 1;
 #endif
-	/* POSIX 1003.2: first arg after -c cmd is $0, remainder $1... */
+	/* POSIX 1003.2: first arg after "-c CMD" is $0, remainder $1... */
 	if (xminusc) {
 		minusc = *xargv++;
 		if (*xargv)
@@ -13533,9 +13653,11 @@ int ash_main(int argc UNUSED_PARAM, char
 			if (!hp) {
 				hp = lookupvar("HOME");
 				if (hp) {
+					INT_OFF;
 					hp = concat_path_file(hp, ".ash_history");
 					setvar0("HISTFILE", hp);
 					free((char*)hp);
+					INT_ON;
 					hp = lookupvar("HISTFILE");
 				}
 			}
diff -urpN busybox-1.26.2/shell/ash_test/ash-glob/glob2.xx busybox-1.27.0/shell/ash_test/ash-glob/glob2.xx
--- busybox-1.26.2/shell/ash_test/ash-glob/glob2.xx	1970-01-01 01:00:00.000000000 +0100
+++ busybox-1.27.0/shell/ash_test/ash-glob/glob2.xx	2016-09-29 00:31:25.000000000 +0200
@@ -0,0 +1,18 @@
+Expected Actual
+Z\*    : Z\f
+Z*     : Z*
+Z\f    : Z\f
+Z\*    : Z\*
+
+Z\z    : Z\z
+Zz     : Zz
+Z\z    : Z\z
+Z\z    : Z\z
+
+Z\     : Z\
+Z\     : Z\
+
+Z\f Zf : Z\f Zf
+Z\f Zf : Z\f Zf
+
+Done: 0
diff -urpN busybox-1.26.2/shell/ash_test/ash-misc/source_argv_and_shift.right busybox-1.27.0/shell/ash_test/ash-misc/source_argv_and_shift.right
--- busybox-1.26.2/shell/ash_test/ash-misc/source_argv_and_shift.right	1970-01-01 01:00:00.000000000 +0100
+++ busybox-1.27.0/shell/ash_test/ash-misc/source_argv_and_shift.right	2017-01-09 08:56:10.000000000 +0100
@@ -0,0 +1,4 @@
+sourced_arg1:1
+arg1:
+sourced_arg1:a
+arg1:1
diff -urpN busybox-1.26.2/shell/ash_test/ash-misc/source_argv_and_shift.tests busybox-1.27.0/shell/ash_test/ash-misc/source_argv_and_shift.tests
--- busybox-1.26.2/shell/ash_test/ash-misc/source_argv_and_shift.tests	1970-01-01 01:00:00.000000000 +0100
+++ busybox-1.27.0/shell/ash_test/ash-misc/source_argv_and_shift.tests	2017-01-09 08:56:10.000000000 +0100
@@ -0,0 +1,12 @@
+echo 'echo sourced_arg1:$1' >sourced1
+echo 'shift' >>sourced1
+
+set -- 1
+. ./sourced1
+echo arg1:$1
+
+set -- 1
+. ./sourced1 a
+echo arg1:$1
+
+rm sourced1
diff -urpN busybox-1.26.2/shell/ash_test/ash-misc/unicode1.tests busybox-1.27.0/shell/ash_test/ash-misc/unicode1.tests
--- busybox-1.26.2/shell/ash_test/ash-misc/unicode1.tests	2016-10-07 16:47:12.000000000 +0200
+++ busybox-1.27.0/shell/ash_test/ash-misc/unicode1.tests	2017-07-01 22:51:12.000000000 +0200
@@ -5,7 +5,7 @@ a=`printf "\xcc\x80"`
 # Should print 1
 echo ${#a}
 
-# A Japanese katakana charachter U+30a3
+# A Japanese katakana character U+30a3
 a=`printf "\xe3\x82\xa3"`
 # Should print 1
 echo ${#a}
diff -urpN busybox-1.26.2/shell/ash_test/ash-read/read_SIGCHLD.right busybox-1.27.0/shell/ash_test/ash-read/read_SIGCHLD.right
--- busybox-1.26.2/shell/ash_test/ash-read/read_SIGCHLD.right	1970-01-01 01:00:00.000000000 +0100
+++ busybox-1.27.0/shell/ash_test/ash-read/read_SIGCHLD.right	2017-07-01 22:51:12.000000000 +0200
@@ -0,0 +1,2 @@
+x='Ok'
+exitcode:0
diff -urpN busybox-1.26.2/shell/ash_test/ash-read/read_SIGCHLD.tests busybox-1.27.0/shell/ash_test/ash-read/read_SIGCHLD.tests
--- busybox-1.26.2/shell/ash_test/ash-read/read_SIGCHLD.tests	1970-01-01 01:00:00.000000000 +0100
+++ busybox-1.27.0/shell/ash_test/ash-read/read_SIGCHLD.tests	2017-07-01 22:51:12.000000000 +0200
@@ -0,0 +1,4 @@
+x=BAD
+{ sleep 0.4; echo Ok; } | { sleep 0.2 & read x; echo "x='$x'"; }
+echo "exitcode:$?"
+
diff -urpN busybox-1.26.2/shell/ash_test/ash-vars/var_bash5.xx busybox-1.27.0/shell/ash_test/ash-vars/var_bash5.xx
--- busybox-1.26.2/shell/ash_test/ash-vars/var_bash5.xx	1970-01-01 01:00:00.000000000 +0100
+++ busybox-1.27.0/shell/ash_test/ash-vars/var_bash5.xx	2016-09-29 00:31:50.000000000 +0200
@@ -0,0 +1,4 @@
+a/c/c
+a/c/d/c
+a/c/e/f/c
+Done: 0
diff -urpN busybox-1.26.2/shell/hush.c busybox-1.27.0/shell/hush.c
--- busybox-1.26.2/shell/hush.c	2017-01-10 16:55:51.000000000 +0100
+++ busybox-1.27.0/shell/hush.c	2017-07-02 21:32:47.000000000 +0200
@@ -44,7 +44,6 @@
  *      special variables (done: PWD, PPID, RANDOM)
  *      tilde expansion
  *      aliases
- *      kill %jobspec
  *      follow IFS rules more precisely, including update semantics
  *      builtins mandated by standards we don't support:
  *          [un]alias, command, fc, getopts, newgrp, readonly, times
@@ -100,8 +99,6 @@
 //config:	bool "bash-compatible extensions"
 //config:	default y
 //config:	depends on HUSH || SH_IS_HUSH || BASH_IS_HUSH
-//config:	help
-//config:	  Enable bash-compatible extensions.
 //config:
 //config:config HUSH_BRACE_EXPANSION
 //config:	bool "Brace expansion"
@@ -110,13 +107,6 @@
 //config:	help
 //config:	  Enable {abc,def} extension.
 //config:
-//config:config HUSH_HELP
-//config:	bool "help builtin"
-//config:	default y
-//config:	depends on HUSH || SH_IS_HUSH || BASH_IS_HUSH
-//config:	help
-//config:	  Enable help builtin in hush. Code size + ~1 kbyte.
-//config:
 //config:config HUSH_INTERACTIVE
 //config:	bool "Interactive mode"
 //config:	default y
@@ -131,8 +121,6 @@
 //config:	bool "Save command history to .hush_history"
 //config:	default y
 //config:	depends on HUSH_INTERACTIVE && FEATURE_EDITING_SAVEHISTORY
-//config:	help
-//config:	  Enable history saving in hush.
 //config:
 //config:config HUSH_JOB
 //config:	bool "Job control"
@@ -146,42 +134,38 @@
 //config:	  but no separate process group is formed.
 //config:
 //config:config HUSH_TICK
-//config:	bool "Process substitution"
+//config:	bool "Support process substitution"
 //config:	default y
 //config:	depends on HUSH || SH_IS_HUSH || BASH_IS_HUSH
 //config:	help
-//config:	  Enable process substitution `command` and $(command) in hush.
+//config:	  Enable `command` and $(command).
 //config:
 //config:config HUSH_IF
 //config:	bool "Support if/then/elif/else/fi"
 //config:	default y
 //config:	depends on HUSH || SH_IS_HUSH || BASH_IS_HUSH
-//config:	help
-//config:	  Enable if/then/elif/else/fi in hush.
 //config:
 //config:config HUSH_LOOPS
 //config:	bool "Support for, while and until loops"
 //config:	default y
 //config:	depends on HUSH || SH_IS_HUSH || BASH_IS_HUSH
-//config:	help
-//config:	  Enable for, while and until loops in hush.
 //config:
 //config:config HUSH_CASE
 //config:	bool "Support case ... esac statement"
 //config:	default y
 //config:	depends on HUSH || SH_IS_HUSH || BASH_IS_HUSH
 //config:	help
-//config:	  Enable case ... esac statement in hush. +400 bytes.
+//config:	  Enable case ... esac statement. +400 bytes.
 //config:
 //config:config HUSH_FUNCTIONS
 //config:	bool "Support funcname() { commands; } syntax"
 //config:	default y
 //config:	depends on HUSH || SH_IS_HUSH || BASH_IS_HUSH
 //config:	help
-//config:	  Enable support for shell functions in hush. +800 bytes.
+//config:	  Enable support for shell functions. +800 bytes.
 //config:
 //config:config HUSH_LOCAL
-//config:	bool "Support local builtin"
+//config:	bool "local builtin"
 //config:	default y
 //config:	depends on HUSH_FUNCTIONS
 //config:	help
@@ -195,20 +179,95 @@
 //config:	  Enable pseudorandom generator and dynamic variable "$RANDOM".
 //config:	  Each read of "$RANDOM" will generate a new pseudorandom value.
 //config:
+//config:config HUSH_MODE_X
+//config:	bool "Support 'hush -x' option and 'set -x' command"
+//config:	default y
+//config:	depends on HUSH || SH_IS_HUSH || BASH_IS_HUSH
+//config:	help
+//config:	  This instructs hush to print commands before execution.
+//config:	  Adds ~300 bytes.
+//config:
+//config:config HUSH_ECHO
+//config:	bool "echo builtin"
+//config:	default y
+//config:	depends on HUSH || SH_IS_HUSH || BASH_IS_HUSH
+//config:
+//config:config HUSH_PRINTF
+//config:	bool "printf builtin"
+//config:	default y
+//config:	depends on HUSH || SH_IS_HUSH || BASH_IS_HUSH
+//config:
+//config:config HUSH_TEST
+//config:	bool "test builtin"
+//config:	default y
+//config:	depends on HUSH || SH_IS_HUSH || BASH_IS_HUSH
+//config:
+//config:config HUSH_HELP
+//config:	bool "help builtin"
+//config:	default y
+//config:	depends on HUSH || SH_IS_HUSH || BASH_IS_HUSH
+//config:
+//config:config HUSH_EXPORT
+//config:	bool "export builtin"
+//config:	default y
+//config:	depends on HUSH || SH_IS_HUSH || BASH_IS_HUSH
+//config:
 //config:config HUSH_EXPORT_N
 //config:	bool "Support 'export -n' option"
 //config:	default y
-//config:	depends on HUSH || SH_IS_HUSH || BASH_IS_HUSH
+//config:	depends on HUSH_EXPORT
 //config:	help
 //config:	  export -n unexports variables. It is a bash extension.
 //config:
-//config:config HUSH_MODE_X
-//config:	bool "Support 'hush -x' option and 'set -x' command"
+//config:config HUSH_KILL
+//config:	bool "kill builtin (supports kill %jobspec)"
 //config:	default y
 //config:	depends on HUSH || SH_IS_HUSH || BASH_IS_HUSH
-//config:	help
-//config:	  This instructs hush to print commands before execution.
-//config:	  Adds ~300 bytes.
+//config:
+//config:config HUSH_WAIT
+//config:	bool "wait builtin"
+//config:	default y
+//config:	depends on HUSH || SH_IS_HUSH || BASH_IS_HUSH
+//config:
+//config:config HUSH_TRAP
+//config:	bool "trap builtin"
+//config:	default y
+//config:	depends on HUSH || SH_IS_HUSH || BASH_IS_HUSH
+//config:
+//config:config HUSH_TYPE
+//config:	bool "type builtin"
+//config:	default y
+//config:	depends on HUSH || SH_IS_HUSH || BASH_IS_HUSH
+//config:
+//config:config HUSH_READ
+//config:	bool "read builtin"
+//config:	default y
+//config:	depends on HUSH || SH_IS_HUSH || BASH_IS_HUSH
+//config:
+//config:config HUSH_SET
+//config:	bool "set builtin"
+//config:	default y
+//config:	depends on HUSH || SH_IS_HUSH || BASH_IS_HUSH
+//config:
+//config:config HUSH_UNSET
+//config:	bool "unset builtin"
+//config:	default y
+//config:	depends on HUSH || SH_IS_HUSH || BASH_IS_HUSH
+//config:
+//config:config HUSH_ULIMIT
+//config:	bool "ulimit builtin"
+//config:	default y
+//config:	depends on HUSH || SH_IS_HUSH || BASH_IS_HUSH
+//config:
+//config:config HUSH_UMASK
+//config:	bool "umask builtin"
+//config:	default y
+//config:	depends on HUSH || SH_IS_HUSH || BASH_IS_HUSH
+//config:
+//config:config HUSH_MEMLEAK
+//config:	bool "memleak builtin (debugging)"
+//config:	default n
+//config:	depends on HUSH || SH_IS_HUSH || BASH_IS_HUSH
 //config:
 //config:config MSH
 //config:	bool "msh (deprecated: aliased to hush)"
@@ -218,8 +277,9 @@
 //config:	  msh is deprecated and will be removed, please migrate to hush.
 
 //applet:IF_HUSH(APPLET(hush, BB_DIR_BIN, BB_SUID_DROP))
-//applet:IF_MSH(APPLET_ODDNAME(msh, hush, BB_DIR_BIN, BB_SUID_DROP, hush))
-//applet:IF_SH_IS_HUSH(APPLET_ODDNAME(sh, hush, BB_DIR_BIN, BB_SUID_DROP, hush))
+//                       APPLET_ODDNAME:name  main  location    suid_type     help
+//applet:IF_MSH(         APPLET_ODDNAME(msh,  hush, BB_DIR_BIN, BB_SUID_DROP, hush))
+//applet:IF_SH_IS_HUSH(  APPLET_ODDNAME(sh,   hush, BB_DIR_BIN, BB_SUID_DROP, hush))
 //applet:IF_BASH_IS_HUSH(APPLET_ODDNAME(bash, hush, BB_DIR_BIN, BB_SUID_DROP, hush))
 
 //kbuild:lib-$(CONFIG_HUSH) += hush.o match.o shell_common.o
@@ -267,6 +327,15 @@
 #endif
 
 
+/* So far, all bash compat is controlled by one config option */
+/* Separate defines document which part of code implements what */
+#define BASH_PATTERN_SUBST ENABLE_HUSH_BASH_COMPAT
+#define BASH_SUBSTR        ENABLE_HUSH_BASH_COMPAT
+#define BASH_SOURCE        ENABLE_HUSH_BASH_COMPAT
+#define BASH_HOSTNAME_VAR  ENABLE_HUSH_BASH_COMPAT
+#define BASH_TEST2         (ENABLE_HUSH_BASH_COMPAT && ENABLE_HUSH_TEST)
+
+
 /* Build knobs */
 #define LEAK_HUNTING 0
 #define BUILD_AS_NOMMU 0
@@ -347,12 +416,12 @@
 
 #define ERR_PTR ((void*)(long)1)
 
-#define JOB_STATUS_FORMAT    "[%d] %-22s %.40s\n"
+#define JOB_STATUS_FORMAT    "[%u] %-22s %.40s\n"
 
 #define _SPECIAL_VARS_STR     "_*@$!?#"
 #define SPECIAL_VARS_STR     ("_*@$!?#" + 1)
 #define NUMERIC_SPECVARS_STR ("_*@$!?#" + 3)
-#if ENABLE_HUSH_BASH_COMPAT
+#if BASH_PATTERN_SUBST
 /* Support / and // replace ops */
 /* Note that // is stored as \ in "encoded" string representation */
 # define VAR_ENCODED_SUBST_OPS      "\\/%#:-=+?"
@@ -513,7 +582,7 @@ struct command {
 	smallint cmd_type;          /* CMD_xxx */
 #define CMD_NORMAL   0
 #define CMD_SUBSHELL 1
-#if ENABLE_HUSH_BASH_COMPAT
+#if BASH_TEST2
 /* used for "[[ EXPR ]]" */
 # define CMD_SINGLEWORD_NOGLOB 2
 #endif
@@ -563,7 +632,7 @@ struct pipe {
 	int alive_cmds;             /* number of commands running (not exited) */
 	int stopped_cmds;           /* number of commands alive, but stopped */
 #if ENABLE_HUSH_JOB
-	int jobid;                  /* job number */
+	unsigned jobid;             /* job number */
 	pid_t pgrp;                 /* process group ID for the job */
 	char *cmdtext;              /* name of job */
 #endif
@@ -740,7 +809,7 @@ struct globals {
 #endif
 #if ENABLE_HUSH_JOB
 	int run_list_level;
-	int last_jobid;
+	unsigned last_jobid;
 	pid_t saved_tty_pgrp;
 	struct pipe *job_list;
 # define G_saved_tty_pgrp (G.saved_tty_pgrp)
@@ -770,8 +839,13 @@ struct globals {
 	smallint exiting; /* used to prevent EXIT trap recursion */
 	/* These four support $?, $#, and $1 */
 	smalluint last_exitcode;
+#if ENABLE_HUSH_SET
 	/* are global_argv and global_argv[1..n] malloced? (note: not [0]) */
 	smalluint global_args_malloced;
+# define G_global_args_malloced (G.global_args_malloced)
+#else
+# define G_global_args_malloced 0
+#endif
 	/* how many non-NULL argv's we have. NB: $# + 1 */
 	int global_argc;
 	char **global_argv;
@@ -810,14 +884,21 @@ struct globals {
 	unsigned special_sig_mask;
 #if ENABLE_HUSH_JOB
 	unsigned fatal_sig_mask;
-# define G_fatal_sig_mask G.fatal_sig_mask
+# define G_fatal_sig_mask (G.fatal_sig_mask)
 #else
 # define G_fatal_sig_mask 0
 #endif
+#if ENABLE_HUSH_TRAP
 	char **traps; /* char *traps[NSIG] */
+# define G_traps G.traps
+#else
+# define G_traps ((char**)NULL)
+#endif
 	sigset_t pending_set;
-#if HUSH_DEBUG
+#if ENABLE_HUSH_MEMLEAK
 	unsigned long memleak_value;
+#endif
+#if HUSH_DEBUG
 	int debug_indent;
 #endif
 	struct sigaction sa;
@@ -839,11 +920,15 @@ struct globals {
 
 /* Function prototypes for builtins */
 static int builtin_cd(char **argv) FAST_FUNC;
+#if ENABLE_HUSH_ECHO
 static int builtin_echo(char **argv) FAST_FUNC;
+#endif
 static int builtin_eval(char **argv) FAST_FUNC;
 static int builtin_exec(char **argv) FAST_FUNC;
 static int builtin_exit(char **argv) FAST_FUNC;
+#if ENABLE_HUSH_EXPORT
 static int builtin_export(char **argv) FAST_FUNC;
+#endif
 #if ENABLE_HUSH_JOB
 static int builtin_fg_bg(char **argv) FAST_FUNC;
 static int builtin_jobs(char **argv) FAST_FUNC;
@@ -857,24 +942,43 @@ static int builtin_history(char **argv)
 #if ENABLE_HUSH_LOCAL
 static int builtin_local(char **argv) FAST_FUNC;
 #endif
-#if HUSH_DEBUG
+#if ENABLE_HUSH_MEMLEAK
 static int builtin_memleak(char **argv) FAST_FUNC;
 #endif
-#if ENABLE_PRINTF
+#if ENABLE_HUSH_PRINTF
 static int builtin_printf(char **argv) FAST_FUNC;
 #endif
 static int builtin_pwd(char **argv) FAST_FUNC;
+#if ENABLE_HUSH_READ
 static int builtin_read(char **argv) FAST_FUNC;
+#endif
+#if ENABLE_HUSH_SET
 static int builtin_set(char **argv) FAST_FUNC;
+#endif
 static int builtin_shift(char **argv) FAST_FUNC;
 static int builtin_source(char **argv) FAST_FUNC;
+#if ENABLE_HUSH_TEST || BASH_TEST2
 static int builtin_test(char **argv) FAST_FUNC;
+#endif
+#if ENABLE_HUSH_TRAP
 static int builtin_trap(char **argv) FAST_FUNC;
+#endif
+#if ENABLE_HUSH_TYPE
 static int builtin_type(char **argv) FAST_FUNC;
+#endif
 static int builtin_true(char **argv) FAST_FUNC;
+#if ENABLE_HUSH_UMASK
 static int builtin_umask(char **argv) FAST_FUNC;
+#endif
+#if ENABLE_HUSH_UNSET
 static int builtin_unset(char **argv) FAST_FUNC;
+#endif
+#if ENABLE_HUSH_KILL
+static int builtin_kill(char **argv) FAST_FUNC;
+#endif
+#if ENABLE_HUSH_WAIT
 static int builtin_wait(char **argv) FAST_FUNC;
+#endif
 #if ENABLE_HUSH_LOOPS
 static int builtin_break(char **argv) FAST_FUNC;
 static int builtin_continue(char **argv) FAST_FUNC;
@@ -901,13 +1005,13 @@ struct built_in_command {
 };
 
 static const struct built_in_command bltins1[] = {
-	BLTIN("."        , builtin_source  , "Run commands in a file"),
+	BLTIN("."        , builtin_source  , "Run commands in file"),
 	BLTIN(":"        , builtin_true    , NULL),
 #if ENABLE_HUSH_JOB
-	BLTIN("bg"       , builtin_fg_bg   , "Resume a job in the background"),
+	BLTIN("bg"       , builtin_fg_bg   , "Resume job in background"),
 #endif
 #if ENABLE_HUSH_LOOPS
-	BLTIN("break"    , builtin_break   , "Exit from a loop"),
+	BLTIN("break"    , builtin_break   , "Exit loop"),
 #endif
 	BLTIN("cd"       , builtin_cd      , "Change directory"),
 #if ENABLE_HUSH_LOOPS
@@ -915,53 +1019,84 @@ static const struct built_in_command blt
 #endif
 	BLTIN("eval"     , builtin_eval    , "Construct and run shell command"),
 	BLTIN("exec"     , builtin_exec    , "Execute command, don't return to shell"),
-	BLTIN("exit"     , builtin_exit    , "Exit"),
+	BLTIN("exit"     , builtin_exit    , NULL),
+#if ENABLE_HUSH_EXPORT
 	BLTIN("export"   , builtin_export  , "Set environment variables"),
+#endif
 #if ENABLE_HUSH_JOB
-	BLTIN("fg"       , builtin_fg_bg   , "Bring job into the foreground"),
+	BLTIN("fg"       , builtin_fg_bg   , "Bring job into foreground"),
 #endif
 #if ENABLE_HUSH_HELP
 	BLTIN("help"     , builtin_help    , NULL),
 #endif
 #if MAX_HISTORY && ENABLE_FEATURE_EDITING
-	BLTIN("history"  , builtin_history , "Show command history"),
+	BLTIN("history"  , builtin_history , "Show history"),
 #endif
 #if ENABLE_HUSH_JOB
 	BLTIN("jobs"     , builtin_jobs    , "List jobs"),
 #endif
+#if ENABLE_HUSH_KILL
+	BLTIN("kill"     , builtin_kill    , "Send signals to processes"),
+#endif
 #if ENABLE_HUSH_LOCAL
 	BLTIN("local"    , builtin_local   , "Set local variables"),
 #endif
-#if HUSH_DEBUG
+#if ENABLE_HUSH_MEMLEAK
 	BLTIN("memleak"  , builtin_memleak , NULL),
 #endif
+#if ENABLE_HUSH_READ
 	BLTIN("read"     , builtin_read    , "Input into variable"),
+#endif
 #if ENABLE_HUSH_FUNCTIONS
-	BLTIN("return"   , builtin_return  , "Return from a function"),
+	BLTIN("return"   , builtin_return  , "Return from function"),
+#endif
+#if ENABLE_HUSH_SET
+	BLTIN("set"      , builtin_set     , "Set positional parameters"),
 #endif
-	BLTIN("set"      , builtin_set     , "Set/unset positional parameters"),
 	BLTIN("shift"    , builtin_shift   , "Shift positional parameters"),
-#if ENABLE_HUSH_BASH_COMPAT
-	BLTIN("source"   , builtin_source  , "Run commands in a file"),
+#if BASH_SOURCE
+	BLTIN("source"   , builtin_source  , NULL),
 #endif
+#if ENABLE_HUSH_TRAP
 	BLTIN("trap"     , builtin_trap    , "Trap signals"),
+#endif
 	BLTIN("true"     , builtin_true    , NULL),
+#if ENABLE_HUSH_TYPE
 	BLTIN("type"     , builtin_type    , "Show command type"),
-	BLTIN("ulimit"   , shell_builtin_ulimit  , "Control resource limits"),
+#endif
+#if ENABLE_HUSH_ULIMIT
+	BLTIN("ulimit"   , shell_builtin_ulimit, "Control resource limits"),
+#endif
+#if ENABLE_HUSH_UMASK
 	BLTIN("umask"    , builtin_umask   , "Set file creation mask"),
+#endif
+#if ENABLE_HUSH_UNSET
 	BLTIN("unset"    , builtin_unset   , "Unset variables"),
+#endif
+#if ENABLE_HUSH_WAIT
 	BLTIN("wait"     , builtin_wait    , "Wait for process"),
+#endif
 };
-/* For now, echo and test are unconditionally enabled.
- * Maybe make it configurable? */
+/* These builtins won't be used if we are on NOMMU and need to re-exec
+ * (it's cheaper to run an external program in this case):
+ */
 static const struct built_in_command bltins2[] = {
+#if ENABLE_HUSH_TEST
 	BLTIN("["        , builtin_test    , NULL),
+#endif
+#if BASH_TEST2
+	BLTIN("[["       , builtin_test    , NULL),
+#endif
+#if ENABLE_HUSH_ECHO
 	BLTIN("echo"     , builtin_echo    , NULL),
-#if ENABLE_PRINTF
+#endif
+#if ENABLE_HUSH_PRINTF
 	BLTIN("printf"   , builtin_printf  , NULL),
 #endif
 	BLTIN("pwd"      , builtin_pwd     , NULL),
+#if ENABLE_HUSH_TEST
 	BLTIN("test"     , builtin_test    , NULL),
+#endif
 };
 
 
@@ -1322,7 +1457,7 @@ static void restore_redirected_FILEs(voi
 		fl = fl->next;
 	}
 }
-#if ENABLE_FEATURE_SH_STANDALONE
+#if ENABLE_FEATURE_SH_STANDALONE && BB_MMU
 static void close_all_FILE_list(void)
 {
 	struct FILE_list *fl = G.FILE_list;
@@ -1346,7 +1481,7 @@ typedef struct save_arg_t {
 	char *sv_argv0;
 	char **sv_g_argv;
 	int sv_g_argc;
-	smallint sv_g_malloced;
+	IF_HUSH_SET(smallint sv_g_malloced;)
 } save_arg_t;
 
 static void save_and_replace_G_args(save_arg_t *sv, char **argv)
@@ -1356,11 +1491,11 @@ static void save_and_replace_G_args(save
 	sv->sv_argv0 = argv[0];
 	sv->sv_g_argv = G.global_argv;
 	sv->sv_g_argc = G.global_argc;
-	sv->sv_g_malloced = G.global_args_malloced;
+	IF_HUSH_SET(sv->sv_g_malloced = G.global_args_malloced;)
 
 	argv[0] = G.global_argv[0]; /* retain $0 */
 	G.global_argv = argv;
-	G.global_args_malloced = 0;
+	IF_HUSH_SET(G.global_args_malloced = 0;)
 
 	n = 1;
 	while (*++argv)
@@ -1370,19 +1505,19 @@ static void save_and_replace_G_args(save
 
 static void restore_G_args(save_arg_t *sv, char **argv)
 {
-	char **pp;
-
+#if ENABLE_HUSH_SET
 	if (G.global_args_malloced) {
 		/* someone ran "set -- arg1 arg2 ...", undo */
-		pp = G.global_argv;
+		char **pp = G.global_argv;
 		while (*++pp) /* note: does not free $0 */
 			free(*pp);
 		free(G.global_argv);
 	}
+#endif
 	argv[0] = sv->sv_argv0;
 	G.global_argv = sv->sv_g_argv;
 	G.global_argc = sv->sv_g_argc;
-	G.global_args_malloced = sv->sv_g_malloced;
+	IF_HUSH_SET(G.global_args_malloced = sv->sv_g_malloced;)
 }
 
 
@@ -1670,13 +1805,13 @@ static void hush_exit(int exitcode)
 #endif
 
 	fflush_all();
-	if (G.exiting <= 0 && G.traps && G.traps[0] && G.traps[0][0]) {
+	if (G.exiting <= 0 && G_traps && G_traps[0] && G_traps[0][0]) {
 		char *argv[3];
 		/* argv[0] is unused */
-		argv[1] = G.traps[0];
+		argv[1] = G_traps[0];
 		argv[2] = NULL;
 		G.exiting = 1; /* prevent EXIT trap recursion */
-		/* Note: G.traps[0] is not cleared!
+		/* Note: G_traps[0] is not cleared!
 		 * "trap" will still show it, if executed
 		 * in the handler */
 		builtin_eval(argv);
@@ -1727,14 +1862,14 @@ static int check_and_run_traps(void)
 		} while (sig < NSIG);
 		break;
  got_sig:
-		if (G.traps && G.traps[sig]) {
+		if (G_traps && G_traps[sig]) {
 			debug_printf_exec("%s: sig:%d handler:'%s'\n", __func__, sig, G.traps[sig]);
-			if (G.traps[sig][0]) {
+			if (G_traps[sig][0]) {
 				/* We have user-defined handler */
 				smalluint save_rcode;
 				char *argv[3];
 				/* argv[0] is unused */
-				argv[1] = G.traps[sig];
+				argv[1] = G_traps[sig];
 				argv[2] = NULL;
 				save_rcode = G.last_exitcode;
 				builtin_eval(argv);
@@ -1773,7 +1908,7 @@ static int check_and_run_traps(void)
 			G.count_SIGCHLD++;
 //bb_error_msg("[%d] check_and_run_traps: G.count_SIGCHLD:%d G.handled_SIGCHLD:%d", getpid(), G.count_SIGCHLD, G.handled_SIGCHLD);
 			/* Note:
-			 * We dont do 'last_sig = sig' here -> NOT returning this sig.
+			 * We don't do 'last_sig = sig' here -> NOT returning this sig.
 			 * This simplifies wait builtin a bit.
 			 */
 			break;
@@ -1782,7 +1917,7 @@ static int check_and_run_traps(void)
 			debug_printf_exec("%s: sig:%d default handling is to ignore\n", __func__, sig);
 			/* SIGTERM, SIGQUIT, SIGTTIN, SIGTTOU, SIGTSTP */
 			/* Note:
-			 * We dont do 'last_sig = sig' here -> NOT returning this sig.
+			 * We don't do 'last_sig = sig' here -> NOT returning this sig.
 			 * Example: wait is not interrupted by TERM
 			 * in interactive shell, because TERM is ignored.
 			 */
@@ -2030,10 +2165,12 @@ static int unset_local_var_len(const cha
 	return EXIT_SUCCESS;
 }
 
+#if ENABLE_HUSH_UNSET
 static int unset_local_var(const char *name)
 {
 	return unset_local_var_len(name, strlen(name));
 }
+#endif
 
 static void unset_vars(char **strings)
 {
@@ -2050,11 +2187,13 @@ static void unset_vars(char **strings)
 	free(strings);
 }
 
+#if BASH_HOSTNAME_VAR || ENABLE_FEATURE_SH_MATH || ENABLE_HUSH_READ
 static void FAST_FUNC set_local_var_from_halves(const char *name, const char *val)
 {
 	char *var = xasprintf("%s=%s", name, val);
 	set_local_var(var, /*flags:*/ 0, /*lvl:*/ 0, /*ro:*/ 0);
 }
+#endif
 
 
 /*
@@ -2141,7 +2280,7 @@ static void reinit_unicode_for_hush(void
  *	AT\
  *	H\
  *	\
- * It excercises a lot of corner cases.
+ * It exercises a lot of corner cases.
  */
 static void cmdedit_update_prompt(void)
 {
@@ -3507,7 +3646,7 @@ static int done_word(o_string *word, str
 						(ctx->ctx_res_w == RES_SNTX));
 				return (ctx->ctx_res_w == RES_SNTX);
 			}
-# if ENABLE_HUSH_BASH_COMPAT
+# if BASH_TEST2
 			if (strcmp(word->data, "[[") == 0) {
 				command->cmd_type = CMD_SINGLEWORD_NOGLOB;
 			}
@@ -4105,7 +4244,7 @@ static int add_till_closing_bracket(o_st
 {
 	int ch;
 	char dbl = end_ch & DOUBLE_CLOSE_CHAR_FLAG;
-# if ENABLE_HUSH_BASH_COMPAT
+# if BASH_SUBSTR || BASH_PATTERN_SUBST
 	char end_char2 = end_ch >> 8;
 # endif
 	end_ch &= (DOUBLE_CLOSE_CHAR_FLAG - 1);
@@ -4116,7 +4255,11 @@ static int add_till_closing_bracket(o_st
 			syntax_error_unterm_ch(end_ch);
 			return 0;
 		}
-		if (ch == end_ch  IF_HUSH_BASH_COMPAT( || ch == end_char2)) {
+		if (ch == end_ch
+# if BASH_SUBSTR || BASH_PATTERN_SUBST
+			|| ch == end_char2
+# endif
+		) {
 			if (!dbl)
 				break;
 			/* we look for closing )) of $((EXPR)) */
@@ -4269,14 +4412,14 @@ static int parse_dollar(o_string *as_str
 
 				/* Eat everything until closing '}' (or ':') */
 				end_ch = '}';
-				if (ENABLE_HUSH_BASH_COMPAT
+				if (BASH_SUBSTR
 				 && ch == ':'
 				 && !strchr(MINUS_PLUS_EQUAL_QUESTION, i_peek(input))
 				) {
 					/* It's ${var:N[:M]} thing */
 					end_ch = '}' * 0x100 + ':';
 				}
-				if (ENABLE_HUSH_BASH_COMPAT
+				if (BASH_PATTERN_SUBST
 				 && ch == '/'
 				) {
 					/* It's ${var/[/]pattern[/repl]} thing */
@@ -4303,7 +4446,9 @@ static int parse_dollar(o_string *as_str
 					o_addchr(as_string, last_ch);
 				}
 
-				if (ENABLE_HUSH_BASH_COMPAT && (end_ch & 0xff00)) {
+				if ((BASH_SUBSTR || BASH_PATTERN_SUBST)
+					 && (end_ch & 0xff00)
+				) {
 					/* close the first block: */
 					o_addchr(dest, SPECIAL_VAR_SYMBOL);
 					/* while parsing N from ${var:N[:M]}
@@ -4314,7 +4459,7 @@ static int parse_dollar(o_string *as_str
 						goto again;
 					}
 					/* got '}' */
-					if (end_ch == '}' * 0x100 + ':') {
+					if (BASH_SUBSTR && end_ch == '}' * 0x100 + ':') {
 						/* it's ${var:N} - emulate :999999999 */
 						o_addstr(dest, "999999999");
 					} /* else: it's ${var/[/]pattern} */
@@ -4389,7 +4534,7 @@ static int parse_dollar(o_string *as_str
 }
 
 #if BB_MMU
-# if ENABLE_HUSH_BASH_COMPAT
+# if BASH_PATTERN_SUBST
 #define encode_string(as_string, dest, input, dquote_end, process_bkslash) \
 	encode_string(dest, input, dquote_end, process_bkslash)
 # else
@@ -4401,7 +4546,7 @@ static int parse_dollar(o_string *as_str
 
 #else /* !MMU */
 
-# if ENABLE_HUSH_BASH_COMPAT
+# if BASH_PATTERN_SUBST
 /* all parameters are needed, no macro tricks */
 # else
 #define encode_string(as_string, dest, input, dquote_end, process_bkslash) \
@@ -4414,7 +4559,7 @@ static int encode_string(o_string *as_st
 		int dquote_end,
 		int process_bkslash)
 {
-#if !ENABLE_HUSH_BASH_COMPAT
+#if !BASH_PATTERN_SUBST
 	const int process_bkslash = 1;
 #endif
 	int ch;
@@ -5057,7 +5202,7 @@ static struct pipe *parse_stream(char **
 /*** Execution routines ***/
 
 /* Expansion can recurse, need forward decls: */
-#if !ENABLE_HUSH_BASH_COMPAT
+#if !BASH_PATTERN_SUBST
 /* only ${var/pattern/repl} (its pattern part) needs additional mode */
 #define expand_string_to_string(str, do_unbackslash) \
 	expand_string_to_string(str)
@@ -5090,7 +5235,7 @@ static void o_addblock_duplicate_backsla
 			/* And now we want to add { or } and continue:
 			 *  o_addchr(o, c);
 			 *  continue;
-			 * luckily, just falling throught achieves this.
+			 * luckily, just falling through achieves this.
 			 */
 		}
 #endif
@@ -5178,7 +5323,7 @@ static int expand_on_ifs(int *ended_with
  * Returns malloced string.
  * As an optimization, we return NULL if expansion is not needed.
  */
-#if !ENABLE_HUSH_BASH_COMPAT
+#if !BASH_PATTERN_SUBST
 /* only ${var/pattern/repl} (its pattern part) needs additional mode */
 #define encode_then_expand_string(str, process_bkslash, do_unbackslash) \
 	encode_then_expand_string(str)
@@ -5232,7 +5377,7 @@ static arith_t expand_and_evaluate_arith
 }
 #endif
 
-#if ENABLE_HUSH_BASH_COMPAT
+#if BASH_PATTERN_SUBST
 /* ${var/[/]pattern[/repl]} helpers */
 static char *strstr_pattern(char *val, const char *pattern, int *size)
 {
@@ -5284,7 +5429,7 @@ static char *replace_pattern(char *val,
 	debug_printf_varexp("result:'%s'\n", result);
 	return result;
 }
-#endif
+#endif /* BASH_PATTERN_SUBST */
 
 /* Helper:
  * Handles <SPECIAL_VAR_SYMBOL>varname...<SPECIAL_VAR_SYMBOL> construct.
@@ -5332,7 +5477,7 @@ static NOINLINE const char *expand_one_v
 			if (exp_op == ':') {
 				exp_op = *exp_word++;
 //TODO: try ${var:} and ${var:bogus} in non-bash config
-				if (ENABLE_HUSH_BASH_COMPAT
+				if (BASH_SUBSTR
 				 && (!exp_op || !strchr(MINUS_PLUS_EQUAL_QUESTION, exp_op))
 				) {
 					/* oops... it's ${var:N[:M]}, not ${var:?xxx} or some such */
@@ -5414,7 +5559,7 @@ static NOINLINE const char *expand_one_v
 				}
 			}
 		}
-#if ENABLE_HUSH_BASH_COMPAT
+#if BASH_PATTERN_SUBST
 		else if (exp_op == '/' || exp_op == '\\') {
 			/* It's ${var/[/]pattern[/repl]} thing.
 			 * Note that in encoded form it has TWO parts:
@@ -5461,9 +5606,9 @@ static NOINLINE const char *expand_one_v
 				free(repl);
 			}
 		}
-#endif
+#endif /* BASH_PATTERN_SUBST */
 		else if (exp_op == ':') {
-#if ENABLE_HUSH_BASH_COMPAT && ENABLE_FEATURE_SH_MATH
+#if BASH_SUBSTR && ENABLE_FEATURE_SH_MATH
 			/* It's ${var:N[:M]} bashism.
 			 * Note that in encoded form it has TWO parts:
 			 * var:N<SPECIAL_VAR_SYMBOL>M<SPECIAL_VAR_SYMBOL>
@@ -5499,7 +5644,7 @@ static NOINLINE const char *expand_one_v
 				}
 				debug_printf_varexp("val:'%s'\n", val);
 			} else
-#endif
+#endif /* HUSH_SUBSTR_EXPANSION && FEATURE_SH_MATH */
 			{
 				die_if_script("malformed ${%s:...}", var);
 				val = NULL;
@@ -5685,7 +5830,7 @@ static NOINLINE int expand_vars_to_list(
 			arg++;
 			/* Can't just stuff it into output o_string,
 			 * expanded result may need to be globbed
-			 * and $IFS-splitted */
+			 * and $IFS-split */
 			debug_printf_subst("SUBST '%s' first_ch %x\n", arg, first_ch);
 			G.last_exitcode = process_command_subs(&subst_result, arg);
 			debug_printf_subst("SUBST RES:%d '%s'\n", G.last_exitcode, subst_result.data);
@@ -5789,7 +5934,7 @@ static char **expand_strvec_to_strvec(ch
 	return expand_variables(argv, EXP_FLAG_GLOB | EXP_FLAG_ESC_GLOB_CHARS);
 }
 
-#if ENABLE_HUSH_BASH_COMPAT
+#if BASH_TEST2
 static char **expand_strvec_to_strvec_singleword_noglob(char **argv)
 {
 	return expand_variables(argv, EXP_FLAG_SINGLEWORD);
@@ -5804,7 +5949,7 @@ static char **expand_strvec_to_strvec_si
  */
 static char *expand_string_to_string(const char *str, int do_unbackslash)
 {
-#if !ENABLE_HUSH_BASH_COMPAT
+#if !BASH_PATTERN_SUBST
 	const int do_unbackslash = 1;
 #endif
 	char *argv[2], **list;
@@ -5882,13 +6027,15 @@ static void switch_off_special_sigs(unsi
 		sig++;
 		if (!(mask & 1))
 			continue;
-		if (G.traps) {
-			if (G.traps[sig] && !G.traps[sig][0])
+#if ENABLE_HUSH_TRAP
+		if (G_traps) {
+			if (G_traps[sig] && !G_traps[sig][0])
 				/* trap is '', has to remain SIG_IGN */
 				continue;
-			free(G.traps[sig]);
-			G.traps[sig] = NULL;
+			free(G_traps[sig]);
+			G_traps[sig] = NULL;
 		}
+#endif
 		/* We are here only if no trap or trap was not '' */
 		install_sighandler(sig, SIG_DFL);
 	}
@@ -5905,7 +6052,7 @@ static void reset_traps_to_defaults(void
 	/* This function is always called in a child shell
 	 * after fork (not vfork, NOMMU doesn't use this function).
 	 */
-	unsigned sig;
+	IF_HUSH_TRAP(unsigned sig;)
 	unsigned mask;
 
 	/* Child shells are not interactive.
@@ -5914,35 +6061,37 @@ static void reset_traps_to_defaults(void
 	 * Same goes for SIGTERM, SIGHUP, SIGINT.
 	 */
 	mask = (G.special_sig_mask & SPECIAL_INTERACTIVE_SIGS) | G_fatal_sig_mask;
-	if (!G.traps && !mask)
+	if (!G_traps && !mask)
 		return; /* already no traps and no special sigs */
 
 	/* Switch off special sigs */
 	switch_off_special_sigs(mask);
-#if ENABLE_HUSH_JOB
+# if ENABLE_HUSH_JOB
 	G_fatal_sig_mask = 0;
-#endif
+# endif
 	G.special_sig_mask &= ~SPECIAL_INTERACTIVE_SIGS;
 	/* SIGQUIT,SIGCHLD and maybe SPECIAL_JOBSTOP_SIGS
 	 * remain set in G.special_sig_mask */
 
-	if (!G.traps)
+# if ENABLE_HUSH_TRAP
+	if (!G_traps)
 		return;
 
 	/* Reset all sigs to default except ones with empty traps */
 	for (sig = 0; sig < NSIG; sig++) {
-		if (!G.traps[sig])
+		if (!G_traps[sig])
 			continue; /* no trap: nothing to do */
-		if (!G.traps[sig][0])
+		if (!G_traps[sig][0])
 			continue; /* empty trap: has to remain SIG_IGN */
 		/* sig has non-empty trap, reset it: */
-		free(G.traps[sig]);
-		G.traps[sig] = NULL;
+		free(G_traps[sig]);
+		G_traps[sig] = NULL;
 		/* There is no signal for trap 0 (EXIT) */
 		if (sig == 0)
 			continue;
 		install_sighandler(sig, pick_sighandler(sig));
 	}
+# endif
 }
 
 #else /* !BB_MMU */
@@ -5982,10 +6131,10 @@ static void re_execute_shell(char ***to_
 		cnt++;
 
 	empty_trap_mask = 0;
-	if (G.traps) {
+	if (G_traps) {
 		int sig;
 		for (sig = 1; sig < NSIG; sig++) {
-			if (G.traps[sig] && !G.traps[sig][0])
+			if (G_traps[sig] && !G_traps[sig][0])
 				empty_trap_mask |= 1LL << sig;
 		}
 	}
@@ -6178,6 +6327,7 @@ static FILE *generate_stream_from_string
 		xmove_fd(channel[1], 1);
 		/* Prevent it from trying to handle ctrl-z etc */
 		IF_HUSH_JOB(G.run_list_level = 1;)
+# if ENABLE_HUSH_TRAP
 		/* Awful hack for `trap` or $(trap).
 		 *
 		 * http://www.opengroup.org/onlinepubs/009695399/utilities/trap.html
@@ -6221,6 +6371,7 @@ static FILE *generate_stream_from_string
 			fflush_all(); /* important */
 			_exit(0);
 		}
+# endif
 # if BB_MMU
 		reset_traps_to_defaults();
 		parse_and_run_string(s);
@@ -6629,6 +6780,7 @@ static struct function *new_function(cha
 	return funcp;
 }
 
+# if ENABLE_HUSH_UNSET
 static void unset_func(const char *name)
 {
 	struct function **funcpp = find_function_slot(name);
@@ -6644,13 +6796,14 @@ static void unset_func(const char *name)
 		if (funcp->body) {
 			free_pipe_list(funcp->body);
 			free(funcp->name);
-# if !BB_MMU
+#  if !BB_MMU
 			free(funcp->body_as_string);
-# endif
+#  endif
 		}
 		free(funcp);
 	}
 }
+# endif
 
 # if BB_MMU
 #define exec_function(to_free, funcp, argv) \
@@ -7043,7 +7196,7 @@ static void insert_bg_job(struct pipe *p
 	job->cmdtext = xstrdup(get_cmdtext(pi));
 
 	if (G_interactive_fd)
-		printf("[%d] %d %s\n", job->jobid, job->cmds[0].pid, job->cmdtext);
+		printf("[%u] %u %s\n", job->jobid, (unsigned)job->cmds[0].pid, job->cmdtext);
 	G.last_jobid = job->jobid;
 }
 
@@ -7167,7 +7320,7 @@ static int process_wait_result(struct pi
 			/* There are still running processes in the fg_pipe */
 			return -1;
 		}
-		/* It wasnt in fg_pipe, look for process in bg pipes */
+		/* It wasn't in fg_pipe, look for process in bg pipes */
 	}
 
 #if ENABLE_HUSH_JOB
@@ -7518,7 +7671,7 @@ static NOINLINE int run_pipe(struct pipe
 		}
 
 		/* Expand the rest into (possibly) many strings each */
-#if ENABLE_HUSH_BASH_COMPAT
+#if BASH_TEST2
 		if (command->cmd_type == CMD_SINGLEWORD_NOGLOB) {
 			argv_expanded = expand_strvec_to_strvec_singleword_noglob(argv + command->assignment_cnt);
 		} else
@@ -8118,10 +8271,12 @@ static void install_sighandlers(unsigned
 		if (old_handler == SIG_IGN) {
 			/* oops... restore back to IGN, and record this fact */
 			install_sighandler(sig, old_handler);
-			if (!G.traps)
-				G.traps = xzalloc(sizeof(G.traps[0]) * NSIG);
-			free(G.traps[sig]);
-			G.traps[sig] = xzalloc(1); /* == xstrdup(""); */
+#if ENABLE_HUSH_TRAP
+			if (!G_traps)
+				G_traps = xzalloc(sizeof(G_traps[0]) * NSIG);
+			free(G_traps[sig]);
+			G_traps[sig] = xzalloc(1); /* == xstrdup(""); */
+#endif
 		}
 	}
 }
@@ -8272,7 +8427,7 @@ int hush_main(int argc, char **argv)
 	/* Export PWD */
 	set_pwd_var(/*exp:*/ 1);
 
-#if ENABLE_HUSH_BASH_COMPAT
+#if BASH_HOSTNAME_VAR
 	/* Set (but not export) HOSTNAME unless already set */
 	if (!get_local_var_value("HOSTNAME")) {
 		struct utsname uts;
@@ -8420,15 +8575,17 @@ int hush_main(int argc, char **argv)
 			optarg++;
 			empty_trap_mask = bb_strtoull(optarg, &optarg, 16);
 			if (empty_trap_mask != 0) {
-				int sig;
+				IF_HUSH_TRAP(int sig;)
 				install_special_sighandlers();
-				G.traps = xzalloc(sizeof(G.traps[0]) * NSIG);
+# if ENABLE_HUSH_TRAP
+				G_traps = xzalloc(sizeof(G_traps[0]) * NSIG);
 				for (sig = 1; sig < NSIG; sig++) {
 					if (empty_trap_mask & (1LL << sig)) {
-						G.traps[sig] = xzalloc(1); /* == xstrdup(""); */
+						G_traps[sig] = xzalloc(1); /* == xstrdup(""); */
 						install_sighandler(sig, SIG_IGN);
 					}
 				}
+# endif
 			}
 # if ENABLE_HUSH_LOOPS
 			optarg++;
@@ -8669,6 +8826,7 @@ static int FAST_FUNC builtin_true(char *
 	return 0;
 }
 
+#if ENABLE_HUSH_TEST || ENABLE_HUSH_ECHO || ENABLE_HUSH_PRINTF || ENABLE_HUSH_KILL
 static int run_applet_main(char **argv, int (*applet_main_func)(int argc, char **argv))
 {
 	int argc = 0;
@@ -8678,24 +8836,50 @@ static int run_applet_main(char **argv,
 	}
 	return applet_main_func(argc, argv - argc);
 }
-
+#endif
+#if ENABLE_HUSH_TEST || BASH_TEST2
 static int FAST_FUNC builtin_test(char **argv)
 {
 	return run_applet_main(argv, test_main);
 }
-
+#endif
+#if ENABLE_HUSH_ECHO
 static int FAST_FUNC builtin_echo(char **argv)
 {
 	return run_applet_main(argv, echo_main);
 }
-
-#if ENABLE_PRINTF
+#endif
+#if ENABLE_HUSH_PRINTF
 static int FAST_FUNC builtin_printf(char **argv)
 {
 	return run_applet_main(argv, printf_main);
 }
 #endif
 
+#if ENABLE_HUSH_HELP
+static int FAST_FUNC builtin_help(char **argv UNUSED_PARAM)
+{
+	const struct built_in_command *x;
+
+	printf(
+		"Built-in commands:\n"
+		"------------------\n");
+	for (x = bltins1; x != &bltins1[ARRAY_SIZE(bltins1)]; x++) {
+		if (x->b_descr)
+			printf("%-10s%s\n", x->b_cmd, x->b_descr);
+	}
+	return EXIT_SUCCESS;
+}
+#endif
+
+#if MAX_HISTORY && ENABLE_FEATURE_EDITING
+static int FAST_FUNC builtin_history(char **argv UNUSED_PARAM)
+{
+	show_history(G.line_input_state);
+	return EXIT_SUCCESS;
+}
+#endif
+
 static char **skip_dash_dash(char **argv)
 {
 	argv++;
@@ -8704,24 +8888,6 @@ static char **skip_dash_dash(char **argv
 	return argv;
 }
 
-static int FAST_FUNC builtin_eval(char **argv)
-{
-	int rcode = EXIT_SUCCESS;
-
-	argv = skip_dash_dash(argv);
-	if (*argv) {
-		char *str = expand_strvec_to_string(argv);
-		/* bash:
-		 * eval "echo Hi; done" ("done" is syntax error):
-		 * "echo Hi" will not execute too.
-		 */
-		parse_and_run_string(str);
-		free(str);
-		rcode = G.last_exitcode;
-	}
-	return rcode;
-}
-
 static int FAST_FUNC builtin_cd(char **argv)
 {
 	const char *newdir;
@@ -8749,6 +8915,30 @@ static int FAST_FUNC builtin_cd(char **a
 	return EXIT_SUCCESS;
 }
 
+static int FAST_FUNC builtin_pwd(char **argv UNUSED_PARAM)
+{
+	puts(get_cwd(0));
+	return EXIT_SUCCESS;
+}
+
+static int FAST_FUNC builtin_eval(char **argv)
+{
+	int rcode = EXIT_SUCCESS;
+
+	argv = skip_dash_dash(argv);
+	if (*argv) {
+		char *str = expand_strvec_to_string(argv);
+		/* bash:
+		 * eval "echo Hi; done" ("done" is syntax error):
+		 * "echo Hi" will not execute too.
+		 */
+		parse_and_run_string(str);
+		free(str);
+		rcode = G.last_exitcode;
+	}
+	return rcode;
+}
+
 static int FAST_FUNC builtin_exec(char **argv)
 {
 	argv = skip_dash_dash(argv);
@@ -8794,41 +8984,188 @@ static int FAST_FUNC builtin_exit(char *
 	hush_exit(xatoi(argv[0]) & 0xff);
 }
 
-static void print_escaped(const char *s)
+#if ENABLE_HUSH_TYPE
+/* http://www.opengroup.org/onlinepubs/9699919799/utilities/type.html */
+static int FAST_FUNC builtin_type(char **argv)
 {
-	if (*s == '\'')
-		goto squote;
-	do {
-		const char *p = strchrnul(s, '\'');
-		/* print 'xxxx', possibly just '' */
-		printf("'%.*s'", (int)(p - s), s);
-		if (*p == '\0')
-			break;
-		s = p;
- squote:
-		/* s points to '; print "'''...'''" */
-		putchar('"');
-		do putchar('\''); while (*++s == '\'');
-		putchar('"');
-	} while (*s);
-}
+	int ret = EXIT_SUCCESS;
 
-#if !ENABLE_HUSH_LOCAL
-#define helper_export_local(argv, exp, lvl) \
-	helper_export_local(argv, exp)
+	while (*++argv) {
+		const char *type;
+		char *path = NULL;
+
+		if (0) {} /* make conditional compile easier below */
+		/*else if (find_alias(*argv))
+			type = "an alias";*/
+#if ENABLE_HUSH_FUNCTIONS
+		else if (find_function(*argv))
+			type = "a function";
 #endif
-static void helper_export_local(char **argv, int exp, int lvl)
-{
-	do {
-		char *name = *argv;
-		char *name_end = strchrnul(name, '=');
+		else if (find_builtin(*argv))
+			type = "a shell builtin";
+		else if ((path = find_in_path(*argv)) != NULL)
+			type = path;
+		else {
+			bb_error_msg("type: %s: not found", *argv);
+			ret = EXIT_FAILURE;
+			continue;
+		}
 
-		/* So far we do not check that name is valid (TODO?) */
+		printf("%s is %s\n", *argv, type);
+		free(path);
+	}
 
-		if (*name_end == '\0') {
-			struct variable *var, **vpp;
+	return ret;
+}
+#endif
 
-			vpp = get_ptr_to_local_var(name, name_end - name);
+#if ENABLE_HUSH_READ
+/* Interruptibility of read builtin in bash
+ * (tested on bash-4.2.8 by sending signals (not by ^C)):
+ *
+ * Empty trap makes read ignore corresponding signal, for any signal.
+ *
+ * SIGINT:
+ * - terminates non-interactive shell;
+ * - interrupts read in interactive shell;
+ * if it has non-empty trap:
+ * - executes trap and returns to command prompt in interactive shell;
+ * - executes trap and returns to read in non-interactive shell;
+ * SIGTERM:
+ * - is ignored (does not interrupt) read in interactive shell;
+ * - terminates non-interactive shell;
+ * if it has non-empty trap:
+ * - executes trap and returns to read;
+ * SIGHUP:
+ * - terminates shell (regardless of interactivity);
+ * if it has non-empty trap:
+ * - executes trap and returns to read;
+ * SIGCHLD from children:
+ * - does not interrupt read regardless of interactivity:
+ *   try: sleep 1 & read x; echo $x
+ */
+static int FAST_FUNC builtin_read(char **argv)
+{
+	const char *r;
+	char *opt_n = NULL;
+	char *opt_p = NULL;
+	char *opt_t = NULL;
+	char *opt_u = NULL;
+	const char *ifs;
+	int read_flags;
+
+	/* "!": do not abort on errors.
+	 * Option string must start with "sr" to match BUILTIN_READ_xxx
+	 */
+	read_flags = getopt32(argv, "!srn:p:t:u:", &opt_n, &opt_p, &opt_t, &opt_u);
+	if (read_flags == (uint32_t)-1)
+		return EXIT_FAILURE;
+	argv += optind;
+	ifs = get_local_var_value("IFS"); /* can be NULL */
+
+ again:
+	r = shell_builtin_read(set_local_var_from_halves,
+		argv,
+		ifs,
+		read_flags,
+		opt_n,
+		opt_p,
+		opt_t,
+		opt_u
+	);
+
+	if ((uintptr_t)r == 1 && errno == EINTR) {
+		unsigned sig = check_and_run_traps();
+		if (sig != SIGINT)
+			goto again;
+	}
+
+	if ((uintptr_t)r > 1) {
+		bb_error_msg("%s", r);
+		r = (char*)(uintptr_t)1;
+	}
+
+	return (uintptr_t)r;
+}
+#endif
+
+#if ENABLE_HUSH_UMASK
+static int FAST_FUNC builtin_umask(char **argv)
+{
+	int rc;
+	mode_t mask;
+
+	rc = 1;
+	mask = umask(0);
+	argv = skip_dash_dash(argv);
+	if (argv[0]) {
+		mode_t old_mask = mask;
+
+		/* numeric umasks are taken as-is */
+		/* symbolic umasks are inverted: "umask a=rx" calls umask(222) */
+		if (!isdigit(argv[0][0]))
+			mask ^= 0777;
+		mask = bb_parse_mode(argv[0], mask);
+		if (!isdigit(argv[0][0]))
+			mask ^= 0777;
+		if ((unsigned)mask > 0777) {
+			mask = old_mask;
+			/* bash messages:
+			 * bash: umask: 'q': invalid symbolic mode operator
+			 * bash: umask: 999: octal number out of range
+			 */
+			bb_error_msg("%s: invalid mode '%s'", "umask", argv[0]);
+			rc = 0;
+		}
+	} else {
+		/* Mimic bash */
+		printf("%04o\n", (unsigned) mask);
+		/* fall through and restore mask which we set to 0 */
+	}
+	umask(mask);
+
+	return !rc; /* rc != 0 - success */
+}
+#endif
+
+#if ENABLE_HUSH_EXPORT || ENABLE_HUSH_TRAP
+static void print_escaped(const char *s)
+{
+	if (*s == '\'')
+		goto squote;
+	do {
+		const char *p = strchrnul(s, '\'');
+		/* print 'xxxx', possibly just '' */
+		printf("'%.*s'", (int)(p - s), s);
+		if (*p == '\0')
+			break;
+		s = p;
+ squote:
+		/* s points to '; print "'''...'''" */
+		putchar('"');
+		do putchar('\''); while (*++s == '\'');
+		putchar('"');
+	} while (*s);
+}
+#endif
+
+#if ENABLE_HUSH_EXPORT || ENABLE_HUSH_LOCAL
+# if !ENABLE_HUSH_LOCAL
+#define helper_export_local(argv, exp, lvl) \
+	helper_export_local(argv, exp)
+# endif
+static void helper_export_local(char **argv, int exp, int lvl)
+{
+	do {
+		char *name = *argv;
+		char *name_end = strchrnul(name, '=');
+
+		/* So far we do not check that name is valid (TODO?) */
+
+		if (*name_end == '\0') {
+			struct variable *var, **vpp;
+
+			vpp = get_ptr_to_local_var(name, name_end - name);
 			var = vpp ? *vpp : NULL;
 
 			if (exp == -1) { /* unexporting? */
@@ -8849,14 +9186,14 @@ static void helper_export_local(char **a
 					continue;
 				}
 			}
-#if ENABLE_HUSH_LOCAL
+# if ENABLE_HUSH_LOCAL
 			if (exp == 0 /* local? */
 			 && var && var->func_nest_level == lvl
 			) {
 				/* "local x=abc; ...; local x" - ignore second local decl */
 				continue;
 			}
-#endif
+# endif
 			/* Exporting non-existing variable.
 			 * bash does not put it in environment,
 			 * but remembers that it is exported,
@@ -8872,7 +9209,9 @@ static void helper_export_local(char **a
 		set_local_var(name, /*exp:*/ exp, /*lvl:*/ lvl, /*ro:*/ 0);
 	} while (*++argv);
 }
+#endif
 
+#if ENABLE_HUSH_EXPORT
 static int FAST_FUNC builtin_export(char **argv)
 {
 	unsigned opt_unexport;
@@ -8918,6 +9257,7 @@ static int FAST_FUNC builtin_export(char
 
 	return EXIT_SUCCESS;
 }
+#endif
 
 #if ENABLE_HUSH_LOCAL
 static int FAST_FUNC builtin_local(char **argv)
@@ -8931,6 +9271,7 @@ static int FAST_FUNC builtin_local(char
 }
 #endif
 
+#if ENABLE_HUSH_UNSET
 /* http://www.opengroup.org/onlinepubs/9699919799/utilities/V3_chap02.html#unset */
 static int FAST_FUNC builtin_unset(char **argv)
 {
@@ -8958,16 +9299,18 @@ static int FAST_FUNC builtin_unset(char
 				ret = EXIT_FAILURE;
 			}
 		}
-#if ENABLE_HUSH_FUNCTIONS
+# if ENABLE_HUSH_FUNCTIONS
 		else {
 			unset_func(*argv);
 		}
-#endif
+# endif
 		argv++;
 	}
 	return ret;
 }
+#endif
 
+#if ENABLE_HUSH_SET
 /* http://www.opengroup.org/onlinepubs/9699919799/utilities/V3_chap02.html#set
  * built-in 'set' handler
  * SUSv3 says:
@@ -9050,6 +9393,7 @@ static int FAST_FUNC builtin_set(char **
 	bb_error_msg("set: %s: invalid option", arg);
 	return EXIT_FAILURE;
 }
+#endif
 
 static int FAST_FUNC builtin_shift(char **argv)
 {
@@ -9059,7 +9403,7 @@ static int FAST_FUNC builtin_shift(char
 		n = atoi(argv[0]);
 	}
 	if (n >= 0 && n < G.global_argc) {
-		if (G.global_args_malloced) {
+		if (G_global_args_malloced) {
 			int m = 1;
 			while (m <= n)
 				free(G.global_argv[m++]);
@@ -9072,87 +9416,78 @@ static int FAST_FUNC builtin_shift(char
 	return EXIT_FAILURE;
 }
 
-/* Interruptibility of read builtin in bash
- * (tested on bash-4.2.8 by sending signals (not by ^C)):
- *
- * Empty trap makes read ignore corresponding signal, for any signal.
- *
- * SIGINT:
- * - terminates non-interactive shell;
- * - interrupts read in interactive shell;
- * if it has non-empty trap:
- * - executes trap and returns to command prompt in interactive shell;
- * - executes trap and returns to read in non-interactive shell;
- * SIGTERM:
- * - is ignored (does not interrupt) read in interactive shell;
- * - terminates non-interactive shell;
- * if it has non-empty trap:
- * - executes trap and returns to read;
- * SIGHUP:
- * - terminates shell (regardless of interactivity);
- * if it has non-empty trap:
- * - executes trap and returns to read;
- */
-static int FAST_FUNC builtin_read(char **argv)
+static int FAST_FUNC builtin_source(char **argv)
 {
-	const char *r;
-	char *opt_n = NULL;
-	char *opt_p = NULL;
-	char *opt_t = NULL;
-	char *opt_u = NULL;
-	const char *ifs;
-	int read_flags;
+	char *arg_path, *filename;
+	FILE *input;
+	save_arg_t sv;
+	char *args_need_save;
+#if ENABLE_HUSH_FUNCTIONS
+	smallint sv_flg;
+#endif
 
-	/* "!": do not abort on errors.
-	 * Option string must start with "sr" to match BUILTIN_READ_xxx
-	 */
-	read_flags = getopt32(argv, "!srn:p:t:u:", &opt_n, &opt_p, &opt_t, &opt_u);
-	if (read_flags == (uint32_t)-1)
+	argv = skip_dash_dash(argv);
+	filename = argv[0];
+	if (!filename) {
+		/* bash says: "bash: .: filename argument required" */
+		return 2; /* bash compat */
+	}
+	arg_path = NULL;
+	if (!strchr(filename, '/')) {
+		arg_path = find_in_path(filename);
+		if (arg_path)
+			filename = arg_path;
+	}
+	input = remember_FILE(fopen_or_warn(filename, "r"));
+	free(arg_path);
+	if (!input) {
+		/* bb_perror_msg("%s", *argv); - done by fopen_or_warn */
+		/* POSIX: non-interactive shell should abort here,
+		 * not merely fail. So far no one complained :)
+		 */
 		return EXIT_FAILURE;
-	argv += optind;
-	ifs = get_local_var_value("IFS"); /* can be NULL */
+	}
 
- again:
-	r = shell_builtin_read(set_local_var_from_halves,
-		argv,
-		ifs,
-		read_flags,
-		opt_n,
-		opt_p,
-		opt_t,
-		opt_u
-	);
+#if ENABLE_HUSH_FUNCTIONS
+	sv_flg = G_flag_return_in_progress;
+	/* "we are inside sourced file, ok to use return" */
+	G_flag_return_in_progress = -1;
+#endif
+	args_need_save = argv[1]; /* used as a boolean variable */
+	if (args_need_save)
+		save_and_replace_G_args(&sv, argv);
 
-	if ((uintptr_t)r == 1 && errno == EINTR) {
-		unsigned sig = check_and_run_traps();
-		if (sig && sig != SIGINT)
-			goto again;
-	}
+	/* "false; . ./empty_line; echo Zero:$?" should print 0 */
+	G.last_exitcode = 0;
+	parse_and_run_file(input);
+	fclose_and_forget(input);
 
-	if ((uintptr_t)r > 1) {
-		bb_error_msg("%s", r);
-		r = (char*)(uintptr_t)1;
-	}
+	if (args_need_save) /* can't use argv[1] instead: "shift" can mangle it */
+		restore_G_args(&sv, argv);
+#if ENABLE_HUSH_FUNCTIONS
+	G_flag_return_in_progress = sv_flg;
+#endif
 
-	return (uintptr_t)r;
+	return G.last_exitcode;
 }
 
+#if ENABLE_HUSH_TRAP
 static int FAST_FUNC builtin_trap(char **argv)
 {
 	int sig;
 	char *new_cmd;
 
-	if (!G.traps)
-		G.traps = xzalloc(sizeof(G.traps[0]) * NSIG);
+	if (!G_traps)
+		G_traps = xzalloc(sizeof(G_traps[0]) * NSIG);
 
 	argv++;
 	if (!*argv) {
 		int i;
 		/* No args: print all trapped */
 		for (i = 0; i < NSIG; ++i) {
-			if (G.traps[i]) {
+			if (G_traps[i]) {
 				printf("trap -- ");
-				print_escaped(G.traps[i]);
+				print_escaped(G_traps[i]);
 				/* note: bash adds "SIG", but only if invoked
 				 * as "bash". If called as "sh", or if set -o posix,
 				 * then it prints short signal names.
@@ -9182,11 +9517,11 @@ static int FAST_FUNC builtin_trap(char *
 				continue;
 			}
 
-			free(G.traps[sig]);
-			G.traps[sig] = xstrdup(new_cmd);
+			free(G_traps[sig]);
+			G_traps[sig] = xstrdup(new_cmd);
 
 			debug_printf("trap: setting SIG%s (%i) to '%s'\n",
-				get_signame(sig), sig, G.traps[sig]);
+				get_signame(sig), sig, G_traps[sig]);
 
 			/* There is no signal for 0 (EXIT) */
 			if (sig == 0)
@@ -9226,59 +9561,54 @@ static int FAST_FUNC builtin_trap(char *
 	argv++;
 	goto process_sig_list;
 }
+#endif
 
-/* http://www.opengroup.org/onlinepubs/9699919799/utilities/type.html */
-static int FAST_FUNC builtin_type(char **argv)
+#if ENABLE_HUSH_JOB
+static struct pipe *parse_jobspec(const char *str)
 {
-	int ret = EXIT_SUCCESS;
+	struct pipe *pi;
+	unsigned jobnum;
 
-	while (*++argv) {
-		const char *type;
-		char *path = NULL;
-
-		if (0) {} /* make conditional compile easier below */
-		/*else if (find_alias(*argv))
-			type = "an alias";*/
-#if ENABLE_HUSH_FUNCTIONS
-		else if (find_function(*argv))
-			type = "a function";
-#endif
-		else if (find_builtin(*argv))
-			type = "a shell builtin";
-		else if ((path = find_in_path(*argv)) != NULL)
-			type = path;
-		else {
-			bb_error_msg("type: %s: not found", *argv);
-			ret = EXIT_FAILURE;
-			continue;
+	if (sscanf(str, "%%%u", &jobnum) != 1) {
+		if (str[0] != '%'
+		 || (str[1] != '%' && str[1] != '+' && str[1] != '\0')
+		) {
+			bb_error_msg("bad argument '%s'", str);
+			return NULL;
+		}
+		/* It is "%%", "%+" or "%" - current job */
+		jobnum = G.last_jobid;
+		if (jobnum == 0) {
+			bb_error_msg("no current job");
+			return NULL;
 		}
-
-		printf("%s is %s\n", *argv, type);
-		free(path);
-	}
-
-	return ret;
-}
-
-#if ENABLE_HUSH_JOB
-static struct pipe *parse_jobspec(const char *str)
-{
-	struct pipe *pi;
-	int jobnum;
-
-	if (sscanf(str, "%%%d", &jobnum) != 1) {
-		bb_error_msg("bad argument '%s'", str);
-		return NULL;
 	}
 	for (pi = G.job_list; pi; pi = pi->next) {
 		if (pi->jobid == jobnum) {
 			return pi;
 		}
 	}
-	bb_error_msg("%d: no such job", jobnum);
+	bb_error_msg("%u: no such job", jobnum);
 	return NULL;
 }
 
+static int FAST_FUNC builtin_jobs(char **argv UNUSED_PARAM)
+{
+	struct pipe *job;
+	const char *status_string;
+
+	checkjobs(NULL, 0 /*(no pid to wait for)*/);
+	for (job = G.job_list; job; job = job->next) {
+		if (job->alive_cmds == job->stopped_cmds)
+			status_string = "Stopped";
+		else
+			status_string = "Running";
+
+		printf(JOB_STATUS_FORMAT, job->jobid, status_string, job->cmdtext);
+	}
+	return EXIT_SUCCESS;
+}
+
 /* built-in 'fg' and 'bg' handler */
 static int FAST_FUNC builtin_fg_bg(char **argv)
 {
@@ -9334,188 +9664,81 @@ static int FAST_FUNC builtin_fg_bg(char
 }
 #endif
 
-#if ENABLE_HUSH_HELP
-static int FAST_FUNC builtin_help(char **argv UNUSED_PARAM)
+#if ENABLE_HUSH_KILL
+static int FAST_FUNC builtin_kill(char **argv)
 {
-	const struct built_in_command *x;
-
-	printf(
-		"Built-in commands:\n"
-		"------------------\n");
-	for (x = bltins1; x != &bltins1[ARRAY_SIZE(bltins1)]; x++) {
-		if (x->b_descr)
-			printf("%-10s%s\n", x->b_cmd, x->b_descr);
-	}
-	return EXIT_SUCCESS;
-}
-#endif
-
-#if MAX_HISTORY && ENABLE_FEATURE_EDITING
-static int FAST_FUNC builtin_history(char **argv UNUSED_PARAM)
-{
-	show_history(G.line_input_state);
-	return EXIT_SUCCESS;
-}
-#endif
+	int ret = 0;
 
-#if ENABLE_HUSH_JOB
-static int FAST_FUNC builtin_jobs(char **argv UNUSED_PARAM)
-{
-	struct pipe *job;
-	const char *status_string;
+# if ENABLE_HUSH_JOB
+	if (argv[1] && strcmp(argv[1], "-l") != 0) {
+		int i = 1;
 
-	checkjobs(NULL, 0 /*(no pid to wait for)*/);
-	for (job = G.job_list; job; job = job->next) {
-		if (job->alive_cmds == job->stopped_cmds)
-			status_string = "Stopped";
-		else
-			status_string = "Running";
+		do {
+			struct pipe *pi;
+			char *dst;
+			int j, n;
 
-		printf(JOB_STATUS_FORMAT, job->jobid, status_string, job->cmdtext);
+			if (argv[i][0] != '%')
+				continue;
+			/*
+			 * "kill %N" - job kill
+			 * Converting to pgrp / pid kill
+			 */
+			pi = parse_jobspec(argv[i]);
+			if (!pi) {
+				/* Eat bad jobspec */
+				j = i;
+				do {
+					j++;
+					argv[j - 1] = argv[j];
+				} while (argv[j]);
+				ret = 1;
+				i--;
+				continue;
+			}
+			/*
+			 * In jobs started under job control, we signal
+			 * entire process group by kill -PGRP_ID.
+			 * This happens, f.e., in interactive shell.
+			 *
+			 * Otherwise, we signal each child via
+			 * kill PID1 PID2 PID3.
+			 * Testcases:
+			 * sh -c 'sleep 1|sleep 1 & kill %1'
+			 * sh -c 'true|sleep 2 & sleep 1; kill %1'
+			 * sh -c 'true|sleep 1 & sleep 2; kill %1'
+			 */
+			n = G_interactive_fd ? 1 : pi->num_cmds;
+			dst = alloca(n * sizeof(int)*4);
+			argv[i] = dst;
+			if (G_interactive_fd)
+				dst += sprintf(dst, " -%u", (int)pi->pgrp);
+			else for (j = 0; j < n; j++) {
+				struct command *cmd = &pi->cmds[j];
+				/* Skip exited members of the job */
+				if (cmd->pid == 0)
+					continue;
+				/*
+				 * kill_main has matching code to expect
+				 * leading space. Needed to not confuse
+				 * negative pids with "kill -SIGNAL_NO" syntax
+				 */
+				dst += sprintf(dst, " %u", (int)cmd->pid);
+			}
+			*dst = '\0';
+		} while (argv[++i]);
 	}
-	return EXIT_SUCCESS;
-}
-#endif
-
-#if HUSH_DEBUG
-static int FAST_FUNC builtin_memleak(char **argv UNUSED_PARAM)
-{
-	void *p;
-	unsigned long l;
-
-# ifdef M_TRIM_THRESHOLD
-	/* Optional. Reduces probability of false positives */
-	malloc_trim(0);
 # endif
-	/* Crude attempt to find where "free memory" starts,
-	 * sans fragmentation. */
-	p = malloc(240);
-	l = (unsigned long)p;
-	free(p);
-	p = malloc(3400);
-	if (l < (unsigned long)p) l = (unsigned long)p;
-	free(p);
 
-
-# if 0  /* debug */
-	{
-		struct mallinfo mi = mallinfo();
-		printf("top alloc:0x%lx malloced:%d+%d=%d\n", l,
-			mi.arena, mi.hblkhd, mi.arena + mi.hblkhd);
+	if (argv[1] || ret == 0) {
+		ret = run_applet_main(argv, kill_main);
 	}
-# endif
-
-	if (!G.memleak_value)
-		G.memleak_value = l;
-
-	l -= G.memleak_value;
-	if ((long)l < 0)
-		l = 0;
-	l /= 1024;
-	if (l > 127)
-		l = 127;
-
-	/* Exitcode is "how many kilobytes we leaked since 1st call" */
-	return l;
-}
-#endif
-
-static int FAST_FUNC builtin_pwd(char **argv UNUSED_PARAM)
-{
-	puts(get_cwd(0));
-	return EXIT_SUCCESS;
+	/* else: ret = 1, "kill %bad_jobspec" case */
+	return ret;
 }
-
-static int FAST_FUNC builtin_source(char **argv)
-{
-	char *arg_path, *filename;
-	FILE *input;
-	save_arg_t sv;
-#if ENABLE_HUSH_FUNCTIONS
-	smallint sv_flg;
 #endif
 
-	argv = skip_dash_dash(argv);
-	filename = argv[0];
-	if (!filename) {
-		/* bash says: "bash: .: filename argument required" */
-		return 2; /* bash compat */
-	}
-	arg_path = NULL;
-	if (!strchr(filename, '/')) {
-		arg_path = find_in_path(filename);
-		if (arg_path)
-			filename = arg_path;
-	}
-	input = remember_FILE(fopen_or_warn(filename, "r"));
-	free(arg_path);
-	if (!input) {
-		/* bb_perror_msg("%s", *argv); - done by fopen_or_warn */
-		/* POSIX: non-interactive shell should abort here,
-		 * not merely fail. So far no one complained :)
-		 */
-		return EXIT_FAILURE;
-	}
-
-#if ENABLE_HUSH_FUNCTIONS
-	sv_flg = G_flag_return_in_progress;
-	/* "we are inside sourced file, ok to use return" */
-	G_flag_return_in_progress = -1;
-#endif
-	if (argv[1])
-		save_and_replace_G_args(&sv, argv);
-
-	/* "false; . ./empty_line; echo Zero:$?" should print 0 */
-	G.last_exitcode = 0;
-	parse_and_run_file(input);
-	fclose_and_forget(input);
-
-	if (argv[1])
-		restore_G_args(&sv, argv);
-#if ENABLE_HUSH_FUNCTIONS
-	G_flag_return_in_progress = sv_flg;
-#endif
-
-	return G.last_exitcode;
-}
-
-static int FAST_FUNC builtin_umask(char **argv)
-{
-	int rc;
-	mode_t mask;
-
-	rc = 1;
-	mask = umask(0);
-	argv = skip_dash_dash(argv);
-	if (argv[0]) {
-		mode_t old_mask = mask;
-
-		/* numeric umasks are taken as-is */
-		/* symbolic umasks are inverted: "umask a=rx" calls umask(222) */
-		if (!isdigit(argv[0][0]))
-			mask ^= 0777;
-		mask = bb_parse_mode(argv[0], mask);
-		if (!isdigit(argv[0][0]))
-			mask ^= 0777;
-		if ((unsigned)mask > 0777) {
-			mask = old_mask;
-			/* bash messages:
-			 * bash: umask: 'q': invalid symbolic mode operator
-			 * bash: umask: 999: octal number out of range
-			 */
-			bb_error_msg("%s: invalid mode '%s'", "umask", argv[0]);
-			rc = 0;
-		}
-	} else {
-		/* Mimic bash */
-		printf("%04o\n", (unsigned) mask);
-		/* fall through and restore mask which we set to 0 */
-	}
-	umask(mask);
-
-	return !rc; /* rc != 0 - success */
-}
-
+#if ENABLE_HUSH_WAIT
 /* http://www.opengroup.org/onlinepubs/9699919799/utilities/wait.html */
 #if !ENABLE_HUSH_JOB
 # define wait_for_child_or_signal(pipe,pid) wait_for_child_or_signal(pid)
@@ -9622,13 +9845,15 @@ static int FAST_FUNC builtin_wait(char *
 #if ENABLE_HUSH_JOB
 			if (argv[0][0] == '%') {
 				struct pipe *wait_pipe;
+				ret = 127; /* bash compat for bad jobspecs */
 				wait_pipe = parse_jobspec(*argv);
 				if (wait_pipe) {
 					ret = job_exited_or_stopped(wait_pipe);
 					if (ret < 0)
 						ret = wait_for_child_or_signal(wait_pipe, 0);
-					continue;
 				}
+				/* else: parse_jobspec() already emitted error msg */
+				continue;
 			}
 #endif
 			/* mimic bash message */
@@ -9674,6 +9899,7 @@ static int FAST_FUNC builtin_wait(char *
 
 	return ret;
 }
+#endif
 
 #if ENABLE_HUSH_LOOPS || ENABLE_HUSH_FUNCTIONS
 static unsigned parse_numeric_argv1(char **argv, unsigned def, unsigned def_min)
@@ -9740,3 +9966,46 @@ static int FAST_FUNC builtin_return(char
 	return rc;
 }
 #endif
+
+#if ENABLE_HUSH_MEMLEAK
+static int FAST_FUNC builtin_memleak(char **argv UNUSED_PARAM)
+{
+	void *p;
+	unsigned long l;
+
+# ifdef M_TRIM_THRESHOLD
+	/* Optional. Reduces probability of false positives */
+	malloc_trim(0);
+# endif
+	/* Crude attempt to find where "free memory" starts,
+	 * sans fragmentation. */
+	p = malloc(240);
+	l = (unsigned long)p;
+	free(p);
+	p = malloc(3400);
+	if (l < (unsigned long)p) l = (unsigned long)p;
+	free(p);
+
+
+# if 0  /* debug */
+	{
+		struct mallinfo mi = mallinfo();
+		printf("top alloc:0x%lx malloced:%d+%d=%d\n", l,
+			mi.arena, mi.hblkhd, mi.arena + mi.hblkhd);
+	}
+# endif
+
+	if (!G.memleak_value)
+		G.memleak_value = l;
+
+	l -= G.memleak_value;
+	if ((long)l < 0)
+		l = 0;
+	l /= 1024;
+	if (l > 127)
+		l = 127;
+
+	/* Exitcode is "how many kilobytes we leaked since 1st call" */
+	return l;
+}
+#endif
diff -urpN busybox-1.26.2/shell/hush_test/hush-misc/source_argv_and_shift.right busybox-1.27.0/shell/hush_test/hush-misc/source_argv_and_shift.right
--- busybox-1.26.2/shell/hush_test/hush-misc/source_argv_and_shift.right	1970-01-01 01:00:00.000000000 +0100
+++ busybox-1.27.0/shell/hush_test/hush-misc/source_argv_and_shift.right	2017-01-09 08:56:10.000000000 +0100
@@ -0,0 +1,4 @@
+sourced_arg1:1
+arg1:
+sourced_arg1:a
+arg1:1
diff -urpN busybox-1.26.2/shell/hush_test/hush-misc/source_argv_and_shift.tests busybox-1.27.0/shell/hush_test/hush-misc/source_argv_and_shift.tests
--- busybox-1.26.2/shell/hush_test/hush-misc/source_argv_and_shift.tests	1970-01-01 01:00:00.000000000 +0100
+++ busybox-1.27.0/shell/hush_test/hush-misc/source_argv_and_shift.tests	2017-01-09 08:56:10.000000000 +0100
@@ -0,0 +1,12 @@
+echo 'echo sourced_arg1:$1' >sourced1
+echo 'shift' >>sourced1
+
+set -- 1
+. ./sourced1
+echo arg1:$1
+
+set -- 1
+. ./sourced1 a
+echo arg1:$1
+
+rm sourced1
diff -urpN busybox-1.26.2/shell/hush_test/hush-misc/unicode1.tests busybox-1.27.0/shell/hush_test/hush-misc/unicode1.tests
--- busybox-1.26.2/shell/hush_test/hush-misc/unicode1.tests	2016-09-27 18:53:50.000000000 +0200
+++ busybox-1.27.0/shell/hush_test/hush-misc/unicode1.tests	2017-07-01 22:51:12.000000000 +0200
@@ -5,7 +5,7 @@ a=`printf "\xcc\x80"`
 # Should print 1
 echo ${#a}
 
-# A Japanese katakana charachter U+30a3
+# A Japanese katakana character U+30a3
 a=`printf "\xe3\x82\xa3"`
 # Should print 1
 echo ${#a}
diff -urpN busybox-1.26.2/shell/hush_test/hush-read/read_SIGCHLD.right busybox-1.27.0/shell/hush_test/hush-read/read_SIGCHLD.right
--- busybox-1.26.2/shell/hush_test/hush-read/read_SIGCHLD.right	1970-01-01 01:00:00.000000000 +0100
+++ busybox-1.27.0/shell/hush_test/hush-read/read_SIGCHLD.right	2017-07-01 22:51:12.000000000 +0200
@@ -0,0 +1,2 @@
+x='Ok'
+exitcode:0
diff -urpN busybox-1.26.2/shell/hush_test/hush-read/read_SIGCHLD.tests busybox-1.27.0/shell/hush_test/hush-read/read_SIGCHLD.tests
--- busybox-1.26.2/shell/hush_test/hush-read/read_SIGCHLD.tests	1970-01-01 01:00:00.000000000 +0100
+++ busybox-1.27.0/shell/hush_test/hush-read/read_SIGCHLD.tests	2017-07-01 22:51:12.000000000 +0200
@@ -0,0 +1,4 @@
+x=BAD
+{ sleep 0.4; echo Ok; } | { sleep 0.2 & read x; echo "x='$x'"; }
+echo "exitcode:$?"
+
diff -urpN busybox-1.26.2/shell/shell_common.c busybox-1.27.0/shell/shell_common.c
--- busybox-1.26.2/shell/shell_common.c	2016-10-07 16:47:12.000000000 +0200
+++ busybox-1.27.0/shell/shell_common.c	2017-07-01 22:51:12.000000000 +0200
@@ -143,7 +143,7 @@ shell_builtin_read(void FAST_FUNC (*setv
 			// Setting it to more than 1 breaks poll():
 			// it blocks even if there's data. !??
 			//tty.c_cc[VMIN] = nchars < 256 ? nchars : 255;
-			/* reads would block only if < 1 char is available */
+			/* reads will block only if < 1 char is available */
 			tty.c_cc[VMIN] = 1;
 			/* no timeout (reads block forever) */
 			tty.c_cc[VTIME] = 0;
@@ -204,15 +204,17 @@ shell_builtin_read(void FAST_FUNC (*setv
 		c = buffer[bufpos];
 		if (c == '\0')
 			continue;
-		if (backslash) {
-			backslash = 0;
-			if (c != '\n')
-				goto put;
-			continue;
-		}
-		if (!(read_flags & BUILTIN_READ_RAW) && c == '\\') {
-			backslash = 1;
-			continue;
+		if (!(read_flags & BUILTIN_READ_RAW)) {
+			if (backslash) {
+				backslash = 0;
+				if (c != '\n')
+					goto put;
+				continue;
+			}
+			if (c == '\\') {
+				backslash = 1;
+				continue;
+			}
 		}
 		if (c == '\n')
 			break;
@@ -401,13 +403,7 @@ shell_builtin_ulimit(char **argv)
 	/* In case getopt was already called:
 	 * reset the libc getopt() function, which keeps internal state.
 	 */
-#ifdef __GLIBC__
-	optind = 0;
-#else /* BSD style */
-	optind = 1;
-	/* optreset = 1; */
-#endif
-	/* optarg = NULL; opterr = 0; optopt = 0; - do we need this?? */
+	GETOPT_RESET();
 
 	argc = 1;
 	while (argv[argc])
diff -urpN busybox-1.26.2/sysklogd/logread.c busybox-1.27.0/sysklogd/logread.c
--- busybox-1.26.2/sysklogd/logread.c	2017-01-01 13:01:04.000000000 +0100
+++ busybox-1.27.0/sysklogd/logread.c	2017-07-01 22:51:12.000000000 +0200
@@ -24,7 +24,7 @@
 //config:	default y
 //config:	depends on LOGREAD
 //config:	help
-//config:	  'logread' ouput to slow serial terminals can have
+//config:	  'logread' output to slow serial terminals can have
 //config:	  side effects on syslog because of the semaphore.
 //config:	  This option make logread to double buffer copy
 //config:	  from circular buffer, minimizing semaphore
@@ -159,7 +159,7 @@ int logread_main(int argc UNUSED_PARAM,
 					cur, shbuf_tail, shbuf_size);
 
 		if (!(follow & 1)) { /* not -f */
-			/* if -F, "convert" it to -f, so that we dont
+			/* if -F, "convert" it to -f, so that we don't
 			 * dump the entire buffer on each iteration
 			 */
 			follow >>= 1;
diff -urpN busybox-1.26.2/sysklogd/syslogd.c busybox-1.27.0/sysklogd/syslogd.c
--- busybox-1.26.2/sysklogd/syslogd.c	2016-09-27 18:53:50.000000000 +0200
+++ busybox-1.27.0/sysklogd/syslogd.c	2017-01-23 01:09:41.000000000 +0100
@@ -135,8 +135,8 @@
 //usage:	)
 //usage:     "\n	-O FILE		Log to FILE (default: /var/log/messages, stdout if -)"
 //usage:	IF_FEATURE_ROTATE_LOGFILE(
-//usage:     "\n	-s SIZE		Max size (KB) before rotation (default:200KB, 0=off)"
-//usage:     "\n	-b N		N rotated logs to keep (default:1, max=99, 0=purge)"
+//usage:     "\n	-s SIZE		Max size (KB) before rotation (default 200KB, 0=off)"
+//usage:     "\n	-b N		N rotated logs to keep (default 1, max 99, 0=purge)"
 //usage:	)
 //usage:     "\n	-l N		Log only messages more urgent than prio N (1-8)"
 //usage:     "\n	-S		Smaller output"
@@ -146,7 +146,7 @@
 //usage:	IF_FEATURE_SYSLOGD_CFG(
 //usage:     "\n	-f FILE		Use FILE as config (default:/etc/syslog.conf)"
 //usage:	)
-/* //usage:  "\n	-m MIN		Minutes between MARK lines (default:20, 0=off)" */
+/* //usage:  "\n	-m MIN		Minutes between MARK lines (default 20, 0=off)" */
 //usage:
 //usage:#define syslogd_example_usage
 //usage:       "$ syslogd -R masterlog:514\n"
diff -urpN busybox-1.26.2/testsuite/cryptpw.tests busybox-1.27.0/testsuite/cryptpw.tests
--- busybox-1.26.2/testsuite/cryptpw.tests	1970-01-01 01:00:00.000000000 +0100
+++ busybox-1.27.0/testsuite/cryptpw.tests	2017-01-16 17:32:02.000000000 +0100
@@ -0,0 +1,28 @@
+#!/bin/sh
+
+# Copyright 2017 by Denys Vlasenko <vda.linux@googlemail.com>
+# Licensed under GPLv2, see file LICENSE in this source tree.
+
+. ./testing.sh
+
+# testing "description" "command" "result" "infile" "stdin"
+
+optional USE_BB_CRYPT_SHA
+testing "cryptpw sha256" \
+	"cryptpw -m sha256 QWErty '123456789012345678901234567890'" \
+	'$5$1234567890123456$5DxfOCmU4vRhtzfsbdK.6wSGMwwVbac7ZkWwusb8Si7\n' "" ""
+
+testing "cryptpw sha256 rounds=99999" \
+	"cryptpw -m sha256 QWErty 'rounds=99999\$123456789012345678901234567890'" \
+	'$5$rounds=99999$1234567890123456$aYellycJGZM6AKyVzaQsSrDBdTixubtMnM6J.MN0xM8\n' "" ""
+
+testing "cryptpw sha512" \
+	"cryptpw -m sha512 QWErty '123456789012345678901234567890'" \
+	'$6$1234567890123456$KB7QqxFyqmJSWyQYcCuGeFukgz1bPQoipWZf7.9L7z3k8UNTXa6UikbKcUGDc2ANn7DOGmDaroxDgpK16w/RE0\n' "" ""
+
+testing "cryptpw sha512 rounds=99999" \
+	"cryptpw -m sha512 QWErty 'rounds=99999\$123456789012345678901234567890'" \
+	'$6$rounds=99999$1234567890123456$BfF6gD6ZjUmwawH5QaAglYAxtU./yvsz0fcQ464l49aMI2DZW3j5ri28CrxK7riPWNpLuUpfaIdY751SBYKUH.\n' "" ""
+SKIP=
+
+exit $FAILCOUNT
diff -urpN busybox-1.26.2/testsuite/factor.tests busybox-1.27.0/testsuite/factor.tests
--- busybox-1.26.2/testsuite/factor.tests	1970-01-01 01:00:00.000000000 +0100
+++ busybox-1.27.0/testsuite/factor.tests	2017-07-01 22:51:12.000000000 +0200
@@ -0,0 +1,48 @@
+#!/bin/sh
+
+# Copyright 2017 by Denys Vlasenko <vda.linux@googlemail.com>
+# Licensed under GPLv2, see file LICENSE in this source tree.
+
+. ./testing.sh
+
+# testing "test name" "command" "expected result" "file input" "stdin"
+#   file input will be file called "input"
+#   test can create a file "actual" instead of writing to stdout
+
+testing "factor '  0'" \
+	"factor '  0'" \
+	"0:\n" \
+	"" ""
+testing "factor +1" \
+	"factor +1" \
+	"1:\n" \
+	"" ""
+testing "factor ' +2'" \
+	"factor ' +2'" \
+	"2: 2\n" \
+	"" ""
+
+testing "factor 1024" \
+	"factor 1024" \
+	"1024: 2 2 2 2 2 2 2 2 2 2\n" \
+	"" ""
+
+testing "factor 2^61-1" \
+	"factor 2305843009213693951" \
+	"2305843009213693951: 2305843009213693951\n" \
+	"" ""
+testing "factor 2^62-1" \
+	"factor 4611686018427387903" \
+	"4611686018427387903: 3 715827883 2147483647\n" \
+	"" ""
+testing "factor 2^64-1" \
+	"factor 18446744073709551615" \
+	"18446744073709551615: 3 5 17 257 641 65537 6700417\n" \
+	"" ""
+# This is a 60-bit number (0x888 86ff db34 4692): first few primes multiplied together:
+testing "factor \$((2*3*5*7*11*13*17*19*23*29*31*37*41*43*47))" \
+	"factor \$((2*3*5*7*11*13*17*19*23*29*31*37*41*43*47))" \
+	"614889782588491410: 2 3 5 7 11 13 17 19 23 29 31 37 41 43 47\n" \
+	"" ""
+
+exit $FAILCOUNT
diff -urpN busybox-1.26.2/testsuite/mdev.tests busybox-1.27.0/testsuite/mdev.tests
--- busybox-1.26.2/testsuite/mdev.tests	2016-09-27 18:53:50.000000000 +0200
+++ busybox-1.27.0/testsuite/mdev.tests	2017-01-10 16:31:40.000000000 +0100
@@ -168,7 +168,7 @@ SKIP=
 # continuing to use directory structure from prev test
 rm -rf mdev.testdir/dev/*
 echo "sda 0:0 644 @echo @echo TEST" >mdev.testdir/etc/mdev.conf
-optional STATIC FEATURE_MDEV_CONF FEATURE_MDEV_EXEC FEATURE_LS_RECURSIVE FEATURE_LS_TIMESTAMPS FEATURE_LS_USERNAME FEATURE_SH_IS_ASH ASH_BUILTIN_ECHO
+optional STATIC FEATURE_MDEV_CONF FEATURE_MDEV_EXEC FEATURE_LS_RECURSIVE FEATURE_LS_TIMESTAMPS FEATURE_LS_USERNAME FEATURE_SH_IS_ASH ASH_ECHO
 testing "mdev command" \
 	"env - PATH=$PATH ACTION=add DEVPATH=/block/sda chroot mdev.testdir /mdev 2>&1;
 	ls -lnR mdev.testdir/dev | $FILTER_LS" \
diff -urpN busybox-1.26.2/testsuite/paste/paste busybox-1.27.0/testsuite/paste/paste
--- busybox-1.26.2/testsuite/paste/paste	1970-01-01 01:00:00.000000000 +0100
+++ busybox-1.27.0/testsuite/paste/paste	2017-04-05 18:27:36.000000000 +0200
@@ -0,0 +1,20 @@
+cat > foo <<EOF
+foo1
+foo2
+foo3
+EOF
+
+cat > bar <<EOF
+bar1
+bar2
+bar3
+EOF
+
+cat > baz <<EOF
+foo1	bar1
+foo2	bar2
+foo3	bar3
+EOF
+
+busybox paste foo bar > qux
+diff -u baz qux
diff -urpN busybox-1.26.2/testsuite/paste/paste-back-cuted-lines busybox-1.27.0/testsuite/paste/paste-back-cuted-lines
--- busybox-1.26.2/testsuite/paste/paste-back-cuted-lines	1970-01-01 01:00:00.000000000 +0100
+++ busybox-1.27.0/testsuite/paste/paste-back-cuted-lines	2017-04-05 18:27:36.000000000 +0200
@@ -0,0 +1,9 @@
+cat > foo <<EOF
+this is the first line
+this is the second line
+this is the third line
+EOF
+cut -b 1-13 -n foo > foo1
+cut -b 14- -n foo > foo2
+busybox paste -d '\0' foo1 foo2 > bar
+cmp foo bar
diff -urpN busybox-1.26.2/testsuite/paste/paste-multi-stdin busybox-1.27.0/testsuite/paste/paste-multi-stdin
--- busybox-1.26.2/testsuite/paste/paste-multi-stdin	1970-01-01 01:00:00.000000000 +0100
+++ busybox-1.27.0/testsuite/paste/paste-multi-stdin	2017-04-05 18:27:36.000000000 +0200
@@ -0,0 +1,16 @@
+cat > foo <<EOF
+line1
+line2
+line3
+line4
+line5
+line6
+EOF
+
+cat > bar <<EOF
+line1	line2	line3
+line4	line5	line6
+EOF
+
+busybox paste - - - < foo > baz
+cmp bar baz
diff -urpN busybox-1.26.2/testsuite/paste/paste-pairs busybox-1.27.0/testsuite/paste/paste-pairs
--- busybox-1.26.2/testsuite/paste/paste-pairs	1970-01-01 01:00:00.000000000 +0100
+++ busybox-1.27.0/testsuite/paste/paste-pairs	2017-04-05 18:27:36.000000000 +0200
@@ -0,0 +1,16 @@
+cat > foo <<EOF
+foo1
+bar1
+foo2
+bar2
+foo3
+EOF
+
+cat > bar <<EOF
+foo1	bar1
+foo2	bar2
+foo3
+EOF
+
+busybox paste -s -d "\t\n" foo > baz
+cmp bar baz
diff -urpN busybox-1.26.2/testsuite/paste/paste-separate busybox-1.27.0/testsuite/paste/paste-separate
--- busybox-1.26.2/testsuite/paste/paste-separate	1970-01-01 01:00:00.000000000 +0100
+++ busybox-1.27.0/testsuite/paste/paste-separate	2017-04-05 18:27:36.000000000 +0200
@@ -0,0 +1,19 @@
+cat > foo <<EOF
+foo1
+foo2
+foo3
+EOF
+
+cat > bar <<EOF
+bar1
+bar2
+bar3
+EOF
+
+cat > baz <<EOF
+foo1	foo2	foo3
+bar1	bar2	bar3
+EOF
+
+busybox paste -s foo bar > qux
+cmp baz qux
diff -urpN busybox-1.26.2/testsuite/readlink.tests busybox-1.27.0/testsuite/readlink.tests
--- busybox-1.26.2/testsuite/readlink.tests	2016-09-27 18:53:50.000000000 +0200
+++ busybox-1.27.0/testsuite/readlink.tests	2017-07-01 22:51:12.000000000 +0200
@@ -29,7 +29,7 @@ pwd=`$pwd`
 testing "readlink -f on a file" "readlink -f ./$TESTFILE" "$pwd/$TESTFILE\n" "" ""
 testing "readlink -f on a link" "readlink -f ./$TESTLINK" "$pwd/$TESTFILE\n" "" ""
 testing "readlink -f on an invalid link" "readlink -f ./$FAILLINK" "" "" ""
-testing "readlink -f on a wierd dir" "readlink -f $TESTDIR/../$TESTFILE" "$pwd/$TESTFILE\n" "" ""
+testing "readlink -f on a weird dir" "readlink -f $TESTDIR/../$TESTFILE" "$pwd/$TESTFILE\n" "" ""
 
 
 # clean up
diff -urpN busybox-1.26.2/testsuite/runtest busybox-1.27.0/testsuite/runtest
--- busybox-1.26.2/testsuite/runtest	2016-09-27 18:53:50.000000000 +0200
+++ busybox-1.27.0/testsuite/runtest	2017-01-25 01:56:57.000000000 +0100
@@ -12,12 +12,12 @@ total_failed=0
 # Option -e will make testcase stop on the first failed command.
 run_applet_testcase()
 {
-	local applet="$1"
-	local testcase="$2"
+	applet="$1"
+	testcase="$2"
 
-	local status=0
-	local uc_applet=$(echo "$applet" | tr a-z A-Z)
-	local testname="$testcase"
+	status=0
+	uc_applet=$(echo "$applet" | tr a-z A-Z)
+	testname="$testcase"
 
 	testname="${testname##*/}" # take basename
 	if grep "^# CONFIG_$uc_applet is not set$" "$bindir/.config" >/dev/null; then
diff -urpN busybox-1.26.2/testsuite/unzip.tests busybox-1.27.0/testsuite/unzip.tests
--- busybox-1.26.2/testsuite/unzip.tests	2016-09-27 18:53:50.000000000 +0200
+++ busybox-1.27.0/testsuite/unzip.tests	2017-01-08 14:34:07.000000000 +0100
@@ -31,6 +31,7 @@ rmdir foo
 rm foo.zip
 
 # File containing some damaged encrypted stream
+optional FEATURE_UNZIP_CDF
 testing "unzip (bad archive)" "uudecode; unzip bad.zip 2>&1; echo \$?" \
 "Archive:  bad.zip
   inflating: ]3jrIK-%Ix
@@ -49,6 +50,7 @@ BDYAAAAMAAEADQAAADIADQAAAEEAAAASw73Ct1DK
 NzITNFBLBQUKAC4JAA04Cw0EOhZQSwUGAQAABAIAAgCZAAAAeQAAAAIALhM=
 ====
 "
+SKIP=
 
 rm *
 
diff -urpN busybox-1.26.2/util-linux/Config.src busybox-1.27.0/util-linux/Config.src
--- busybox-1.26.2/util-linux/Config.src	2016-12-10 18:46:36.000000000 +0100
+++ busybox-1.27.0/util-linux/Config.src	2017-01-10 16:31:40.000000000 +0100
@@ -40,7 +40,7 @@ config FEATURE_MOUNT_LOOP_CREATE
 	  if it does not find a free one.
 
 config FEATURE_MTAB_SUPPORT
-	bool "Support for the old /etc/mtab file"
+	bool "Support old /etc/mtab file"
 	default n
 	depends on MOUNT || UMOUNT
 	select FEATURE_MOUNT_FAKE
diff -urpN busybox-1.26.2/util-linux/cal.c busybox-1.27.0/util-linux/cal.c
--- busybox-1.26.2/util-linux/cal.c	1970-01-01 01:00:00.000000000 +0100
+++ busybox-1.27.0/util-linux/cal.c	2017-07-01 22:51:12.000000000 +0200
@@ -0,0 +1,390 @@
+/* vi: set sw=4 ts=4: */
+/*
+ * Calendar implementation for busybox
+ *
+ * See original copyright at the end of this file
+ *
+ * Licensed under GPLv2 or later, see file LICENSE in this source tree.
+ */
+/* Mar 16, 2003      Manuel Novoa III   (mjn3@codepoet.org)
+ *
+ * Major size reduction... over 50% (>1.5k) on i386.
+ */
+//config:config CAL
+//config:	bool "cal"
+//config:	default y
+//config:	help
+//config:	  cal is used to display a monthly calendar.
+
+//applet:IF_CAL(APPLET(cal, BB_DIR_USR_BIN, BB_SUID_DROP))
+
+//kbuild:lib-$(CONFIG_CAL) += cal.o
+
+/* BB_AUDIT SUSv3 compliant with -j and -y extensions (from util-linux). */
+/* BB_AUDIT BUG: The output of 'cal -j 1752' is incorrect.  The upstream
+ * BB_AUDIT BUG: version in util-linux seems to be broken as well. */
+/* http://www.opengroup.org/onlinepubs/007904975/utilities/cal.html */
+
+//usage:#define cal_trivial_usage
+//usage:       "[-jy] [[MONTH] YEAR]"
+//usage:#define cal_full_usage "\n\n"
+//usage:       "Display a calendar\n"
+//usage:     "\n	-j	Use julian dates"
+//usage:     "\n	-y	Display the entire year"
+
+#include "libbb.h"
+#include "unicode.h"
+
+/* We often use "unsigned" instead of "int", it's easier to div on most CPUs */
+
+#define	THURSDAY		4		/* for reformation */
+#define	SATURDAY		6		/* 1 Jan 1 was a Saturday */
+
+#define	FIRST_MISSING_DAY	639787		/* 3 Sep 1752 */
+#define	NUMBER_MISSING_DAYS	11		/* 11 day correction */
+
+#define	MAXDAYS			42		/* max slots in a month array */
+#define	SPACE			-1		/* used in day array */
+
+static const unsigned char days_in_month[] ALIGN1 = {
+	0, 31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31
+};
+
+static const unsigned char sep1752[] ALIGN1 = {
+		1,	2,	14,	15,	16,
+	17,	18,	19,	20,	21,	22,	23,
+	24,	25,	26,	27,	28,	29,	30
+};
+
+/* Set to 0 or 1 in main */
+#define julian ((unsigned)option_mask32)
+
+/* leap year -- account for Gregorian reformation in 1752 */
+static int leap_year(unsigned yr)
+{
+	if (yr <= 1752)
+		return !(yr % 4);
+	return (!(yr % 4) && (yr % 100)) || !(yr % 400);
+}
+
+/* number of centuries since 1700, not inclusive */
+#define	centuries_since_1700(yr) \
+	((yr) > 1700 ? (yr) / 100 - 17 : 0)
+
+/* number of centuries since 1700 whose modulo of 400 is 0 */
+#define	quad_centuries_since_1700(yr) \
+	((yr) > 1600 ? ((yr) - 1600) / 400 : 0)
+
+/* number of leap years between year 1 and this year, not inclusive */
+#define	leap_years_since_year_1(yr) \
+	((yr) / 4 - centuries_since_1700(yr) + quad_centuries_since_1700(yr))
+
+static void center(char *, unsigned, unsigned);
+static void day_array(unsigned, unsigned, unsigned *);
+static void trim_trailing_spaces_and_print(char *);
+
+static void blank_string(char *buf, size_t buflen);
+static char *build_row(char *p, unsigned *dp);
+
+#define	DAY_LEN		3		/* 3 spaces per day */
+#define	J_DAY_LEN	(DAY_LEN + 1)
+#define	WEEK_LEN	20		/* 7 * 3 - one space at the end */
+#define	J_WEEK_LEN	(WEEK_LEN + 7)
+#define	HEAD_SEP	2		/* spaces between day headings */
+
+int cal_main(int argc, char **argv) MAIN_EXTERNALLY_VISIBLE;
+int cal_main(int argc UNUSED_PARAM, char **argv)
+{
+	struct tm zero_tm;
+	time_t now;
+	unsigned month, year, flags, i;
+	char *month_names[12];
+	/* normal heading: */
+	/* "Su Mo Tu We Th Fr Sa" */
+	/* -j heading: */
+	/* " Su  Mo  Tu  We  Th  Fr  Sa" */
+	char day_headings[ENABLE_UNICODE_SUPPORT ? 28 * 6 : 28];
+	IF_UNICODE_SUPPORT(char *hp = day_headings;)
+	char buf[40];
+
+	init_unicode();
+
+	flags = getopt32(argv, "jy");
+	/* This sets julian = flags & 1: */
+	option_mask32 &= 1;
+	month = 0;
+	argv += optind;
+
+	if (!argv[0]) {
+		struct tm *ptm;
+
+		time(&now);
+		ptm = localtime(&now);
+		year = ptm->tm_year + 1900;
+		if (!(flags & 2)) { /* no -y */
+			month = ptm->tm_mon + 1;
+		}
+	} else {
+		if (argv[1]) {
+			if (argv[2]) {
+				bb_show_usage();
+			}
+			if (!(flags & 2)) { /* no -y */
+				month = xatou_range(*argv, 1, 12);
+			}
+			argv++;
+		}
+		year = xatou_range(*argv, 1, 9999);
+	}
+
+	blank_string(day_headings, sizeof(day_headings) - 7 + 7*julian);
+
+	i = 0;
+	do {
+		zero_tm.tm_mon = i;
+		/* full month name according to locale */
+		strftime(buf, sizeof(buf), "%B", &zero_tm);
+		month_names[i] = xstrdup(buf);
+
+		if (i < 7) {
+			zero_tm.tm_wday = i;
+			/* abbreviated weekday name according to locale */
+			strftime(buf, sizeof(buf), "%a", &zero_tm);
+#if ENABLE_UNICODE_SUPPORT
+			if (julian)
+				*hp++ = ' ';
+			{
+				char *two_wchars = unicode_conv_to_printable_fixedwidth(/*NULL,*/ buf, 2);
+				strcpy(hp, two_wchars);
+				free(two_wchars);
+			}
+			hp += strlen(hp);
+			*hp++ = ' ';
+#else
+			strncpy(day_headings + i * (3+julian) + julian, buf, 2);
+#endif
+		}
+	} while (++i < 12);
+	IF_UNICODE_SUPPORT(hp[-1] = '\0';)
+
+	if (month) {
+		unsigned row, len, days[MAXDAYS];
+		unsigned *dp = days;
+		char lineout[30];
+
+		day_array(month, year, dp);
+		len = sprintf(lineout, "%s %u", month_names[month - 1], year);
+		printf("%*s%s\n%s\n",
+				((7*julian + WEEK_LEN) - len) / 2, "",
+				lineout, day_headings);
+		for (row = 0; row < 6; row++) {
+			build_row(lineout, dp)[0] = '\0';
+			dp += 7;
+			trim_trailing_spaces_and_print(lineout);
+		}
+	} else {
+		unsigned row, which_cal, week_len, days[12][MAXDAYS];
+		unsigned *dp;
+		char lineout[80];
+
+		sprintf(lineout, "%u", year);
+		center(lineout,
+				(WEEK_LEN * 3 + HEAD_SEP * 2)
+				+ julian * (J_WEEK_LEN * 2 + HEAD_SEP
+						- (WEEK_LEN * 3 + HEAD_SEP * 2)),
+				0
+		);
+		puts("\n");		/* two \n's */
+		for (i = 0; i < 12; i++) {
+			day_array(i + 1, year, days[i]);
+		}
+		blank_string(lineout, sizeof(lineout));
+		week_len = WEEK_LEN + julian * (J_WEEK_LEN - WEEK_LEN);
+		for (month = 0; month < 12; month += 3-julian) {
+			center(month_names[month], week_len, HEAD_SEP);
+			if (!julian) {
+				center(month_names[month + 1], week_len, HEAD_SEP);
+			}
+			center(month_names[month + 2 - julian], week_len, 0);
+			printf("\n%s%*s%s", day_headings, HEAD_SEP, "", day_headings);
+			if (!julian) {
+				printf("%*s%s", HEAD_SEP, "", day_headings);
+			}
+			bb_putchar('\n');
+			for (row = 0; row < (6*7); row += 7) {
+				for (which_cal = 0; which_cal < 3-julian; which_cal++) {
+					dp = days[month + which_cal] + row;
+					build_row(lineout + which_cal * (week_len + 2), dp);
+				}
+				/* blank_string took care of nul termination. */
+				trim_trailing_spaces_and_print(lineout);
+			}
+		}
+	}
+
+	fflush_stdout_and_exit(EXIT_SUCCESS);
+}
+
+/*
+ * day_array --
+ *	Fill in an array of 42 integers with a calendar.  Assume for a moment
+ *	that you took the (maximum) 6 rows in a calendar and stretched them
+ *	out end to end.  You would have 42 numbers or spaces.  This routine
+ *	builds that array for any month from Jan. 1 through Dec. 9999.
+ */
+static void day_array(unsigned month, unsigned year, unsigned *days)
+{
+	unsigned long temp;
+	unsigned i;
+	unsigned day, dw, dm;
+
+	memset(days, SPACE, MAXDAYS * sizeof(int));
+
+	if ((month == 9) && (year == 1752)) {
+		/* Assumes the Gregorian reformation eliminates
+		 * 3 Sep. 1752 through 13 Sep. 1752.
+		 */
+		unsigned j_offset = julian * 244;
+		size_t oday = 0;
+
+		do {
+			days[oday+2] = sep1752[oday] + j_offset;
+		} while (++oday < sizeof(sep1752));
+
+		return;
+	}
+
+	/* day_in_year
+	 * return the 1 based day number within the year
+	 */
+	day = 1;
+	if ((month > 2) && leap_year(year)) {
+		++day;
+	}
+
+	i = month;
+	while (i) {
+		day += days_in_month[--i];
+	}
+
+	/* day_in_week
+	 * return the 0 based day number for any date from 1 Jan. 1 to
+	 * 31 Dec. 9999.  Assumes the Gregorian reformation eliminates
+	 * 3 Sep. 1752 through 13 Sep. 1752.  Returns Thursday for all
+	 * missing days.
+	 */
+	temp = (long)(year - 1) * 365 + leap_years_since_year_1(year - 1) + day;
+	if (temp < FIRST_MISSING_DAY) {
+		dw = ((temp - 1 + SATURDAY) % 7);
+	} else {
+		dw = (((temp - 1 + SATURDAY) - NUMBER_MISSING_DAYS) % 7);
+	}
+
+	if (!julian) {
+		day = 1;
+	}
+
+	dm = days_in_month[month];
+	if ((month == 2) && leap_year(year)) {
+		++dm;
+	}
+
+	do {
+		days[dw++] = day++;
+	} while (--dm);
+}
+
+static void trim_trailing_spaces_and_print(char *s)
+{
+	char *p = s;
+
+	while (*p) {
+		++p;
+	}
+	while (p != s) {
+		--p;
+		if (!isspace(*p)) {
+			p[1] = '\0';
+			break;
+		}
+	}
+
+	puts(s);
+}
+
+static void center(char *str, unsigned len, unsigned separate)
+{
+	unsigned n = strlen(str);
+	len -= n;
+	printf("%*s%*s", (len/2) + n, str, (len/2) + (len % 2) + separate, "");
+}
+
+static void blank_string(char *buf, size_t buflen)
+{
+	memset(buf, ' ', buflen);
+	buf[buflen-1] = '\0';
+}
+
+static char *build_row(char *p, unsigned *dp)
+{
+	unsigned col, val, day;
+
+	memset(p, ' ', (julian + DAY_LEN) * 7);
+
+	col = 0;
+	do {
+		day = *dp++;
+		if (day != SPACE) {
+			if (julian) {
+				++p;
+				if (day >= 100) {
+					*p = '0';
+					p[-1] = (day / 100) + '0';
+					day %= 100;
+				}
+			}
+			val = day / 10;
+			if (val > 0) {
+				*p = val + '0';
+			}
+			*++p = day % 10 + '0';
+			p += 2;
+		} else {
+			p += DAY_LEN + julian;
+		}
+	} while (++col < 7);
+
+	return p;
+}
+
+/*
+ * Copyright (c) 1989, 1993, 1994
+ *	The Regents of the University of California.  All rights reserved.
+ *
+ * This code is derived from software contributed to Berkeley by
+ * Kim Letkeman.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ * 1. Redistributions of source code must retain the above copyright
+ *    notice, this list of conditions and the following disclaimer.
+ * 2. Redistributions in binary form must reproduce the above copyright
+ *    notice, this list of conditions and the following disclaimer in the
+ *    documentation and/or other materials provided with the distribution.
+ * 3. Neither the name of the University nor the names of its contributors
+ *    may be used to endorse or promote products derived from this software
+ *    without specific prior written permission.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND
+ * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
+ * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
+ * ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE
+ * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
+ * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
+ * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
+ * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
+ * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
+ * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
+ * SUCH DAMAGE.
+ */
diff -urpN busybox-1.26.2/util-linux/chrt.c busybox-1.27.0/util-linux/chrt.c
--- busybox-1.26.2/util-linux/chrt.c	1970-01-01 01:00:00.000000000 +0100
+++ busybox-1.27.0/util-linux/chrt.c	2017-07-01 22:51:12.000000000 +0200
@@ -0,0 +1,149 @@
+/* vi: set sw=4 ts=4: */
+/*
+ * chrt - manipulate real-time attributes of a process
+ * Copyright (c) 2006-2007 Bernhard Reutner-Fischer
+ *
+ * Licensed under GPLv2 or later, see file LICENSE in this source tree.
+ */
+//config:config CHRT
+//config:	bool "chrt"
+//config:	default y
+//config:	help
+//config:	  manipulate real-time attributes of a process.
+//config:	  This requires sched_{g,s}etparam support in your libc.
+
+//applet:IF_CHRT(APPLET(chrt, BB_DIR_USR_BIN, BB_SUID_DROP))
+
+//kbuild:lib-$(CONFIG_CHRT) += chrt.o
+
+//usage:#define chrt_trivial_usage
+//usage:       "[-prfom] [PRIO] [PID | PROG ARGS]"
+//usage:#define chrt_full_usage "\n\n"
+//usage:       "Change scheduling priority and class for a process\n"
+//usage:     "\n	-p	Operate on PID"
+//usage:     "\n	-r	Set SCHED_RR class"
+//usage:     "\n	-f	Set SCHED_FIFO class"
+//usage:     "\n	-o	Set SCHED_OTHER class"
+//usage:     "\n	-m	Show min/max priorities"
+//usage:
+//usage:#define chrt_example_usage
+//usage:       "$ chrt -r 4 sleep 900; x=$!\n"
+//usage:       "$ chrt -f -p 3 $x\n"
+//usage:       "You need CAP_SYS_NICE privileges to set scheduling attributes of a process"
+
+#include <sched.h>
+#include "libbb.h"
+
+static const struct {
+	int policy;
+	char name[sizeof("SCHED_OTHER")];
+} policies[] = {
+	{SCHED_OTHER, "SCHED_OTHER"},
+	{SCHED_FIFO, "SCHED_FIFO"},
+	{SCHED_RR, "SCHED_RR"}
+};
+
+//TODO: add
+// -b, SCHED_BATCH
+// -i, SCHED_IDLE
+
+static void show_min_max(int pol)
+{
+	const char *fmt = "%s min/max priority\t: %u/%u\n";
+	int max, min;
+
+	max = sched_get_priority_max(pol);
+	min = sched_get_priority_min(pol);
+	if ((max|min) < 0)
+		fmt = "%s not supported\n";
+	printf(fmt, policies[pol].name, min, max);
+}
+
+#define OPT_m (1<<0)
+#define OPT_p (1<<1)
+#define OPT_r (1<<2)
+#define OPT_f (1<<3)
+#define OPT_o (1<<4)
+
+int chrt_main(int argc, char **argv) MAIN_EXTERNALLY_VISIBLE;
+int chrt_main(int argc UNUSED_PARAM, char **argv)
+{
+	pid_t pid = 0;
+	unsigned opt;
+	struct sched_param sp;
+	char *pid_str;
+	char *priority = priority; /* for compiler */
+	const char *current_new;
+	int policy = SCHED_RR;
+
+	/* only one policy accepted */
+	opt_complementary = "r--fo:f--ro:o--rf";
+	opt = getopt32(argv, "+mprfo");
+	if (opt & OPT_m) { /* print min/max and exit */
+		show_min_max(SCHED_FIFO);
+		show_min_max(SCHED_RR);
+		show_min_max(SCHED_OTHER);
+		fflush_stdout_and_exit(EXIT_SUCCESS);
+	}
+	if (opt & OPT_r)
+		policy = SCHED_RR;
+	if (opt & OPT_f)
+		policy = SCHED_FIFO;
+	if (opt & OPT_o)
+		policy = SCHED_OTHER;
+
+	argv += optind;
+	if (!argv[0])
+		bb_show_usage();
+	if (opt & OPT_p) {
+		pid_str = *argv++;
+		if (*argv) { /* "-p <priority> <pid> [...]" */
+			priority = pid_str;
+			pid_str = *argv;
+		}
+		/* else "-p <pid>", and *argv == NULL */
+		pid = xatoul_range(pid_str, 1, ((unsigned)(pid_t)ULONG_MAX) >> 1);
+	} else {
+		priority = *argv++;
+		if (!*argv)
+			bb_show_usage();
+	}
+
+	current_new = "current\0new";
+	if (opt & OPT_p) {
+		int pol;
+ print_rt_info:
+		pol = sched_getscheduler(pid);
+		if (pol < 0)
+			bb_perror_msg_and_die("can't %cet pid %d's policy", 'g', (int)pid);
+		printf("pid %d's %s scheduling policy: %s\n",
+				pid, current_new, policies[pol].name);
+		if (sched_getparam(pid, &sp))
+			bb_perror_msg_and_die("can't get pid %d's attributes", (int)pid);
+		printf("pid %d's %s scheduling priority: %d\n",
+				(int)pid, current_new, sp.sched_priority);
+		if (!*argv) {
+			/* Either it was just "-p <pid>",
+			 * or it was "-p <priority> <pid>" and we came here
+			 * for the second time (see goto below) */
+			return EXIT_SUCCESS;
+		}
+		*argv = NULL;
+		current_new += 8;
+	}
+
+	/* from the manpage of sched_getscheduler:
+	[...] sched_priority can have a value in the range 0 to 99.
+	[...] SCHED_OTHER or SCHED_BATCH must be assigned static priority 0.
+	[...] SCHED_FIFO or SCHED_RR can have static priority in 1..99 range.
+	*/
+	sp.sched_priority = xstrtou_range(priority, 0, policy != SCHED_OTHER ? 1 : 0, 99);
+
+	if (sched_setscheduler(pid, policy, &sp) < 0)
+		bb_perror_msg_and_die("can't %cet pid %d's policy", 's', (int)pid);
+
+	if (!argv[0]) /* "-p <priority> <pid> [...]" */
+		goto print_rt_info;
+
+	BB_EXECVP_or_die(argv);
+}
diff -urpN busybox-1.26.2/util-linux/dmesg.c busybox-1.27.0/util-linux/dmesg.c
--- busybox-1.26.2/util-linux/dmesg.c	2016-12-10 18:46:36.000000000 +0100
+++ busybox-1.27.0/util-linux/dmesg.c	2017-01-10 16:31:40.000000000 +0100
@@ -22,7 +22,7 @@
 //config:	  wish to enable the 'dmesg' utility.
 //config:
 //config:config FEATURE_DMESG_PRETTY
-//config:	bool "Pretty dmesg output"
+//config:	bool "Pretty output"
 //config:	default y
 //config:	depends on DMESG
 //config:	help
diff -urpN busybox-1.26.2/util-linux/eject.c busybox-1.27.0/util-linux/eject.c
--- busybox-1.26.2/util-linux/eject.c	1970-01-01 01:00:00.000000000 +0100
+++ busybox-1.27.0/util-linux/eject.c	2017-07-01 22:51:12.000000000 +0200
@@ -0,0 +1,152 @@
+/* vi: set sw=4 ts=4: */
+/*
+ * eject implementation for busybox
+ *
+ * Copyright (C) 2004  Peter Willis <psyphreak@phreaker.net>
+ * Copyright (C) 2005  Tito Ragusa <farmatito@tiscali.it>
+ *
+ * Licensed under GPLv2 or later, see file LICENSE in this source tree.
+ */
+
+/*
+ * This is a simple hack of eject based on something Erik posted in #uclibc.
+ * Most of the dirty work blatantly ripped off from cat.c =)
+ */
+//config:config EJECT
+//config:	bool "eject"
+//config:	default y
+//config:	select PLATFORM_LINUX
+//config:	help
+//config:	  Used to eject cdroms. (defaults to /dev/cdrom)
+//config:
+//config:config FEATURE_EJECT_SCSI
+//config:	bool "SCSI support"
+//config:	default y
+//config:	depends on EJECT
+//config:	help
+//config:	  Add the -s option to eject, this allows to eject SCSI-Devices and
+//config:	  usb-storage devices.
+
+//applet:IF_EJECT(APPLET(eject, BB_DIR_USR_BIN, BB_SUID_DROP))
+
+//kbuild:lib-$(CONFIG_EJECT) += eject.o
+
+//usage:#define eject_trivial_usage
+//usage:       "[-t] [-T] [DEVICE]"
+//usage:#define eject_full_usage "\n\n"
+//usage:       "Eject DEVICE or default /dev/cdrom\n"
+//usage:	IF_FEATURE_EJECT_SCSI(
+//usage:     "\n	-s	SCSI device"
+//usage:	)
+//usage:     "\n	-t	Close tray"
+//usage:     "\n	-T	Open/close tray (toggle)"
+
+#include <sys/mount.h>
+#include "libbb.h"
+#if ENABLE_FEATURE_EJECT_SCSI
+/* Must be after libbb.h: they need size_t */
+# include "fix_u32.h"
+# include <scsi/sg.h>
+# include <scsi/scsi.h>
+#endif
+
+#define dev_fd 3
+
+/* Code taken from the original eject (http://eject.sourceforge.net/),
+ * refactored it a bit for busybox (ne-bb@nicoerfurth.de) */
+
+#if ENABLE_FEATURE_EJECT_SCSI
+static void eject_scsi(const char *dev)
+{
+	static const char sg_commands[3][6] ALIGN1 = {
+		{ ALLOW_MEDIUM_REMOVAL, 0, 0, 0, 0, 0 },
+		{ START_STOP, 0, 0, 0, 1, 0 },
+		{ START_STOP, 0, 0, 0, 2, 0 }
+	};
+
+	unsigned i;
+	unsigned char sense_buffer[32];
+	unsigned char inqBuff[2];
+	sg_io_hdr_t io_hdr;
+
+	if ((ioctl(dev_fd, SG_GET_VERSION_NUM, &i) < 0) || (i < 30000))
+		bb_error_msg_and_die("not a sg device or old sg driver");
+
+	memset(&io_hdr, 0, sizeof(sg_io_hdr_t));
+	io_hdr.interface_id = 'S';
+	io_hdr.cmd_len = 6;
+	io_hdr.mx_sb_len = sizeof(sense_buffer);
+	io_hdr.dxfer_direction = SG_DXFER_NONE;
+	/* io_hdr.dxfer_len = 0; */
+	io_hdr.dxferp = inqBuff;
+	io_hdr.sbp = sense_buffer;
+	io_hdr.timeout = 2000;
+
+	for (i = 0; i < 3; i++) {
+		io_hdr.cmdp = (void *)sg_commands[i];
+		ioctl_or_perror_and_die(dev_fd, SG_IO, (void *)&io_hdr, "%s", dev);
+	}
+
+	/* force kernel to reread partition table when new disc is inserted */
+	ioctl(dev_fd, BLKRRPART);
+}
+#else
+# define eject_scsi(dev) ((void)0)
+#endif
+
+/* various defines swiped from linux/cdrom.h */
+#define CDROMCLOSETRAY            0x5319  /* pendant of CDROMEJECT  */
+#define CDROMEJECT                0x5309  /* Ejects the cdrom media */
+#define CDROM_DRIVE_STATUS        0x5326  /* Get tray position, etc. */
+/* drive status possibilities returned by CDROM_DRIVE_STATUS ioctl */
+#define CDS_TRAY_OPEN        2
+
+#define FLAG_CLOSE  1
+#define FLAG_SMART  2
+#define FLAG_SCSI   4
+
+static void eject_cdrom(unsigned flags, const char *dev)
+{
+	int cmd = CDROMEJECT;
+
+	if (flags & FLAG_CLOSE
+	 || ((flags & FLAG_SMART) && ioctl(dev_fd, CDROM_DRIVE_STATUS) == CDS_TRAY_OPEN)
+	) {
+		cmd = CDROMCLOSETRAY;
+	}
+
+	ioctl_or_perror_and_die(dev_fd, cmd, NULL, "%s", dev);
+}
+
+int eject_main(int argc, char **argv) MAIN_EXTERNALLY_VISIBLE;
+int eject_main(int argc UNUSED_PARAM, char **argv)
+{
+	unsigned flags;
+	const char *device;
+
+	opt_complementary = "?1:t--T:T--t";
+	flags = getopt32(argv, "tT" IF_FEATURE_EJECT_SCSI("s"));
+	device = argv[optind] ? argv[optind] : "/dev/cdrom";
+
+	/* We used to do "umount <device>" here, but it was buggy
+	   if something was mounted OVER cdrom and
+	   if cdrom is mounted many times.
+
+	   This works equally well (or better):
+	   #!/bin/sh
+	   umount /dev/cdrom
+	   eject /dev/cdrom
+	*/
+
+	xmove_fd(xopen_nonblocking(device), dev_fd);
+
+	if (ENABLE_FEATURE_EJECT_SCSI && (flags & FLAG_SCSI))
+		eject_scsi(device);
+	else
+		eject_cdrom(flags, device);
+
+	if (ENABLE_FEATURE_CLEAN_UP)
+		close(dev_fd);
+
+	return EXIT_SUCCESS;
+}
diff -urpN busybox-1.26.2/util-linux/fallocate.c busybox-1.27.0/util-linux/fallocate.c
--- busybox-1.26.2/util-linux/fallocate.c	1970-01-01 01:00:00.000000000 +0100
+++ busybox-1.27.0/util-linux/fallocate.c	2017-07-01 22:51:12.000000000 +0200
@@ -0,0 +1,104 @@
+/* vi: set sw=4 ts=4: */
+/*
+ * Copyright (C) 2017 Denys Vlasenko <vda.linux@googlemail.com>
+ *
+ * Licensed under GPLv2, see file LICENSE in this source tree.
+ */
+
+//config:config FALLOCATE
+//config:	bool "fallocate"
+//config:	default y
+//config:	help
+//config:	  Preallocate space for files.
+
+//applet:IF_FALLOCATE(APPLET(fallocate, BB_DIR_USR_BIN, BB_SUID_DROP))
+
+//kbuild:lib-$(CONFIG_FALLOCATE) += fallocate.o
+
+//usage:#define fallocate_trivial_usage
+//usage:       "[-o OFS] -l LEN FILE"
+//		fallocate [-c|-p|-z] [-n] [-o OFS] -l LEN FILE
+//		fallocate -d [-o OFS] [-l LEN] FILE
+//usage:#define fallocate_full_usage "\n\n"
+//usage:	"Preallocate space for FILE\n"
+//           "\n	-c	Remove range"
+//           "\n	-p	Make hole"
+//           "\n	-z	Zero and allocate range"
+//           "\n	-d	Convert zeros to holes"
+//           "\n	-n	Keep size"
+//usage:     "\n	-o OFS	Offset of range"
+//usage:     "\n	-l LEN	Length of range"
+
+//Upstream options:
+//The options --collapse-range, --dig-holes, --punch-hole and --zero-range
+//are mutually exclusive.
+//-c, --collapse-range
+//    Removes a byte range from a file, without leaving a hole. The byte range
+//    to be collapsed starts at offset and continues for length bytes.
+//    At the completion of the operation, the contents of the file starting
+//    at the location offset+length will be appended at the location offset,
+//    and the file will be length bytes smaller. The option --keep-size may
+//    not be specified for the collapse-range operation.
+//-d, --dig-holes
+//    Detect and dig holes. This makes the file sparse in-place, without using
+//    extra disk space. The minimum size of the hole depends on filesystem I/O
+//    block size (usually 4096 bytes). Also,
+//-l, --length length
+//    Specifies the length of the range, in bytes.
+//-n, --keep-size
+//    Do not modify the apparent length of the file. This may effectively
+//    allocate blocks past EOF, which can be removed with a truncate.
+//-o, --offset offset
+//    Specifies the beginning offset of the range, in bytes.
+//-p, --punch-hole
+//    Deallocates space (i.e., creates a hole) in the byte range starting
+//    at offset and continuing for length bytes. Within the specified range,
+//    partial filesystem blocks are zeroed, and whole
+//    filesystem blocks are removed from the file. After a successful call,
+//    subsequent reads from this range will return zeroes. This option may not
+//    be specified at the same time as the
+//    --zero-range option. Also, when using this option, --keep-size is implied.
+//-z, --zero-range
+//    Zeroes space in the byte range starting at offset and continuing for
+//    length bytes. Within the specified range, blocks are preallocated for
+//    the regions that span the holes in the file. After
+//    a successful call, subsequent reads from this range will return zeroes.
+//    Zeroing is done within the filesystem preferably by converting the range
+//    into unwritten extents. This approach means that the specified range
+//    will not be physically zeroed out on the device (except for partial
+//    blocks at the either end of the range), and I/O is (otherwise) required
+//    only to update metadata.
+//    Option --keep-size can be specified to prevent file length modification.
+
+#include "libbb.h"
+
+int fallocate_main(int argc, char **argv) MAIN_EXTERNALLY_VISIBLE;
+int fallocate_main(int argc UNUSED_PARAM, char **argv)
+{
+	const char *str_l;
+	const char *str_o = "0";
+	off_t ofs, len;
+	unsigned opts;
+	int fd;
+
+	/* exactly one non-option arg */
+	opt_complementary = "=1";
+	opts = getopt32(argv, "l:o:", &str_l, &str_o);
+	if (!(opts & 1))
+		bb_show_usage();
+
+	ofs = xatoull_sfx(str_o, kmg_i_suffixes);
+	len = xatoull_sfx(str_l, kmg_i_suffixes);
+
+	argv += optind;
+	fd = xopen3(*argv, O_RDWR | O_CREAT, 0666);
+
+	/* posix_fallocate has unusual method of returning error */
+	/* maybe use Linux-specific fallocate(int fd, int mode, off_t offset, off_t len) instead? */
+	if ((errno = posix_fallocate(fd, ofs, len)) != 0)
+		bb_perror_msg_and_die("fallocate '%s'", *argv);
+
+	/* util-linux also performs fsync(fd); */
+
+	return EXIT_SUCCESS;
+}
diff -urpN busybox-1.26.2/util-linux/fbset.c busybox-1.27.0/util-linux/fbset.c
--- busybox-1.26.2/util-linux/fbset.c	2016-12-10 18:46:36.000000000 +0100
+++ busybox-1.27.0/util-linux/fbset.c	2017-01-10 16:31:40.000000000 +0100
@@ -22,7 +22,7 @@
 //config:	  if you wish to enable the 'fbset' utility.
 //config:
 //config:config FEATURE_FBSET_FANCY
-//config:	bool "Turn on extra fbset options"
+//config:	bool "Enable extra options"
 //config:	default y
 //config:	depends on FBSET
 //config:	help
@@ -32,7 +32,7 @@
 //config:	  options.
 //config:
 //config:config FEATURE_FBSET_READMODE
-//config:	bool "Turn on fbset readmode support"
+//config:	bool "Enable readmode support"
 //config:	default y
 //config:	depends on FBSET
 //config:	help
diff -urpN busybox-1.26.2/util-linux/fdisk.c busybox-1.27.0/util-linux/fdisk.c
--- busybox-1.26.2/util-linux/fdisk.c	2016-12-10 18:46:36.000000000 +0100
+++ busybox-1.27.0/util-linux/fdisk.c	2017-01-19 16:21:18.000000000 +0100
@@ -21,8 +21,6 @@
 //config:	default y
 //config:	depends on FDISK
 //config:	depends on !LFS   # with LFS no special code is needed
-//config:	help
-//config:	  Enable this option to support large disks > 4GB.
 //config:
 //config:config FEATURE_FDISK_WRITABLE
 //config:	bool "Write support"
@@ -105,8 +103,8 @@
 //usage:	)
 //usage:     "\n	-b 2048		(for certain MO disks) use 2048-byte sectors"
 //usage:     "\n	-C CYLINDERS	Set number of cylinders/heads/sectors"
-//usage:     "\n	-H HEADS"
-//usage:     "\n	-S SECTORS"
+//usage:     "\n	-H HEADS	Typically 255"
+//usage:     "\n	-S SECTORS	Typically 63"
 
 #ifndef _LARGEFILE64_SOURCE
 /* For lseek64 */
diff -urpN busybox-1.26.2/util-linux/freeramdisk.c busybox-1.27.0/util-linux/freeramdisk.c
--- busybox-1.26.2/util-linux/freeramdisk.c	2016-12-10 18:46:36.000000000 +0100
+++ busybox-1.27.0/util-linux/freeramdisk.c	2017-01-30 21:57:30.000000000 +0100
@@ -33,6 +33,7 @@
 //config:	  ramdisk. If you have no use for freeing memory from a ramdisk, leave
 //config:	  this disabled.
 
+//                  APPLET_ODDNAME:name     main         location    suid_type     help
 //applet:IF_FDFLUSH(APPLET_ODDNAME(fdflush, freeramdisk, BB_DIR_BIN, BB_SUID_DROP, fdflush))
 //applet:IF_FREERAMDISK(APPLET(freeramdisk, BB_DIR_SBIN, BB_SUID_DROP))
 
diff -urpN busybox-1.26.2/util-linux/fsck_minix.c busybox-1.27.0/util-linux/fsck_minix.c
--- busybox-1.26.2/util-linux/fsck_minix.c	2016-12-10 18:46:36.000000000 +0100
+++ busybox-1.27.0/util-linux/fsck_minix.c	2017-01-15 00:18:53.000000000 +0100
@@ -1226,7 +1226,6 @@ void check2(void);
 int fsck_minix_main(int argc, char **argv) MAIN_EXTERNALLY_VISIBLE;
 int fsck_minix_main(int argc UNUSED_PARAM, char **argv)
 {
-	struct termios tmp;
 	int retcode = 0;
 
 	xfunc_error_retval = 8;
@@ -1271,10 +1270,7 @@ int fsck_minix_main(int argc UNUSED_PARA
 	read_tables();
 
 	if (OPT_manual) {
-		tcgetattr(0, &sv_termios);
-		tmp = sv_termios;
-		tmp.c_lflag &= ~(ICANON | ECHO);
-		tcsetattr_stdin_TCSANOW(&tmp);
+		set_termios_to_raw(STDIN_FILENO, &sv_termios, 0);
 		termios_set = 1;
 	}
 
diff -urpN busybox-1.26.2/util-linux/fsfreeze.c busybox-1.27.0/util-linux/fsfreeze.c
--- busybox-1.26.2/util-linux/fsfreeze.c	1970-01-01 01:00:00.000000000 +0100
+++ busybox-1.27.0/util-linux/fsfreeze.c	2017-07-01 22:51:12.000000000 +0200
@@ -0,0 +1,54 @@
+/* vi: set sw=4 ts=4: */
+/*
+ * Copyright (C) 2017 Denys Vlasenko <vda.linux@googlemail.com>
+ *
+ * Licensed under GPLv2, see file LICENSE in this source tree.
+ */
+
+//config:config FSFREEZE
+//config:	bool "fsfreeze"
+//config:	default y
+//config:	select PLATFORM_LINUX
+//config:	select LONG_OPTS
+//config:	help
+//config:	  Halt new accesses and flush writes on a mounted filesystem.
+
+//applet:IF_FSFREEZE(APPLET(fsfreeze, BB_DIR_USR_SBIN, BB_SUID_DROP))
+
+//kbuild:lib-$(CONFIG_FSFREEZE) += fsfreeze.o
+
+//usage:#define fsfreeze_trivial_usage
+//usage:       "--[un]freeze MOUNTPOINT"
+//usage:#define fsfreeze_full_usage "\n\n"
+//usage:	"Flush and halt writes to MOUNTPOINT"
+
+#include "libbb.h"
+#include <linux/fs.h>
+
+#ifndef FIFREEZE
+# define FIFREEZE _IOWR('X', 119, int)
+# define FITHAW   _IOWR('X', 120, int)
+#endif
+
+int fsfreeze_main(int argc, char **argv) MAIN_EXTERNALLY_VISIBLE;
+int fsfreeze_main(int argc UNUSED_PARAM, char **argv)
+{
+	unsigned opts;
+	int fd;
+
+	applet_long_options =
+		"freeze\0"   No_argument "\xff"
+		"unfreeze\0" No_argument "\xfe"
+	;
+	/* exactly one non-option arg: the mountpoint */
+	/* one of opts is required */
+	/* opts are mutually exclusive */
+	opt_complementary = "=1:""\xff:\xfe:""\xff--\xfe:\xfe--\xff";
+	opts = getopt32(argv, "");
+
+	fd = xopen(argv[optind], O_RDONLY);
+	/* Works with NULL arg on linux-4.8.0 */
+	xioctl(fd, (opts & 1) ? FIFREEZE : FITHAW, NULL);
+
+	return EXIT_SUCCESS;
+}
diff -urpN busybox-1.26.2/util-linux/fstrim.c busybox-1.27.0/util-linux/fstrim.c
--- busybox-1.26.2/util-linux/fstrim.c	2016-12-22 14:10:40.000000000 +0100
+++ busybox-1.27.0/util-linux/fstrim.c	2017-01-23 01:09:41.000000000 +0100
@@ -23,9 +23,9 @@
 //usage:       "[OPTIONS] MOUNTPOINT"
 //usage:#define fstrim_full_usage "\n\n"
 //usage:	IF_LONG_OPTS(
-//usage:       "	-o,--offset=OFFSET	Offset in bytes to discard from"
-//usage:     "\n	-l,--length=LEN		Bytes to discard"
-//usage:     "\n	-m,--minimum=MIN	Minimum extent length"
+//usage:       "	-o,--offset OFFSET	Offset in bytes to discard from"
+//usage:     "\n	-l,--length LEN		Bytes to discard"
+//usage:     "\n	-m,--minimum MIN	Minimum extent length"
 //usage:     "\n	-v,--verbose		Print number of discarded bytes"
 //usage:	)
 //usage:	IF_NOT_LONG_OPTS(
diff -urpN busybox-1.26.2/util-linux/getopt.c busybox-1.27.0/util-linux/getopt.c
--- busybox-1.26.2/util-linux/getopt.c	2016-12-10 18:46:36.000000000 +0100
+++ busybox-1.27.0/util-linux/getopt.c	2017-07-01 22:51:12.000000000 +0200
@@ -57,13 +57,13 @@
 //usage:	IF_LONG_OPTS(
 //usage:	IF_FEATURE_GETOPT_LONG(
 //usage:       "	-a,--alternative		Allow long options starting with single -\n"
-//usage:       "	-l,--longoptions=LOPT[,...]	Long options to recognize\n"
+//usage:       "	-l,--longoptions LOPT[,...]	Long options to recognize\n"
 //usage:	)
-//usage:       "	-n,--name=PROGNAME		The name under which errors are reported"
-//usage:     "\n	-o,--options=OPTSTRING		Short options to recognize"
+//usage:       "	-n,--name PROGNAME		The name under which errors are reported"
+//usage:     "\n	-o,--options OPTSTRING		Short options to recognize"
 //usage:     "\n	-q,--quiet			No error messages on unrecognized options"
 //usage:     "\n	-Q,--quiet-output		No normal output"
-//usage:     "\n	-s,--shell=SHELL		Set shell quoting conventions"
+//usage:     "\n	-s,--shell SHELL		Set shell quoting conventions"
 //usage:     "\n	-T,--test			Version test (exits with 4)"
 //usage:     "\n	-u,--unquoted			Don't quote output"
 //usage:	)
@@ -246,12 +246,7 @@ static int generate_output(char **argv,
 
 	/* We used it already in main() in getopt32(),
 	 * we *must* reset getopt(3): */
-#ifdef __GLIBC__
-	optind = 0;
-#else /* BSD style */
-	optind = 1;
-	/* optreset = 1; */
-#endif
+	GETOPT_RESET();
 
 	while (1) {
 #if ENABLE_FEATURE_GETOPT_LONG
diff -urpN busybox-1.26.2/util-linux/hexdump.c busybox-1.27.0/util-linux/hexdump.c
--- busybox-1.26.2/util-linux/hexdump.c	2016-12-10 18:46:36.000000000 +0100
+++ busybox-1.27.0/util-linux/hexdump.c	2017-01-30 21:57:30.000000000 +0100
@@ -41,19 +41,21 @@
 //usage:       "[-bcCdefnosvx" IF_FEATURE_HEXDUMP_REVERSE("R") "] [FILE]..."
 //usage:#define hexdump_full_usage "\n\n"
 //usage:       "Display FILEs (or stdin) in a user specified format\n"
-//usage:     "\n	-b		One-byte octal display"
-//usage:     "\n	-c		One-byte character display"
-//usage:     "\n	-C		Canonical hex+ASCII, 16 bytes per line"
-//usage:     "\n	-d		Two-byte decimal display"
-//usage:     "\n	-e FORMAT_STRING"
+//usage:     "\n	-b		1-byte octal display"
+//usage:     "\n	-c		1-byte character display"
+//usage:     "\n	-d		2-byte decimal display"
+//usage:     "\n	-o		2-byte octal display"
+//usage:     "\n	-x		2-byte hex display"
+//usage:     "\n	-C		hex+ASCII 16 bytes per line"
+//usage:     "\n	-v		Show all (no dup folding)"
+//usage:     "\n	-e FORMAT_STR	Example: '16/1 \"%02x|\"\"\\n\"'"
 //usage:     "\n	-f FORMAT_FILE"
-//usage:     "\n	-n LENGTH	Interpret only LENGTH bytes of input"
-//usage:     "\n	-o		Two-byte octal display"
+// exactly the same help text lines in hexdump and xxd:
+//usage:     "\n	-n LENGTH	Show only first LENGTH bytes"
 //usage:     "\n	-s OFFSET	Skip OFFSET bytes"
-//usage:     "\n	-v		Display all input data"
-//usage:     "\n	-x		Two-byte hexadecimal display"
 //usage:	IF_FEATURE_HEXDUMP_REVERSE(
 //usage:     "\n	-R		Reverse of 'hexdump -Cv'")
+// TODO: NONCOMPAT!!! move -R to xxd -r
 //usage:
 //usage:#define hd_trivial_usage
 //usage:       "FILE..."
@@ -83,11 +85,11 @@ static void bb_dump_addfile(dumper_t *du
 }
 
 static const char *const add_strings[] = {
-	"\"%07.7_ax \" 16/1 \"%03o \" \"\\n\"",   /* b */
-	"\"%07.7_ax \" 16/1 \"%3_c \" \"\\n\"",   /* c */
-	"\"%07.7_ax \" 8/2 \"  %05u \" \"\\n\"",  /* d */
-	"\"%07.7_ax \" 8/2 \" %06o \" \"\\n\"",   /* o */
-	"\"%07.7_ax \" 8/2 \"   %04x \" \"\\n\"", /* x */
+	"\"%07.7_ax \"16/1 \"%03o \"\"\n\"",   /* b */
+	"\"%07.7_ax \"16/1 \"%3_c \"\"\n\"",   /* c */
+	"\"%07.7_ax \"8/2 \"  %05u \"\"\n\"",  /* d */
+	"\"%07.7_ax \"8/2 \" %06o \"\"\n\"",   /* o */
+	"\"%07.7_ax \"8/2 \"   %04x \"\"\n\"", /* x */
 };
 
 static const char add_first[] ALIGN1 = "\"%07.7_Ax\n\"";
@@ -125,9 +127,11 @@ int hexdump_main(int argc, char **argv)
 		/* Save a little bit of space below by omitting the 'else's. */
 		if (ch == 'C') {
  hd_applet:
-			bb_dump_add(dumper, "\"%08.8_Ax\n\"");
-			bb_dump_add(dumper, "\"%08.8_ax  \" 8/1 \"%02x \" \"  \" 8/1 \"%02x \" ");
-			bb_dump_add(dumper, "\"  |\" 16/1 \"%_p\" \"|\\n\"");
+			bb_dump_add(dumper, "\"%08.8_Ax\n\""); // final address line after dump
+			//------------------- "address  "   8 * "xx "    "  "  8 * "xx "
+			bb_dump_add(dumper, "\"%08.8_ax  \"8/1 \"%02x \"\"  \"8/1 \"%02x \"");
+			//------------------- "  |ASCII...........|\n"
+			bb_dump_add(dumper, "\"  |\"16/1 \"%_p\"\"|\n\"");
 		}
 		if (ch == 'e') {
 			bb_dump_add(dumper, optarg);
@@ -158,7 +162,7 @@ int hexdump_main(int argc, char **argv)
 
 	if (!dumper->fshead) {
 		bb_dump_add(dumper, add_first);
-		bb_dump_add(dumper, "\"%07.7_ax \" 8/2 \"%04x \" \"\\n\"");
+		bb_dump_add(dumper, "\"%07.7_ax \"8/2 \"%04x \"\"\n\"");
 	}
 
 	argv += optind;
diff -urpN busybox-1.26.2/util-linux/hexdump_xxd.c busybox-1.27.0/util-linux/hexdump_xxd.c
--- busybox-1.26.2/util-linux/hexdump_xxd.c	1970-01-01 01:00:00.000000000 +0100
+++ busybox-1.27.0/util-linux/hexdump_xxd.c	2017-01-30 21:57:30.000000000 +0100
@@ -0,0 +1,146 @@
+/* vi: set sw=4 ts=4: */
+/*
+ * xxd implementation for busybox
+ *
+ * Copyright (c) 2017 Denys Vlasenko <vda.linux@gmail.com>
+ *
+ * Licensed under GPLv2, see file LICENSE in this source tree.
+ */
+//config:config XXD
+//config:	bool "xxd"
+//config:	default y
+//config:	help
+//config:	  The xxd utility is used to display binary data in a readable
+//config:	  way that is comparable to the output from most hex editors.
+
+//applet:IF_XXD(APPLET_NOEXEC(xxd, xxd, BB_DIR_USR_BIN, BB_SUID_DROP, xxd))
+
+//kbuild:lib-$(CONFIG_XXD) += hexdump_xxd.o
+
+// $ xxd --version
+// xxd V1.10 27oct98 by Juergen Weigert
+// $ xxd --help
+// Usage:
+//       xxd [options] [infile [outfile]]
+//    or
+//       xxd -r [-s [-]offset] [-c cols] [-ps] [infile [outfile]]
+// Options:
+//    -a          toggle autoskip: A single '*' replaces nul-lines. Default off.
+//    -b          binary digit dump (incompatible with -ps,-i,-r). Default hex.
+//    -c cols     format <cols> octets per line. Default 16 (-i: 12, -ps: 30).
+//    -E          show characters in EBCDIC. Default ASCII.
+//    -e          little-endian dump (incompatible with -ps,-i,-r).
+//    -g          number of octets per group in normal output. Default 2 (-e: 4).
+//    -i          output in C include file style.
+//    -l len      stop after <len> octets.
+//    -o off      add <off> to the displayed file position.
+//    -ps         output in postscript plain hexdump style.
+//    -r          reverse operation: convert (or patch) hexdump into binary.
+//    -r -s off   revert with <off> added to file positions found in hexdump.
+//    -s [+][-]seek  start at <seek> bytes abs. (or +: rel.) infile offset.
+//    -u          use upper case hex letters.
+
+//usage:#define xxd_trivial_usage
+//usage:       "[OPTIONS] [FILE]"
+//usage:#define xxd_full_usage "\n\n"
+//usage:       "Hex dump FILE (or stdin)\n"
+//usage:     "\n	-g N		Bytes per group"
+//usage:     "\n	-c N		Bytes per line"
+//usage:     "\n	-p		Show only hex bytes, assumes -c30"
+// exactly the same help text lines in hexdump and xxd:
+//usage:     "\n	-l LENGTH	Show only first LENGTH bytes"
+//usage:     "\n	-s OFFSET	Skip OFFSET bytes"
+// TODO: implement -r (see hexdump -R)
+
+#include "libbb.h"
+#include "dump.h"
+
+/* This is a NOEXEC applet. Be very careful! */
+
+int xxd_main(int argc, char **argv) MAIN_EXTERNALLY_VISIBLE;
+int xxd_main(int argc UNUSED_PARAM, char **argv)
+{
+	char buf[80];
+	dumper_t *dumper;
+	char *opt_l, *opt_s;
+	unsigned bytes = 2;
+	unsigned cols = 0;
+	unsigned opt;
+
+	dumper = alloc_dumper();
+
+#define OPT_l (1 << 0)
+#define OPT_s (1 << 1)
+#define OPT_a (1 << 2)
+#define OPT_p (1 << 3)
+	opt_complementary = "?1"; /* 1 argument max */
+	opt = getopt32(argv, "l:s:apg:+c:+", &opt_l, &opt_s, &bytes, &cols);
+	argv += optind;
+
+	dumper->dump_vflag = ALL;
+//	if (opt & OPT_a)
+//		dumper->dump_vflag = SKIPNUL; ..does not exist
+	if (opt & OPT_l) {
+		dumper->dump_length = xstrtou_range(
+				opt_l,
+				/*base:*/ 0,
+				/*lo:*/ 0, /*hi:*/ INT_MAX
+		);
+	}
+	if (opt & OPT_s) {
+		dumper->dump_skip = xstrtoull_range(
+				opt_s,
+				/*base:*/ 0,
+				/*lo:*/ 0, /*hi:*/ OFF_T_MAX
+		);
+		//BUGGY for /proc/version (unseekable?)
+	}
+
+	if (opt & OPT_p) {
+		if (cols == 0)
+			cols = 30;
+		bytes = cols; /* -p ignores -gN */
+	} else {
+		if (cols == 0)
+			cols = 16;
+		bb_dump_add(dumper, "\"%08.8_ax: \""); // "address: "
+	}
+
+	if (bytes < 1 || bytes >= cols) {
+		sprintf(buf, "%u/1 \"%%02x\"", cols); // cols * "xx"
+		bb_dump_add(dumper, buf);
+	}
+	else if (bytes == 1) {
+		sprintf(buf, "%u/1 \"%%02x \"", cols); // cols * "xx "
+		bb_dump_add(dumper, buf);
+	}
+	else {
+/* Format "print byte" with and without trailing space */
+#define BS "/1 \"%02x \""
+#define B  "/1 \"%02x\""
+		unsigned i;
+		char *bigbuf = xmalloc(cols * (sizeof(BS)-1));
+		char *p = bigbuf;
+		for (i = 1; i <= cols; i++) {
+			if (i == cols || i % bytes)
+				p = stpcpy(p, B);
+			else
+				p = stpcpy(p, BS);
+		}
+		// for -g3, this results in B B BS B B BS... B = "xxxxxx xxxxxx .....xx"
+		// todo: can be more clever and use
+		// one 'bytes-1/1 "%02x"' format instead of many "B B B..." formats
+		//bb_error_msg("ADDED:'%s'", bigbuf);
+		bb_dump_add(dumper, bigbuf);
+		free(bigbuf);
+	}
+
+	if (!(opt & OPT_p)) {
+		sprintf(buf, "\"  \"%u/1 \"%%_p\"\"\n\"", cols); // "  ASCII\n"
+		bb_dump_add(dumper, buf);
+	} else {
+		bb_dump_add(dumper, "\"\n\"");
+	}
+
+	return bb_dump_dump(dumper, argv);
+}
diff -urpN busybox-1.26.2/util-linux/hwclock.c busybox-1.27.0/util-linux/hwclock.c
--- busybox-1.26.2/util-linux/hwclock.c	2016-12-10 18:46:36.000000000 +0100
+++ busybox-1.27.0/util-linux/hwclock.c	2017-07-01 22:51:12.000000000 +0200
@@ -20,10 +20,6 @@
 //config:	bool "Support long options (--hctosys,...)"
 //config:	default y
 //config:	depends on HWCLOCK && LONG_OPTS
-//config:	help
-//config:	  By default, the hwclock utility only uses short options. If you
-//config:	  are overly fond of its long options, such as --hctosys, --utc, etc)
-//config:	  then enable this option.
 //config:
 //config:config FEATURE_HWCLOCK_ADJTIME_FHS
 //config:	bool "Use FHS /var/lib/hwclock/adjtime"
@@ -171,7 +167,7 @@ static void from_sys_clock(const char **
  * On x86, even though code does set hw clock within <1ms of exact
  * whole seconds, apparently hw clock (at least on some machines)
  * doesn't reset internal fractional seconds to 0,
- * making all this a pointless excercise.
+ * making all this a pointless exercise.
  */
 	/* If we see that we are N usec away from whole second,
 	 * we'll sleep for N-ADJ usecs. ADJ corrects for the fact
diff -urpN busybox-1.26.2/util-linux/ionice.c busybox-1.27.0/util-linux/ionice.c
--- busybox-1.26.2/util-linux/ionice.c	1970-01-01 01:00:00.000000000 +0100
+++ busybox-1.27.0/util-linux/ionice.c	2017-07-01 22:51:12.000000000 +0200
@@ -0,0 +1,115 @@
+/* vi: set sw=4 ts=4: */
+/*
+ * ionice implementation for busybox based on linux-utils-ng 2.14
+ *
+ * Copyright (C) 2008 by  <u173034@informatik.uni-oldenburg.de>
+ *
+ * Licensed under GPLv2 or later, see file LICENSE in this source tree.
+ */
+//config:config IONICE
+//config:	bool "ionice"
+//config:	default y
+//config:	select PLATFORM_LINUX
+//config:	help
+//config:	  Set/set program io scheduling class and priority
+//config:	  Requires kernel >= 2.6.13
+
+//applet:IF_IONICE(APPLET(ionice, BB_DIR_BIN, BB_SUID_DROP))
+
+//kbuild:lib-$(CONFIG_IONICE) += ionice.o
+
+//usage:#define ionice_trivial_usage
+//usage:	"[-c 1-3] [-n 0-7] [-p PID] [PROG]"
+//usage:#define ionice_full_usage "\n\n"
+//usage:       "Change I/O priority and class\n"
+//usage:     "\n	-c	Class. 1:realtime 2:best-effort 3:idle"
+//usage:     "\n	-n	Priority"
+
+#include <sys/syscall.h>
+#include <asm/unistd.h>
+#include "libbb.h"
+
+static int ioprio_set(int which, int who, int ioprio)
+{
+	return syscall(SYS_ioprio_set, which, who, ioprio);
+}
+
+static int ioprio_get(int which, int who)
+{
+	return syscall(SYS_ioprio_get, which, who);
+}
+
+enum {
+	IOPRIO_WHO_PROCESS = 1,
+	IOPRIO_WHO_PGRP,
+	IOPRIO_WHO_USER
+};
+
+enum {
+	IOPRIO_CLASS_NONE,
+	IOPRIO_CLASS_RT,
+	IOPRIO_CLASS_BE,
+	IOPRIO_CLASS_IDLE
+};
+
+static const char to_prio[] ALIGN1 = "none\0realtime\0best-effort\0idle";
+
+#define IOPRIO_CLASS_SHIFT      13
+
+int ionice_main(int argc, char **argv) MAIN_EXTERNALLY_VISIBLE;
+int ionice_main(int argc UNUSED_PARAM, char **argv)
+{
+	/* Defaults */
+	int ioclass = 0;
+	int pri = 0;
+	int pid = 0; /* affect own porcess */
+	int opt;
+	enum {
+		OPT_n = 1,
+		OPT_c = 2,
+		OPT_p = 4,
+	};
+
+	/* Numeric params */
+	/* '+': stop at first non-option */
+	opt = getopt32(argv, "+n:+c:+p:+", &pri, &ioclass, &pid);
+	argv += optind;
+
+	if (opt & OPT_c) {
+		if (ioclass > 3)
+			bb_error_msg_and_die("bad class %d", ioclass);
+// Do we need this (compat?)?
+//		if (ioclass == IOPRIO_CLASS_NONE)
+//			ioclass = IOPRIO_CLASS_BE;
+//		if (ioclass == IOPRIO_CLASS_IDLE) {
+//			//if (opt & OPT_n)
+//			//	bb_error_msg("ignoring priority for idle class");
+//			pri = 7;
+//		}
+	}
+
+	if (!(opt & (OPT_n|OPT_c))) {
+		if (!(opt & OPT_p) && *argv)
+			pid = xatoi_positive(*argv);
+
+		pri = ioprio_get(IOPRIO_WHO_PROCESS, pid);
+		if (pri == -1)
+			bb_perror_msg_and_die("ioprio_%cet", 'g');
+
+		ioclass = (pri >> IOPRIO_CLASS_SHIFT) & 0x3;
+		pri &= 0xff;
+		printf((ioclass == IOPRIO_CLASS_IDLE) ? "%s\n" : "%s: prio %d\n",
+				nth_string(to_prio, ioclass), pri);
+	} else {
+//printf("pri=%d class=%d val=%x\n",
+//pri, ioclass, pri | (ioclass << IOPRIO_CLASS_SHIFT));
+		pri |= (ioclass << IOPRIO_CLASS_SHIFT);
+		if (ioprio_set(IOPRIO_WHO_PROCESS, pid, pri) == -1)
+			bb_perror_msg_and_die("ioprio_%cet", 's');
+		if (argv[0]) {
+			BB_EXECVP_or_die(argv);
+		}
+	}
+
+	return EXIT_SUCCESS;
+}
diff -urpN busybox-1.26.2/util-linux/last.c busybox-1.27.0/util-linux/last.c
--- busybox-1.26.2/util-linux/last.c	1970-01-01 01:00:00.000000000 +0100
+++ busybox-1.27.0/util-linux/last.c	2017-07-01 22:51:12.000000000 +0200
@@ -0,0 +1,166 @@
+/* vi: set sw=4 ts=4: */
+/*
+ * last implementation for busybox
+ *
+ * Copyright (C) 2003-2004 by Erik Andersen <andersen@codepoet.org>
+ *
+ * Licensed under GPLv2, see file LICENSE in this source tree.
+ */
+//config:config LAST
+//config:	bool "last"
+//config:	default y
+//config:	depends on FEATURE_WTMP
+//config:	help
+//config:	  'last' displays a list of the last users that logged into the system.
+//config:
+//config:config FEATURE_LAST_FANCY
+//config:	bool "Output extra information"
+//config:	default y
+//config:	depends on LAST
+//config:	help
+//config:	  'last' displays detailed information about the last users that
+//config:	  logged into the system (mimics sysvinit last). +900 bytes.
+
+//applet:IF_LAST(APPLET(last, BB_DIR_USR_BIN, BB_SUID_DROP))
+
+//kbuild:ifeq ($(CONFIG_FEATURE_LAST_FANCY),y)
+//kbuild:lib-$(CONFIG_FEATURE_LAST_FANCY) += last_fancy.o
+//kbuild:else
+//kbuild:lib-$(CONFIG_LAST) += last.o
+//kbuild:endif
+
+//usage:#define last_trivial_usage
+//usage:       ""IF_FEATURE_LAST_FANCY("[-HW] [-f FILE]")
+//usage:#define last_full_usage "\n\n"
+//usage:       "Show listing of the last users that logged into the system"
+//usage:	IF_FEATURE_LAST_FANCY( "\n"
+/* //usage:  "\n	-H	Show header line" */
+//usage:     "\n	-W	Display with no host column truncation"
+//usage:     "\n	-f FILE Read from FILE instead of /var/log/wtmp"
+//usage:	)
+
+#include "libbb.h"
+
+/* NB: ut_name and ut_user are the same field, use only one name (ut_user)
+ * to reduce confusion */
+
+#ifndef SHUTDOWN_TIME
+#  define SHUTDOWN_TIME 254
+#endif
+
+/* Grr... utmp char[] members do not have to be nul-terminated.
+ * Do what we can while still keeping this reasonably small.
+ * Note: We are assuming the ut_id[] size is fixed at 4. */
+
+#if defined UT_LINESIZE \
+	&& ((UT_LINESIZE != 32) || (UT_NAMESIZE != 32) || (UT_HOSTSIZE != 256))
+#error struct utmpx member char[] size(s) have changed!
+#elif defined __UT_LINESIZE \
+	&& ((__UT_LINESIZE != 32) || (__UT_NAMESIZE != 32) || (__UT_HOSTSIZE != 256))
+/* __UT_NAMESIZE was checked with 64 above, but glibc-2.11 definitely uses 32! */
+#error struct utmpx member char[] size(s) have changed!
+#endif
+
+#if EMPTY != 0 || RUN_LVL != 1 || BOOT_TIME != 2 || NEW_TIME != 3 || \
+	OLD_TIME != 4
+#error Values for the ut_type field of struct utmpx changed
+#endif
+
+int last_main(int argc, char **argv) MAIN_EXTERNALLY_VISIBLE;
+int last_main(int argc UNUSED_PARAM, char **argv UNUSED_PARAM)
+{
+	struct utmpx ut;
+	int n, file = STDIN_FILENO;
+	time_t t_tmp;
+	off_t pos;
+	static const char _ut_usr[] ALIGN1 =
+			"runlevel\0" "reboot\0" "shutdown\0";
+	static const char _ut_lin[] ALIGN1 =
+			"~\0" "{\0" "|\0" /* "LOGIN\0" "date\0" */;
+	enum {
+		TYPE_RUN_LVL = RUN_LVL,         /* 1 */
+		TYPE_BOOT_TIME = BOOT_TIME,     /* 2 */
+		TYPE_SHUTDOWN_TIME = SHUTDOWN_TIME
+	};
+	enum {
+		_TILDE = EMPTY, /* 0 */
+		TYPE_NEW_TIME,  /* NEW_TIME, 3 */
+		TYPE_OLD_TIME   /* OLD_TIME, 4 */
+	};
+
+	if (argv[1]) {
+		bb_show_usage();
+	}
+	file = xopen(bb_path_wtmp_file, O_RDONLY);
+
+	printf("%-10s %-14s %-18s %-12.12s %s\n",
+		"USER", "TTY", "HOST", "LOGIN", "TIME");
+	/* yikes. We reverse over the file and that is a not too elegant way */
+	pos = xlseek(file, 0, SEEK_END);
+	pos = lseek(file, pos - sizeof(ut), SEEK_SET);
+	while ((n = full_read(file, &ut, sizeof(ut))) > 0) {
+		if (n != sizeof(ut)) {
+			bb_perror_msg_and_die("short read");
+		}
+		n = index_in_strings(_ut_lin, ut.ut_line);
+		if (n == _TILDE) { /* '~' */
+#if 1
+/* do we really need to be cautious here? */
+			n = index_in_strings(_ut_usr, ut.ut_user);
+			if (++n > 0)
+				ut.ut_type = n != 3 ? n : SHUTDOWN_TIME;
+#else
+			if (is_prefixed_with(ut.ut_user, "shutdown"))
+				ut.ut_type = SHUTDOWN_TIME;
+			else if (is_prefixed_with(ut.ut_user, "reboot"))
+				ut.ut_type = BOOT_TIME;
+			else if (is_prefixed_with(ut.ut_user, "runlevel"))
+				ut.ut_type = RUN_LVL;
+#endif
+		} else {
+			if (ut.ut_user[0] == '\0' || strcmp(ut.ut_user, "LOGIN") == 0) {
+				/* Don't bother.  This means we can't find how long
+				 * someone was logged in for.  Oh well. */
+				goto next;
+			}
+			if (ut.ut_type != DEAD_PROCESS
+			 && ut.ut_user[0]
+			 && ut.ut_line[0]
+			) {
+				ut.ut_type = USER_PROCESS;
+			}
+			if (strcmp(ut.ut_user, "date") == 0) {
+				if (n == TYPE_OLD_TIME) { /* '|' */
+					ut.ut_type = OLD_TIME;
+				}
+				if (n == TYPE_NEW_TIME) { /* '{' */
+					ut.ut_type = NEW_TIME;
+				}
+			}
+		}
+
+		if (ut.ut_type != USER_PROCESS) {
+			switch (ut.ut_type) {
+				case OLD_TIME:
+				case NEW_TIME:
+				case RUN_LVL:
+				case SHUTDOWN_TIME:
+					goto next;
+				case BOOT_TIME:
+					strcpy(ut.ut_line, "system boot");
+			}
+		}
+		/* manpages say ut_tv.tv_sec *is* time_t,
+		 * but some systems have it wrong */
+		t_tmp = (time_t)ut.ut_tv.tv_sec;
+		printf("%-10s %-14s %-18s %-12.12s\n",
+			ut.ut_user, ut.ut_line, ut.ut_host, ctime(&t_tmp) + 4);
+ next:
+		pos -= sizeof(ut);
+		if (pos <= 0)
+			break; /* done. */
+		xlseek(file, pos, SEEK_SET);
+	}
+
+	fflush_stdout_and_exit(EXIT_SUCCESS);
+}
diff -urpN busybox-1.26.2/util-linux/last_fancy.c busybox-1.27.0/util-linux/last_fancy.c
--- busybox-1.26.2/util-linux/last_fancy.c	1970-01-01 01:00:00.000000000 +0100
+++ busybox-1.27.0/util-linux/last_fancy.c	2017-07-01 22:51:12.000000000 +0200
@@ -0,0 +1,300 @@
+/* vi: set sw=4 ts=4: */
+/*
+ * (sysvinit like) last implementation
+ *
+ * Copyright (C) 2008 by Patricia Muscalu <patricia.muscalu@axis.com>
+ *
+ * Licensed under GPLv2 or later, see file LICENSE in this source tree.
+ */
+
+#include "libbb.h"
+
+/* NB: ut_name and ut_user are the same field, use only one name (ut_user)
+ * to reduce confusion */
+
+#ifndef SHUTDOWN_TIME
+#  define SHUTDOWN_TIME 254
+#endif
+
+#define HEADER_FORMAT     "%-8.8s %-12.12s %-*.*s %-16.16s %-7.7s %s\n"
+#define HEADER_LINE       "USER", "TTY", \
+	INET_ADDRSTRLEN, INET_ADDRSTRLEN, "HOST", "LOGIN", "  TIME", ""
+#define HEADER_LINE_WIDE  "USER", "TTY", \
+	INET6_ADDRSTRLEN, INET6_ADDRSTRLEN, "HOST", "LOGIN", "  TIME", ""
+
+#if !defined __UT_LINESIZE && defined UT_LINESIZE
+# define __UT_LINESIZE UT_LINESIZE
+#endif
+
+enum {
+	NORMAL,
+	LOGGED,
+	DOWN,
+	REBOOT,
+	CRASH,
+	GONE
+};
+
+enum {
+	LAST_OPT_W = (1 << 0),  /* -W wide            */
+	LAST_OPT_f = (1 << 1),  /* -f input file      */
+	LAST_OPT_H = (1 << 2),  /* -H header          */
+};
+
+#define show_wide (option_mask32 & LAST_OPT_W)
+
+static void show_entry(struct utmpx *ut, int state, time_t dur_secs)
+{
+	unsigned days, hours, mins;
+	char duration[sizeof("(%u+02:02)") + sizeof(int)*3];
+	char login_time[17];
+	char logout_time[8];
+	const char *logout_str;
+	const char *duration_str;
+	time_t tmp;
+
+	/* manpages say ut_tv.tv_sec *is* time_t,
+	 * but some systems have it wrong */
+	tmp = ut->ut_tv.tv_sec;
+	safe_strncpy(login_time, ctime(&tmp), 17);
+	tmp = dur_secs;
+	snprintf(logout_time, 8, "- %s", ctime(&tmp) + 11);
+
+	dur_secs = MAX(dur_secs - (time_t)ut->ut_tv.tv_sec, (time_t)0);
+	/* unsigned int is easier to divide than time_t (which may be signed long) */
+	mins = dur_secs / 60;
+	days = mins / (24*60);
+	mins = mins % (24*60);
+	hours = mins / 60;
+	mins = mins % 60;
+
+//	if (days) {
+		sprintf(duration, "(%u+%02u:%02u)", days, hours, mins);
+//	} else {
+//		sprintf(duration, " (%02u:%02u)", hours, mins);
+//	}
+
+	logout_str = logout_time;
+	duration_str = duration;
+	switch (state) {
+	case NORMAL:
+		break;
+	case LOGGED:
+		logout_str = "  still";
+		duration_str = "logged in";
+		break;
+	case DOWN:
+		logout_str = "- down ";
+		break;
+	case REBOOT:
+		break;
+	case CRASH:
+		logout_str = "- crash";
+		break;
+	case GONE:
+		logout_str = "   gone";
+		duration_str = "- no logout";
+		break;
+	}
+
+	printf(HEADER_FORMAT,
+		ut->ut_user,
+		ut->ut_line,
+		show_wide ? INET6_ADDRSTRLEN : INET_ADDRSTRLEN,
+		show_wide ? INET6_ADDRSTRLEN : INET_ADDRSTRLEN,
+		ut->ut_host,
+		login_time,
+		logout_str,
+		duration_str);
+}
+
+static int get_ut_type(struct utmpx *ut)
+{
+	if (ut->ut_line[0] == '~') {
+		if (strcmp(ut->ut_user, "shutdown") == 0) {
+			return SHUTDOWN_TIME;
+		}
+		if (strcmp(ut->ut_user, "reboot") == 0) {
+			return BOOT_TIME;
+		}
+		if (strcmp(ut->ut_user, "runlevel") == 0) {
+			return RUN_LVL;
+		}
+		return ut->ut_type;
+	}
+
+	if (ut->ut_user[0] == 0) {
+		return DEAD_PROCESS;
+	}
+
+	if ((ut->ut_type != DEAD_PROCESS)
+	 && (strcmp(ut->ut_user, "LOGIN") != 0)
+	 && ut->ut_user[0]
+	 && ut->ut_line[0]
+	) {
+		ut->ut_type = USER_PROCESS;
+	}
+
+	if (strcmp(ut->ut_user, "date") == 0) {
+		if (ut->ut_line[0] == '|') {
+			return OLD_TIME;
+		}
+		if (ut->ut_line[0] == '{') {
+			return NEW_TIME;
+		}
+	}
+	return ut->ut_type;
+}
+
+static int is_runlevel_shutdown(struct utmpx *ut)
+{
+	if (((ut->ut_pid & 255) == '0') || ((ut->ut_pid & 255) == '6')) {
+		return 1;
+	}
+
+	return 0;
+}
+
+int last_main(int argc, char **argv) MAIN_EXTERNALLY_VISIBLE;
+int last_main(int argc UNUSED_PARAM, char **argv)
+{
+	struct utmpx ut;
+	const char *filename = _PATH_WTMP;
+	llist_t *zlist;
+	off_t pos;
+	time_t start_time;
+	time_t boot_time;
+	time_t down_time;
+	int file;
+	smallint going_down;
+	smallint boot_down;
+
+	/*opt =*/ getopt32(argv, "Wf:" /* "H" */, &filename);
+#ifdef BUT_UTIL_LINUX_LAST_HAS_NO_SUCH_OPT
+	if (opt & LAST_OPT_H) {
+		/* Print header line */
+		if (opt & LAST_OPT_W) {
+			printf(HEADER_FORMAT, HEADER_LINE_WIDE);
+		} else {
+			printf(HEADER_FORMAT, HEADER_LINE);
+		}
+	}
+#endif
+
+	file = xopen(filename, O_RDONLY);
+	{
+		/* in case the file is empty... */
+		struct stat st;
+		fstat(file, &st);
+		start_time = st.st_ctime;
+	}
+
+	time(&down_time);
+	going_down = 0;
+	boot_down = NORMAL; /* 0 */
+	zlist = NULL;
+	boot_time = 0;
+	/* get file size, rounding down to last full record */
+	pos = xlseek(file, 0, SEEK_END) / sizeof(ut) * sizeof(ut);
+	for (;;) {
+		pos -= (off_t)sizeof(ut);
+		if (pos < 0) {
+			/* Beyond the beginning of the file boundary =>
+			 * the whole file has been read. */
+			break;
+		}
+		xlseek(file, pos, SEEK_SET);
+		xread(file, &ut, sizeof(ut));
+		/* rewritten by each record, eventially will have
+		 * first record's ut_tv.tv_sec: */
+		start_time = ut.ut_tv.tv_sec;
+
+		switch (get_ut_type(&ut)) {
+		case SHUTDOWN_TIME:
+			down_time = ut.ut_tv.tv_sec;
+			boot_down = DOWN;
+			going_down = 1;
+			break;
+		case RUN_LVL:
+			if (is_runlevel_shutdown(&ut)) {
+				down_time = ut.ut_tv.tv_sec;
+				going_down = 1;
+				boot_down = DOWN;
+			}
+			break;
+		case BOOT_TIME:
+			strcpy(ut.ut_line, "system boot");
+			show_entry(&ut, REBOOT, down_time);
+			boot_down = CRASH;
+			going_down = 1;
+			break;
+		case DEAD_PROCESS:
+			if (!ut.ut_line[0]) {
+				break;
+			}
+			/* add_entry */
+			llist_add_to(&zlist, xmemdup(&ut, sizeof(ut)));
+			break;
+		case USER_PROCESS: {
+			int show;
+
+			if (!ut.ut_line[0]) {
+				break;
+			}
+			/* find_entry */
+			show = 1;
+			{
+				llist_t *el, *next;
+				for (el = zlist; el; el = next) {
+					struct utmpx *up = (struct utmpx *)el->data;
+					next = el->link;
+					if (strncmp(up->ut_line, ut.ut_line, __UT_LINESIZE) == 0) {
+						if (show) {
+							show_entry(&ut, NORMAL, up->ut_tv.tv_sec);
+							show = 0;
+						}
+						llist_unlink(&zlist, el);
+						free(el->data);
+						free(el);
+					}
+				}
+			}
+
+			if (show) {
+				int state = boot_down;
+
+				if (boot_time == 0) {
+					state = LOGGED;
+					/* Check if the process is alive */
+					if ((ut.ut_pid > 0)
+					 && (kill(ut.ut_pid, 0) != 0)
+					 && (errno == ESRCH)) {
+						state = GONE;
+					}
+				}
+				show_entry(&ut, state, boot_time);
+			}
+			/* add_entry */
+			llist_add_to(&zlist, xmemdup(&ut, sizeof(ut)));
+			break;
+		}
+		}
+
+		if (going_down) {
+			boot_time = ut.ut_tv.tv_sec;
+			llist_free(zlist, free);
+			zlist = NULL;
+			going_down = 0;
+		}
+	}
+
+	if (ENABLE_FEATURE_CLEAN_UP) {
+		llist_free(zlist, free);
+	}
+
+	printf("\nwtmp begins %s", ctime(&start_time));
+
+	if (ENABLE_FEATURE_CLEAN_UP)
+		close(file);
+	fflush_stdout_and_exit(EXIT_SUCCESS);
+}
diff -urpN busybox-1.26.2/util-linux/losetup.c busybox-1.27.0/util-linux/losetup.c
--- busybox-1.26.2/util-linux/losetup.c	2016-12-10 18:46:36.000000000 +0100
+++ busybox-1.27.0/util-linux/losetup.c	2017-04-05 18:27:36.000000000 +0200
@@ -127,12 +127,37 @@ int losetup_main(int argc UNUSED_PARAM,
 			d = *argv++;
 
 		if (argv[0]) {
-			if (set_loop(&d, argv[0], offset, (opt & OPT_r)) < 0)
+			if (set_loop(&d, argv[0], offset, (opt & OPT_r) ? BB_LO_FLAGS_READ_ONLY : 0) < 0)
 				bb_simple_perror_msg_and_die(argv[0]);
 			return EXIT_SUCCESS;
 		}
 	}
 
+	/* TODO: util-linux 2.28 shows this when run w/o params:
+	 * NAME       SIZELIMIT OFFSET AUTOCLEAR RO BACK-FILE     DIO
+	 * /dev/loop0         0      0         1  0 /PATH/TO/FILE   0
+	 *
+	 * implemented by reading /sys:
+	 *
+	 * open("/sys/block", O_RDONLY|O_NONBLOCK|O_DIRECTORY|O_CLOEXEC) = 3
+	 * newfstatat(3, "loop0/loop/backing_file", {st_mode=S_IFREG|0444, st_size=4096, ...}, 0) = 0
+	 * stat("/dev/loop0", {st_mode=S_IFBLK|0660, st_rdev=makedev(7, 0), ...}) = 0
+	 * open("/sys/dev/block/7:0/loop/offset", O_RDONLY|O_CLOEXEC) = 5
+	 * read(5, "0\n", 4096)                    = 2
+	 * open("/sys/dev/block/7:0/loop/sizelimit", O_RDONLY|O_CLOEXEC) = 5
+	 * read(5, "0\n", 4096)                    = 2
+	 * open("/sys/dev/block/7:0/loop/offset", O_RDONLY|O_CLOEXEC) = 5
+	 * read(5, "0\n", 4096)                    = 2
+	 * open("/sys/dev/block/7:0/loop/autoclear", O_RDONLY|O_CLOEXEC) = 5
+	 * read(5, "1\n", 4096)                    = 2
+	 * open("/sys/dev/block/7:0/ro", O_RDONLY|O_CLOEXEC)     = 5
+	 * read(5, "0\n", 4096)                    = 2
+	 * open("/sys/dev/block/7:0/loop/backing_file", O_RDONLY|O_CLOEXEC) = 5
+	 * read(5, "/PATH/TO/FILE", 4096) = 37
+	 * open("/sys/dev/block/7:0/loop/dio", O_RDONLY|O_CLOEXEC) = 5
+	 * read(5, "0\n", 4096)                    = 2
+	 */
+
 	bb_show_usage(); /* does not return */
 	/*return EXIT_FAILURE;*/
 }
diff -urpN busybox-1.26.2/util-linux/mesg.c busybox-1.27.0/util-linux/mesg.c
--- busybox-1.26.2/util-linux/mesg.c	1970-01-01 01:00:00.000000000 +0100
+++ busybox-1.27.0/util-linux/mesg.c	2017-07-01 22:51:12.000000000 +0200
@@ -0,0 +1,76 @@
+/* vi: set sw=4 ts=4: */
+/*
+ * mesg implementation for busybox
+ *
+ * Copyright (c) 2002 Manuel Novoa III  <mjn3@codepoet.org>
+ *
+ * Licensed under GPLv2 or later, see file LICENSE in this source tree.
+ */
+
+//config:config MESG
+//config:	bool "mesg"
+//config:	default y
+//config:	help
+//config:	  Mesg controls access to your terminal by others. It is typically
+//config:	  used to allow or disallow other users to write to your terminal
+//config:
+//config:config FEATURE_MESG_ENABLE_ONLY_GROUP
+//config:	bool "Enable writing to tty only by group, not by everybody"
+//config:	default y
+//config:	depends on MESG
+//config:	help
+//config:	  Usually, ttys are owned by group "tty", and "write" tool is
+//config:	  setgid to this group. This way, "mesg y" only needs to enable
+//config:	  "write by owning group" bit in tty mode.
+//config:
+//config:	  If you set this option to N, "mesg y" will enable writing
+//config:	  by anybody at all. This is not recommended.
+
+//applet:IF_MESG(APPLET(mesg, BB_DIR_USR_BIN, BB_SUID_DROP))
+
+//kbuild:lib-$(CONFIG_MESG) += mesg.o
+
+//usage:#define mesg_trivial_usage
+//usage:       "[y|n]"
+//usage:#define mesg_full_usage "\n\n"
+//usage:       "Control write access to your terminal\n"
+//usage:       "	y	Allow write access to your terminal\n"
+//usage:       "	n	Disallow write access to your terminal"
+
+#include "libbb.h"
+
+#if ENABLE_FEATURE_MESG_ENABLE_ONLY_GROUP
+#define S_IWGRP_OR_S_IWOTH  S_IWGRP
+#else
+#define S_IWGRP_OR_S_IWOTH  (S_IWGRP | S_IWOTH)
+#endif
+
+int mesg_main(int argc, char **argv) MAIN_EXTERNALLY_VISIBLE;
+int mesg_main(int argc UNUSED_PARAM, char **argv)
+{
+	struct stat sb;
+	mode_t m;
+	char c = 0;
+
+	argv++;
+
+	if (argv[0]
+	 && (argv[1] || ((c = argv[0][0]) != 'y' && c != 'n'))
+	) {
+		bb_show_usage();
+	}
+
+	if (!isatty(STDIN_FILENO))
+		bb_error_msg_and_die("not a tty");
+
+	xfstat(STDIN_FILENO, &sb, "stderr");
+	if (c == 0) {
+		puts((sb.st_mode & (S_IWGRP|S_IWOTH)) ? "is y" : "is n");
+		return EXIT_SUCCESS;
+	}
+	m = (c == 'y') ? sb.st_mode | S_IWGRP_OR_S_IWOTH
+	               : sb.st_mode & ~(S_IWGRP|S_IWOTH);
+	if (fchmod(STDIN_FILENO, m) != 0)
+		bb_perror_nomsg_and_die();
+	return EXIT_SUCCESS;
+}
diff -urpN busybox-1.26.2/util-linux/mkfs_ext2.c busybox-1.27.0/util-linux/mkfs_ext2.c
--- busybox-1.26.2/util-linux/mkfs_ext2.c	2016-12-10 18:46:36.000000000 +0100
+++ busybox-1.27.0/util-linux/mkfs_ext2.c	2017-01-30 21:57:30.000000000 +0100
@@ -21,7 +21,8 @@
 //config:	help
 //config:	  Alias to "mke2fs".
 
-//applet:IF_MKE2FS(APPLET_ODDNAME(mke2fs, mkfs_ext2, BB_DIR_SBIN, BB_SUID_DROP, mkfs_ext2))
+//                    APPLET_ODDNAME:name       main       location     suid_type     help
+//applet:IF_MKE2FS(   APPLET_ODDNAME(mke2fs,    mkfs_ext2, BB_DIR_SBIN, BB_SUID_DROP, mkfs_ext2))
 //applet:IF_MKFS_EXT2(APPLET_ODDNAME(mkfs.ext2, mkfs_ext2, BB_DIR_SBIN, BB_SUID_DROP, mkfs_ext2))
 ////////:IF_MKFS_EXT3(APPLET_ODDNAME(mkfs.ext3, mkfs_ext2, BB_DIR_SBIN, BB_SUID_DROP, mkfs_ext2))
 
diff -urpN busybox-1.26.2/util-linux/mkfs_minix.c busybox-1.27.0/util-linux/mkfs_minix.c
--- busybox-1.26.2/util-linux/mkfs_minix.c	2016-12-10 18:46:36.000000000 +0100
+++ busybox-1.27.0/util-linux/mkfs_minix.c	2017-01-30 21:57:30.000000000 +0100
@@ -80,6 +80,7 @@
 //config:	  this. If you enabled 'mkfs_minix' then you almost certainly want to
 //config:	  be using the version 2 filesystem support.
 
+//                     APPLET_ODDNAME:name        main        location     suid_type     help
 //applet:IF_MKFS_MINIX(APPLET_ODDNAME(mkfs.minix, mkfs_minix, BB_DIR_SBIN, BB_SUID_DROP, mkfs_minix))
 
 //kbuild:lib-$(CONFIG_MKFS_MINIX) += mkfs_minix.o
diff -urpN busybox-1.26.2/util-linux/mkfs_vfat.c busybox-1.27.0/util-linux/mkfs_vfat.c
--- busybox-1.26.2/util-linux/mkfs_vfat.c	2016-12-10 18:46:36.000000000 +0100
+++ busybox-1.27.0/util-linux/mkfs_vfat.c	2017-01-30 21:57:30.000000000 +0100
@@ -21,7 +21,8 @@
 //config:	help
 //config:	  Alias to "mkdosfs".
 
-//applet:IF_MKDOSFS(APPLET_ODDNAME(mkdosfs, mkfs_vfat, BB_DIR_SBIN, BB_SUID_DROP, mkfs_vfat))
+//                    APPLET_ODDNAME:name       main       location     suid_type     help
+//applet:IF_MKDOSFS(  APPLET_ODDNAME(mkdosfs,   mkfs_vfat, BB_DIR_SBIN, BB_SUID_DROP, mkfs_vfat))
 //applet:IF_MKFS_VFAT(APPLET_ODDNAME(mkfs.vfat, mkfs_vfat, BB_DIR_SBIN, BB_SUID_DROP, mkfs_vfat))
 
 //kbuild:lib-$(CONFIG_MKDOSFS) += mkfs_vfat.o
diff -urpN busybox-1.26.2/util-linux/more.c busybox-1.27.0/util-linux/more.c
--- busybox-1.26.2/util-linux/more.c	2016-12-10 18:46:36.000000000 +0100
+++ busybox-1.27.0/util-linux/more.c	2017-01-15 00:18:53.000000000 +0100
@@ -38,32 +38,33 @@
 #include "libbb.h"
 #include "common_bufsiz.h"
 
-/* Support for FEATURE_USE_TERMIOS */
-
 struct globals {
-	int cin_fileno;
+	int tty_fileno;
+	unsigned terminal_width;
+	unsigned terminal_height;
 	struct termios initial_settings;
-	struct termios new_settings;
 } FIX_ALIASING;
 #define G (*(struct globals*)bb_common_bufsiz1)
-#define initial_settings (G.initial_settings)
-#define new_settings     (G.new_settings    )
-#define cin_fileno       (G.cin_fileno      )
 #define INIT_G() do { setup_common_bufsiz(); } while (0)
 
-#define setTermSettings(fd, argp) \
-do { \
-	if (ENABLE_FEATURE_USE_TERMIOS) \
-		tcsetattr(fd, TCSANOW, argp); \
-} while (0)
-#define getTermSettings(fd, argp) tcgetattr(fd, argp)
+static void get_wh(void)
+{
+	/* never returns w, h <= 1 */
+	get_terminal_width_height(G.tty_fileno, &G.terminal_width, &G.terminal_height);
+	G.terminal_height -= 1;
+}
+
+static void tcsetattr_tty_TCSANOW(struct termios *settings)
+{
+	tcsetattr(G.tty_fileno, TCSANOW, settings);
+}
 
 static void gotsig(int sig UNUSED_PARAM)
 {
 	/* bb_putchar_stderr doesn't use stdio buffering,
 	 * therefore it is safe in signal handler */
 	bb_putchar_stderr('\n');
-	setTermSettings(cin_fileno, &initial_settings);
+	tcsetattr_tty_TCSANOW(&G.initial_settings);
 	_exit(EXIT_FAILURE);
 }
 
@@ -73,22 +74,16 @@ int more_main(int argc, char **argv) MAI
 int more_main(int argc UNUSED_PARAM, char **argv)
 {
 	int c = c; /* for compiler */
-	int lines;
 	int input = 0;
 	int spaces = 0;
 	int please_display_more_prompt;
-	struct stat st;
-	FILE *file;
-	FILE *cin;
-	int len;
-	unsigned terminal_width;
-	unsigned terminal_height;
+	FILE *tty;
 
 	INIT_G();
 
 	/* Parse options */
 	/* Accepted but ignored: */
-	/* -d	Display help instead of ringing bell is pressed */
+	/* -d	Display help instead of ringing bell */
 	/* -f	Count logical lines (IOW: long lines are not folded) */
 	/* -l	Do not pause after any line containing a ^L (form feed) */
 	/* -s	Squeeze blank lines into one */
@@ -100,26 +95,22 @@ int more_main(int argc UNUSED_PARAM, cha
 	 * is not a tty and turns into cat. This makes sense. */
 	if (!isatty(STDOUT_FILENO))
 		return bb_cat(argv);
-	cin = fopen_for_read(CURRENT_TTY);
-	if (!cin)
+	tty = fopen_for_read(CURRENT_TTY);
+	if (!tty)
 		return bb_cat(argv);
 
-	if (ENABLE_FEATURE_USE_TERMIOS) {
-		cin_fileno = fileno(cin);
-		getTermSettings(cin_fileno, &initial_settings);
-		new_settings = initial_settings;
-		new_settings.c_lflag &= ~(ICANON | ECHO);
-		new_settings.c_cc[VMIN] = 1;
-		new_settings.c_cc[VTIME] = 0;
-		setTermSettings(cin_fileno, &new_settings);
-		bb_signals(0
-			+ (1 << SIGINT)
-			+ (1 << SIGQUIT)
-			+ (1 << SIGTERM)
-			, gotsig);
-	}
+	G.tty_fileno = fileno(tty);
+
+	/* Turn on unbuffered input; turn off echoing */
+	set_termios_to_raw(G.tty_fileno, &G.initial_settings, 0);
+	bb_signals(BB_FATAL_SIGS, gotsig);
 
 	do {
+		struct stat st;
+		FILE *file;
+		int len;
+		int lines;
+
 		file = stdin;
 		if (*argv) {
 			file = fopen_or_warn(*argv, "r");
@@ -129,17 +120,20 @@ int more_main(int argc UNUSED_PARAM, cha
 		st.st_size = 0;
 		fstat(fileno(file), &st);
 
-		please_display_more_prompt = 0;
-		/* never returns w, h <= 1 */
-		get_terminal_width_height(fileno(cin), &terminal_width, &terminal_height);
-		terminal_height -= 1;
+		get_wh();
 
+		please_display_more_prompt = 0;
 		len = 0;
 		lines = 0;
-		while (spaces || (c = getc(file)) != EOF) {
+		for (;;) {
 			int wrap;
+
 			if (spaces)
 				spaces--;
+			else {
+				c = getc(file);
+				if (c == EOF) break;
+			}
  loop_top:
 			if (input != 'r' && please_display_more_prompt) {
 				len = printf("--More-- ");
@@ -151,26 +145,26 @@ int more_main(int argc UNUSED_PARAM, cha
 						(int) ((uoff_t)ftello(file) / d),
 						st.st_size);
 				}
-				fflush_all();
 
 				/*
 				 * We've just displayed the "--More--" prompt, so now we need
 				 * to get input from the user.
 				 */
 				for (;;) {
-					input = getc(cin);
+					fflush_all();
+					input = getc(tty);
 					input = tolower(input);
-					if (!ENABLE_FEATURE_USE_TERMIOS)
-						printf("\033[A"); /* cursor up */
 					/* Erase the last message */
 					printf("\r%*s\r", len, "");
 
+					if (input == 'q')
+						goto end;
 					/* Due to various multibyte escape
 					 * sequences, it's not ok to accept
 					 * any input as a command to scroll
 					 * the screen. We only allow known
 					 * commands, else we show help msg. */
-					if (input == ' ' || input == '\n' || input == 'q' || input == 'r')
+					if (input == ' ' || input == '\n' || input == 'r')
 						break;
 					len = printf("(Enter:next line Space:next page Q:quit R:show the rest)");
 				}
@@ -178,15 +172,9 @@ int more_main(int argc UNUSED_PARAM, cha
 				lines = 0;
 				please_display_more_prompt = 0;
 
-				if (input == 'q')
-					goto end;
-
 				/* The user may have resized the terminal.
 				 * Re-read the dimensions. */
-				if (ENABLE_FEATURE_USE_TERMIOS) {
-					get_terminal_width_height(cin_fileno, &terminal_width, &terminal_height);
-					terminal_height -= 1;
-				}
+				get_wh();
 			}
 
 			/* Crudely convert tabs into spaces, which are
@@ -206,11 +194,11 @@ int more_main(int argc UNUSED_PARAM, cha
 			 * see if any characters have been hit in the _input_ stream. This
 			 * allows the user to quit while in the middle of a file.
 			 */
-			wrap = (++len > terminal_width);
+			wrap = (++len > G.terminal_width);
 			if (c == '\n' || wrap) {
 				/* Then outputting this character
 				 * will move us to a new line. */
-				if (++lines >= terminal_height || input == '\n')
+				if (++lines >= G.terminal_height || input == '\n')
 					please_display_more_prompt = 1;
 				len = 0;
 			}
@@ -230,6 +218,6 @@ int more_main(int argc UNUSED_PARAM, cha
 		fflush_all();
 	} while (*argv && *++argv);
  end:
-	setTermSettings(cin_fileno, &initial_settings);
+	tcsetattr_tty_TCSANOW(&G.initial_settings);
 	return 0;
 }
diff -urpN busybox-1.26.2/util-linux/mount.c busybox-1.27.0/util-linux/mount.c
--- busybox-1.26.2/util-linux/mount.c	2016-12-10 18:46:36.000000000 +0100
+++ busybox-1.27.0/util-linux/mount.c	2017-04-05 18:27:36.000000000 +0200
@@ -90,7 +90,7 @@
 //config:
 //config:config FEATURE_MOUNT_FLAGS
 //config:	depends on MOUNT
-//config:	bool "Support lots of -o flags in mount"
+//config:	bool "Support lots of -o flags"
 //config:	default y
 //config:	help
 //config:	  Without this, mount only supports ro/rw/remount. With this, it
@@ -1887,6 +1887,7 @@ static int nfsmount(struct mntent *mp, u
 // NB: mp->xxx fields may be trashed on exit
 static int singlemount(struct mntent *mp, int ignore_busy)
 {
+	int loopfd = -1;
 	int rc = -1;
 	unsigned long vfsflags;
 	char *loopFile = NULL, *filteropts = NULL;
@@ -2026,7 +2027,20 @@ static int singlemount(struct mntent *mp
 		if (ENABLE_FEATURE_MOUNT_LOOP && S_ISREG(st.st_mode)) {
 			loopFile = bb_simplify_path(mp->mnt_fsname);
 			mp->mnt_fsname = NULL; // will receive malloced loop dev name
-			if (set_loop(&mp->mnt_fsname, loopFile, 0, /*ro:*/ (vfsflags & MS_RDONLY)) < 0) {
+
+			// mount always creates AUTOCLEARed loopdevs, so that umounting
+			// drops them without any code in the userspace.
+			// This happens since circa linux-2.6.25:
+			// commit 96c5865559cee0f9cbc5173f3c949f6ce3525581
+			// Date:    Wed Feb 6 01:36:27 2008 -0800
+			// Subject: Allow auto-destruction of loop devices
+			loopfd = set_loop(&mp->mnt_fsname,
+					loopFile,
+					0,
+					((vfsflags & MS_RDONLY) ? BB_LO_FLAGS_READ_ONLY : 0)
+						| BB_LO_FLAGS_AUTOCLEAR
+			);
+			if (loopfd < 0) {
 				if (errno == EPERM || errno == EACCES)
 					bb_error_msg(bb_msg_perm_denied_are_you_root);
 				else
@@ -2074,6 +2088,8 @@ static int singlemount(struct mntent *mp
 	}
 
 	// If mount failed, clean up loop file (if any).
+	// (Newer kernels which support LO_FLAGS_AUTOCLEAR should not need this,
+	// merely "close(loopfd)" should do it?)
 	if (ENABLE_FEATURE_MOUNT_LOOP && rc && loopFile) {
 		del_loop(mp->mnt_fsname);
 		if (ENABLE_FEATURE_CLEAN_UP) {
@@ -2086,6 +2102,9 @@ static int singlemount(struct mntent *mp
 	if (ENABLE_FEATURE_CLEAN_UP)
 		free(filteropts);
 
+	if (loopfd >= 0)
+		close(loopfd);
+
 	if (errno == EBUSY && ignore_busy)
 		return 0;
 	if (errno == ENOENT && (vfsflags & MOUNT_NOFAIL))
@@ -2312,7 +2331,7 @@ int mount_main(int argc UNUSED_PARAM, ch
 				bb_error_msg_and_die(bb_msg_you_must_be_root);
 
 			// Does type match? (NULL matches always)
-			if (!match_fstype(mtcur, fstype))
+			if (!fstype_matches(mtcur->mnt_type, fstype))
 				continue;
 
 			// Skip noauto and swap anyway
diff -urpN busybox-1.26.2/util-linux/mountpoint.c busybox-1.27.0/util-linux/mountpoint.c
--- busybox-1.26.2/util-linux/mountpoint.c	1970-01-01 01:00:00.000000000 +0100
+++ busybox-1.27.0/util-linux/mountpoint.c	2017-07-01 22:51:12.000000000 +0200
@@ -0,0 +1,105 @@
+/* vi: set sw=4 ts=4: */
+/*
+ * mountpoint implementation for busybox
+ *
+ * Copyright (C) 2005 Bernhard Reutner-Fischer
+ *
+ * Licensed under GPLv2 or later, see file LICENSE in this source tree.
+ *
+ * Based on sysvinit's mountpoint
+ */
+//config:config MOUNTPOINT
+//config:	bool "mountpoint"
+//config:	default y
+//config:	help
+//config:	  mountpoint checks if the directory is a mountpoint.
+
+//applet:IF_MOUNTPOINT(APPLET(mountpoint, BB_DIR_BIN, BB_SUID_DROP))
+
+//kbuild:lib-$(CONFIG_MOUNTPOINT) += mountpoint.o
+
+//usage:#define mountpoint_trivial_usage
+//usage:       "[-q] <[-dn] DIR | -x DEVICE>"
+//usage:#define mountpoint_full_usage "\n\n"
+//usage:       "Check if the directory is a mountpoint\n"
+//usage:     "\n	-q	Quiet"
+//usage:     "\n	-d	Print major/minor device number of the filesystem"
+//usage:     "\n	-n	Print device name of the filesystem"
+//usage:     "\n	-x	Print major/minor device number of the blockdevice"
+//usage:
+//usage:#define mountpoint_example_usage
+//usage:       "$ mountpoint /proc\n"
+//usage:       "/proc is not a mountpoint\n"
+//usage:       "$ mountpoint /sys\n"
+//usage:       "/sys is a mountpoint\n"
+
+#include "libbb.h"
+
+int mountpoint_main(int argc, char **argv) MAIN_EXTERNALLY_VISIBLE;
+int mountpoint_main(int argc UNUSED_PARAM, char **argv)
+{
+	struct stat st;
+	const char *msg;
+	char *arg;
+	int rc, opt;
+
+	opt_complementary = "=1"; /* must have one argument */
+	opt = getopt32(argv, "qdxn");
+#define OPT_q (1)
+#define OPT_d (2)
+#define OPT_x (4)
+#define OPT_n (8)
+	arg = argv[optind];
+	msg = "%s";
+
+	rc = (opt & OPT_x) ? stat(arg, &st) : lstat(arg, &st);
+	if (rc != 0)
+		goto err;
+
+	if (opt & OPT_x) {
+		if (S_ISBLK(st.st_mode)) {
+			printf("%u:%u\n", major(st.st_rdev),
+						minor(st.st_rdev));
+			return EXIT_SUCCESS;
+		}
+		errno = 0; /* make perror_msg work as error_msg */
+		msg = "%s: not a block device";
+		goto err;
+	}
+
+	errno = ENOTDIR;
+	if (S_ISDIR(st.st_mode)) {
+		dev_t st_dev = st.st_dev;
+		ino_t st_ino = st.st_ino;
+		char *p = xasprintf("%s/..", arg);
+
+		if (stat(p, &st) == 0) {
+			//int is_mnt = (st_dev != st.st_dev) || (st_dev == st.st_dev && st_ino == st.st_ino);
+			int is_not_mnt = (st_dev == st.st_dev) && (st_ino != st.st_ino);
+
+			if (opt & OPT_d)
+				printf("%u:%u\n", major(st_dev), minor(st_dev));
+			if (opt & OPT_n) {
+				const char *d = find_block_device(arg);
+				/* name is undefined, but device is mounted -> anonymous superblock! */
+				/* happens with btrfs */
+				if (!d) {
+					d = "UNKNOWN";
+					/* TODO: iterate /proc/mounts, or /proc/self/mountinfo
+					 * to find out the device name */
+				}
+				printf("%s %s\n", d, arg);
+			}
+			if (!(opt & (OPT_q | OPT_d | OPT_n)))
+				printf("%s is %sa mountpoint\n", arg, is_not_mnt ? "not " : "");
+			return is_not_mnt;
+		}
+		arg = p;
+		/* else: stat had set errno, just fall through */
+	}
+
+ err:
+	if (!(opt & OPT_q))
+		bb_perror_msg(msg, arg);
+	return EXIT_FAILURE;
+}
diff -urpN busybox-1.26.2/util-linux/nsenter.c busybox-1.27.0/util-linux/nsenter.c
--- busybox-1.26.2/util-linux/nsenter.c	2016-09-27 18:53:50.000000000 +0200
+++ busybox-1.27.0/util-linux/nsenter.c	2017-01-23 01:09:41.000000000 +0100
@@ -30,19 +30,19 @@
 //usage:       "[OPTIONS] [PROG [ARGS]]"
 //usage:#if ENABLE_FEATURE_NSENTER_LONG_OPTS
 //usage:#define nsenter_full_usage "\n"
-//usage:     "\n	-t, --target=PID		Target process to get namespaces from"
-//usage:     "\n	-m, --mount[=FILE]		Enter mount namespace"
-//usage:     "\n	-u, --uts[=FILE]		Enter UTS namespace (hostname etc)"
-//usage:     "\n	-i, --ipc[=FILE]		Enter System V IPC namespace"
-//usage:     "\n	-n, --net[=FILE]		Enter network namespace"
-//usage:     "\n	-p, --pid[=FILE]		Enter pid namespace"
-//usage:     "\n	-U, --user[=FILE]		Enter user namespace"
-//usage:     "\n	-S, --setuid=UID		Set uid in entered namespace"
-//usage:     "\n	-G, --setgid=GID		Set gid in entered namespace"
-//usage:     "\n	--preserve-credentials		Don't touch uids or gids"
-//usage:     "\n	-r, --root[=DIR]		Set root directory"
-//usage:     "\n	-w, --wd[=DIR]			Set working directory"
-//usage:     "\n	-F, --no-fork			Don't fork before exec'ing PROG"
+//usage:     "\n	-t,--target PID		Target process to get namespaces from"
+//usage:     "\n	-m,--mount[=FILE]	Enter mount namespace"
+//usage:     "\n	-u,--uts[=FILE]		Enter UTS namespace (hostname etc)"
+//usage:     "\n	-i,--ipc[=FILE]		Enter System V IPC namespace"
+//usage:     "\n	-n,--net[=FILE]		Enter network namespace"
+//usage:     "\n	-p,--pid[=FILE]		Enter pid namespace"
+//usage:     "\n	-U,--user[=FILE]	Enter user namespace"
+//usage:     "\n	-S,--setuid UID		Set uid in entered namespace"
+//usage:     "\n	-G,--setgid GID		Set gid in entered namespace"
+//usage:     "\n	--preserve-credentials	Don't touch uids or gids"
+//usage:     "\n	-r,--root[=DIR]		Set root directory"
+//usage:     "\n	-w,--wd[=DIR]		Set working directory"
+//usage:     "\n	-F,--no-fork		Don't fork before exec'ing PROG"
 //usage:#else
 //usage:#define nsenter_full_usage "\n"
 //usage:     "\n	-t PID		Target process to get namespaces from"
diff -urpN busybox-1.26.2/util-linux/rdate.c busybox-1.27.0/util-linux/rdate.c
--- busybox-1.26.2/util-linux/rdate.c	2016-12-10 18:46:36.000000000 +0100
+++ busybox-1.27.0/util-linux/rdate.c	2017-01-23 01:09:41.000000000 +0100
@@ -21,11 +21,11 @@
 //kbuild:lib-$(CONFIG_RDATE) += rdate.o
 
 //usage:#define rdate_trivial_usage
-//usage:       "[-sp] HOST"
+//usage:       "[-s/-p] HOST"
 //usage:#define rdate_full_usage "\n\n"
-//usage:       "Get and possibly set system time from a remote HOST\n"
-//usage:     "\n	-s	Set system time (default)"
-//usage:     "\n	-p	Print time"
+//usage:       "Set and print time from HOST using RFC 868\n"
+//usage:     "\n	-s	Only set system time"
+//usage:     "\n	-p	Only print time"
 
 #include "libbb.h"
 
@@ -58,8 +58,22 @@ static time_t askremotedate(const char *
 	 * the RFC 868 time 2,208,988,800 corresponds to 00:00  1 Jan 1970 GMT
 	 * Subtract the RFC 868 time to get Linux epoch.
 	 */
+	nett = ntohl(nett) - RFC_868_BIAS;
 
-	return ntohl(nett) - RFC_868_BIAS;
+	if (sizeof(time_t) > 4) {
+		/* Now we have 32-bit lsb of a wider time_t
+		 * Imagine that  nett =   0x00000001,
+		 * current time  cur = 0x123ffffffff.
+		 * Assuming our time is not some 40 years off,
+		 * remote time must be 0x12400000001.
+		 * Need to adjust out time by (int32_t)(nett - cur).
+		 */
+		time_t cur = time(NULL);
+		int32_t adjust = (int32_t)(nett - (uint32_t)cur);
+		return cur + adjust;
+	}
+	/* This is not going to work, but what can we do */
+	return (time_t)nett;
 }
 
 int rdate_main(int argc, char **argv) MAIN_EXTERNALLY_VISIBLE;
@@ -73,11 +87,15 @@ int rdate_main(int argc UNUSED_PARAM, ch
 
 	remote_time = askremotedate(argv[optind]);
 
-	if (!(flags & 2)) { /* no -p (-s may be present) */
-		time_t current_time;
+	/* Manpages of various Unixes are confusing. What happens is:
+	 * (no opts) set and print time
+	 * -s: set time ("do not print the time")
+	 * -p: print time ("do not set, just print the remote time")
+	 * -sp: print time (that's what we do, not sure this is right)
+	 */
 
-		time(&current_time);
-		if (current_time == remote_time)
+	if (!(flags & 2)) { /* no -p (-s may be present) */
+		if (time(NULL) == remote_time)
 			bb_error_msg("current time matches remote time");
 		else
 			if (stime(&remote_time) < 0)
diff -urpN busybox-1.26.2/util-linux/renice.c busybox-1.27.0/util-linux/renice.c
--- busybox-1.26.2/util-linux/renice.c	1970-01-01 01:00:00.000000000 +0100
+++ busybox-1.27.0/util-linux/renice.c	2017-07-01 22:51:12.000000000 +0200
@@ -0,0 +1,148 @@
+/* vi: set sw=4 ts=4: */
+/*
+ * renice implementation for busybox
+ *
+ * Copyright (C) 2005  Manuel Novoa III  <mjn3@codepoet.org>
+ *
+ * Licensed under GPLv2 or later, see file LICENSE in this source tree.
+ */
+
+/* Notes:
+ *   Setting an absolute priority was obsoleted in SUSv2 and removed
+ *   in SUSv3.  However, the common linux version of renice does
+ *   absolute and not relative.  So we'll continue supporting absolute,
+ *   although the stdout logging has been removed since both SUSv2 and
+ *   SUSv3 specify that stdout isn't used.
+ *
+ *   This version is lenient in that it doesn't require any IDs.  The
+ *   options -p, -g, and -u are treated as mode switches for the
+ *   following IDs (if any).  Multiple switches are allowed.
+ */
+//config:config RENICE
+//config:	bool "renice"
+//config:	default y
+//config:	help
+//config:	  Renice alters the scheduling priority of one or more running
+//config:	  processes.
+
+//applet:IF_RENICE(APPLET(renice, BB_DIR_USR_BIN, BB_SUID_DROP))
+
+//kbuild:lib-$(CONFIG_RENICE) += renice.o
+
+//usage:#define renice_trivial_usage
+//usage:       "[-n] PRIORITY [[-p | -g | -u] ID...]..."
+//usage:#define renice_full_usage "\n\n"
+//usage:       "Change scheduling priority of a running process\n"
+//usage:     "\n	-n	Add PRIORITY to current nice value"
+//usage:     "\n		Without -n, nice value is set to PRIORITY"
+//usage:     "\n	-p	Process ids (default)"
+//usage:     "\n	-g	Process group ids"
+//usage:     "\n	-u	Process user names"
+
+#include "libbb.h"
+#include <sys/resource.h>
+
+void BUG_bad_PRIO_PROCESS(void);
+void BUG_bad_PRIO_PGRP(void);
+void BUG_bad_PRIO_USER(void);
+
+int renice_main(int argc, char **argv) MAIN_EXTERNALLY_VISIBLE;
+int renice_main(int argc UNUSED_PARAM, char **argv)
+{
+	static const char Xetpriority_msg[] ALIGN1 = "%cetpriority";
+
+	int retval = EXIT_SUCCESS;
+	int which = PRIO_PROCESS;  /* Default 'which' value. */
+	int use_relative = 0;
+	int adjustment, new_priority;
+	unsigned who;
+	char *arg;
+
+	/* Yes, they are not #defines in glibc 2.4! #if won't work */
+	if (PRIO_PROCESS < CHAR_MIN || PRIO_PROCESS > CHAR_MAX)
+		BUG_bad_PRIO_PROCESS();
+	if (PRIO_PGRP < CHAR_MIN || PRIO_PGRP > CHAR_MAX)
+		BUG_bad_PRIO_PGRP();
+	if (PRIO_USER < CHAR_MIN || PRIO_USER > CHAR_MAX)
+		BUG_bad_PRIO_USER();
+
+	arg = *++argv;
+
+	/* Check if we are using a relative adjustment. */
+	if (arg && arg[0] == '-' && arg[1] == 'n') {
+		use_relative = 1;
+		if (!arg[2])
+			arg = *++argv;
+		else
+			arg += 2;
+	}
+
+	if (!arg) {  /* No args?  Then show usage. */
+		bb_show_usage();
+	}
+
+	/* Get the priority adjustment (absolute or relative). */
+	adjustment = xatoi_range(arg, INT_MIN/2, INT_MAX/2);
+
+	while ((arg = *++argv) != NULL) {
+		/* Check for a mode switch. */
+		if (arg[0] == '-' && arg[1]) {
+			static const char opts[] ALIGN1 = {
+				'p', 'g', 'u', 0, PRIO_PROCESS, PRIO_PGRP, PRIO_USER
+			};
+			const char *p = strchr(opts, arg[1]);
+			if (p) {
+				which = p[4];
+				if (!arg[2])
+					continue;
+				arg += 2;
+			}
+		}
+
+		/* Process an ID arg. */
+		if (which == PRIO_USER) {
+			struct passwd *p;
+			p = getpwnam(arg);
+			if (!p) {
+				bb_error_msg("unknown user %s", arg);
+				goto HAD_ERROR;
+			}
+			who = p->pw_uid;
+		} else {
+			who = bb_strtou(arg, NULL, 10);
+			if (errno) {
+				bb_error_msg("invalid number '%s'", arg);
+				goto HAD_ERROR;
+			}
+		}
+
+		/* Get priority to use, and set it. */
+		if (use_relative) {
+			int old_priority;
+
+			errno = 0;  /* Needed for getpriority error detection. */
+			old_priority = getpriority(which, who);
+			if (errno) {
+				bb_perror_msg(Xetpriority_msg, 'g');
+				goto HAD_ERROR;
+			}
+
+			new_priority = old_priority + adjustment;
+		} else {
+			new_priority = adjustment;
+		}
+
+		if (setpriority(which, who, new_priority) == 0) {
+			continue;
+		}
+
+		bb_perror_msg(Xetpriority_msg, 's');
+ HAD_ERROR:
+		retval = EXIT_FAILURE;
+	}
+
+	/* No need to check for errors outputting to stderr since, if it
+	 * was used, the HAD_ERROR label was reached and retval was set. */
+
+	return retval;
+}
diff -urpN busybox-1.26.2/util-linux/rtcwake.c busybox-1.27.0/util-linux/rtcwake.c
--- busybox-1.26.2/util-linux/rtcwake.c	2016-12-10 18:46:36.000000000 +0100
+++ busybox-1.27.0/util-linux/rtcwake.c	2017-01-23 01:09:41.000000000 +0100
@@ -41,10 +41,10 @@
 //usage:     "\n	-a,--auto	Read clock mode from adjtime"
 //usage:     "\n	-l,--local	Clock is set to local time"
 //usage:     "\n	-u,--utc	Clock is set to UTC time"
-//usage:     "\n	-d,--device=DEV	Specify the RTC device"
-//usage:     "\n	-m,--mode=MODE	Set sleep state (default: standby)"
-//usage:     "\n	-s,--seconds=SEC Set timeout in SEC seconds from now"
-//usage:     "\n	-t,--time=TIME	Set timeout to TIME seconds from epoch"
+//usage:     "\n	-d,--device DEV	Specify the RTC device"
+//usage:     "\n	-m,--mode MODE	Set sleep state (default: standby)"
+//usage:     "\n	-s,--seconds SEC Set timeout in SEC seconds from now"
+//usage:     "\n	-t,--time TIME	Set timeout to TIME seconds from epoch"
 //usage:	)
 //usage:	IF_NOT_LONG_OPTS(
 //usage:     "\n	-a	Read clock mode from adjtime"
diff -urpN busybox-1.26.2/util-linux/setarch.c busybox-1.27.0/util-linux/setarch.c
--- busybox-1.26.2/util-linux/setarch.c	2016-12-10 18:46:36.000000000 +0100
+++ busybox-1.27.0/util-linux/setarch.c	2017-01-30 21:57:30.000000000 +0100
@@ -31,6 +31,7 @@
 //config:	  Alias to "setarch linux64".
 
 //applet:IF_SETARCH(APPLET(setarch, BB_DIR_BIN, BB_SUID_DROP))
+//                  APPLET_ODDNAME:name     main     location    suid_type     help
 //applet:IF_LINUX32(APPLET_ODDNAME(linux32, setarch, BB_DIR_BIN, BB_SUID_DROP, linux32))
 //applet:IF_LINUX64(APPLET_ODDNAME(linux64, setarch, BB_DIR_BIN, BB_SUID_DROP, linux64))
 
diff -urpN busybox-1.26.2/util-linux/setpriv.c busybox-1.27.0/util-linux/setpriv.c
--- busybox-1.26.2/util-linux/setpriv.c	1970-01-01 01:00:00.000000000 +0100
+++ busybox-1.27.0/util-linux/setpriv.c	2017-07-01 22:51:12.000000000 +0200
@@ -0,0 +1,73 @@
+/* vi: set sw=4 ts=4: */
+/*
+ * setpriv implementation for busybox based on linux-utils-ng 2.29
+ *
+ * Copyright (C) 2017 by  <assafgordon@gmail.com>
+ *
+ * Licensed under GPLv2 or later, see file LICENSE in this source tree.
+ *
+ */
+//config:config SETPRIV
+//config:	bool "setpriv"
+//config:	default y
+//config:	select PLATFORM_LINUX
+//config:	select LONG_OPTS
+//config:	help
+//config:	  Run a program with different Linux privilege settings.
+//config:	  Requires kernel >= 3.5
+
+//applet:IF_SETPRIV(APPLET(setpriv, BB_DIR_BIN, BB_SUID_DROP))
+
+//kbuild:lib-$(CONFIG_SETPRIV) += setpriv.o
+
+//usage:#define setpriv_trivial_usage
+//usage:	"[OPTIONS] PROG [ARGS]"
+//usage:#define setpriv_full_usage "\n\n"
+//usage:       "Run PROG with different privilege settings\n"
+//usage:     "\n--nnp,--no-new-privs	Ignore setuid/setgid bits and file capabilities"
+
+//setpriv from util-linux 2.28:
+// -d, --dump               show current state (and do not exec anything)
+// --nnp, --no-new-privs    disallow granting new privileges
+// --inh-caps <caps,...>    set inheritable capabilities
+// --bounding-set <caps>    set capability bounding set
+// --ruid <uid>             set real uid
+// --euid <uid>             set effective uid
+// --rgid <gid>             set real gid
+// --egid <gid>             set effective gid
+// --reuid <uid>            set real and effective uid
+// --regid <gid>            set real and effective gid
+// --clear-groups           clear supplementary groups
+// --keep-groups            keep supplementary groups
+// --groups <group,...>     set supplementary groups
+// --securebits <bits>      set securebits
+// --selinux-label <label>  set SELinux label
+// --apparmor-profile <pr>  set AppArmor profile
+
+#include <sys/prctl.h>
+#include "libbb.h"
+
+#ifndef PR_SET_NO_NEW_PRIVS
+#define PR_SET_NO_NEW_PRIVS 38
+#endif
+
+int setpriv_main(int argc, char **argv) MAIN_EXTERNALLY_VISIBLE;
+int setpriv_main(int argc UNUSED_PARAM, char **argv)
+{
+	static const char setpriv_longopts[] ALIGN1 =
+		"nnp\0"          No_argument	"\xff"
+		"no-new-privs\0" No_argument	"\xff"
+		;
+	int opts;
+
+	opt_complementary = "-1";
+	applet_long_options = setpriv_longopts;
+	opts = getopt32(argv, "");
+	if (opts) {
+		if (prctl(PR_SET_NO_NEW_PRIVS, 1, 0, 0, 0))
+			bb_simple_perror_msg_and_die("prctl: NO_NEW_PRIVS");
+	}
+
+	argv += optind;
+	BB_EXECVP_or_die(argv);
+}
diff -urpN busybox-1.26.2/util-linux/setsid.c busybox-1.27.0/util-linux/setsid.c
--- busybox-1.26.2/util-linux/setsid.c	1970-01-01 01:00:00.000000000 +0100
+++ busybox-1.27.0/util-linux/setsid.c	2017-07-01 22:51:12.000000000 +0200
@@ -0,0 +1,82 @@
+/* vi: set sw=4 ts=4: */
+/*
+ * setsid.c -- execute a command in a new session
+ * Rick Sladkey <jrs@world.std.com>
+ * In the public domain.
+ *
+ * 1999-02-22 Arkadiusz Mickiewicz <misiek@pld.ORG.PL>
+ * - added Native Language Support
+ *
+ * 2001-01-18 John Fremlin <vii@penguinpowered.com>
+ * - fork in case we are process group leader
+ *
+ * 2004-11-12 Paul Fox
+ * - busyboxed
+ */
+//config:config SETSID
+//config:	bool "setsid"
+//config:	default y
+//config:	help
+//config:	  setsid runs a program in a new session
+
+//applet:IF_SETSID(APPLET(setsid, BB_DIR_USR_BIN, BB_SUID_DROP))
+
+//kbuild:lib-$(CONFIG_SETSID) += setsid.o
+
+//usage:#define setsid_trivial_usage
+//usage:       "[-c] PROG ARGS"
+//usage:#define setsid_full_usage "\n\n"
+//usage:       "Run PROG in a new session. PROG will have no controlling terminal\n"
+//usage:       "and will not be affected by keyboard signals (^C etc).\n"
+//usage:     "\n	-c	Set controlling terminal to stdin"
+
+#include "libbb.h"
+
+int setsid_main(int argc, char **argv) MAIN_EXTERNALLY_VISIBLE;
+int setsid_main(int argc UNUSED_PARAM, char **argv)
+{
+	unsigned opt;
+
+	opt_complementary = "-1"; /* at least one arg */
+	opt = getopt32(argv, "+c"); /* +: stop on first non-opt */
+	argv += optind;
+
+	/* setsid() is allowed only when we are not a process group leader.
+	 * Otherwise our PID serves as PGID of some existing process group
+	 * and cannot be used as PGID of a new process group.
+	 *
+	 * Example: setsid() below fails when run alone in interactive shell:
+	 *  $ setsid PROG
+	 * because shell's child (setsid) is put in a new process group.
+	 * But doesn't fail if shell is not interactive
+	 * (and therefore doesn't create process groups for pipes),
+	 * or if setsid is not the first process in the process group:
+	 *  $ true | setsid PROG
+	 * or if setsid is executed in backquotes (`setsid PROG`)...
+	 */
+	if (setsid() < 0) {
+		pid_t pid = fork_or_rexec(argv);
+		if (pid != 0) {
+			/* parent */
+			/* TODO:
+			 * we can waitpid(pid, &status, 0) and then even
+			 * emulate exitcode, making the behavior consistent
+			 * in both forked and non forked cases.
+			 * However, the code is larger and upstream
+			 * does not do such trick.
+			 */
+			return EXIT_SUCCESS;
+		}
+
+		/* child */
+		/* now there should be no error: */
+		setsid();
+	}
+
+	if (opt) {
+		/* -c: set (with stealing) controlling tty */
+		ioctl(0, TIOCSCTTY, 1);
+	}
+
+	BB_EXECVP_or_die(argv);
+}
diff -urpN busybox-1.26.2/util-linux/swaponoff.c busybox-1.27.0/util-linux/swaponoff.c
--- busybox-1.26.2/util-linux/swaponoff.c	2016-12-10 18:46:36.000000000 +0100
+++ busybox-1.27.0/util-linux/swaponoff.c	2017-01-30 21:57:30.000000000 +0100
@@ -41,7 +41,8 @@
 //config:	help
 //config:	  This option enables the 'swapoff' utility.
 
-//applet:IF_SWAPON(APPLET_ODDNAME(swapon, swap_on_off, BB_DIR_SBIN, BB_SUID_DROP, swapon))
+//                  APPLET_ODDNAME:name     main         location     suid_type     help
+//applet:IF_SWAPON( APPLET_ODDNAME(swapon,  swap_on_off, BB_DIR_SBIN, BB_SUID_DROP, swapon))
 //applet:IF_SWAPOFF(APPLET_ODDNAME(swapoff, swap_on_off, BB_DIR_SBIN, BB_SUID_DROP, swapoff))
 
 //kbuild:lib-$(CONFIG_SWAPON) += swaponoff.o
diff -urpN busybox-1.26.2/util-linux/switch_root.c busybox-1.27.0/util-linux/switch_root.c
--- busybox-1.26.2/util-linux/switch_root.c	2016-12-10 18:46:36.000000000 +0100
+++ busybox-1.27.0/util-linux/switch_root.c	2017-07-01 22:51:12.000000000 +0200
@@ -141,10 +141,12 @@ int switch_root_main(int argc UNUSED_PAR
 
 	// If a new console specified, redirect stdin/stdout/stderr to it
 	if (console) {
-		close(0);
-		xopen(console, O_RDWR);
-		xdup2(0, 1);
-		xdup2(0, 2);
+		int fd = open_or_warn(console, O_RDWR);
+		if (fd >= 0) {
+			xmove_fd(fd, 0);
+			xdup2(0, 1);
+			xdup2(0, 2);
+		}
 	}
 
 	// Exec real init
@@ -181,7 +183,7 @@ So there's a step that needs to be sort
 script.  (You can work around this with static linking or very carefully laid
 out paths and sequencing, but it's brittle, ugly, and non-obvious.)
 
-2) The "find | rm" bit will acually delete everything because the mount points
+2) The "find | rm" bit will actually delete everything because the mount points
 still show up (even if their contents don't), and rm -rf will then happily zap
 that.  So the first line is an oversimplification of what you need to do _not_
 to descend into other filesystems and delete their contents.
diff -urpN busybox-1.26.2/util-linux/taskset.c busybox-1.27.0/util-linux/taskset.c
--- busybox-1.26.2/util-linux/taskset.c	1970-01-01 01:00:00.000000000 +0100
+++ busybox-1.27.0/util-linux/taskset.c	2017-07-01 22:51:12.000000000 +0200
@@ -0,0 +1,221 @@
+/* vi: set sw=4 ts=4: */
+/*
+ * taskset - retrieve or set a processes' CPU affinity
+ * Copyright (c) 2006 Bernhard Reutner-Fischer
+ *
+ * Licensed under GPLv2 or later, see file LICENSE in this source tree.
+ */
+
+//config:config TASKSET
+//config:	bool "taskset"
+//config:	default y
+//config:	help
+//config:	  Retrieve or set a processes's CPU affinity.
+//config:	  This requires sched_{g,s}etaffinity support in your libc.
+//config:
+//config:config FEATURE_TASKSET_FANCY
+//config:	bool "Fancy output"
+//config:	default y
+//config:	depends on TASKSET
+//config:	help
+//config:	  Needed for machines with more than 32-64 CPUs:
+//config:	  affinity parameter 0xHHHHHHHHHHHHHHHHHHHH can be arbitrarily long
+//config:	  in this case. Otherwise, it is limited to sizeof(long).
+
+//applet:IF_TASKSET(APPLET(taskset, BB_DIR_USR_BIN, BB_SUID_DROP))
+//kbuild:lib-$(CONFIG_TASKSET) += taskset.o
+
+//usage:#define taskset_trivial_usage
+//usage:       "[-p] [HEXMASK] PID | PROG ARGS"
+//usage:#define taskset_full_usage "\n\n"
+//usage:       "Set or get CPU affinity\n"
+//usage:     "\n	-p	Operate on an existing PID"
+//usage:
+//usage:#define taskset_example_usage
+//usage:       "$ taskset 0x7 ./dgemm_test&\n"
+//usage:       "$ taskset -p 0x1 $!\n"
+//usage:       "pid 4790's current affinity mask: 7\n"
+//usage:       "pid 4790's new affinity mask: 1\n"
+//usage:       "$ taskset 0x7 /bin/sh -c './taskset -p 0x1 $$'\n"
+//usage:       "pid 6671's current affinity mask: 1\n"
+//usage:       "pid 6671's new affinity mask: 1\n"
+//usage:       "$ taskset -p 1\n"
+//usage:       "pid 1's current affinity mask: 3\n"
+/*
+ * Not yet implemented:
+ * -a/--all-tasks (affect all threads)
+ *	needs to get TIDs from /proc/PID/task/ and use _them_ as "pid" in sched_setaffinity(pid)
+ * -c/--cpu-list  (specify CPUs via "1,3,5-7")
+ */
+
+#include <sched.h>
+#include "libbb.h"
+
+typedef unsigned long ul;
+#define SZOF_UL (unsigned)(sizeof(ul))
+#define BITS_UL (unsigned)(sizeof(ul)*8)
+#define MASK_UL (unsigned)(sizeof(ul)*8 - 1)
+
+#if ENABLE_FEATURE_TASKSET_FANCY
+#define TASKSET_PRINTF_MASK "%s"
+/* craft a string from the mask */
+static char *from_mask(const ul *mask, unsigned sz_in_bytes)
+{
+	char *str = xzalloc((sz_in_bytes+1) * 2); /* we will leak it */
+	char *p = str;
+	for (;;) {
+		ul v = *mask++;
+		if (SZOF_UL == 4)
+			p += sprintf(p, "%08lx", v);
+		if (SZOF_UL == 8)
+			p += sprintf(p, "%016lx", v);
+		if (SZOF_UL == 16)
+			p += sprintf(p, "%032lx", v); /* :) */
+		sz_in_bytes -= SZOF_UL;
+		if ((int)sz_in_bytes <= 0)
+			break;
+	}
+	while (str[0] == '0' && str[1])
+		str++;
+	return str;
+}
+#else
+#define TASKSET_PRINTF_MASK "%lx"
+static unsigned long long from_mask(ul *mask, unsigned sz_in_bytes UNUSED_PARAM)
+{
+	return *mask;
+}
+#endif
+
+static unsigned long *get_aff(int pid, unsigned *sz)
+{
+	int r;
+	unsigned long *mask = NULL;
+	unsigned sz_in_bytes = *sz;
+
+	for (;;) {
+		mask = xrealloc(mask, sz_in_bytes);
+		r = sched_getaffinity(pid, sz_in_bytes, (void*)mask);
+		if (r == 0)
+			break;
+		sz_in_bytes *= 2;
+		if (errno == EINVAL && (int)sz_in_bytes > 0)
+			continue;
+		bb_perror_msg_and_die("can't %cet pid %d's affinity", 'g', pid);
+	}
+	//bb_error_msg("get mask[0]:%lx sz_in_bytes:%d", mask[0], sz_in_bytes);
+	*sz = sz_in_bytes;
+	return mask;
+}
+
+int taskset_main(int argc, char **argv) MAIN_EXTERNALLY_VISIBLE;
+int taskset_main(int argc UNUSED_PARAM, char **argv)
+{
+	ul *mask;
+	unsigned mask_size_in_bytes;
+	pid_t pid = 0;
+	unsigned opt_p;
+	const char *current_new;
+	char *aff;
+
+	/* NB: we mimic util-linux's taskset: -p does not take
+	 * an argument, i.e., "-pN" is NOT valid, only "-p N"!
+	 * Indeed, util-linux-2.13-pre7 uses:
+	 * getopt_long(argc, argv, "+pchV", ...), not "...p:..." */
+
+	opt_complementary = "-1"; /* at least 1 arg */
+	opt_p = getopt32(argv, "+p");
+	argv += optind;
+
+	aff = *argv++;
+	if (opt_p) {
+		char *pid_str = aff;
+		if (*argv) { /* "-p <aff> <pid> ...rest.is.ignored..." */
+			pid_str = *argv; /* NB: *argv != NULL in this case */
+		}
+		/* else it was just "-p <pid>", and *argv == NULL */
+		pid = xatoul_range(pid_str, 1, ((unsigned)(pid_t)ULONG_MAX) >> 1);
+	} else {
+		/* <aff> <cmd...> */
+		if (!*argv)
+			bb_show_usage();
+	}
+
+	mask_size_in_bytes = SZOF_UL;
+	current_new = "current";
+ print_aff:
+	mask = get_aff(pid, &mask_size_in_bytes);
+	if (opt_p) {
+		printf("pid %d's %s affinity mask: "TASKSET_PRINTF_MASK"\n",
+				pid, current_new, from_mask(mask, mask_size_in_bytes));
+		if (*argv == NULL) {
+			/* Either it was just "-p <pid>",
+			 * or it was "-p <aff> <pid>" and we came here
+			 * for the second time (see goto below) */
+			return EXIT_SUCCESS;
+		}
+		*argv = NULL;
+		current_new = "new";
+	}
+	memset(mask, 0, mask_size_in_bytes);
+
+	/* Affinity was specified, translate it into mask */
+	/* it is always in hex, skip "0x" if it exists */
+	if (aff[0] == '0' && (aff[1]|0x20) == 'x')
+		aff += 2;
+
+	if (!ENABLE_FEATURE_TASKSET_FANCY) {
+		mask[0] = xstrtoul(aff, 16);
+	} else {
+		unsigned i;
+		char *last_char;
+
+		i = 0; /* bit pos in mask[] */
+
+		/* aff is ASCII hex string, accept very long masks in this form.
+		 * Process hex string AABBCCDD... to ulong mask[]
+		 * from the rightmost nibble, which is least-significant.
+		 * Bits not fitting into mask[] are ignored: (example: 1234
+		 * in 12340000000000000000000000000000000000000ff)
+		 */
+		last_char = strchrnul(aff, '\0');
+		while (last_char > aff) {
+			char c;
+			ul val;
+
+			last_char--;
+			c = *last_char;
+			if (isdigit(c))
+				val = c - '0';
+			else if ((c|0x20) >= 'a' && (c|0x20) <= 'f')
+				val = (c|0x20) - ('a' - 10);
+			else
+				bb_error_msg_and_die("bad affinity '%s'", aff);
+
+			if (i < mask_size_in_bytes * 8) {
+				mask[i / BITS_UL] |= val << (i & MASK_UL);
+				//bb_error_msg("bit %d set", i);
+			}
+			/* else:
+			 * We can error out here, but we don't.
+			 * For one, kernel itself ignores bits in mask[]
+			 * which do not map to any CPUs:
+			 * if mask[] has one 32-bit long element,
+			 * but you have only 8 CPUs, all bits beyond first 8
+			 * are ignored, silently.
+			 * No point in making bits past 31th to be errors.
+			 */
+			i += 4;
+		}
+	}
+
+	/* Set pid's or our own (pid==0) affinity */
+	if (sched_setaffinity(pid, mask_size_in_bytes, (void*)mask))
+		bb_perror_msg_and_die("can't %cet pid %d's affinity", 's', pid);
+	//bb_error_msg("set mask[0]:%lx", mask[0]);
+
+	if (!argv[0]) /* "-p <aff> <pid> [...ignored...]" */
+		goto print_aff; /* print new affinity and exit */
+
+	BB_EXECVP_or_die(argv);
+}
diff -urpN busybox-1.26.2/util-linux/umount.c busybox-1.27.0/util-linux/umount.c
--- busybox-1.26.2/util-linux/umount.c	2016-12-10 18:46:36.000000000 +0100
+++ busybox-1.27.0/util-linux/umount.c	2017-04-05 18:27:36.000000000 +0200
@@ -42,7 +42,7 @@
 //usage:     "\n	-l	Lazy umount (detach filesystem)"
 //usage:     "\n	-f	Force umount (i.e., unreachable NFS server)"
 //usage:	IF_FEATURE_MOUNT_LOOP(
-//usage:     "\n	-D	Don't free loop device even if it has been used"
+//usage:     "\n	-d	Free loop device if it has been used"
 //usage:	)
 //usage:
 //usage:#define umount_example_usage
@@ -68,22 +68,14 @@ static struct mntent *getmntent_r(FILE*
 }
 #endif
 
-/* Ignored: -v -t -i
- * bbox always acts as if -d is present.
- * -D can be used to suppress it (bbox extension).
- * Rationale:
- * (1) util-linux's umount does it if "loop=..." is seen in /etc/mtab:
- * thus, on many systems, bare umount _does_ drop loop devices.
- * (2) many users request this feature.
- */
-#define OPTION_STRING           "fldDnra" "vt:i"
+/* ignored: -v -t -i */
+#define OPTION_STRING           "fldnra" "vt:i"
 #define OPT_FORCE               (1 << 0) // Same as MNT_FORCE
 #define OPT_LAZY                (1 << 1) // Same as MNT_DETACH
-//#define OPT_FREE_LOOP           (1 << 2) // -d is assumed always present
-#define OPT_DONT_FREE_LOOP      (1 << 3)
-#define OPT_NO_MTAB             (1 << 4)
-#define OPT_REMOUNT             (1 << 5)
-#define OPT_ALL                 (ENABLE_FEATURE_UMOUNT_ALL ? (1 << 6) : 0)
+#define OPT_FREELOOP            (1 << 2)
+#define OPT_NO_MTAB             (1 << 3)
+#define OPT_REMOUNT             (1 << 4)
+#define OPT_ALL                 (ENABLE_FEATURE_UMOUNT_ALL ? (1 << 5) : 0)
 
 int umount_main(int argc, char **argv) MAIN_EXTERNALLY_VISIBLE;
 int umount_main(int argc UNUSED_PARAM, char **argv)
@@ -125,8 +117,8 @@ int umount_main(int argc UNUSED_PARAM, c
 	} else {
 		setup_common_bufsiz();
 		while (getmntent_r(fp, &me, bb_common_bufsiz1, COMMON_BUFSIZE)) {
-			/* Match fstype if passed */
-			if (!match_fstype(&me, fstype))
+			/* Match fstype (fstype==NULL matches always) */
+			if (!fstype_matches(me.mnt_type, fstype))
 				continue;
 			m = xzalloc(sizeof(*m));
 			m->next = mtl;
@@ -206,7 +198,7 @@ int umount_main(int argc UNUSED_PARAM, c
 		} else {
 			// De-allocate the loop device.  This ioctl should be ignored on
 			// any non-loop block devices.
-			if (ENABLE_FEATURE_MOUNT_LOOP && !(opt & OPT_DONT_FREE_LOOP) && m)
+			if (ENABLE_FEATURE_MOUNT_LOOP && (opt & OPT_FREELOOP) && m)
 				del_loop(m->device);
 			if (ENABLE_FEATURE_MTAB_SUPPORT && !(opt & OPT_NO_MTAB) && m)
 				erase_mtab(m->dir);
diff -urpN busybox-1.26.2/util-linux/unshare.c busybox-1.27.0/util-linux/unshare.c
--- busybox-1.26.2/util-linux/unshare.c	2016-12-10 18:46:36.000000000 +0100
+++ busybox-1.27.0/util-linux/unshare.c	2017-07-01 22:51:12.000000000 +0200
@@ -9,12 +9,13 @@
 //config:config UNSHARE
 //config:	bool "unshare"
 //config:	default y
-//config:	depends on LONG_OPTS && !NOMMU
+//config:	depends on !NOMMU
 //config:	select PLATFORM_LINUX
+//config:	select LONG_OPTS
 //config:	help
 //config:	  Run program with some namespaces unshared from parent.
 
-// depends on LONG_OPTS: it is awkward to exclude code which handles --propagation
+// needs LONG_OPTS: it is awkward to exclude code which handles --propagation
 // and --setgroups based on LONG_OPTS, so instead applet requires LONG_OPTS.
 // depends on !NOMMU: we need fork()
 
@@ -25,14 +26,14 @@
 //usage:#define unshare_trivial_usage
 //usage:       "[OPTIONS] [PROG [ARGS]]"
 //usage:#define unshare_full_usage "\n"
-//usage:     "\n	-m, --mount[=FILE]	Unshare mount namespace"
-//usage:     "\n	-u, --uts[=FILE]	Unshare UTS namespace (hostname etc.)"
-//usage:     "\n	-i, --ipc[=FILE]	Unshare System V IPC namespace"
-//usage:     "\n	-n, --net[=FILE]	Unshare network namespace"
-//usage:     "\n	-p, --pid[=FILE]	Unshare PID namespace"
-//usage:     "\n	-U, --user[=FILE}	Unshare user namespace"
-//usage:     "\n	-f, --fork		Fork before execing PROG"
-//usage:     "\n	-r, --map-root-user	Map current user to root (implies -u)"
+//usage:     "\n	-m,--mount[=FILE]	Unshare mount namespace"
+//usage:     "\n	-u,--uts[=FILE]		Unshare UTS namespace (hostname etc.)"
+//usage:     "\n	-i,--ipc[=FILE]		Unshare System V IPC namespace"
+//usage:     "\n	-n,--net[=FILE]		Unshare network namespace"
+//usage:     "\n	-p,--pid[=FILE]		Unshare PID namespace"
+//usage:     "\n	-U,--user[=FILE]	Unshare user namespace"
+//usage:     "\n	-f,--fork		Fork before execing PROG"
+//usage:     "\n	-r,--map-root-user	Map current user to root (implies -U)"
 //usage:     "\n	--mount-proc[=DIR]	Mount /proc filesystem first (implies -m)"
 //usage:     "\n	--propagation slave|shared|private|unchanged"
 //usage:     "\n				Modify mount propagation in mount namespace"
diff -urpN busybox-1.26.2/util-linux/volume_id/bcache.c busybox-1.27.0/util-linux/volume_id/bcache.c
--- busybox-1.26.2/util-linux/volume_id/bcache.c	2016-09-27 18:53:50.000000000 +0200
+++ busybox-1.27.0/util-linux/volume_id/bcache.c	2017-01-10 16:31:40.000000000 +0100
@@ -10,14 +10,10 @@
 
 //kbuild:lib-$(CONFIG_FEATURE_VOLUMEID_BCACHE) += bcache.o
 
-//config:
 //config:config FEATURE_VOLUMEID_BCACHE
 //config:	bool "bcache filesystem"
 //config:	default y
 //config:	depends on VOLUMEID
-//config:	help
-//config:	  TODO
-//config:
 
 #include "volume_id_internal.h"
 
diff -urpN busybox-1.26.2/util-linux/volume_id/btrfs.c busybox-1.27.0/util-linux/volume_id/btrfs.c
--- busybox-1.26.2/util-linux/volume_id/btrfs.c	2016-09-27 18:53:50.000000000 +0200
+++ busybox-1.27.0/util-linux/volume_id/btrfs.c	2017-01-10 16:31:40.000000000 +0100
@@ -21,14 +21,10 @@
 
 //kbuild:lib-$(CONFIG_FEATURE_VOLUMEID_BTRFS) += btrfs.o
 
-//config:
 //config:config FEATURE_VOLUMEID_BTRFS
 //config:	bool "btrfs filesystem"
 //config:	default y
 //config:	depends on VOLUMEID
-//config:	help
-//config:	  TODO
-//config:
 
 #include "volume_id_internal.h"
 
diff -urpN busybox-1.26.2/util-linux/volume_id/cramfs.c busybox-1.27.0/util-linux/volume_id/cramfs.c
--- busybox-1.26.2/util-linux/volume_id/cramfs.c	2016-09-27 18:53:50.000000000 +0200
+++ busybox-1.27.0/util-linux/volume_id/cramfs.c	2017-01-10 16:31:40.000000000 +0100
@@ -20,14 +20,10 @@
 
 //kbuild:lib-$(CONFIG_FEATURE_VOLUMEID_CRAMFS) += cramfs.o
 
-//config:
 //config:config FEATURE_VOLUMEID_CRAMFS
 //config:	bool "cramfs filesystem"
 //config:	default y
 //config:	depends on VOLUMEID
-//config:	help
-//config:	  TODO
-//config:
 
 #include "volume_id_internal.h"
 
diff -urpN busybox-1.26.2/util-linux/volume_id/exfat.c busybox-1.27.0/util-linux/volume_id/exfat.c
--- busybox-1.26.2/util-linux/volume_id/exfat.c	2016-09-27 18:53:50.000000000 +0200
+++ busybox-1.27.0/util-linux/volume_id/exfat.c	2017-01-10 16:31:40.000000000 +0100
@@ -20,7 +20,6 @@
 
 //kbuild:lib-$(CONFIG_FEATURE_VOLUMEID_EXFAT) += exfat.o
 
-//config:
 //config:config FEATURE_VOLUMEID_EXFAT
 //config:	bool "exFAT filesystem"
 //config:	default y
@@ -29,7 +28,6 @@
 //config:	  exFAT (extended FAT) is a proprietary file system designed especially
 //config:	  for flash drives. It has many features from NTFS, but with less
 //config:	  overhead. exFAT is used on most SDXC cards for consumer electronics.
-//config:
 
 #include "volume_id_internal.h"
 
diff -urpN busybox-1.26.2/util-linux/volume_id/ext.c busybox-1.27.0/util-linux/volume_id/ext.c
--- busybox-1.26.2/util-linux/volume_id/ext.c	2016-09-27 18:53:50.000000000 +0200
+++ busybox-1.27.0/util-linux/volume_id/ext.c	2017-01-10 16:31:40.000000000 +0100
@@ -20,14 +20,10 @@
 
 //kbuild:lib-$(CONFIG_FEATURE_VOLUMEID_EXT) += ext.o
 
-//config:
 //config:config FEATURE_VOLUMEID_EXT
 //config:	bool "Ext filesystem"
 //config:	default y
 //config:	depends on VOLUMEID
-//config:	help
-//config:	  TODO
-//config:
 
 #include "volume_id_internal.h"
 #include "bb_e2fs_defs.h"
diff -urpN busybox-1.26.2/util-linux/volume_id/f2fs.c busybox-1.27.0/util-linux/volume_id/f2fs.c
--- busybox-1.26.2/util-linux/volume_id/f2fs.c	2016-09-27 18:53:50.000000000 +0200
+++ busybox-1.27.0/util-linux/volume_id/f2fs.c	2017-01-10 16:31:40.000000000 +0100
@@ -8,7 +8,6 @@
 
 //kbuild:lib-$(CONFIG_FEATURE_VOLUMEID_F2FS) += f2fs.o
 
-//config:
 //config:config FEATURE_VOLUMEID_F2FS
 //config:	bool "f2fs filesystem"
 //config:	default y
@@ -18,7 +17,6 @@
 //config:	  which is adapted to newer forms of storage. F2FS also remedies some
 //config:	  known issues of the older log structured file systems, such as high
 //config:	  cleaning overhead.
-//config:
 
 #include "volume_id_internal.h"
 
diff -urpN busybox-1.26.2/util-linux/volume_id/fat.c busybox-1.27.0/util-linux/volume_id/fat.c
--- busybox-1.26.2/util-linux/volume_id/fat.c	2016-09-27 18:53:50.000000000 +0200
+++ busybox-1.27.0/util-linux/volume_id/fat.c	2017-01-10 16:31:40.000000000 +0100
@@ -20,14 +20,10 @@
 
 //kbuild:lib-$(CONFIG_FEATURE_VOLUMEID_FAT) += fat.o
 
-//config:
 //config:config FEATURE_VOLUMEID_FAT
 //config:	bool "fat filesystem"
 //config:	default y
 //config:	depends on VOLUMEID
-//config:	help
-//config:	  TODO
-//config:
 
 #include "volume_id_internal.h"
 
diff -urpN busybox-1.26.2/util-linux/volume_id/hfs.c busybox-1.27.0/util-linux/volume_id/hfs.c
--- busybox-1.26.2/util-linux/volume_id/hfs.c	2016-09-27 18:53:50.000000000 +0200
+++ busybox-1.27.0/util-linux/volume_id/hfs.c	2017-01-10 16:31:40.000000000 +0100
@@ -20,14 +20,10 @@
 
 //kbuild:lib-$(CONFIG_FEATURE_VOLUMEID_HFS) += hfs.o
 
-//config:
 //config:config FEATURE_VOLUMEID_HFS
 //config:	bool "hfs filesystem"
 //config:	default y
 //config:	depends on VOLUMEID
-//config:	help
-//config:	  TODO
-//config:
 
 #include "volume_id_internal.h"
 
diff -urpN busybox-1.26.2/util-linux/volume_id/iso9660.c busybox-1.27.0/util-linux/volume_id/iso9660.c
--- busybox-1.26.2/util-linux/volume_id/iso9660.c	2016-09-27 18:53:50.000000000 +0200
+++ busybox-1.27.0/util-linux/volume_id/iso9660.c	2017-01-10 16:31:40.000000000 +0100
@@ -20,14 +20,10 @@
 
 //kbuild:lib-$(CONFIG_FEATURE_VOLUMEID_ISO9660) += iso9660.o
 
-//config:
 //config:config FEATURE_VOLUMEID_ISO9660
 //config:	bool "iso9660 filesystem"
 //config:	default y
 //config:	depends on VOLUMEID
-//config:	help
-//config:	  TODO
-//config:
 
 #include "volume_id_internal.h"
 
diff -urpN busybox-1.26.2/util-linux/volume_id/jfs.c busybox-1.27.0/util-linux/volume_id/jfs.c
--- busybox-1.26.2/util-linux/volume_id/jfs.c	2016-09-27 18:53:50.000000000 +0200
+++ busybox-1.27.0/util-linux/volume_id/jfs.c	2017-01-10 16:31:40.000000000 +0100
@@ -20,14 +20,10 @@
 
 //kbuild:lib-$(CONFIG_FEATURE_VOLUMEID_JFS) += jfs.o
 
-//config:
 //config:config FEATURE_VOLUMEID_JFS
 //config:	bool "jfs filesystem"
 //config:	default y
 //config:	depends on VOLUMEID
-//config:	help
-//config:	  TODO
-//config:
 
 #include "volume_id_internal.h"
 
diff -urpN busybox-1.26.2/util-linux/volume_id/linux_raid.c busybox-1.27.0/util-linux/volume_id/linux_raid.c
--- busybox-1.26.2/util-linux/volume_id/linux_raid.c	2016-09-27 18:53:50.000000000 +0200
+++ busybox-1.27.0/util-linux/volume_id/linux_raid.c	2017-01-10 16:31:40.000000000 +0100
@@ -20,14 +20,10 @@
 
 //kbuild:lib-$(CONFIG_FEATURE_VOLUMEID_LINUXRAID) += linux_raid.o
 
-//config:
 //config:config FEATURE_VOLUMEID_LINUXRAID
 //config:	bool "linuxraid"
 //config:	default y
 //config:	depends on VOLUMEID
-//config:	help
-//config:	  TODO
-//config:
 
 #include "volume_id_internal.h"
 
diff -urpN busybox-1.26.2/util-linux/volume_id/linux_swap.c busybox-1.27.0/util-linux/volume_id/linux_swap.c
--- busybox-1.26.2/util-linux/volume_id/linux_swap.c	2016-09-27 18:53:50.000000000 +0200
+++ busybox-1.27.0/util-linux/volume_id/linux_swap.c	2017-01-10 16:31:40.000000000 +0100
@@ -20,14 +20,10 @@
 
 //kbuild:lib-$(CONFIG_FEATURE_VOLUMEID_LINUXSWAP) += linux_swap.o
 
-//config:
 //config:config FEATURE_VOLUMEID_LINUXSWAP
 //config:	bool "linux swap filesystem"
 //config:	default y
 //config:	depends on VOLUMEID
-//config:	help
-//config:	  TODO
-//config:
 
 #include "volume_id_internal.h"
 
diff -urpN busybox-1.26.2/util-linux/volume_id/luks.c busybox-1.27.0/util-linux/volume_id/luks.c
--- busybox-1.26.2/util-linux/volume_id/luks.c	2016-09-27 18:53:50.000000000 +0200
+++ busybox-1.27.0/util-linux/volume_id/luks.c	2017-01-10 16:31:40.000000000 +0100
@@ -20,14 +20,10 @@
 
 //kbuild:lib-$(CONFIG_FEATURE_VOLUMEID_LUKS) += luks.o
 
-//config:
 //config:config FEATURE_VOLUMEID_LUKS
 //config:	bool "luks filesystem"
 //config:	default y
 //config:	depends on VOLUMEID
-//config:	help
-//config:	  TODO
-//config:
 
 #include "volume_id_internal.h"
 
diff -urpN busybox-1.26.2/util-linux/volume_id/nilfs.c busybox-1.27.0/util-linux/volume_id/nilfs.c
--- busybox-1.26.2/util-linux/volume_id/nilfs.c	2016-09-27 18:53:50.000000000 +0200
+++ busybox-1.27.0/util-linux/volume_id/nilfs.c	2017-01-10 16:31:40.000000000 +0100
@@ -21,7 +21,6 @@
 
 //kbuild:lib-$(CONFIG_FEATURE_VOLUMEID_NILFS) += nilfs.o
 
-//config:
 //config:config FEATURE_VOLUMEID_NILFS
 //config:	bool "nilfs filesystem"
 //config:	default y
@@ -37,7 +36,6 @@
 //config:	  SOX compliance logging, and so forth. It can serve as an alternative
 //config:	  filesystem for Linux desktop environment, or as a basis of advanced
 //config:	  storage appliances.
-//config:
 
 #include "volume_id_internal.h"
 
diff -urpN busybox-1.26.2/util-linux/volume_id/ntfs.c busybox-1.27.0/util-linux/volume_id/ntfs.c
--- busybox-1.26.2/util-linux/volume_id/ntfs.c	2016-09-27 18:53:50.000000000 +0200
+++ busybox-1.27.0/util-linux/volume_id/ntfs.c	2017-01-10 16:31:40.000000000 +0100
@@ -20,14 +20,10 @@
 
 //kbuild:lib-$(CONFIG_FEATURE_VOLUMEID_NTFS) += ntfs.o
 
-//config:
 //config:config FEATURE_VOLUMEID_NTFS
 //config:	bool "ntfs filesystem"
 //config:	default y
 //config:	depends on VOLUMEID
-//config:	help
-//config:	  TODO
-//config:
 
 #include "volume_id_internal.h"
 
diff -urpN busybox-1.26.2/util-linux/volume_id/ocfs2.c busybox-1.27.0/util-linux/volume_id/ocfs2.c
--- busybox-1.26.2/util-linux/volume_id/ocfs2.c	2016-09-27 18:53:50.000000000 +0200
+++ busybox-1.27.0/util-linux/volume_id/ocfs2.c	2017-01-10 16:31:40.000000000 +0100
@@ -20,14 +20,10 @@
 
 //kbuild:lib-$(CONFIG_FEATURE_VOLUMEID_OCFS2) += ocfs2.o
 
-//config:
 //config:config FEATURE_VOLUMEID_OCFS2
 //config:	bool "ocfs2 filesystem"
 //config:	default y
 //config:	depends on VOLUMEID
-//config:	help
-//config:	  TODO
-//config:
 
 #include "volume_id_internal.h"
 
diff -urpN busybox-1.26.2/util-linux/volume_id/reiserfs.c busybox-1.27.0/util-linux/volume_id/reiserfs.c
--- busybox-1.26.2/util-linux/volume_id/reiserfs.c	2016-09-27 18:53:50.000000000 +0200
+++ busybox-1.27.0/util-linux/volume_id/reiserfs.c	2017-01-10 16:31:40.000000000 +0100
@@ -21,14 +21,10 @@
 
 //kbuild:lib-$(CONFIG_FEATURE_VOLUMEID_REISERFS) += reiserfs.o
 
-//config:
 //config:config FEATURE_VOLUMEID_REISERFS
 //config:	bool "Reiser filesystem"
 //config:	default y
 //config:	depends on VOLUMEID
-//config:	help
-//config:	  TODO
-//config:
 
 #include "volume_id_internal.h"
 
diff -urpN busybox-1.26.2/util-linux/volume_id/romfs.c busybox-1.27.0/util-linux/volume_id/romfs.c
--- busybox-1.26.2/util-linux/volume_id/romfs.c	2016-09-27 18:53:50.000000000 +0200
+++ busybox-1.27.0/util-linux/volume_id/romfs.c	2017-01-10 16:31:40.000000000 +0100
@@ -20,14 +20,10 @@
 
 //kbuild:lib-$(CONFIG_FEATURE_VOLUMEID_ROMFS) += romfs.o
 
-//config:
 //config:config FEATURE_VOLUMEID_ROMFS
 //config:	bool "romfs filesystem"
 //config:	default y
 //config:	depends on VOLUMEID
-//config:	help
-//config:	  TODO
-//config:
 
 #include "volume_id_internal.h"
 
diff -urpN busybox-1.26.2/util-linux/volume_id/squashfs.c busybox-1.27.0/util-linux/volume_id/squashfs.c
--- busybox-1.26.2/util-linux/volume_id/squashfs.c	2016-09-27 18:53:50.000000000 +0200
+++ busybox-1.27.0/util-linux/volume_id/squashfs.c	2017-01-10 16:31:40.000000000 +0100
@@ -8,7 +8,6 @@
 
 //kbuild:lib-$(CONFIG_FEATURE_VOLUMEID_SQUASHFS) += squashfs.o
 
-//config:
 //config:config FEATURE_VOLUMEID_SQUASHFS
 //config:	bool "SquashFS filesystem"
 //config:	default y
@@ -18,7 +17,6 @@
 //config:	  intended for general read-only filesystem use and in constrained block
 //config:	  device/memory systems (e.g. embedded systems) where low overhead is
 //config:	  needed.
-//config:
 
 #include "volume_id_internal.h"
 
diff -urpN busybox-1.26.2/util-linux/volume_id/sysv.c busybox-1.27.0/util-linux/volume_id/sysv.c
--- busybox-1.26.2/util-linux/volume_id/sysv.c	2016-09-27 18:53:50.000000000 +0200
+++ busybox-1.27.0/util-linux/volume_id/sysv.c	2017-01-10 16:31:40.000000000 +0100
@@ -20,14 +20,10 @@
 
 //kbuild:lib-$(CONFIG_FEATURE_VOLUMEID_SYSV) += sysv.o
 
-//config:
 //config:config FEATURE_VOLUMEID_SYSV
 //config:	bool "sysv filesystem"
 //config:	default y
 //config:	depends on VOLUMEID
-//config:	help
-//config:	  TODO
-//config:
 
 #include "volume_id_internal.h"
 
diff -urpN busybox-1.26.2/util-linux/volume_id/ubifs.c busybox-1.27.0/util-linux/volume_id/ubifs.c
--- busybox-1.26.2/util-linux/volume_id/ubifs.c	2016-09-27 18:53:50.000000000 +0200
+++ busybox-1.27.0/util-linux/volume_id/ubifs.c	2017-01-10 16:31:40.000000000 +0100
@@ -8,7 +8,6 @@
 
 //kbuild:lib-$(CONFIG_FEATURE_VOLUMEID_UBIFS) += ubifs.o
 
-//config:
 //config:config FEATURE_VOLUMEID_UBIFS
 //config:	bool "UBIFS filesystem"
 //config:	default y
@@ -16,7 +15,6 @@
 //config:	help
 //config:	  UBIFS (Unsorted Block Image File System) is a file
 //config:	  system for use with raw flash memory media.
-//config:
 
 #include "volume_id_internal.h"
 
diff -urpN busybox-1.26.2/util-linux/volume_id/udf.c busybox-1.27.0/util-linux/volume_id/udf.c
--- busybox-1.26.2/util-linux/volume_id/udf.c	2016-09-27 18:53:50.000000000 +0200
+++ busybox-1.27.0/util-linux/volume_id/udf.c	2017-07-01 22:51:12.000000000 +0200
@@ -20,14 +20,10 @@
 
 //kbuild:lib-$(CONFIG_FEATURE_VOLUMEID_UDF) += udf.o
 
-//config:
 //config:config FEATURE_VOLUMEID_UDF
 //config:	bool "udf filesystem"
 //config:	default y
 //config:	depends on VOLUMEID
-//config:	help
-//config:	  TODO
-//config:
 
 #include "volume_id_internal.h"
 
@@ -141,7 +137,7 @@ anchor:
 	if (type != 2) /* TAG_ID_AVDP */
 		goto found;
 
-	/* get desriptor list address and block count */
+	/* get descriptor list address and block count */
 	count = le32_to_cpu(vd->type.anchor.length) / bs;
 	loc = le32_to_cpu(vd->type.anchor.location);
 	dbg("0x%x descriptors starting at logical secor 0x%x", count, loc);
diff -urpN busybox-1.26.2/util-linux/volume_id/unused_highpoint.c busybox-1.27.0/util-linux/volume_id/unused_highpoint.c
--- busybox-1.26.2/util-linux/volume_id/unused_highpoint.c	2016-09-27 18:53:50.000000000 +0200
+++ busybox-1.27.0/util-linux/volume_id/unused_highpoint.c	2017-01-10 16:31:40.000000000 +0100
@@ -20,14 +20,10 @@
 
 //kbuild:### lib-$(CONFIG_FEATURE_VOLUMEID_HIGHPOINTRAID) += highpoint.o
 
-//config:
 //config:### config FEATURE_VOLUMEID_HIGHPOINTRAID
 //config:###	bool "highpoint raid"
 //config:###	default y
 //config:###	depends on VOLUMEID
-//config:###	help
-//config:###	  TODO
-//config:
 
 #include "volume_id_internal.h"
 
diff -urpN busybox-1.26.2/util-linux/volume_id/unused_hpfs.c busybox-1.27.0/util-linux/volume_id/unused_hpfs.c
--- busybox-1.26.2/util-linux/volume_id/unused_hpfs.c	2016-09-27 18:53:50.000000000 +0200
+++ busybox-1.27.0/util-linux/volume_id/unused_hpfs.c	2017-01-10 16:31:40.000000000 +0100
@@ -20,14 +20,10 @@
 
 //kbuild:### lib-$(CONFIG_FEATURE_VOLUMEID_HPFS) += hpfs.o
 
-//config:
 //config:### config FEATURE_VOLUMEID_HPFS
 //config:###	bool "hpfs filesystem"
 //config:###	default y
 //config:###	depends on VOLUMEID
-//config:###	help
-//config:###	  TODO
-//config:
 
 #include "volume_id_internal.h"
 
diff -urpN busybox-1.26.2/util-linux/volume_id/unused_isw_raid.c busybox-1.27.0/util-linux/volume_id/unused_isw_raid.c
--- busybox-1.26.2/util-linux/volume_id/unused_isw_raid.c	2016-09-27 18:53:50.000000000 +0200
+++ busybox-1.27.0/util-linux/volume_id/unused_isw_raid.c	2017-01-10 16:31:40.000000000 +0100
@@ -20,14 +20,10 @@
 
 //kbuild:### lib-$(CONFIG_FEATURE_VOLUMEID_ISWRAID) += isw_raid.o
 
-//config:
 //config:### config FEATURE_VOLUMEID_ISWRAID
 //config:###	bool "intel raid"
 //config:###	default y
 //config:###	depends on VOLUMEID
-//config:###	help
-//config:###	  TODO
-//config:
 
 #include "volume_id_internal.h"
 
diff -urpN busybox-1.26.2/util-linux/volume_id/unused_lsi_raid.c busybox-1.27.0/util-linux/volume_id/unused_lsi_raid.c
--- busybox-1.26.2/util-linux/volume_id/unused_lsi_raid.c	2016-09-27 18:53:50.000000000 +0200
+++ busybox-1.27.0/util-linux/volume_id/unused_lsi_raid.c	2017-01-10 16:31:40.000000000 +0100
@@ -20,14 +20,10 @@
 
 //kbuild:### lib-$(CONFIG_FEATURE_VOLUMEID_LSIRAID) += lsi_raid.o
 
-//config:
 //config:### config FEATURE_VOLUMEID_LSIRAID
 //config:###	bool "lsi raid"
 //config:###	default y
 //config:###	depends on VOLUMEID
-//config:###	help
-//config:###	  TODO
-//config:
 
 #include "volume_id_internal.h"
 
diff -urpN busybox-1.26.2/util-linux/volume_id/unused_lvm.c busybox-1.27.0/util-linux/volume_id/unused_lvm.c
--- busybox-1.26.2/util-linux/volume_id/unused_lvm.c	2016-09-27 18:53:50.000000000 +0200
+++ busybox-1.27.0/util-linux/volume_id/unused_lvm.c	2017-01-10 16:31:40.000000000 +0100
@@ -20,14 +20,10 @@
 
 //kbuild:### lib-$(CONFIG_FEATURE_VOLUMEID_LVM) += lvm.o
 
-//config:
 //config:### config FEATURE_VOLUMEID_LVM
 //config:###	bool "lvm"
 //config:###	default y
 //config:###	depends on VOLUMEID
-//config:###	help
-//config:###	  TODO
-//config:
 
 #include "volume_id_internal.h"
 
diff -urpN busybox-1.26.2/util-linux/volume_id/unused_mac.c busybox-1.27.0/util-linux/volume_id/unused_mac.c
--- busybox-1.26.2/util-linux/volume_id/unused_mac.c	2016-09-27 18:53:50.000000000 +0200
+++ busybox-1.27.0/util-linux/volume_id/unused_mac.c	2017-01-10 16:31:40.000000000 +0100
@@ -20,14 +20,10 @@
 
 //kbuild:### lib-$(CONFIG_FEATURE_VOLUMEID_MAC) += mac.o
 
-//config:
 //config:### config FEATURE_VOLUMEID_MAC
 //config:###	bool "mac filesystem"
 //config:###	default y
 //config:###	depends on VOLUMEID
-//config:###	help
-//config:###	  TODO
-//config:
 
 #include "volume_id_internal.h"
 
diff -urpN busybox-1.26.2/util-linux/volume_id/unused_minix.c busybox-1.27.0/util-linux/volume_id/unused_minix.c
--- busybox-1.26.2/util-linux/volume_id/unused_minix.c	2016-09-27 18:53:50.000000000 +0200
+++ busybox-1.27.0/util-linux/volume_id/unused_minix.c	2017-01-10 16:31:40.000000000 +0100
@@ -20,14 +20,10 @@
 
 //kbuild:### lib-$(CONFIG_FEATURE_VOLUMEID_MINIX) += minix.o
 
-//config:
 //config:### config FEATURE_VOLUMEID_MINIX
 //config:###	bool "minix filesystem"
 //config:###	default y
 //config:###	depends on VOLUMEID
-//config:###	help
-//config:###	  TODO
-//config:
 
 #include "volume_id_internal.h"
 
diff -urpN busybox-1.26.2/util-linux/volume_id/unused_msdos.c busybox-1.27.0/util-linux/volume_id/unused_msdos.c
--- busybox-1.26.2/util-linux/volume_id/unused_msdos.c	2016-09-27 18:53:50.000000000 +0200
+++ busybox-1.27.0/util-linux/volume_id/unused_msdos.c	2017-01-10 16:31:40.000000000 +0100
@@ -20,14 +20,10 @@
 
 //kbuild:### lib-$(CONFIG_FEATURE_VOLUMEID_MSDOS) += msdos.o
 
-//config:
 //config:### config FEATURE_VOLUMEID_MSDOS
 //config:###	bool "msdos filesystem"
 //config:###	default y
 //config:###	depends on VOLUMEID
-//config:###	help
-//config:###	  TODO
-//config:
 
 #include "volume_id_internal.h"
 
diff -urpN busybox-1.26.2/util-linux/volume_id/unused_nvidia_raid.c busybox-1.27.0/util-linux/volume_id/unused_nvidia_raid.c
--- busybox-1.26.2/util-linux/volume_id/unused_nvidia_raid.c	2016-09-27 18:53:50.000000000 +0200
+++ busybox-1.27.0/util-linux/volume_id/unused_nvidia_raid.c	2017-01-10 16:31:40.000000000 +0100
@@ -20,14 +20,10 @@
 
 //kbuild:### lib-$(CONFIG_FEATURE_VOLUMEID_NVIDIARAID) += nvidia_raid.o
 
-//config:
 //config:### config FEATURE_VOLUMEID_NVIDIARAID
 //config:###	bool "nvidia raid"
 //config:###	default y
 //config:###	depends on VOLUMEID
-//config:###	help
-//config:###	  TODO
-//config:
 
 #include "volume_id_internal.h"
 
diff -urpN busybox-1.26.2/util-linux/volume_id/unused_promise_raid.c busybox-1.27.0/util-linux/volume_id/unused_promise_raid.c
--- busybox-1.26.2/util-linux/volume_id/unused_promise_raid.c	2016-09-27 18:53:50.000000000 +0200
+++ busybox-1.27.0/util-linux/volume_id/unused_promise_raid.c	2017-01-10 16:31:40.000000000 +0100
@@ -20,14 +20,10 @@
 
 //kbuild:### lib-$(CONFIG_FEATURE_VOLUMEID_PROMISERAID) += promise_raid.o
 
-//config:
 //config:### config FEATURE_VOLUMEID_PROMISERAID
 //config:###	bool "promise raid"
 //config:###	default y
 //config:###	depends on VOLUMEID
-//config:###	help
-//config:###	  TODO
-//config:
 
 #include "volume_id_internal.h"
 
diff -urpN busybox-1.26.2/util-linux/volume_id/unused_silicon_raid.c busybox-1.27.0/util-linux/volume_id/unused_silicon_raid.c
--- busybox-1.26.2/util-linux/volume_id/unused_silicon_raid.c	2016-09-27 18:53:50.000000000 +0200
+++ busybox-1.27.0/util-linux/volume_id/unused_silicon_raid.c	2017-01-10 16:31:40.000000000 +0100
@@ -20,14 +20,10 @@
 
 //kbuild:### lib-$(CONFIG_FEATURE_VOLUMEID_SILICONRAID) += silicon_raid.o
 
-//config:
 //config:### config FEATURE_VOLUMEID_SILICONRAID
 //config:###	bool "silicon raid"
 //config:###	default y
 //config:###	depends on VOLUMEID
-//config:###	help
-//config:###	  TODO
-//config:
 
 #include "volume_id_internal.h"
 
diff -urpN busybox-1.26.2/util-linux/volume_id/unused_ufs.c busybox-1.27.0/util-linux/volume_id/unused_ufs.c
--- busybox-1.26.2/util-linux/volume_id/unused_ufs.c	2016-09-27 18:53:50.000000000 +0200
+++ busybox-1.27.0/util-linux/volume_id/unused_ufs.c	2017-01-10 16:31:40.000000000 +0100
@@ -20,14 +20,10 @@
 
 //kbuild:### lib-$(CONFIG_FEATURE_VOLUMEID_UFS) += ufs.o
 
-//config:
 //config:### config FEATURE_VOLUMEID_UFS
 //config:###	bool "ufs filesystem"
 //config:###	default y
 //config:###	depends on VOLUMEID
-//config:###	help
-//config:###	  TODO
-//config:
 
 #include "volume_id_internal.h"
 
diff -urpN busybox-1.26.2/util-linux/volume_id/unused_via_raid.c busybox-1.27.0/util-linux/volume_id/unused_via_raid.c
--- busybox-1.26.2/util-linux/volume_id/unused_via_raid.c	2016-09-27 18:53:50.000000000 +0200
+++ busybox-1.27.0/util-linux/volume_id/unused_via_raid.c	2017-01-10 16:31:40.000000000 +0100
@@ -20,14 +20,10 @@
 
 //kbuild:### lib-$(CONFIG_FEATURE_VOLUMEID_VIARAID) += via_raid.o
 
-//config:
 //config:### config FEATURE_VOLUMEID_VIARAID
 //config:###	bool "via raid"
 //config:###	default y
 //config:###	depends on VOLUMEID
-//config:###	help
-//config:###	  TODO
-//config:
 
 #include "volume_id_internal.h"
 
diff -urpN busybox-1.26.2/util-linux/volume_id/xfs.c busybox-1.27.0/util-linux/volume_id/xfs.c
--- busybox-1.26.2/util-linux/volume_id/xfs.c	2016-09-27 18:53:50.000000000 +0200
+++ busybox-1.27.0/util-linux/volume_id/xfs.c	2017-01-10 16:31:40.000000000 +0100
@@ -20,14 +20,10 @@
 
 //kbuild:lib-$(CONFIG_FEATURE_VOLUMEID_XFS) += xfs.o
 
-//config:
 //config:config FEATURE_VOLUMEID_XFS
 //config:	bool "xfs filesystem"
 //config:	default y
 //config:	depends on VOLUMEID
-//config:	help
-//config:	  TODO
-//config:
 
 #include "volume_id_internal.h"
 
diff -urpN busybox-1.26.2/util-linux/wall.c busybox-1.27.0/util-linux/wall.c
--- busybox-1.26.2/util-linux/wall.c	1970-01-01 01:00:00.000000000 +0100
+++ busybox-1.27.0/util-linux/wall.c	2017-07-01 22:51:12.000000000 +0200
@@ -0,0 +1,63 @@
+/* vi: set sw=4 ts=4: */
+/*
+ * wall - write a message to all logged-in users
+ * Copyright (c) 2009 Bernhard Reutner-Fischer
+ *
+ * Licensed under GPLv2 or later, see file LICENSE in this source tree.
+ */
+
+//config:config WALL
+//config:	bool "wall"
+//config:	default y
+//config:	depends on FEATURE_UTMP
+//config:	help
+//config:	  Write a message to all users that are logged in.
+
+/* Needs to be run by root or be suid root - needs to write to /dev/TTY: */
+//applet:IF_WALL(APPLET(wall, BB_DIR_USR_BIN, BB_SUID_REQUIRE))
+
+//kbuild:lib-$(CONFIG_WALL) += wall.o
+
+//usage:#define wall_trivial_usage
+//usage:	"[FILE]"
+//usage:#define wall_full_usage "\n\n"
+//usage:	"Write content of FILE or stdin to all logged-in users"
+//usage:
+//usage:#define wall_sample_usage
+//usage:	"echo foo | wall\n"
+//usage:	"wall ./mymessage"
+
+#include "libbb.h"
+
+int wall_main(int argc, char **argv) MAIN_EXTERNALLY_VISIBLE;
+int wall_main(int argc UNUSED_PARAM, char **argv)
+{
+	struct utmpx *ut;
+	char *msg;
+	int fd;
+
+	fd = STDIN_FILENO;
+	if (argv[1]) {
+		/* The applet is setuid.
+		 * Access to the file must be under user's uid/gid.
+		 */
+		fd = xopen_as_uid_gid(argv[1], O_RDONLY, getuid(), getgid());
+	}
+	msg = xmalloc_read(fd, NULL);
+	if (ENABLE_FEATURE_CLEAN_UP && argv[1])
+		close(fd);
+	setutxent();
+	while ((ut = getutxent()) != NULL) {
+		char *line;
+		if (ut->ut_type != USER_PROCESS)
+			continue;
+		line = concat_path_file("/dev", ut->ut_line);
+		xopen_xwrite_close(line, msg);
+		free(line);
+	}
+	if (ENABLE_FEATURE_CLEAN_UP) {
+		endutxent();
+		free(msg);
+	}
+	return EXIT_SUCCESS;
+}

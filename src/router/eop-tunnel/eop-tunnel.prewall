#!/bin/sh
nv=/usr/sbin/nvram
/bin/mkdir -p /tmp/oet/pid
cd /tmp/oet/pid
rmmod eoip >/dev/null 2>&1
tunnels=$($nv get oet_tunnels)
WAN_IF=$(get_wanface)
IP=ip
IP6=echo
WGDELRT=/tmp/wgdelrt
ipv6_en=$($nv get ipv6_enable)
if [[ $ipv6_en -eq 1 ]]; then 
    IP6="ip -6"
fi
GATEWAY="$($nv get wan_gateway)"
GATEWAY6="$($IP6 route show table main | awk '/default via/ { print $3;exit; }')"
[[ $($nv get wan_proto) = "disabled" ]] && { GATEWAY="$($nv get lan_gateway)"; logger -p user.info "WireGuard no wan_gateway detected, assuming WAP"; }
# set failstate, 0 is default meaning tunnel can start (at (re)boot failstate of all tunnels is set to 0, sysinit.c:3386), 1 is failed, set to 2 if this is the one to start
if [[ $tunnels -gt 0 ]]; then
	fset=0
	for i in $(seq 1 $tunnels); do
		[[ -z $($nv get oet${i}_failgrp) ]] && $nv set oet${i}_failgrp=0 #add missing default delete in future version
		if [[ $($nv get oet${i}_en) -eq 1 && $($nv get oet${i}_failgrp) -eq 1 && $($nv get oet${i}_failstate) -eq 2  ]]; then
			fset=$((fset+1))
			logger -p user.info "WireGuard tunnel oet${i} is the fail over group start tunnel"
		fi
	done
	for i in $(seq 1 $tunnels); do
		if [[ $($nv get oet${i}_en) -ne 1 ]]; then #non enabled tunnels reset
			$nv set oet${i}_failstate=0
		else #enabled tunnels
			if [[ $($nv get oet${i}_failgrp) -eq 1 ]]; then
				#search for first tunnel with failgroup enabled which is not failed and set to 2
				if [[ $($nv get oet${i}_failstate) -eq 0 ]]; then #non failed tunnels
					if [[ $fset -eq 0 ]]; then
						fset=$((fset+1))
						#set this tunnel to start the fail over group
						logger -p user.info "WireGuard tunnel oet${i} is the fail over group start tunnel"
						$nv set oet${i}_failstate=2
					else  #number of failgroup running or standby
						fset=$((fset+1))
						#$nv set oet${i}_failstate=0
					fi
				fi
			else #enabled tunnels not part of fail group reset
				$nv set oet${i}_failstate=0
			fi
		fi
	done
	logger -p user.info "WireGuard number of non failed tunnels in fail set: $fset"
fi
#reset dns
if [[ -e /tmp/resolv.dnsmasq_oet ]]; then
	logger -p user.info "WireGuard DNS reset"
	cp -f /tmp/resolv.dnsmasq_oet /tmp/resolv.dnsmasq
	rm -f /tmp/resolv.dnsmasq_oet
fi
$nv unset wg_get_dns
#remove route to endpoint
if [[ -f "$WGDELRT" ]]; then
	(while read route; do $route >/dev/null 2>&1; done < $WGDELRT)
	rm $WGDELRT
fi
for i in $(seq 1 $tunnels); do
	if [[ -e "${i}.pid" ]]; then
		{
		emf del iface $(getbridge oet${i}) oet${i}
		brctl delif $(getbridge oet${i}) oet${i}
		$IP tunnel del oet${i}
		$IP link del oet${i}
		rm -f ${i}.pid
		} >/dev/null 2>&1
		TID=$((20+$i))
		while $IP rule delete from 0/0 to 0/0 table $TID >/dev/null 2>&1; do true; done
		$IP route flush table $TID
		if [[ $ipv6_en -eq 1 ]]; then 
			while $IP6 rule delete from ::/0 to ::/0 table $TID >/dev/null 2>&1; do true; done
			$IP6 route show table all | grep "table $TID" | while read v6r; do
				$IP6 route del ${v6r%error*} >/dev/null 2>&1
			done
		fi
		logger -p user.info "Flush delete PBR interface oet${i}, table : $TID"
		ps | grep "[w]ireguard-fwatchdog" | awk '{print $1}' | xargs kill -9 >/dev/null 2>&1 #use [w] to exclude the ps line
		[[ ! -z "$($nv get oet${i}_rtdownscript | sed '/^[[:blank:]]*#/d')" ]] && { sh $($nv get oet${i}_rtdownscript) & }
		# remove destination routes
		WGDPBRIP="/tmp/wgdpbrip_oet${i}"
		if [[ -f "$WGDPBRIP" ]]; then
			(while read dpbrip; do $IP route del $dpbrip >/dev/null 2>&1; done < $WGDPBRIP)
			rm $WGDPBRIP >/dev/null 2>&1
		fi
		WGDNSRT="/tmp/wgdnsrt_oet${i}"
		if [[ -f "$WGDNSRT" ]]; then
			(while read dnsrt; do $dnsrt >/dev/null 2>&1; done < $WGDNSRT)
			rm $WGDNSRT
		fi
		$IP route flush cache
		if [[ $ipv6_en -eq 1 ]]; then 
		    $IP6 route flush cache >/dev/null 2>&1
		fi
	fi
done
for i in $(seq 1 $tunnels); do
	if [[ $($nv get oet${i}_en) -eq 1 ]]; then
		if [[ $($nv get oet${i}_proto) -eq 2 ]] && [[ $($nv get oet${i}_failgrp) -ne 1 || $($nv get oet${i}_failstate) -eq 2 ]]; then
			{
			mkdir -p /tmp/wireguard
			insmod ipv6
			insmod udp_tunnel
			insmod ip6_udp_tunnel
			insmod ip_tunnel
			insmod wireguard
			} >/dev/null 2>&1
			logger -p user.info "Enable WireGuard interface oet${i} on port $($nv get oet${i}_port)"
			if [ -z "$($nv get oet${i}_mtu)" ]; then
				overhead=60
				if [ "$($nv get ipv6_enable)" == "1" ]; then
					overhead=80
				fi
				if [ "$($nv get wan_proto)" != "disabled" ]; then
					$nv set oet${i}_mtu=$(($($nv get wan_mtu) - $overhead))
				else
					$nv set oet${i}_mtu=$((1500 - $overhead))
				fi
			fi
			$IP link add oet${i} type wireguard
			wg set oet${i} listen-port $($nv get oet${i}_port)
			$nv get oet${i}_private > /tmp/wireguard/oet${i}_private
			wg set oet${i} private-key /tmp/wireguard/oet${i}_private
			$nv set oet${i}_public="$($nv get oet${i}_private|wg pubkey)"
			if [[ ! -z "$($nv get oet${i}_fwmark)" ]]; then
				wg set oet${i} fwmark $($nv get oet${i}_fwmark)
			fi
			peers=$(($($nv get oet${i}_peers) - 1))
			$nv set oet${i}_bridged=0
			$nv set oet${i}_nat=0
			for p in $(seq 0 $peers); do
				PSKARG1=
				PSKARG2=
				ENDPOINTARG1=
				ENDPOINTARG2=
				ipv4=
				ipv6=
				if [ $($nv get oet${i}_usepsk${p}) -eq 1 ]; then
					$nv get oet${i}_psk${p} > /tmp/wireguard/oet${i}_psk${p}
					PSKARG1="preshared-key" 
					PSKARG2="/tmp/wireguard/oet${i}_psk${p}"
				fi
				if [ $($nv get oet${i}_endpoint${p}) -eq 1 ]; then
					logger -p user.info "Establishing WireGuard tunnel with peer endpoint $($nv get oet${i}_rem${p}):$($nv get oet${i}_peerport${p})"
					ENDPOINTARG1="endpoint"
					endp="$($nv get oet${i}_rem${p} | sed 's/\[//g;s/\]//g')"
					ENDPOINTARG2="$endp:$($nv get oet${i}_peerport${p})"
					if [[ "$endp" != "${endp#*[0-9].[0-9]}" ]]; then
						ipv4=$endp
						logger -p user.info "WireGuard experimental endpoint routing for oet${i} to endpoint $endp:$($nv get oet${i}_peerport${p}) is IPv4: [$endp]"
					elif [[ $ipv6_en -eq 1 && "$endp" != "${endp#*:[0-9a-fA-F]}" ]]; then
						ipv6=$endp
						logger -p user.info "WireGuard experimental endpoint routing for oet${i} to endpoint $endp:$($nv get oet${i}_peerport${p}) is IPv6: [$endp]"
					else
						nsl=$(nslookup "$endp")
						ipv4=$(echo "$nsl" | awk '/^Name:/,0 {if (/^Addr[^:]*: [0-9]{1,3}\./) print $3}' | head -n 1)
						[[ $ipv6_en -eq 1 ]] && { ipv6=$(echo "$nsl" | awk '/^Name:/,0 {if (/^Addr[^:]*: [23]...:/) print $3}' | head -n 1); }
						logger -p user.info "WireGuard experimental endpoint routing for oet${i} to endpoint $endp:$($nv get oet${i}_peerport${p}) is Domain Name resolving to IPv4:[$ipv4]; IPv6:[$ipv6]"
					fi
					if [[ ! -z $ipv4 ]]; then 
						$IP route add $ipv4 via $GATEWAY dev $WAN_IF >/dev/null 2>&1
						echo "$IP route del $ipv4 via $GATEWAY dev $WAN_IF " >> $WGDELRT
					fi
					if [[ ! -z $ipv6 ]]; then 
						#IPv6 route needs via nexthop
						$IP6 route add $ipv6 via $GATEWAY6 dev $WAN_IF >/dev/null 2>&1
						echo "$IP6 route del $ipv6 via $GATEWAY6 dev $WAN_IF " >> $WGDELRT
					fi
				fi
				wg set oet${i} peer $($nv get oet${i}_peerkey${p}) persistent-keepalive $($nv get oet${i}_ka${p}) $PSKARG1 $PSKARG2 allowed-ips "$($nv get oet${i}_aip${p})" $ENDPOINTARG1 $ENDPOINTARG2 &
			done
			ifconfig oet${i} promisc up >/dev/null 2>&1
			$IP link set mtu $($nv get oet${i}_mtu) up dev oet${i} >/dev/null 2>&1
			echo enable > ${i}.pid
			# alternative input with ipaddrmask
			if [[ ! -z "$($nv get oet${i}_ipaddrmask)" ]]
			then
				for ipaddrmask in $($nv get oet${i}_ipaddrmask | sed "s/,/ /g") ; do
					# set ip address and netmask for backwards compatibility only for IPv4
					case $ipaddrmask in
					  *.*) #IPv4
						IPADDR=${ipaddrmask%%/*}
						mask="${ipaddrmask#*/}"
						# error handling if netmask is not specified
						if [[ $mask -lt 33 ]] ;then
							mask="${ipaddrmask#*/}"
						else
							logger -p user.err "ERROR: WireGuard no valid tunnel address for oet${i}: $ipaddrmask, please correct, using /24"
							mask=24
						fi
						$IP addr add $IPADDR/$mask dev oet${i} >/dev/null 2>&1
						logger -p user.info "WireGuard $IPADDR/$mask added to oet${i}"
						set -- $(( 5 - ($mask / 8) )) 255 255 255 255 $(( (255 << (8 - ($mask % 8))) & 255 )) 0 0 0
						[ $1 -gt 1 ] && shift $1 || shift
						NETMASK=${1-0}.${2-0}.${3-0}.${4-0}
						$nv set oet${i}_ipaddr=$IPADDR
						$nv set oet${i}_netmask=$NETMASK
						;;
					  *:*) #IPv6
						$IP addr add $ipaddrmask dev oet${i} >/dev/null 2>&1
						logger -p user.info "WireGuard $ipaddrmask added to oet${i}"
						;;
					  *)
						logger -p user.err "ERROR: WireGuard no valid IPv4 or IPV6 tunnel address for oet${i}: $ipaddrmask, please correct"
						;;
					esac
				done
			else
				logger -p user.err "ERROR: WireGuard no valid IPv4 or IPV6 tunnel address for oet${i}: $ipaddrmask, please correct, trying the old way"
				$IP addr add $($nv get oet${i}_ipaddr)/$(getmask $($nv get oet${i}_netmask)) dev oet${i} >/dev/null 2>&1
			fi
		fi
		if [ $($nv get oet${i}_proto) -eq 1 ]; then
			insmod gre
			insmod eoip
			logger -p user.info "Enable Mikrotik Tunnel interface oet${i} on address $($nv get oet${i}_local) with peer $($nv get oet${i}_rem)"
			eoip add tunnel-id $($nv get oet${i}_id) name oet${i} remote $($nv get oet${i}_rem) local $($nv get oet${i}_local)
			if [ $($nv get oet${i}_bridged) -eq 1 ]; then
				ifconfig oet${i} up >/dev/null 2>&1
				ifconfig oet${i} promisc >/dev/null 2>&1
				brctl addif $(getbridge oet${i}) oet${i} >/dev/null 2>&1
				setportprio $(getbridge oet${i}) oet${i}
				emf add iface $(getbridge oet${i}) oet${i} >/dev/null 2>&1
			else
				ifconfig oet${i} promisc up >/dev/null 2>&1
				$IP addr add $($nv get oet${i}_ipaddr)/$(getmask $($nv get oet${i}_netmask)) dev oet${i} >/dev/null 2>&1
			fi
			echo enable > ${i}.pid
		fi
		if [ $($nv get oet${i}_proto) -eq 0 ]; then
			insmod etherip
			if [ $($nv get oet${i}_local) == "0.0.0.0" ]; then
				logger -p user.info "Enable RFC 3378 EtherIP Tunnel interface oet${i} with peer $($nv get oet${i}_rem)"
				$IP tunnel add oet${i} mode etherip remote $($nv get oet${i}_rem) local any
			else
				logger -p user.info "Enable RFC 3378 EtherIP Tunnel interface oet${i} on address $($nv get oet${i}_local) with peer $($nv get oet${i}_rem)"
				$IP tunnel add oet${i} mode etherip remote $($nv get oet${i}_rem) local $($nv get oet${i}_local)
			fi
			if [ $($nv get oet${i}_bridged) -eq 1 ]; then
				$IP link set dev oet${i} up
				ifconfig oet${i} up >/dev/null 2>&1
				ifconfig oet${i} promisc >/dev/null 2>&1
				brctl addif $(getbridge oet${i}) oet${i} >/dev/null 2>&1
				setportprio $(getbridge oet${i}) oet${i}
				emf add iface $(getbridge oet${i}) oet${i} >/dev/null 2>&1
			else
				$IP link set dev oet${i} up
				ifconfig oet${i} promisc >/dev/null 2>&1
				$IP addr add $($nv get oet${i}_ipaddr)/$(getmask $($nv get oet${i}_netmask)) dev oet${i} >/dev/null 2>&1
    			fi
			echo enable > ${i}.pid
		fi
	fi
done
service set_routes start
# start route setting only if active tunnels
for i in $(seq 1 $tunnels); do
	if [[ $($nv get oet${i}_en) -eq 1 ]]; then
		/usr/bin/eop-tunnel-raip.sh $fset &
		break
	fi
done


.TH "Maintain a registry of MIB subtrees, together with related information regarding mibmodule, sessions, etc" 3 "24 Nov 2006" "Version 5.4" "net-snmp" \" -*- nroff -*-
.ad l
.nh
.SH NAME
Maintain a registry of MIB subtrees, together with related information regarding mibmodule, sessions, etc \- 
.SS "Data Structures"

.in +1c
.ti -1c
.RI "struct \fBlookup_cache_s\fP"
.br
.ti -1c
.RI "struct \fBlookup_cache_context_s\fP"
.br
.in -1c
.SS "Defines"

.in +1c
.ti -1c
.RI "#define \fBIN_SNMP_VARS_C\fP"
.br
.ti -1c
.RI "#define \fBSUBTREE_DEFAULT_CACHE_SIZE\fP   8"
.br
.ti -1c
.RI "#define \fBSUBTREE_MAX_CACHE_SIZE\fP   32"
.br
.in -1c
.SS "Typedefs"

.in +1c
.ti -1c
.RI "typedef \fBlookup_cache_s\fP \fBlookup_cache\fP"
.br
.ti -1c
.RI "typedef \fBlookup_cache_context_s\fP \fBlookup_cache_context\fP"
.br
.in -1c
.SS "Functions"

.in +1c
.ti -1c
.RI "NETSNMP_STATIC_INLINE void \fBinvalidate_lookup_cache\fP (const char *context)"
.br
.ti -1c
.RI "void \fBnetsnmp_set_lookup_cache_size\fP (int newsize)"
.br
.RI "\fIset the lookup cache size for optimized agent registration performance. \fP"
.ti -1c
.RI "int \fBnetsnmp_get_lookup_cache_size\fP (void)"
.br
.RI "\fIretrieves the current value of the lookup cache size \fP"
.ti -1c
.RI "void \fBnetsnmp_subtree_free\fP (\fBnetsnmp_subtree\fP *a)"
.br
.ti -1c
.RI "\fBnetsnmp_subtree\fP * \fBnetsnmp_subtree_deepcopy\fP (\fBnetsnmp_subtree\fP *a)"
.br
.ti -1c
.RI "\fBsubtree_context_cache\fP * \fBget_top_context_cache\fP (void)"
.br
.ti -1c
.RI "\fBnetsnmp_subtree\fP * \fBnetsnmp_subtree_find_first\fP (const char *context_name)"
.br
.ti -1c
.RI "\fBnetsnmp_subtree\fP * \fBadd_subtree\fP (\fBnetsnmp_subtree\fP *new_tree, const char *context_name)"
.br
.ti -1c
.RI "\fBnetsnmp_subtree\fP * \fBnetsnmp_subtree_replace_first\fP (\fBnetsnmp_subtree\fP *new_tree, const char *context_name)"
.br
.ti -1c
.RI "NETSNMP_INLINE void \fBnetsnmp_subtree_change_next\fP (\fBnetsnmp_subtree\fP *ptr, \fBnetsnmp_subtree\fP *thenext)"
.br
.ti -1c
.RI "NETSNMP_INLINE void \fBnetsnmp_subtree_change_prev\fP (\fBnetsnmp_subtree\fP *ptr, \fBnetsnmp_subtree\fP *theprev)"
.br
.ti -1c
.RI "int \fBnetsnmp_subtree_compare\fP (const \fBnetsnmp_subtree\fP *ap, const \fBnetsnmp_subtree\fP *bp)"
.br
.ti -1c
.RI "void \fBnetsnmp_subtree_join\fP (\fBnetsnmp_subtree\fP *root)"
.br
.ti -1c
.RI "\fBnetsnmp_subtree\fP * \fBnetsnmp_subtree_split\fP (\fBnetsnmp_subtree\fP *current, oid name[], int name_len)"
.br
.ti -1c
.RI "int \fBnetsnmp_subtree_load\fP (\fBnetsnmp_subtree\fP *new_sub, const char *context_name)"
.br
.ti -1c
.RI "int \fBnetsnmp_register_mib\fP (const char *moduleName, struct \fBvariable\fP *var, size_t varsize, size_t numvars, oid *mibloc, size_t mibloclen, int priority, int range_subid, oid range_ubound, \fBnetsnmp_session\fP *ss, const char *context, int timeout, int flags, \fBnetsnmp_handler_registration\fP *reginfo, int perform_callback)"
.br
.ti -1c
.RI "void \fBregister_mib_reattach\fP (void)"
.br
.ti -1c
.RI "void \fBregister_mib_detach\fP (void)"
.br
.ti -1c
.RI "int \fBregister_mib_context\fP (const char *moduleName, struct \fBvariable\fP *var, size_t varsize, size_t numvars, oid *mibloc, size_t mibloclen, int priority, int range_subid, oid range_ubound, \fBnetsnmp_session\fP *ss, const char *context, int timeout, int flags)"
.br
.ti -1c
.RI "int \fBregister_mib_range\fP (const char *moduleName, struct \fBvariable\fP *var, size_t varsize, size_t numvars, oid *mibloc, size_t mibloclen, int priority, int range_subid, oid range_ubound, \fBnetsnmp_session\fP *ss)"
.br
.ti -1c
.RI "int \fBregister_mib_priority\fP (const char *moduleName, struct \fBvariable\fP *var, size_t varsize, size_t numvars, oid *mibloc, size_t mibloclen, int priority)"
.br
.ti -1c
.RI "int \fBregister_mib\fP (const char *moduleName, struct \fBvariable\fP *var, size_t varsize, size_t numvars, oid *mibloc, size_t mibloclen)"
.br
.ti -1c
.RI "void \fBnetsnmp_subtree_unload\fP (\fBnetsnmp_subtree\fP *sub, \fBnetsnmp_subtree\fP *prev, const char *context)"
.br
.ti -1c
.RI "int \fBunregister_mib_context\fP (oid *name, size_t len, int priority, int range_subid, oid range_ubound, const char *context)"
.br
.RI "\fIUnregisters an OID that has an associated context name value. \fP"
.ti -1c
.RI "int \fBnetsnmp_unregister_mib_table_row\fP (oid *name, size_t len, int priority, int var_subid, oid range_ubound, const char *context)"
.br
.ti -1c
.RI "int \fBunregister_mib_range\fP (oid *name, size_t len, int priority, int range_subid, oid range_ubound)"
.br
.ti -1c
.RI "int \fBunregister_mib_priority\fP (oid *name, size_t len, int priority)"
.br
.ti -1c
.RI "int \fBunregister_mib\fP (oid *name, size_t len)"
.br
.ti -1c
.RI "void \fBunregister_mibs_by_session\fP (\fBnetsnmp_session\fP *ss)"
.br
.ti -1c
.RI "int \fBin_a_view\fP (oid *name, size_t *namelen, \fBnetsnmp_pdu\fP *pdu, int type)"
.br
.ti -1c
.RI "int \fBcheck_access\fP (\fBnetsnmp_pdu\fP *pdu)"
.br
.ti -1c
.RI "int \fBnetsnmp_acm_check_subtree\fP (\fBnetsnmp_pdu\fP *pdu, oid *name, size_t namelen)"
.br
.RI "\fIchecks to see if everything within a given subtree is either: in view, not in view, or possibly both. \fP"
.ti -1c
.RI "NETSNMP_STATIC_INLINE \fBlookup_cache_context\fP * \fBget_context_lookup_cache\fP (const char *context)"
.br
.ti -1c
.RI "NETSNMP_STATIC_INLINE void \fBlookup_cache_add\fP (const char *context, \fBnetsnmp_subtree\fP *next, \fBnetsnmp_subtree\fP *previous)"
.br
.ti -1c
.RI "NETSNMP_STATIC_INLINE void \fBlookup_cache_replace\fP (\fBlookup_cache\fP *ptr, \fBnetsnmp_subtree\fP *next, \fBnetsnmp_subtree\fP *previous)"
.br
.ti -1c
.RI "NETSNMP_STATIC_INLINE \fBlookup_cache\fP * \fBlookup_cache_find\fP (const char *context, oid *name, size_t name_len, int *retcmp)"
.br
.ti -1c
.RI "\fBnetsnmp_subtree\fP * \fBnetsnmp_subtree_find_prev\fP (oid *name, size_t len, \fBnetsnmp_subtree\fP *subtree, const char *context_name)"
.br
.ti -1c
.RI "\fBnetsnmp_subtree\fP * \fBnetsnmp_subtree_find_next\fP (oid *name, size_t len, \fBnetsnmp_subtree\fP *subtree, const char *context_name)"
.br
.ti -1c
.RI "\fBnetsnmp_subtree\fP * \fBnetsnmp_subtree_find\fP (oid *name, size_t len, \fBnetsnmp_subtree\fP *subtree, const char *context_name)"
.br
.ti -1c
.RI "\fBnetsnmp_session\fP * \fBget_session_for_oid\fP (oid *name, size_t len, const char *context_name)"
.br
.ti -1c
.RI "void \fBsetup_tree\fP (void)"
.br
.ti -1c
.RI "int \fBremove_tree_entry\fP (oid *name, size_t len)"
.br
.ti -1c
.RI "void \fBshutdown_tree\fP (void)"
.br
.ti -1c
.RI "void \fBclear_subtree\fP (\fBnetsnmp_subtree\fP *sub)"
.br
.ti -1c
.RI "void \fBclear_lookup_cache\fP (void)"
.br
.ti -1c
.RI "void \fBclear_context\fP (void)"
.br
.ti -1c
.RI "void \fBdump_idx_registry\fP (void)"
.br
.ti -1c
.RI "void \fBdump_registry\fP (void)"
.br
.ti -1c
.RI "RETSIGTYPE \fBagent_SIGCHLD_handler\fP (int sig)"
.br
.ti -1c
.RI "int \fBregister_signal\fP (int sig, void(*func)(int))"
.br
.ti -1c
.RI "int \fBunregister_signal\fP (int sig)"
.br
.in -1c
.SS "Variables"

.in +1c
.ti -1c
.RI "\fBsubtree_context_cache\fP * \fBcontext_subtrees\fP = NULL"
.br
.ti -1c
.RI "int \fBlookup_cache_size\fP = 0"
.br
.ti -1c
.RI "int \fBexternal_signal_scheduled\fP [NUM_EXTERNAL_SIGS]"
.br
.ti -1c
.RI "void(* \fBexternal_signal_handler\fP [NUM_EXTERNAL_SIGS])(int)"
.br
.in -1c
.SH "Function Documentation"
.PP 
.SS "int netsnmp_acm_check_subtree (\fBnetsnmp_pdu\fP * pdu, oid * name, size_t namelen)"
.PP
checks to see if everything within a given subtree is either: in view, not in view, or possibly both. 
.PP
If the entire subtree is not-in-view we can use this information to skip calling the sub-handlers entirely. 
.PP
\fBReturns:\fP
.RS 4
0 if entire subtree is accessible, 5 if not and 7 if portions are both. 1 on error (illegal pdu version). 
.RE
.PP

.PP
Definition at line 1297 of file agent_registry.c.
.PP
References view_parameters::check_subtree, view_parameters::errorcode, snmp_pdu::flags, view_parameters::name, view_parameters::namelen, view_parameters::pdu, snmp_call_callbacks(), and snmp_pdu::version.
.PP
Referenced by netsnmp_add_varbind_to_cache().
.SS "int netsnmp_get_lookup_cache_size (void)"
.PP
retrieves the current value of the lookup cache size 
.PP
\fBReturns:\fP
.RS 4
the current lookup cache size 
.RE
.PP

.PP
Definition at line 1370 of file agent_registry.c.
.PP
Referenced by netsnmp_register_mib(), and unregister_mib_context().
.SS "void netsnmp_set_lookup_cache_size (int newsize)"
.PP
set the lookup cache size for optimized agent registration performance. 
.PP
\fBParameters:\fP
.RS 4
\fInewsize\fP set to the maximum size of a cache for a given context. Set to 0 to completely disable caching, or to -1 to set to the default cache size (8), or to a number of your chosing. The rough guide is that it should be equal to the maximum number of simultanious managers you expect to talk to the agent (M) times 80% (or so, he says randomly) the average number (N) of varbinds you expect to receive in a given request for a manager. ie, M times N. Bigger does NOT necessarily mean better. Certainly 16 should be an upper limit. 32 is the hard coded limit. 
.RE
.PP

.PP
Definition at line 1357 of file agent_registry.c.
.PP
References SUBTREE_DEFAULT_CACHE_SIZE, and SUBTREE_MAX_CACHE_SIZE.
.PP
Referenced by init_master_agent(), netsnmp_register_mib(), and unregister_mib_context().
.SS "int unregister_mib_context (oid * name, size_t len, int priority, int range_subid, oid range_ubound, const char * context)"
.PP
Unregisters an OID that has an associated context name value. 
.PP
Typically used when a module has multiple contexts defined. The parameters priority, range_subid, and range_ubound should be used in conjunction with agentx, see RFC 2741, otherwise these values should always be 0.
.PP
\fBParameters:\fP
.RS 4
\fIname\fP the specific OID to unregister if it conatins the associated context.
.br
\fIlen\fP the length of the OID, use OID_LENGTH macro.
.br
\fIpriority\fP a value between 1 and 255, used to achieve a desired configuration when different sessions register identical or overlapping regions. Subagents with no particular knowledge of priority should register with the default value of 127.
.br
\fIrange_subid\fP permits specifying a range in place of one of a subtree sub-identifiers. When this value is zero, no range is being specified.
.br
\fIrange_ubound\fP the upper bound of a sub-identifier's range. This field is present only if range_subid is not 0.
.br
\fIcontext\fP a context name that has been created
.RE
.PP
\fBReturns:\fP
.RS 4
.RE
.PP

.PP
Definition at line 963 of file agent_registry.c.
.PP
References netsnmp_subtree_s::children, netsnmp_get_lookup_cache_size(), netsnmp_oid_equals(), netsnmp_set_lookup_cache_size(), netsnmp_subtree_find(), netsnmp_subtree_find_first(), and NULL.
.PP
Referenced by netsnmp_register_mib(), netsnmp_unregister_handler(), remove_tree_entry(), and unregister_mib_range().

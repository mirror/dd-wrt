<html><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8"><title>Generic Functions</title><link rel="stylesheet" href="docbook.css" type="text/css"><meta name="generator" content="DocBook XSL Stylesheets V1.73.2"><meta name="keywords" content="Intellon, Atheros, Qualcomm, HomePlug, powerline, communications, INT6000, INT6300, INT6400, AR7400, AR7420"><link rel="start" href="index.html" title="Qualcomm Atheros Open Powerline Toolkit"><link rel="up" href="ch07.html" title="Chapter 7.  Support Function Reference"><link rel="prev" href="ch07s04.html" title="Network Functions"><link rel="next" href="ch07s06.html" title="Message Debug Functions"></head><body bgcolor="white" text="black" link="#0000FF" vlink="#840084" alink="#0000FF"><div class="navheader"><table width="100%" summary="Navigation header"><tr><th colspan="3" align="center">
		Generic Functions
		</th></tr><tr><td width="20%" align="left"><a accesskey="p" href="ch07s04.html">Prev</a> </td><th width="60%" align="center">Chapter 7. 
		Support Function Reference
		</th><td width="20%" align="right"> <a accesskey="n" href="ch07s06.html">Next</a></td></tr></table><hr></div><div class="section" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="support-generic"></a>
		Generic Functions
		</h2></div></div></div><p>
		The functions in this chapter are generic and may have application beyond the Open Powerline Toolkit. In some cases, these functions appear in other Atheros or Open Source software packages. In a few cases, the Toolkit may include complementary or supplementary support functions but only use one or two of them. For example, functions <code class="function">memincr</code> and <code class="function">memdecr</code> are both included but <code class="function">memdecr</code> is not used.
		</p><div class="section" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="support-binout"></a>
			binout
			</h3></div></div></div><div class="funcsynopsis"><table border="0" summary="Function synopsis" cellspacing="0" cellpadding="0"><tr><td><code class="funcdef">void <b class="fsfunc">binout</b> (</code></td><td><code>void const * </code> </td><td><var class="pdparam">memory</var>, </td></tr><tr><td> </td><td><code>size_t </code> </td><td><var class="pdparam">extent</var>, </td></tr><tr><td> </td><td><code>char </code> </td><td><var class="pdparam">c</var>, </td></tr><tr><td> </td><td><code>char </code> </td><td><var class="pdparam">e</var>, </td></tr><tr><td> </td><td><code>FILE * </code> </td><td><var class="pdparam">fp</var><code class="funcdef">)</code>;</td></tr></table></div><p>
			Print a <code class="varname">memory</code> region as a series of binary octets separated by character <code class="varname">c</code> and terminated by character <code class="varname">e</code>. Normally, character <code class="constant">c</code> will be <code class="constant">BIN_EXTENDER</code>, defined in file <a class="ulink" href="number.h.html" target="_top">number.h</a>, but it could be any character value. Normally, character <code class="varname">e</code> will be a space or newline, but it could be any character value. A typical use might be to print a <acronym class="acronym">register</acronym> in readable format. For example, specifying <code class="varname">c</code> as <code class="constant">'-'</code>, <code class="varname">e</code> as <code class="constant">';'</code> and <code class="varname">extent</code> as <code class="constant">4</code> would produce output looking something like <code class="computeroutput">"10101010-1111111-00000000-11001100;"</code> where each octet is expressed as a binary integer. The function is declared in <a class="ulink" href="memory.h.html" target="_top">memory.h</a> and defined in <a class="ulink" href="binout.c.html" target="_top">binout.c</a>.
			</p></div><div class="section" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="support-checksum32"></a>
			checksum32
			</h3></div></div></div><div class="funcsynopsis"><table border="0" summary="Function synopsis" cellspacing="0" cellpadding="0"><tr><td><code class="funcdef">unint32_t <b class="fsfunc">checksum32</b> (</code></td><td><code>const uint32_t </code> </td><td><var class="pdparam">memory</var> [], </td></tr><tr><td> </td><td><code>size_t </code> </td><td><var class="pdparam">extent</var>, </td></tr><tr><td> </td><td><code>uint32_t </code> </td><td><var class="pdparam">checksum</var><code class="funcdef">)</code>;</td></tr></table></div><p>
				Return the 32 bit checksum of a <code class="varname">memory</code> region. The checksum is the one's complement of the XOR of all 32 bit words in the region. Argument <code class="varname">extent</code> is the region extent in 32 bit words. Argument <code class="varname">checksum</code> is the reference checksum. The function will return the computed checksum when reference<code class="varname">checksum</code> is <code class="constant">0</code> and will return <code class="constant">0</code> if reference <code class="varname">checksum</code> equals the computed checksum. A typical use is to validate <acronym class="acronym">PIB</acronym> and <acronym class="acronym">NVM</acronym> files or compute new checksums when these files are created or modified. The function is declared in <a class="ulink" href="memory.h.html" target="_top">memory.h</a> and defined in <a class="ulink" href="checksum32.c.html" target="_top">checksum32.c</a>.
				</p><p>
				This function is similar to <a class="link" href="ch07s05.html#support-checksum-32" title="checksum_32">checksum_32</a> but is used exclusively by API functions. It may be deprecated at some point in the future.
				</p></div><div class="section" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="support-checksum-32"></a>
			checksum_32
			</h3></div></div></div><div class="funcsynopsis"><table border="0" summary="Function synopsis" cellspacing="0" cellpadding="0"><tr><td><code class="funcdef">unint32_t <b class="fsfunc">checksum_32</b> (</code></td><td><code>void const * </code> </td><td><var class="pdparam">memory</var>, </td></tr><tr><td> </td><td><code>size_t </code> </td><td><var class="pdparam">extent</var>, </td></tr><tr><td> </td><td><code>uint32_t </code> </td><td><var class="pdparam">checksum</var><code class="funcdef">)</code>;</td></tr></table></div><p>
				Return the 32 bit checksum of a <code class="varname">memory</code> region. The checksum is the one's complement of the XOR of all 32 bit words in the region. The region <code class="varname">extent</code> is specified in bytes but it will be rounded down to the nearest multiple of 4 bytes. Argument <code class="varname">checksum</code> is the reference checksum. The function will return the computed checksum when reference<code class="varname">checksum</code> is <code class="constant">0</code> and will return <code class="constant">0</code> if reference <code class="varname">checksum</code> equals the computed checksum. A typical use is to validate <acronym class="acronym">PIB</acronym> and <acronym class="acronym">NVM</acronym> files or compute new checksums when these files are created or modified. The function is declared in <a class="ulink" href="memory.h.html" target="_top">memory.h</a> and defined in <a class="ulink" href="checksum_32.c.html" target="_top">checksum_32.c</a>.
				</p><p>
				This function is similar to function <a class="link" href="ch07s05.html#support-checksum32" title="checksum32">checksum32</a> however there is no need to cast <code class="varname">memory</code> to <code class="varname">uint32_t</code> and there is no need to round <code class="varname">extent</code> down to a multiple of 4 bytes before calling the function because both operations are performed internally. Also, there is no unecessary endian manipulation of the checksum. It is the prefered method of computing a checksum.
				</p></div><div class="section" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="support-chrout"></a>
			chrout
			</h3></div></div></div><div class="funcsynopsis"><table border="0" summary="Function synopsis" cellspacing="0" cellpadding="0"><tr><td><code class="funcdef">void <b class="fsfunc">chrout</b> (</code></td><td><code>void const * </code> </td><td><var class="pdparam">memory</var>, </td></tr><tr><td> </td><td><code>size_t </code> </td><td><var class="pdparam">extent</var>, </td></tr><tr><td> </td><td><code>char </code> </td><td><var class="pdparam">c</var>, </td></tr><tr><td> </td><td><code>char </code> </td><td><var class="pdparam">e</var>, </td></tr><tr><td> </td><td><code>FILE * </code> </td><td><var class="pdparam">fp</var><code class="funcdef">)</code>;</td></tr></table></div><p>
			Print a <code class="varname">memory</code> region as a string of printable ASCII characters terminated by character <code class="varname">e</code>. Character <code class="varname">c</code> is printed in place of non-printable characters. The string is terminated by character <code class="constant">e</code>. Normally, character <code class="varname">c</code> is <code class="constant">'.'</code> but it could be any character value. Normally, character <code class="varname">e</code> is space or newline but it could be any charcter value. A typical use might be to print a memory region that may (or may not) contain an <acronym class="acronym">HFID</acronym> or other printable text. The function is declared in <a class="ulink" href="memory.h.html" target="_top">memory.h</a> and defined in <a class="ulink" href="chrout.c.html" target="_top">chrout.c</a>.
			</p></div><div class="section" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="support-decout"></a>
			decout
			</h3></div></div></div><div class="funcsynopsis"><table border="0" summary="Function synopsis" cellspacing="0" cellpadding="0"><tr><td><code class="funcdef">void <b class="fsfunc">decout</b> (</code></td><td><code>void const * </code> </td><td><var class="pdparam">memory</var>, </td></tr><tr><td> </td><td><code>size_t </code> </td><td><var class="pdparam">extent</var>, </td></tr><tr><td> </td><td><code>char </code> </td><td><var class="pdparam">c</var>, </td></tr><tr><td> </td><td><code>char </code> </td><td><var class="pdparam">e</var>, </td></tr><tr><td> </td><td><code>FILE * </code> </td><td><var class="pdparam">fp</var><code class="funcdef">)</code>;</td></tr></table></div><p>
			Print a <code class="varname">memory</code> region as a series of decimal octets separated by character <code class="varname">c</code> and terminated by character <code class="varname">e</code>. Normally, character <code class="varname">c</code> will be <code class="constant">DEC_EXTENDER</code>, defined in file <a class="ulink" href="number.h.html" target="_top">number.h</a>, but it could be any character value. Normally, character <code class="varname">e</code> will be a space or newline but it could be any character value.  A typical use might be to print an <acronym class="acronym">IP</acronym> address in readable format. For example, specifying <code class="varname">c</code> as <code class="constant">'.'</code>, character <code class="varname">e</code> as <code class="constant">'/'</code> and <code class="varname">extent</code> as <code class="constant">4</code> would produce output looking something like <code class="computeroutput">"192.168.099.001/"</code> where each octet is expressed as a decimal integer. The function is declared in <a class="ulink" href="memory.h.html" target="_top">memory.h</a> and defined in <a class="ulink" href="decout.c.html" target="_top">decout.c</a>.
			</p></div><div class="section" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="support-endian"></a>
			endian
			</h3></div></div></div><div class="funcsynopsis"><p><code class="funcdef">void <b class="fsfunc">endian</b> (</code>void  * <var class="pdparam">memory</var>, size_t <var class="pdparam">extent</var><code class="funcdef">)</code>;</p></div><p>
			Reverse the byte order of a <code class="varname">memory</code> region. It is a variable extent version of functions like <code class="function">__bswap_16</code>, <code class="function">__bswap_32</code> and <code class="function">__bswap_64</code>. The function is declared in <a class="ulink" href="memory.h.html" target="_top">memory.h</a> and defined in <a class="ulink" href="endian.c.html" target="_top">endian.c</a>.
			</p></div><div class="section" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="support-fdchecksum32"></a>
			fdchecksum32
			</h3></div></div></div><div class="funcsynopsis"><table border="0" summary="Function synopsis" cellspacing="0" cellpadding="0"><tr><td><code class="funcdef">unit32_t <b class="fsfunc">fdchecksum32</b> (</code></td><td><code>int </code> </td><td><var class="pdparam">fd</var>, </td></tr><tr><td> </td><td><code>size_t </code> </td><td><var class="pdparam">extent</var>, </td></tr><tr><td> </td><td><code>unit32_t </code> </td><td><var class="pdparam">checksum</var><code class="funcdef">)</code>;</td></tr></table></div><p>
				Return the 32 bit checksum of a file region starting from the current file position. The checksum is the one's complement of the XOR or of all 32 bit words in the region. Argument <code class="varname">extent</code> must be specified in 32 bit words, not bytes. Argument <code class="varname">checksum</code> is the reference checksum. The function will return the computed checksum when reference<code class="varname">checksum</code> is <code class="constant">0</code> and will return <code class="constant">0</code> if reference <code class="varname">checksum</code> equals the computed checksum. A typical use is to validate <acronym class="acronym">NVM</acronym> files header by header or section by section. The function is declared in <a class="ulink" href="memory.h.html" target="_top">memory.h</a> and defined in <a class="ulink" href="fdchecksum32.c.html" target="_top">fdchecksum32.c</a>.
				</p></div><div class="section" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="support-fdchecksum-32"></a>
			fdchecksum_32
			</h3></div></div></div><div class="funcsynopsis"><table border="0" summary="Function synopsis" cellspacing="0" cellpadding="0"><tr><td><code class="funcdef">unit32_t <b class="fsfunc">fdchecksum_32</b> (</code></td><td><code>int </code> </td><td><var class="pdparam">fd</var>, </td></tr><tr><td> </td><td><code>size_t </code> </td><td><var class="pdparam">extent</var>, </td></tr><tr><td> </td><td><code>unit32_t </code> </td><td><var class="pdparam">checksum</var><code class="funcdef">)</code>;</td></tr></table></div><p>
				Return the 32 bit checksum of a file region starting from the current file position. The checksum is the one's complement of the XOR or of all 32 bit words in the region. Argument <code class="varname">extent</code> is specified in bytes but is rounded down to the nearest multiple of 4 bytes. Argument <code class="varname">checksum</code> is the reference checksum. The function will return the computed checksum when reference<code class="varname">checksum</code> is <code class="constant">0</code> and will return <code class="constant">0</code> if reference <code class="varname">checksum</code> equals the computed checksum. A typical use is to validate <acronym class="acronym">NVM</acronym> files header by header or section by section. The function is declared in <a class="ulink" href="memory.h.html" target="_top">memory.h</a> and defined in <a class="ulink" href="fdchecksum_32.c.html" target="_top">fdchecksum_32.c</a>.
				</p><p>
				This function is similar to function <a class="link" href="ch07s05.html#support-fdchecksum32" title="fdchecksum32">fdchecksum32</a> but there is no need to round <code class="varname">extent</code> down to the nearest multiple of 4 bytes before calling the function because that is done internally. Also, there is no unecessary endian manuipulation of the checksum.
				</p></div><div class="section" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="support-filepar"></a>
			filepart
			</h3></div></div></div><div class="funcsynopsis"><table border="0" summary="Function synopsis" cellspacing="0" cellpadding="0"><tr><td><code class="funcdef">char const * <b class="fsfunc">filepart</b> (</code></td><td><code>char const * </code> </td><td><var class="pdparam">pathname</var><code class="funcdef">)</code>;</td></tr></table></div><p>
				Return the address of the filename portion of a <code class="varname">pathname</code> string. The filename portion is everything after the rightmost path separator. If a path separator is not present then the address of the <code class="varname">pathname</code> string is returned. This function is similar to the <acronym class="acronym">POSIX</acronym> <code class="constant">basename</code> function but it returns an empty string whenever the rightmost character is a path separator. The path separator can be either slash (<code class="constant">'/'</code>) or backslash (<code class="constant">'\\'</code>). The function is declared in <a class="ulink" href="files.h.html" target="_top">files.h</a> and defined in <a class="ulink" href="filepart.c.html" target="_top">filepart.c</a>.
				</p></div><div class="section" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="support-hexdecode"></a>
			hexdecode
			</h3></div></div></div><div class="funcsynopsis"><table border="0" summary="Function synopsis" cellspacing="0" cellpadding="0"><tr><td><code class="funcdef">signed <b class="fsfunc">hexdecode</b> (</code></td><td><code>void  * </code> </td><td><var class="pdparam">memory</var>, </td></tr><tr><td> </td><td><code>size_t </code> </td><td><var class="pdparam">extent</var>, </td></tr><tr><td> </td><td><code>char const </code> </td><td><var class="pdparam">buffer</var> [], </td></tr><tr><td> </td><td><code>size_t </code> </td><td><var class="pdparam">extent</var><code class="funcdef">)</code>;</td></tr></table></div><p>
			Decode a <code class="varname">memory</code> region as a string of <acronym class="acronym">ASCII</acronym> hexadecimal digits. Convert memory until the buffer or memory exhausts and return the string extent. Allow three (3) string characters for each memory byte to be decoded. The number of bytes decoded will be the lesser of argument <code class="varname">extent</code> divided by <code class="constant">3</code> or argument <code class="varname">extent</code>. The function is declared in <a class="ulink" href="memory.h.html" target="_top">memory.h</a> and defined in <a class="ulink" href="hexdecode.c.html" target="_top">hexdecode.c</a>.
			</p></div><div class="section" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="support-hexdump"></a>
			hexdump
			</h3></div></div></div><div class="funcsynopsis"><table border="0" summary="Function synopsis" cellspacing="0" cellpadding="0"><tr><td><code class="funcdef">void <b class="fsfunc">hexdump</b> (</code></td><td><code>void const * </code> </td><td><var class="pdparam">memory</var>, </td></tr><tr><td> </td><td><code>size_t </code> </td><td><var class="pdparam">offset</var>, </td></tr><tr><td> </td><td><code>size_t </code> </td><td><var class="pdparam">extent</var>, </td></tr><tr><td> </td><td><code>FILE * </code> </td><td><var class="pdparam">fp</var><code class="funcdef">)</code>;</td></tr></table></div><p>
			Print a full or partial <code class="varname">memory</code> region in hexadecimal format showing memory offsets, hexadecimal byte values and ASCII character values. Argument <code class="varname">memory</code> contains some memory region. Argument <code class="varname">extent</code> is the region extent. Argument <code class="varname">offset</code> is the starting display location. Locations <code class="varname">memory</code> [<code class="varname">offset</code>] up to <code class="varname">memory</code> [<code class="varname">extent</code>] are displayed, allowing a partial dump of the memory region. An <code class="varname">offset</code> of <code class="constant">0</code> will display the entire region. The function is declared in <a class="ulink" href="memory.h.html" target="_top">memory.h</a> and defined in <a class="ulink" href="hexdump.c.html" target="_top">hexdump.c</a>. 			
			</p><p>
			This function is similar to but different from function <a class="link" href="ch07s05.html#support-hexview" title="hexview">hexview</a> .
			</p></div><div class="section" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="support-hexencode"></a>
			hexencode
			</h3></div></div></div><div class="funcsynopsis"><table border="0" summary="Function synopsis" cellspacing="0" cellpadding="0"><tr><td><code class="funcdef">signed <b class="fsfunc">hexencode</b> (</code></td><td><code>void  * </code> </td><td><var class="pdparam">memory</var>, </td></tr><tr><td> </td><td><code>size_t </code> </td><td><var class="pdparam">extent</var>, </td></tr><tr><td> </td><td><code>char const * </code> </td><td><var class="pdparam">string</var><code class="funcdef">)</code>;</td></tr></table></div><p>
			Encode a <code class="varname">memory</code> region with the binary equivalent of an <acronym class="acronym">ASCII</acronym> hexadecimal string. Return the number of bytes encoded or <code class="constant">0</code> on error. The value of <code class="varname">errno</code> is set to <code class="constant">EINVAL</code> if the number of bytes encoded is less than <code class="varname">extent</code> or the entire string cannot be converted due to illegal digits or excessive digits. Ignore optional <code class="constant">HEX_EXTENDER</code> characters separating octets in argument <code class="varname">string</code>. Constant <code class="constant">HEX_EXTENDER</code> is defined in file <a class="ulink" href="number.h.html" target="_top">number.h</a>. The function is declared in <a class="ulink" href="memory.h.html" target="_top">memory.h</a> and defined in <a class="ulink" href="hexencode.c.html" target="_top">hexencode.c</a>.
			</p></div><div class="section" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="support-hexin"></a>
			hexin
			</h3></div></div></div><div class="funcsynopsis"><table border="0" summary="Function synopsis" cellspacing="0" cellpadding="0"><tr><td><code class="funcdef">ssize_t <b class="fsfunc">hexin</b> (</code></td><td><code>void const * </code> </td><td><var class="pdparam">memory</var>, </td></tr><tr><td> </td><td><code>size_t </code> </td><td><var class="pdparam">extent</var>, </td></tr><tr><td> </td><td><code>FILE * </code> </td><td><var class="pdparam">fp</var><code class="funcdef">)</code>;</td></tr></table></div><p>
			This function is similar to <a class="link" href="ch07s05.html#support-hexencode" title="hexencode">hexencode</a> but it reads from file, instead of a string and ignores non-hexadecimal text and comments within the input stream. Incoming text is binary encoded and written to the specified <code class="varname">memory</code> region. The actual number of bytes encoded is returned or <code class="constant">-1</code> on error. See the <a class="ulink" href="efsu.7.html" target="_top">efsu</a> man page for a thorough explanation of function behavior. The function is declared in <a class="ulink" href="memory.h.html" target="_top">memory.h</a> and defined in <a class="ulink" href="hexin.c.html" target="_top">hexin.c</a>.
			</p></div><div class="section" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="support-hexout"></a>
			hexout
			</h3></div></div></div><div class="funcsynopsis"><table border="0" summary="Function synopsis" cellspacing="0" cellpadding="0"><tr><td><code class="funcdef">void <b class="fsfunc">hexout</b> (</code></td><td><code>void const * </code> </td><td><var class="pdparam">memory</var>, </td></tr><tr><td> </td><td><code>size_t </code> </td><td><var class="pdparam">extent</var>, </td></tr><tr><td> </td><td><code>char </code> </td><td><var class="pdparam">c</var>, </td></tr><tr><td> </td><td><code>char </code> </td><td><var class="pdparam">e</var>, </td></tr><tr><td> </td><td><code>FILE * </code> </td><td><var class="pdparam">fp</var><code class="funcdef">)</code>;</td></tr></table></div><p>
			Print a <code class="varname">memory</code> region as a series of hexdecimal octets separated by character <code class="varname">c</code> and termianted by character <code class="varname">e</code>. Normally, character <code class="varname">c</code> will be <code class="constant">HEX_EXTENDER</code>, defined in file <a class="ulink" href="number.h.html" target="_top">number.h</a>, but it could be any character value. Normally, character <code class="varname">e</code> will be a space or newline but it could be any character value. A typical use might be to print a <acronym class="acronym">MAC</acronym> or <acronym class="acronym">Ethernet</acronym> address in readable format. For example, specifying <code class="varname">c</code> as <code class="constant">':'</code>, character <code class="varname">e</code> as <code class="constant">','</code> and <code class="varname">extent</code> as <code class="constant">6</code> would produce output looking something like <code class="computeroutput">"00:B0:52:DA:DA:01,"</code> where each octet is expressed as a hexadecimal integer. The function is declared in <a class="ulink" href="memory.h.html" target="_top">memory.h</a> and defined in <a class="ulink" href="hexout.c.html" target="_top">hexout.c</a>.
			</p></div><div class="section" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="support-hexstring"></a>
			hexstring
			</h3></div></div></div><div class="funcsynopsis"><table border="0" summary="Function synopsis" cellspacing="0" cellpadding="0"><tr><td><code class="funcdef">char * <b class="fsfunc">hexstring</b> (</code></td><td><code>char </code> </td><td><var class="pdparam">buffer</var> [], </td></tr><tr><td> </td><td><code>size_t </code> </td><td><var class="pdparam">length</var>, </td></tr><tr><td> </td><td><code>void const * </code> </td><td><var class="pdparam">memory</var>, </td></tr><tr><td> </td><td><code>size_t </code> </td><td><var class="pdparam">extent</var><code class="funcdef">)</code>;</td></tr></table></div><p>
			Convert a <code class="varname">memory</code> region to a <code class="constant">NUL</code> terminated string and return the string address. This function is identical to function <a class="link" href="ch07s05.html#support-hexdecode" title="hexdecode">hexdecode</a> but it return the string address instead of the number of characters decoded. The function is declared in <a class="ulink" href="memory.h.html" target="_top">memory.h</a> and defined in <a class="ulink" href="hexstring.c.html" target="_top">hexstring.c</a>.
			</p></div><div class="section" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="support-hexview"></a>
			hexview
			</h3></div></div></div><div class="funcsynopsis"><table border="0" summary="Function synopsis" cellspacing="0" cellpadding="0"><tr><td><code class="funcdef">void <b class="fsfunc">hexview</b> (</code></td><td><code>void const * </code> </td><td><var class="pdparam">memory</var>, </td></tr><tr><td> </td><td><code>size_t </code> </td><td><var class="pdparam">offset</var>, </td></tr><tr><td> </td><td><code>size_t </code> </td><td><var class="pdparam">extent</var>, </td></tr><tr><td> </td><td><code>FILE * </code> </td><td><var class="pdparam">fp</var><code class="funcdef">)</code>;</td></tr></table></div><p>
			Print a partial <code class="varname">memory</code> region in hexadecimal format showing memory offsets, hexadecimal byte values and ASCII character values. Argument <code class="varname">memory</code> contains part of a larger memory region, much like a file window. Argument <code class="varname">extent</code> is the window length. Argument <code class="varname">offset</code> is the relative offset of the window within the region. Locations <code class="varname">memory</code> [<code class="constant">0</code>] up to but excluding  <code class="varname">memory</code> [<code class="varname">extent</code>] are displayed as a partial dump, providing a window into the region. The function is declared in <a class="ulink" href="memory.h.html" target="_top">memory.h</a> and defined in <a class="ulink" href="hexview.c.html" target="_top">hexview.c</a>. 			</p><p>
			This function is similar to but different from function <a class="link" href="ch07s05.html#support-hexdump" title="hexdump">hexdump</a>.
			</p></div><div class="section" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="support-memdecr"></a>
			memdecr
			</h3></div></div></div><div class="funcsynopsis"><table border="0" summary="Function synopsis" cellspacing="0" cellpadding="0"><tr><td><code class="funcdef">signed <b class="fsfunc">memdecr</b> (</code></td><td><code>void  * </code> </td><td><var class="pdparam">memory</var>, </td></tr><tr><td> </td><td><code>size_t </code> </td><td><var class="pdparam">extent</var><code class="funcdef">)</code>;</td></tr></table></div><p>
			Decrement a multi-byte <code class="varname">memory</code> region. Return <code class="constant">0</code> on success or <code class="constant">-1</code> if all bytes have decremented to <code class="constant">0x00</code>. For example, <code class="computeroutput">{ 0xFF, 0xFF, 0xFF }</code> decrements to <code class="computeroutput">{ 0xFF, 0xFF, 0xFE }</code> and <code class="computeroutput">{ 0xFF, 0x00, 0x00 }</code> decrements to <code class="computeroutput">{ 0xFE, 0xFF, 0xFF }</code>. A typical use is to iterate through a range if <acronym class="acronym">IP</acronym> or <acronym class="acronym">MAC</acronym> address values. The function is declared in <a class="ulink" href="memory.h.html" target="_top">memory.h</a> and defined in <a class="ulink" href="memdecr.c.html" target="_top">memdecr.c</a>.
			</p></div><div class="section" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="support-memincr"></a>
			memincr
			</h3></div></div></div><div class="funcsynopsis"><table border="0" summary="Function synopsis" cellspacing="0" cellpadding="0"><tr><td><code class="funcdef">signed <b class="fsfunc">memincr</b> (</code></td><td><code>void  * </code> </td><td><var class="pdparam">memory</var>, </td></tr><tr><td> </td><td><code>size_t </code> </td><td><var class="pdparam">extent</var><code class="funcdef">)</code>;</td></tr></table></div><p>
			Increment a multi-byte <code class="varname">memory</code> region. Return <code class="constant">0</code> on success or <code class="constant">-1</code> once all bytes have been incremented to <code class="constant">0xFF</code>. For example <code class="computeroutput">{ 0x00, 0x00, 0x00 }</code> increments to <code class="computeroutput">{ 0x00, 0x00, 0x01 }</code> and <code class="computeroutput">{ 0x00, 0xFF, 0xFF }</code> increments to <code class="computeroutput">{ 0x01, 0x00, 0x00 }</code>. A typical use is to iterate through a range of <acronym class="acronym">IP</acronym> or <acronym class="acronym">MAC</acronym> address values. The function is declared in <a class="ulink" href="memory.h.html" target="_top">memory.h</a> and defined in <a class="ulink" href="memincr.c.html" target="_top">memincr.c</a>.
			</p></div><div class="section" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="support-memout"></a>
			memout
			</h3></div></div></div><div class="funcsynopsis"><table border="0" summary="Function synopsis" cellspacing="0" cellpadding="0"><tr><td><code class="funcdef">void <b class="fsfunc">memout</b> (</code></td><td><code>void const * </code> </td><td><var class="pdparam">memory</var>, </td></tr><tr><td> </td><td><code>size_t </code> </td><td><var class="pdparam">extent</var>, </td></tr><tr><td> </td><td><code>char const * </code> </td><td><var class="pdparam">format</var>, </td></tr><tr><td> </td><td><code>unsigned </code> </td><td><var class="pdparam">group</var>, </td></tr><tr><td> </td><td><code>signed </code> </td><td><var class="pdparam">c</var>, </td></tr><tr><td> </td><td><code>FILE * </code> </td><td><var class="pdparam">fp</var><code class="funcdef">)</code>;</td></tr></table></div><p>
			Print a <code class="varname">memory</code> region as a series of octet groups wach separated by character <code class="constant">c</code>. The <code class="varname">group</code> argument specifies the number of octets per group. The <code class="varname">format</code> argument determines how each octet is displayed. Normally, character <code class="constant">c</code> will be one of <code class="constant">BIN_EXTENDER</code>, <code class="constant">DEC_EXTENDER</code> or <code class="constant">HEX_EXTENDER</code> as defined in file <a class="ulink" href="number.h.html" target="_top">number.h</a>, but it could be any character value. The function is declared in <a class="ulink" href="memory.h.html" target="_top">memory.h</a> and defined in <a class="ulink" href="memout.c.html" target="_top">memout.c</a>.
			</p></div><div class="section" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="support-memswap"></a>
			memswap
			</h3></div></div></div><div class="funcsynopsis"><table border="0" summary="Function synopsis" cellspacing="0" cellpadding="0"><tr><td><code class="funcdef">void <b class="fsfunc">memswap</b> (</code></td><td><code>void  * </code> </td><td><var class="pdparam">buffer1</var>, </td></tr><tr><td> </td><td><code>void  * </code> </td><td><var class="pdparam">buffer2</var>, </td></tr><tr><td> </td><td><code>size_t </code> </td><td><var class="pdparam">length</var><code class="funcdef">)</code>;</td></tr></table></div><p>
			Exchange the contents of one buffer with that of another. No provision is made for buffer overlap. No value is returned. A typical use might be to exchange source and destination addresses in an ethernet packet. The function is declared in <a class="ulink" href="memory.h.html" target="_top">memory.h</a> and defined in <a class="ulink" href="memswap.c.html" target="_top">memswap.c</a>.
			</p></div><div class="section" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="support-strdecr"></a>
			strdecr
			</h3></div></div></div><div class="funcsynopsis"><table border="0" summary="Function synopsis" cellspacing="0" cellpadding="0"><tr><td><code class="funcdef">signed <b class="fsfunc">strdecr</b> (</code></td><td><code>void  * </code> </td><td><var class="pdparam">memory</var>, </td></tr><tr><td> </td><td><code>size_t </code> </td><td><var class="pdparam">extent</var>, </td></tr><tr><td> </td><td><code>byte </code> </td><td><var class="pdparam">min</var>, </td></tr><tr><td> </td><td><code>byte </code> </td><td><var class="pdparam">max</var><code class="funcdef">)</code>;</td></tr></table></div><p>
			Decrement a multi-byte <code class="varname">memory</code> region using only ASCII character values in the range <code class="varname">min</code> through <code class="varname">max</code>. Return <code class="constant">0</code> on success or <code class="constant">-1</code> once all characters have been decremented to the value of argument <code class="varname">min</code>. For example,  if argument <code class="varname">min</code> is <code class="constant">'A'</code> and argument <code class="varname">max</code> is <code class="constant">'Z'</code> then <code class="computeroutput">{ 'A', 'B', 'C' }</code> decrements to <code class="computeroutput">{ 'A', 'B', 'B' }</code> and <code class="computeroutput">{ 'B', 'Z', 'Z' }</code> decrements to <code class="computeroutput">{ 'A', 'A', 'A' }</code>. A typical use is to generate a sequence of distinct character strings to seed encryption key functions. The function is declared in <a class="ulink" href="memory.h.html" target="_top">memory.h</a> and defined in <a class="ulink" href="strdecr.c.html" target="_top">strdecr.c</a>.
			</p></div><div class="section" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="support-strfbits"></a>
			strfbits
			</h3></div></div></div><div class="funcsynopsis"><table border="0" summary="Function synopsis" cellspacing="0" cellpadding="0"><tr><td><code class="funcdef">size_t <b class="fsfunc">strfbits</b> (</code></td><td><code>char const </code> </td><td><var class="pdparam">buffer</var> [], </td></tr><tr><td> </td><td><code>size_t </code> </td><td><var class="pdparam">length</var>, </td></tr><tr><td> </td><td><code>char const * </code> </td><td><var class="pdparam">operands</var> [], </td></tr><tr><td> </td><td><code>char const * </code> </td><td><var class="pdparam">operator</var>, </td></tr><tr><td> </td><td><code>unsigned </code> </td><td><var class="pdparam">flagword</var><code class="funcdef">)</code>;</td></tr></table></div><p>
			Encode a <code class="varname">buffer</code> with an enumerated list of the <code class="varname">operands</code> associated with the corresponding bits in <code class="varname">flagword</code>. separate enumerated <code class="varname">operands</code> with an <code class="varname">operator</code> string. For example, given <code class="computeroutput">char const *operands [] = { "loop", "wait",  "busy" }</code> and <code class="computeroutput">unsigned flagword = 0x05</code> then <code class="computeroutput">strfbits (buffer,  length, operands, "|", flagword)</code> would encode buffer with <code class="constant">"loop|busy"</code>. Observe that each bit set in <code class="varname">flagword</code> appears in <code class="varname">buffer</code> as the corresponding string from <code class="varname">operands</code>. A typical application for this function is the enumeration of flagword states. The function is declared in <a class="ulink" href="format.h.html" target="_top">format.h</a> and defined in <a class="ulink" href="strfbits.c.html" target="_top">strfbits.c</a>.
			</p></div><div class="section" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="support-strincr"></a>
			strincr
			</h3></div></div></div><div class="funcsynopsis"><table border="0" summary="Function synopsis" cellspacing="0" cellpadding="0"><tr><td><code class="funcdef">signed <b class="fsfunc">strincr</b> (</code></td><td><code>void  * </code> </td><td><var class="pdparam">memory</var>, </td></tr><tr><td> </td><td><code>size_t </code> </td><td><var class="pdparam">extent</var>, </td></tr><tr><td> </td><td><code>byte </code> </td><td><var class="pdparam">min</var>, </td></tr><tr><td> </td><td><code>byte </code> </td><td><var class="pdparam">max</var><code class="funcdef">)</code>;</td></tr></table></div><p>
			Increment a multi-byte <code class="varname">memory</code> region using only ASCII character values in the range <code class="varname">min</code> through <code class="varname">max</code>. Return <code class="constant">0</code> on success or <code class="constant">-1</code> once all characters have been incremented to the value of argument <code class="varname">max</code>.  For example,  if argument <code class="varname">min</code> is <code class="constant">'A'</code> and argument <code class="varname">max</code> is <code class="constant">'Z'</code> then <code class="computeroutput">{ 'A', 'B', 'C' }</code> increments to <code class="computeroutput">{ 'A', 'B', 'D' }</code> and <code class="computeroutput">{ 'A', 'Z', 'Z' }</code> increments to <code class="computeroutput">{ 'B', 'A', 'A' }</code>. A typical use is to generate a sequence of distinct character strings to seed encryption key functions. The function is declared in <a class="ulink" href="memory.h.html" target="_top">memory.h</a> and defined in <a class="ulink" href="strincr.c.html" target="_top">strincr.c</a>.
			</p></div><div class="section" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="support-todigit"></a>
			todigit
			</h3></div></div></div><div class="funcsynopsis"><p><code class="funcdef">unsigned <b class="fsfunc">todigit</b> (</code>unsigned <var class="pdparam">c</var><code class="funcdef">)</code>;</p></div><p>
			Return the integer value of character <code class="varname">c</code> interpreted as digit in the base 36 number system. It is called by many encode functions to support number base conversion. If the value of <code class="varname">c</code> is <code class="constant">'0'</code> through <code class="constant">'9'</code> then integer <code class="constant">0</code> through <code class="constant">9</code> is returned.  If the value of <code class="varname">c</code> is <code class="constant">'A'</code> through <code class="constant">'Z'</code> or <code class="constant">'a'</code> through <code class="constant">'z'</code> then integer <code class="constant">10</code> through <code class="constant">35</code> is returned. The function is declared in <a class="ulink" href="number.h.html" target="_top">number.h</a> and defined in <a class="ulink" href="todigit.c.html" target="_top">todigit.c</a>.
			</p></div><div class="section" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="support-typename"></a>
			typename
			</h3></div></div></div><div class="funcsynopsis"><table border="0" summary="Function synopsis" cellspacing="0" cellpadding="0"><tr><td><code class="funcdef">char const * <b class="fsfunc">typename</b> (</code></td><td><code>const struct _type_ </code> </td><td><var class="pdparam">list</var> [], </td></tr><tr><td> </td><td><code>size_t </code> </td><td><var class="pdparam">size</var>, </td></tr><tr><td> </td><td><code>type_t </code> </td><td><var class="pdparam">type</var>, </td></tr><tr><td> </td><td><code>char const * </code> </td><td><var class="pdparam">name</var><code class="funcdef">)</code>;</td></tr></table></div><p>
			Return the name associated with a message <code class="varname">type</code> by searching a list arranged in ascending order by message type. Return argument <code class="varname">name</code> as the function value if the message <code class="varname">type</code> is not present in the <code class="varname">list</code>. Data types <code class="varname">struct _type_</code> and <code class="varname">type_t</code> are defined in file <a class="ulink" href="types.h.html" target="_top">types.h</a>. A typical use might be to return the name of message based on the message type. The function is declared in <a class="ulink" href="symbol.h.html" target="_top">symbol.h</a> and defined in <a class="ulink" href="typename.c.html" target="_top">typename.c</a>.
			</p></div></div><div class="navfooter"><hr><table width="100%" summary="Navigation footer"><tr><td width="40%" align="left"><a accesskey="p" href="ch07s04.html">Prev</a> </td><td width="20%" align="center"><a accesskey="u" href="ch07.html">Up</a></td><td width="40%" align="right"> <a accesskey="n" href="ch07s06.html">Next</a></td></tr><tr><td width="40%" align="left" valign="top">
		Network Functions
		 </td><td width="20%" align="center"><a accesskey="h" href="index.html">Home</a></td><td width="40%" align="right" valign="top"> 
		Message Debug Functions
		</td></tr></table></div></body></html>0

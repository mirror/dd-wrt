<html><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8"><title>Key Generation Functions</title><link rel="stylesheet" href="docbook.css" type="text/css"><meta name="generator" content="DocBook XSL Stylesheets V1.73.2"><meta name="keywords" content="Intellon, Atheros, Qualcomm, HomePlug, powerline, communications, INT6000, INT6300, INT6400, AR7400, AR7420"><link rel="start" href="index.html" title="Qualcomm Atheros Open Powerline Toolkit"><link rel="up" href="ch07.html" title="Chapter 7.  Support Function Reference"><link rel="prev" href="ch07s06.html" title="Message Debug Functions"><link rel="next" href="ch07s08.html" title="XML Editing Functions"></head><body bgcolor="white" text="black" link="#0000FF" vlink="#840084" alink="#0000FF"><div class="navheader"><table width="100%" summary="Navigation header"><tr><th colspan="3" align="center">
			Key Generation Functions
			</th></tr><tr><td width="20%" align="left"><a accesskey="p" href="ch07s06.html">Prev</a> </td><th width="60%" align="center">Chapter 7. 
		Support Function Reference
		</th><td width="20%" align="right"> <a accesskey="n" href="ch07s08.html">Next</a></td></tr></table><hr></div><div class="section" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="support-key"></a>
			Key Generation Functions
			</h2></div></div></div><p>
			Atheros applications use the SHA256 algorithm to compute unique HomePlug AV keys, including the Device Access Key (<acronym class="acronym">DAK</acronym>), Network Membership Key (<acronym class="acronym">NMK</acronym>) and Network Identifier (<acronym class="acronym">NID</acronym>). The SHA256 algorithm is seeded, salted and rehashed differently for each type of HomePlug AV key. A different function is used to compute each type of HomePlug AV key but all of them call the SHA256 functions. The SHA256 algorithm returns a <code class="constant">256</code> bit (<code class="constant">32</code> byte) digest but only the upper <code class="constant">128</code> bits (<code class="constant">16</code> bytes) are used for HomePlug AV keys. 
			</p><div class="example"><a name="idp12531696"></a><p class="title"><b>Example 7.3. 
				SHA256 Digest Computation
				</b></p><div class="example-contents"><p>
			The following code example illustrates how to generate, rehash and print an SHA256 digest, or key, from a user-defined seed string and salt string. This logic is typical of that used to generate HomePlug AV compliant keys. See the HomePlug AV Specification for the specific rules used to generate each type of key.
			</p><pre class="programlisting">
#include &lt;stdio.h&gt;

#include "../crypt/SHA256.h"

#include "../crypt/SHA256Reset.c"
#include "../crypt/SHA256Block.c"
#include "../crypt/SHA256Write.c"
#include "../crypt/SHA256Fetch.c"

struct sha256 sha256; 
char * seed = "ForMeToKnowAndYouToFindOut"; 
char * salt = "X$z@p"; 
byte digest [SHA256_DIGEST_SIZE];
int i; 

SHA256Reset (&amp;sha256); 
SHA256Write (&amp;sha256, (byte *)(seed), strlen (seed)); 
SHA256Write (&amp;sha256, (byte *)(salt), strlen (salt)); 
SHA256Fetch (&amp;sha256, digest); 

for (i = 0; i &lt; 999; i++)
{
	SHA256Reset (&amp;sha256); 
	SHA256Write (&amp;sha256, digest, sizeof (digest)); 
	SHA256Fetch (&amp;sha256, digest); 
}
for (i = 0;  i &lt; 16; i++)
{
	printf ("%02x", digest [i]); 
}
printf ("\n"); 
</pre><p>
				Above, we declare struct <code class="varname">sha256</code> and initialize it using function <a class="link" href="ch07s07.html#support-SHA256Reset" title="SHA256Reset">SHA256Reset</a>. We then write a user-defined seed string (or password) followed by an optional salt string to the digest using function <a class="link" href="ch07s07.html#support-SHA256Write" title="SHA256Write">SHA256Write</a>. The resulting digest (or key) is obtained by calling function <a class="link" href="ch07s07.html#support-SHA256Fetch" title="SHA256Fetch">SHA256Fetch</a>. Constant <code class="constant">SHA256_DIGEST_SIZE</code> is defined in <a class="ulink" href="SHA256.h.html" target="_top">SHA256.h</a>. Although the digest is probably secure enough at this point, we rehash it <code class="constant">999</code> times for good measure. We then print the first <code class="constant">16</code> bytes of the result because HomePlug AV keys are always <code class="constant">16</code> bytes long.
				</p></div></div><br class="example-break"><div class="section" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="support-MACPasswords"></a>
				MACPasswords
				</h3></div></div></div><div class="funcsynopsis"><table border="0" summary="Function synopsis" cellspacing="0" cellpadding="0"><tr><td><code class="funcdef">void <b class="fsfunc">MACPasswords</b> (</code></td><td><code>uint32_t</code> </td><td><var class="pdparam">vendor</var>, </td></tr><tr><td> </td><td><code>uint32_t</code> </td><td><var class="pdparam">device</var>, </td></tr><tr><td> </td><td><code>uint32_t</code> </td><td><var class="pdparam">number</var>, </td></tr><tr><td> </td><td><code>unsigned </code> </td><td><var class="pdparam">count</var>, </td></tr><tr><td> </td><td><code>unsigned </code> </td><td><var class="pdparam">bunch</var>, </td></tr><tr><td> </td><td><code>unsigned </code> </td><td><var class="pdparam">space</var>, </td></tr><tr><td> </td><td><code>flag_t </code> </td><td><var class="pdparam">flags</var><code class="funcdef">)</code>;</td></tr></table></div><p>
				Print a range of device addresses and user passwords on stdout. The calling application must split the starting device address into a three-byte <acronym class="acronym">OUI</acronym> and three-byte device number and pass them as the unsigned 32-bit integers <code class="varname">vendor</code> and <code class="varname">device</code>, respectively. Argument <code class="varname">device</code> is the first device number in the range and <code class="varname">number</code> is the final device number. Argument <code class="varname">count</code> is the number of uppercase letters comprising a password. Passwords contain this many letters but the letters are grouped for easy reading. Letter groups are separated by hyphens. Argument <code class="varname">bunch</code> defines how many letters form each group. Argument <code class="varname">space</code> is the character used to separate groups of letters. Argument <code class="varname">flags</code> enables or disables function features such as insertion of a “<span class="quote">used</span>” flag for use by the Atheros Production Test System or the omission of the device address on output. The output of this function is similar to that produced by the <span class="application">DB Builder</span> utility distributed with the <acronym class="acronym">PTS</acronym>. This function is declared in <a class="ulink" href="keys.h.html" target="_top">keys.h</a> and defined in <a class="ulink" href="MACPasswords.c.html" target="_top">MACPasswords.c</a>. 				</p></div><div class="section" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="support-HPAVKeyDAK"></a>
				HPAVKeyDAK
				</h3></div></div></div><div class="funcsynopsis"><table border="0" summary="Function synopsis" cellspacing="0" cellpadding="0"><tr><td><code class="funcdef">void <b class="fsfunc">HPAVKeyDAK</b> (</code></td><td><code> byte </code> </td><td><var class="pdparam">DAK</var> [], </td></tr><tr><td> </td><td><code>char const </code> </td><td><var class="pdparam">string</var><code class="funcdef">)</code>;</td></tr></table></div><p>
				Encode buffer <code class="varname">DAK</code> with the Device Access Key (<acronym class="acronym">DAK</acronym>) derived from the <code class="constant">NUL</code> terminated <code class="varname">string</code>. The <code class="varname">string</code> is salted, hashed and re-hashed using the <acronym class="acronym">SHA256</acronym> algorithm. The <code class="varname">DAK</code> is always <code class="constant">HPAVKEY_DAK_LEN</code> bytes, defined in <a class="ulink" href="HPAVKey.h.html" target="_top">HPAVKey.h</a>,  so no length argument is needed. See the HomePlug AV Specification for more information. This function is declared in <a class="ulink" href="HPAVKey.h.html" target="_top">HPAVKey.h</a> and defined in <a class="ulink" href="HPAVKeyDAK.c.html" target="_top">HPAVKeyDAK.c</a>.				
				</p></div><div class="section" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="support-HPAVKeyNMK"></a>
				HPAVKeyNMK
				</h3></div></div></div><div class="funcsynopsis"><table border="0" summary="Function synopsis" cellspacing="0" cellpadding="0"><tr><td><code class="funcdef">void <b class="fsfunc">HPAVKeyNMK</b> (</code></td><td><code> byte </code> </td><td><var class="pdparam">digest</var> [], </td></tr><tr><td> </td><td><code>char const </code> </td><td><var class="pdparam">string</var><code class="funcdef">)</code>;</td></tr></table></div><p>
				Encode buffer <code class="varname">NMK</code> with the Network Membership Key (<acronym class="acronym">NMK</acronym>) derived from the <code class="constant">NUL</code> terminated <code class="varname">string</code>. The string is salted, hashed and re-hashed using the <acronym class="acronym">SHA256</acronym> algorithm. The <code class="varname">DAK</code> is always <code class="constant">HPAVKEY_NMK_LEN</code> bytes,  as defined in <a class="ulink" href="HPAVKey.h.html" target="_top">HPAVKey.h</a>,  so no length argument is needed. See the HomePlug AV Specification for more information. This function is declared in <a class="ulink" href="HPAVKey.h.html" target="_top">HPAVKey.h</a> and defined in <a class="ulink" href="HPAVKeyNMK.c.html" target="_top">HPAVKeyNMK.c</a>.				
				</p></div><div class="section" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="support-HPAVKeyNID"></a>
				HPAVKeyNID
				</h3></div></div></div><div class="funcsynopsis"><table border="0" summary="Function synopsis" cellspacing="0" cellpadding="0"><tr><td><code class="funcdef">void <b class="fsfunc">HPAVKeyNID</b> (</code></td><td><code> byte </code> </td><td><var class="pdparam">NID</var> [], </td></tr><tr><td> </td><td><code>byte const </code> </td><td><var class="pdparam">NMK</var> [], </td></tr><tr><td> </td><td><code>signed </code> </td><td><var class="pdparam">level</var><code class="funcdef">)</code>;</td></tr></table></div><p>
				Encode buffer <code class="varname">NID</code> with the Network Identification Key (<acronym class="acronym">NID</acronym>) derived from the 16-byte Network Membership Key (<acronym class="acronym">NMK</acronym>). The <code class="varname">NMK</code> is hashed and re-hashed using the <acronym class="acronym">SHA256</acronym> algorithm then encoded with the security <code class="varname">level</code>. The <code class="varname">NID</code> is always <code class="constant">HPAVKEY_NID_LEN</code> bytes,  as defined in <a class="ulink" href="HPAVKey.h.html" target="_top">HPAVKey.h</a>,  so no length argument is needed. See the HomePlug AV Specification for more information. This function is declared in <a class="ulink" href="HPAVKey.h.html" target="_top">HPAVKey.h</a> and defined in <a class="ulink" href="HPAVKeyNID.c.html" target="_top">HPAVKeyNID.c</a>.				
				</p></div><div class="section" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="support-HPAVKeyOut"></a>
				HPAVKeyOut
				</h3></div></div></div><div class="funcsynopsis"><table border="0" summary="Function synopsis" cellspacing="0" cellpadding="0"><tr><td><code class="funcdef">void <b class="fsfunc">HPAVKeyOut</b> (</code></td><td><code>byte const </code> </td><td><var class="pdparam">digest</var> [], </td></tr><tr><td> </td><td><code>size_t </code> </td><td><var class="pdparam">length</var>, </td></tr><tr><td> </td><td><code>char const * </code> </td><td><var class="pdparam">phrase</var>, </td></tr><tr><td> </td><td><code>flag_t </code> </td><td><var class="pdparam">flags</var><code class="funcdef">)</code>;</td></tr></table></div><p>
				Decode and print up to <code class="varname">length</code> bytes from buffer <code class="varname">digest</code> on stdout. Print <code class="constant">NUL</code> terminated <code class="varname">phrase</code> on the same line following the digest when bit <code class="varname">HPAVKEY_VERBOSE</code>, defined in <a class="ulink" href="HPAVKey.h.html" target="_top">HPAVKey.h</a>, is set in <code class="varname">flags</code>. This procedure prints keys and phrases in a standard column-oriented format that other applications can easily read and use. This function is declared in <a class="ulink" href="HPAVKey.h.html" target="_top">HPAVKey.h</a> and defined in <a class="ulink" href="HPAVKeyOut.c.html" target="_top">HPAVKeyOut.c</a>.				
				</p></div><div class="section" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="support-SHA256Block"></a>
				SHA256Block
				</h3></div></div></div><div class="funcsynopsis"><table border="0" summary="Function synopsis" cellspacing="0" cellpadding="0"><tr><td><code class="funcdef">void <b class="fsfunc">SHA256Block</b> (</code></td><td><code>struct sha256 * </code> </td><td><var class="pdparam">sha256</var>, </td></tr><tr><td> </td><td><code>void const * </code> </td><td><var class="pdparam">memory</var><code class="funcdef">)</code>;</td></tr></table></div><p>
				Merge 64 bytes of memory into the current <acronym class="acronym">SHA256</acronym> digest. This function performs the core computations required by the <acronym class="acronym">SHA256</acronym> algoithm. It is called by function <a class="link" href="ch07s07.html#support-SHA256Fetch" title="SHA256Fetch"><code class="varname">SHA256Fetch</code></a> and so there is no reason to call this function directly. The <code class="varname">sha256</code> structure is defined in <a class="ulink" href="SHA256.h.html" target="_top">SHA256.h</a>. The function is declared in <a class="ulink" href="SHA256.h.html" target="_top">SHA256.h</a> and defined in <a class="ulink" href="SHA256Block.c.html" target="_top">SHA256Block.c</a>. 
				</p></div><div class="section" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="support-SHA256Fetch"></a>
				SHA256Fetch
				</h3></div></div></div><div class="funcsynopsis"><table border="0" summary="Function synopsis" cellspacing="0" cellpadding="0"><tr><td><code class="funcdef">void <b class="fsfunc">SHA256Fetch</b> (</code></td><td><code>struct sha256 * </code> </td><td><var class="pdparam">sha256</var>, </td></tr><tr><td> </td><td><code> byte </code> </td><td><var class="pdparam">digest</var> []<code class="funcdef">)</code>;</td></tr></table></div><p>
				 Conclude <acronym class="acronym">SHA256</acronym> computation and transfer the result to the named 32-byte <code class="varname">digest</code> then flush the <code class="varname">sha256</code> structure. The <code class="varname">digest</code> is always 32 bytes long regardless of the amount of information that has been written using function <a class="link" href="ch07s07.html#support-SHA256Write" title="SHA256Write">SHA256Write</a>. The <code class="varname">sha256</code> structure is defined in <a class="ulink" href="SHA256.h.html" target="_top">SHA256.h</a>. This function is declared in <a class="ulink" href="SHA256.h.html" target="_top">SHA256.h</a> and defined in <a class="ulink" href="SHA256Fetch.c.html" target="_top">SHA256Fetch.c</a>.
				</p><p>
				Once this function is called, the <code class="varname">sha256</code> structure is purged for security reasons. You must call <a class="link" href="ch07s07.html#support-SHA256Reset" title="SHA256Reset">SHA256Reset</a> again before starting another hash or subsequent calls to this function or <a class="link" href="ch07s07.html#support-SHA256Write" title="SHA256Write">SHA256Write</a> will have unpredictable results. .
				</p></div><div class="section" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="support-SHA256Ident"></a>
				SHA256Ident
				</h3></div></div></div><div class="funcsynopsis"><p><code class="funcdef">void <b class="fsfunc">SHA256Ident</b> (</code>int <var class="pdparam">fd</var>,  byte <var class="pdparam">digest</var> []<code class="funcdef">)</code>;</p></div><p>
				Compute the SHA256 digest from the content of a file. The digest serves as the file “<span class="quote">fingerprint</span>” and can be used to identify identical content despite filename changes. File descriptor <code class="varname">fd</code> is the subject file which must be positioned to the start befor calling this function. Buffer <code class="varname">digest</code> will be written with the computed 256-digest and must be <code class="constant">SHA256_DIGEST_SIZE</code> bytes long, as defined in <a class="ulink" href="SHA256.h.html" target="_top">SHA256.h</a>. This function is declared in <a class="ulink" href="SHA256.h.html" target="_top">SHA256.h</a> and defined in <a class="ulink" href="SHA256Ident.c.html" target="_top">SHA256Ident.c</a>.  
				</p></div><div class="section" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="support-SHA256Match"></a>
				SHA256Match
				</h3></div></div></div><div class="funcsynopsis"><table border="0" summary="Function synopsis" cellspacing="0" cellpadding="0"><tr><td><code class="funcdef">void <b class="fsfunc">SHA256Match</b> (</code></td><td><code>int </code> </td><td><var class="pdparam">fd</var>, </td></tr><tr><td> </td><td><code>byte const </code> </td><td><var class="pdparam">digest</var> []<code class="funcdef">)</code>;</td></tr></table></div><p>
				Search a registry file for a known SHA256 digest. Return <code class="constant">true</code> on success or <code class="constant">false</code> on failure. File descriptor <code class="varname">fd</code> is the registry file which must be positioned to the start before calling this function. Buffer <code class="varname">digest</code> contains the known 256-bit digest and must be <code class="constant">SHA256_DIGEST_SIZE</code> bytes long, as defined in <a class="ulink" href="SHA256.h.html" target="_top">SHA256.h</a>. A registry file consists of 64-digit hexadecimal strings that represent SHA256 digest values. Optional text may be appear between the digest and newline to document digest significance. This function ignores such text. This function is declared in <a class="ulink" href="SHA256.h.html" target="_top">SHA256.h</a> and defined in <a class="ulink" href="SHA256Match.c.html" target="_top">SHA256Match.c</a>.  
				</p></div><div class="section" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="support-SHA256Print"></a>
				SHA256Print
				</h3></div></div></div><div class="funcsynopsis"><table border="0" summary="Function synopsis" cellspacing="0" cellpadding="0"><tr><td><code class="funcdef">void <b class="fsfunc">SHA256Print</b> (</code></td><td><code>byte const </code> </td><td><var class="pdparam">digest</var> [], </td></tr><tr><td> </td><td><code>char const * </code> </td><td><var class="pdparam">string</var><code class="funcdef">)</code>;</td></tr></table></div><p>
				Print an SHA256 <code class="varname">digest</code> and optional <code class="varname">string</code> on <code class="constant">stdout</code>. Buffer <code class="varname">digest</code> must be <code class="constant">SHA256_DIGEST_SIZE</code> bytes long, as defined in <a class="ulink" href="SHA256.h.html" target="_top">SHA256.h</a>, which results in 64 hexadecimal digits on output. Variable length string is <code class="constant">NUL</code> terminated but may be <code class="constant">NULL</code>. If <code class="varname">string</code> is not <code class="constant">NULL</code> and is not empty then a space is inserted between the digest and the string on output. This function may be used to print SHA256 digests and optional strings in standard format,  such as a registry file. This function is declared in <a class="ulink" href="SHA256.h.html" target="_top">SHA256.h</a> and defined in <a class="ulink" href="SHA256Print.c.html" target="_top">SHA256Print.c</a>.  
				</p></div><div class="section" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="support-SHA256Reset"></a>
				SHA256Reset
				</h3></div></div></div><div class="funcsynopsis"><p><code class="funcdef">void <b class="fsfunc">SHA256Reset</b> (</code>struct sha256 * <var class="pdparam">sha256</var><code class="funcdef">)</code>;</p></div><p>
				Initialize a <code class="varname">sha256</code> structure before computing a new <acronym class="acronym">SHA256</acronym> digest. This function should be called once before calling <a class="link" href="ch07s07.html#support-SHA256Write" title="SHA256Write">SHA256Write</a> for the first time for a given digest. The <code class="varname">sha256</code> structure is defined in <a class="ulink" href="SHA256.h.html" target="_top">SHA256.h</a>. This function is declared in <a class="ulink" href="SHA256.h.html" target="_top">SHA256.h</a> and defined in <a class="ulink" href="SHA256Reset.c.html" target="_top">SHA256Reset.c</a>.  
				</p></div><div class="section" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="support-SHA256Write"></a>
				SHA256Write
				</h3></div></div></div><div class="funcsynopsis"><table border="0" summary="Function synopsis" cellspacing="0" cellpadding="0"><tr><td><code class="funcdef">void <b class="fsfunc">SHA256Write</b> (</code></td><td><code>struct sha256 * </code> </td><td><var class="pdparam">sha256</var>, </td></tr><tr><td> </td><td><code>void const * </code> </td><td><var class="pdparam">memory</var>, </td></tr><tr><td> </td><td><code>size_t </code> </td><td><var class="pdparam">extent</var><code class="funcdef">)</code>;</td></tr></table></div><p>
				Writes a region of memory to the current <acronym class="acronym">SHA256</acronym> digest contained in an <code class="varname">sha256</code> structure. An application may call this function any number of times to concatinate multiple memory regions before fetching the digest with function <code class="function">SHA256Fetch</code>. The <code class="varname">sha256</code> structure is defined in <a class="ulink" href="SHA256.h.html" target="_top">SHA256.h</a>.  This function is declared in <a class="ulink" href="SHA256.h.html" target="_top">SHA256.h</a> and defined in <a class="ulink" href="SHA256Write.c.html" target="_top">SHA256Write.c</a>.				
				</p></div></div><div class="navfooter"><hr><table width="100%" summary="Navigation footer"><tr><td width="40%" align="left"><a accesskey="p" href="ch07s06.html">Prev</a> </td><td width="20%" align="center"><a accesskey="u" href="ch07.html">Up</a></td><td width="40%" align="right"> <a accesskey="n" href="ch07s08.html">Next</a></td></tr><tr><td width="40%" align="left" valign="top">
		Message Debug Functions
		 </td><td width="20%" align="center"><a accesskey="h" href="index.html">Home</a></td><td width="40%" align="right" valign="top"> 
		XML Editing Functions
		</td></tr></table></div></body></html>0

# detect-arch.cmake -- Detect compiler architecture and set ARCH and BASEARCH
# Copyright (C) 2019 Hans Kristian Rosbach
# Licensed under the Zlib license, see LICENSE.md for details
if(CMAKE_OSX_ARCHITECTURES)
    # If multiple architectures are requested (universal build), pick only the first
    list(GET CMAKE_OSX_ARCHITECTURES 0 ARCH)
elseif(MSVC)
    set(ARCH ${MSVC_C_ARCHITECTURE_ID})
elseif(EMSCRIPTEN)
    set(ARCH "wasm32")
elseif(CMAKE_CROSSCOMPILING)
    set(ARCH ${CMAKE_C_COMPILER_TARGET})
else()
    # Let preprocessor parse archdetect.c and raise an error containing the arch identifier
    try_run(
        run_result_unused
        compile_result_unused
        ${CMAKE_CURRENT_BINARY_DIR}
        ${CMAKE_CURRENT_LIST_DIR}/detect-arch.c
        COMPILE_OUTPUT_VARIABLE RAWOUTPUT
        CMAKE_FLAGS CMAKE_OSX_ARCHITECTURES=${CMAKE_OSX_ARCHITECTURES}
    )

    # Find basearch tag, and extract the arch word into BASEARCH variable
    string(REGEX REPLACE ".*archfound ([a-zA-Z0-9_]+).*" "\\1" ARCH "${RAWOUTPUT}")
    if(NOT ARCH)
        set(ARCH unknown)
    endif()
endif()

# Make sure we have ARCH set
if(NOT ARCH OR ARCH STREQUAL "unknown")
    set(ARCH ${CMAKE_SYSTEM_PROCESSOR})
    message(STATUS "Arch not recognized, falling back to cmake arch: '${ARCH}'")
else()
    message(STATUS "Arch detected: '${ARCH}'")
endif()

# Convert ARCH to lowercase
string(TOLOWER "${ARCH}" ARCH)

# Base arch detection
if("${ARCH}" MATCHES "(x86(_32|_64)?|amd64|x64|i[3-6]86)")
    set(BASEARCH "x86")
    set(BASEARCH_X86_FOUND TRUE)
    add_compile_definitions(ARCH_X86)
    if("${ARCH}" MATCHES "(x86_64|amd64|x64)")
        set(ARCH_BITS 64)
    else()
        set(ARCH_BITS 32)
    endif()
elseif("${ARCH}" MATCHES "(aarch64|arm64(ec)?|aarch32|arm(v[0-9])?|cortex)")
    set(BASEARCH "arm")
    set(BASEARCH_ARM_FOUND TRUE)
    add_compile_definitions(ARCH_ARM)
    if("${ARCH}" MATCHES "(aarch64|arm64(ec)?)")
        set(ARCH_BITS 64)
    else()
        set(ARCH_BITS 32)
    endif()
elseif("${ARCH}" MATCHES "(ppc|powerpc)(64)?(le)?")
    set(BASEARCH "ppc")
    set(BASEARCH_PPC_FOUND TRUE)
    add_compile_definitions(ARCH_POWER)
    if("${ARCH}" MATCHES "(ppc|powerpc)64(le)?")
        set(ARCH_BITS 64)
    else()
        set(ARCH_BITS 32)
    endif()
elseif("${ARCH}" MATCHES "alpha")
    set(BASEARCH "alpha")
    set(BASEARCH_ALPHA_FOUND TRUE)
    add_compile_definitions(ARCH_ALPHA)
    set(ARCH_BITS 64)
elseif("${ARCH}" MATCHES "blackfin")
    set(BASEARCH "blackfin")
    set(BASEARCH_BLACKFIN_FOUND TRUE)
    add_compile_definitions(ARCH_BLACKFIN)
    set(ARCH_BITS 32)
elseif("${ARCH}" MATCHES "ia64")
    set(BASEARCH "ia64")
    set(BASEARCH_IA64_FOUND TRUE)
    add_compile_definitions(ARCH_IA64)
    set(ARCH_BITS 64)
elseif("${ARCH}" MATCHES "mips(isa)?(64)?")
    set(BASEARCH "mips")
    set(BASEARCH_MIPS_FOUND TRUE)
    add_compile_definitions(ARCH_MIPS)
    if("${ARCH}" MATCHES "mips(isa)?64")
        set(ARCH_BITS 64)
    else()
        set(ARCH_BITS 32)
    endif()
elseif("${ARCH}" MATCHES "m68k")
    set(BASEARCH "m68k")
    set(BASEARCH_M68K_FOUND TRUE)
    add_compile_definitions(ARCH_M68K)
    set(ARCH_BITS 32)
elseif("${ARCH}" MATCHES "sh")
    set(BASEARCH "sh")
    set(BASEARCH_SH_FOUND TRUE)
    add_compile_definitions(ARCH_SH)
    set(ARCH_BITS 32)
elseif("${ARCH}" MATCHES "sparc(v)?[89]?(64)?")
    set(BASEARCH "sparc")
    set(BASEARCH_SPARC_FOUND TRUE)
    add_compile_definitions(ARCH_SPARC)
    if("${ARCH}" MATCHES "(sparc64|sparc(v)?9)")
        set(ARCH_BITS 64)
    else()
        set(ARCH_BITS 32)
    endif()
elseif("${ARCH}" MATCHES "s3[679]0x?")
    set(BASEARCH "s360")
    set(BASEARCH_S360_FOUND TRUE)
    add_compile_definitions(ARCH_S390)
    if("${ARCH}" MATCHES "s3[679]0x")
        set(ARCH_BITS 64)
    else()
        set(ARCH_BITS 32)
    endif()
elseif("${ARCH}" MATCHES "(parisc|hppa)(64)?")
    set(BASEARCH "parisc")
    set(BASEARCH_PARISC_FOUND TRUE)
    add_compile_definitions(ARCH_PARISC)
    if("${ARCH}" MATCHES "(parisc|hppa)64")
        set(ARCH_BITS 64)
    else()
        set(ARCH_BITS 32)
    endif()
elseif("${ARCH}" MATCHES "rs6000")
    set(BASEARCH "rs6000")
    set(BASEARCH_RS6000_FOUND TRUE)
    add_compile_definitions(ARCH_RS6000)
    set(ARCH_BITS 32)
elseif("${ARCH}" MATCHES "riscv(32|64)")
    set(BASEARCH "riscv")
    set(BASEARCH_RISCV_FOUND TRUE)
    add_compile_definitions(ARCH_RISCV)
    if("${ARCH}" MATCHES "riscv64")
        set(ARCH_BITS 64)
    else()
        set(ARCH_BITS 32)
    endif()
elseif("${ARCH}" MATCHES "(loong64|loongarch64)")
    set(BASEARCH "loongarch")
    set(BASEARCH_LOONGARCH_FOUND TRUE)
    add_compile_definitions(ARCH_LOONGARCH)
    set(ARCH_BITS 64)
elseif("${ARCH}" MATCHES "wasm(32|64)")
    set(BASEARCH "wasm32")
    set(BASEARCH_WASM32_FOUND TRUE)
    add_compile_definitions(ARCH_WASM)
    if("${ARCH}" MATCHES "wasm64")
        set(ARCH_BITS 64)
    else()
        set(ARCH_BITS 32)
    endif()
else()
    set(BASEARCH "x86")
    set(BASEARCH_X86_FOUND TRUE)
    add_compile_definitions(ARCH_X86)
    set(ARCH_BITS 32)
    message(STATUS "Basearch '${ARCH}' not recognized, defaulting to 'x86'.")
endif()

if (ARCH_BITS EQUAL 64)
    set(ARCH_64BIT TRUE)
    set(ARCH_32BIT FALSE)
    add_compile_definitions(ARCH_64BIT)
else()
    set(ARCH_64BIT FALSE)
    set(ARCH_32BIT TRUE)
    add_compile_definitions(ARCH_32BIT)
endif()

message(STATUS "Basearch of '${ARCH}' (${ARCH_BITS}bit) has been detected as: '${BASEARCH}'")
